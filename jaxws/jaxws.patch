--- old/./THIRD_PARTY_README	Tue Aug  4 09:26:42 2009
+++ new/./THIRD_PARTY_README	Tue Aug  4 09:26:41 2009
@@ -32,7 +32,7 @@
 
 --- end of LICENSE file ---
 %% This notice is provided with respect to ASM, which may be included with this software: 
-Copyright (c) 2000-2005 INRIA, France Telecom
+Copyright (c) 2000-2007 INRIA, France Telecom
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
--- old/src/share/classes/com/sun/codemodel/internal/JAnnotatable.java	Tue Aug  4 09:26:44 2009
+++ new/src/share/classes/com/sun/codemodel/internal/JAnnotatable.java	Tue Aug  4 09:26:44 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.codemodel.internal;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/codemodel/internal/JAnnotationUse.java	Tue Aug  4 09:26:46 2009
+++ new/src/share/classes/com/sun/codemodel/internal/JAnnotationUse.java	Tue Aug  4 09:26:46 2009
@@ -199,8 +199,7 @@
       *
       */
      public JAnnotationUse param(String name, Class value){
-         addValue(name, new JAnnotationStringValue(JExpr.lit(value.getName())));
-         return this;
+         return param(name,clazz.owner().ref(value));
     }
 
     /**
--- old/src/share/classes/com/sun/codemodel/internal/JAnnotationWriter.java	Tue Aug  4 09:26:48 2009
+++ new/src/share/classes/com/sun/codemodel/internal/JAnnotationWriter.java	Tue Aug  4 09:26:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.codemodel.internal;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/codemodel/internal/JBlock.java	Tue Aug  4 09:26:51 2009
+++ new/src/share/classes/com/sun/codemodel/internal/JBlock.java	Tue Aug  4 09:26:50 2009
@@ -111,7 +111,15 @@
         return r;
     }
 
+    /**
+     * Returns true if this block is empty and does not contain
+     * any statement.
+     */
+    public boolean isEmpty() {
+        return content.isEmpty();
+    }
 
+
     /**
      * Adds a local variable declaration to this block
      *
--- old/src/share/classes/com/sun/codemodel/internal/JCommentPart.java	Tue Aug  4 09:26:53 2009
+++ new/src/share/classes/com/sun/codemodel/internal/JCommentPart.java	Tue Aug  4 09:26:52 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.codemodel.internal;
 
 import java.util.ArrayList;
@@ -77,7 +78,8 @@
      */
     protected void format( JFormatter f, String indent ) {
         if(!f.isPrinting()) {
-            // quickly pass the types to JFormatter
+            // quickly pass the types to JFormatter, as that's all we care.
+            // we don't need to worry about the exact formatting of text.
             for( Object o : this )
                 if(o instanceof JClass)
                     f.g((JClass)o);
@@ -97,12 +99,12 @@
                 while( (idx=s.indexOf('\n'))!=-1 ) {
                     String line = s.substring(0,idx);
                     if(line.length()>0)
-                        f.p(line);
+                        f.p(escape(line));
                     s = s.substring(idx+1);
                     f.nl().p(indent);
                 }
                 if(s.length()!=0)
-                    f.p(s);
+                    f.p(escape(s));
             } else
             if(o instanceof JClass) {
                 // TODO: this doesn't print the parameterized type properly
@@ -117,4 +119,16 @@
         if(!isEmpty())
             f.nl();
     }
+
+    /**
+     * Escapes the appearance of the comment terminator.
+     */
+    private String escape(String s) {
+        while(true) {
+            int idx = s.indexOf("*/");
+            if(idx <0)   return s;
+
+            s = s.substring(0,idx+1)+"<!---->"+s.substring(idx+1);
+        }
+    }
 }
--- old/src/share/classes/com/sun/codemodel/internal/JDirectClass.java	Tue Aug  4 09:26:55 2009
+++ new/src/share/classes/com/sun/codemodel/internal/JDirectClass.java	Tue Aug  4 09:26:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.codemodel.internal;
 
 import java.util.Iterator;
--- old/src/share/classes/com/sun/codemodel/internal/JExpr.java	Tue Aug  4 09:26:57 2009
+++ new/src/share/classes/com/sun/codemodel/internal/JExpr.java	Tue Aug  4 09:26:57 2009
@@ -198,8 +198,12 @@
             char c = s.charAt(i);
             int j = charEscape.indexOf(c);
             if(j>=0) {
-                sb.append('\\');
-                sb.append(charMacro.charAt(j));
+                if((quote=='"' && c=='\'') || (quote=='\'' && c=='"')) {
+                    sb.append(c);
+                } else {
+                    sb.append('\\');
+                    sb.append(charMacro.charAt(j));
+                }
             } else {
                 // technically Unicode escape shouldn't be done here,
                 // for it's a lexical level handling.
--- old/src/share/classes/com/sun/codemodel/internal/JJavaName.java	Tue Aug  4 09:26:59 2009
+++ new/src/share/classes/com/sun/codemodel/internal/JJavaName.java	Tue Aug  4 09:26:59 2009
@@ -231,6 +231,7 @@
               "(.*)basis","$1bases",
                "(.*)axis","$1axes",
                  "(.+)is","$1ises",
+                 "(.+)ss","$1sses",
                  "(.+)us","$1uses",
                   "(.+)s","$1s",
                "(.*)foot","$1feet",
--- old/src/share/classes/com/sun/codemodel/internal/JMethod.java	Tue Aug  4 09:27:02 2009
+++ new/src/share/classes/com/sun/codemodel/internal/JMethod.java	Tue Aug  4 09:27:01 2009
@@ -388,10 +388,11 @@
                 f.g(a).nl();
         }
 
-                // declare the generics parameters
+        f.g(mods);
+
+        // declare the generics parameters
                 super.declare(f);
 
-                f.g(mods);
                 if (!isConstructor())
                         f.g(type);
                 f.id(name).p('(').i();
--- old/src/share/classes/com/sun/codemodel/internal/JPackage.java	Tue Aug  4 09:27:04 2009
+++ new/src/share/classes/com/sun/codemodel/internal/JPackage.java	Tue Aug  4 09:27:03 2009
@@ -98,34 +98,9 @@
     JPackage(String name, JCodeModel cw) {
         this.owner = cw;
         if (name.equals(".")) {
-            String msg = "JPackage name . is not allowed";
+            String msg = "Package name . is not allowed";
             throw new IllegalArgumentException(msg);
         }
-
-        int dots = 1;
-        for (int i = 0; i < name.length(); i++) {
-            char c = name.charAt(i);
-            if (c == '.') {
-                dots++;
-                continue;
-            }
-            if (dots > 1) {
-                String msg = "JPackage name " + name + " missing identifier";
-                throw new IllegalArgumentException(msg);
-            } else if (dots == 1 && !Character.isJavaIdentifierStart(c)) {
-                String msg =
-                    "JPackage name " + name + " contains illegal " + "character for beginning of identifier: " + c;
-                throw new IllegalArgumentException(msg);
-            } else if (!Character.isJavaIdentifierPart(c)) {
-                String msg = "JPackage name " + name + "contains illegal " + "character: " + c;
-                throw new IllegalArgumentException(msg);
-            }
-            dots = 0;
-        }
-        if (!name.trim().equals("") && dots != 0) {
-            String msg = "JPackage name not allowed to end with .";
-            throw new IllegalArgumentException(msg);
-        }
 
         if(JCodeModel.isCaseSensitiveFileSystem)
             upperCaseClassMap = null;
--- old/src/share/classes/com/sun/codemodel/internal/JTypeWildcard.java	Tue Aug  4 09:27:06 2009
+++ new/src/share/classes/com/sun/codemodel/internal/JTypeWildcard.java	Tue Aug  4 09:27:06 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.codemodel.internal;
 
 import java.util.Iterator;
--- old/src/share/classes/com/sun/codemodel/internal/TypedAnnotationWriter.java	Tue Aug  4 09:27:08 2009
+++ new/src/share/classes/com/sun/codemodel/internal/TypedAnnotationWriter.java	Tue Aug  4 09:27:08 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.codemodel.internal;
 
 import java.lang.reflect.InvocationHandler;
--- old/src/share/classes/com/sun/codemodel/internal/package-info.java	Tue Aug  4 09:27:10 2009
+++ new/src/share/classes/com/sun/codemodel/internal/package-info.java	Tue Aug  4 09:27:10 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /**
  * <h1>Library for generating Java source code</h1>.
  *
--- old/src/share/classes/com/sun/codemodel/internal/util/EncoderFactory.java	Tue Aug  4 09:27:12 2009
+++ new/src/share/classes/com/sun/codemodel/internal/util/EncoderFactory.java	Tue Aug  4 09:27:12 2009
@@ -22,11 +22,10 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /*
  * @(#)$Id: EncoderFactory.java,v 1.3 2005/09/10 19:07:33 kohsuke Exp $
  */
-
-
 package com.sun.codemodel.internal.util;
 
 import java.lang.reflect.Constructor;
--- old/src/share/classes/com/sun/codemodel/internal/util/MS1252Encoder.java	Tue Aug  4 09:27:15 2009
+++ new/src/share/classes/com/sun/codemodel/internal/util/MS1252Encoder.java	Tue Aug  4 09:27:14 2009
@@ -22,11 +22,10 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /*
  * @(#)$Id: MS1252Encoder.java,v 1.2 2005/09/10 19:07:33 kohsuke Exp $
  */
-
-
 package com.sun.codemodel.internal.util;
 
 import java.nio.charset.Charset;
--- old/src/share/classes/com/sun/codemodel/internal/writer/FilterCodeWriter.java	Tue Aug  4 09:27:17 2009
+++ new/src/share/classes/com/sun/codemodel/internal/writer/FilterCodeWriter.java	Tue Aug  4 09:27:16 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.codemodel.internal.writer;
 
 import java.io.OutputStream;
--- old/src/share/classes/com/sun/istack/internal/Pool.java	Tue Aug  4 09:27:19 2009
+++ new/src/share/classes/com/sun/istack/internal/Pool.java	Tue Aug  4 09:27:19 2009
@@ -25,6 +25,7 @@
 package com.sun.istack.internal;
 
 import java.util.concurrent.ConcurrentLinkedQueue;
+import java.lang.ref.WeakReference;
 
 /**
  * Pool of reusable objects that are indistinguishable from each other,
@@ -33,6 +34,7 @@
  * @author Kohsuke Kawaguchi
  */
 public interface Pool<T> {
+
     /**
      * Gets a new object from the pool.
      *
@@ -46,7 +48,6 @@
      */
     void recycle(@NotNull T t);
 
-
     /**
      * Default implementation that uses {@link ConcurrentLinkedQueue}
      * as the data store.
@@ -55,7 +56,10 @@
      * <p>
      * Don't rely on the fact that this class extends from {@link ConcurrentLinkedQueue}.
      */
-    public abstract class Impl<T> extends ConcurrentLinkedQueue<T> implements Pool<T> {
+    public abstract class Impl<T> implements Pool<T> {
+
+        private volatile WeakReference<ConcurrentLinkedQueue<T>> queue;
+
         /**
          * Gets a new object from the pool.
          *
@@ -66,9 +70,10 @@
          *      always non-null.
          */
         public final @NotNull T take() {
-            T t = super.poll();
-            if(t==null)
+            T t = getQueue().poll();
+            if(t==null) {
                 return create();
+            }
             return t;
         }
 
@@ -76,9 +81,24 @@
          * Returns an object back to the pool.
          */
         public final void recycle(T t) {
-            super.offer(t);
+            getQueue().offer(t);
         }
 
+        private ConcurrentLinkedQueue<T> getQueue() {
+            WeakReference<ConcurrentLinkedQueue<T>> q = queue;
+            if (q != null) {
+                ConcurrentLinkedQueue<T> d = q.get();
+                if (d != null) {
+                    return d;
+                }
+            }
+            // overwrite the queue
+            ConcurrentLinkedQueue<T> d = new ConcurrentLinkedQueue<T>();
+            queue = new WeakReference<ConcurrentLinkedQueue<T>>(d);
+
+            return d;
+        }
+
         /**
          * Creates a new instance of object.
          *
--- old/src/share/classes/com/sun/istack/internal/XMLStreamReaderToContentHandler.java	Tue Aug  4 09:27:21 2009
+++ new/src/share/classes/com/sun/istack/internal/XMLStreamReaderToContentHandler.java	Tue Aug  4 09:27:21 2009
@@ -54,14 +54,24 @@
 
     // if true, when the conversion is completed, leave the cursor to the last
     // event that was fired (such as end element)
-    private boolean eagerQuit;
+    private final boolean eagerQuit;
 
     /**
      * If true, not start/endDocument event.
      */
-    private boolean fragment;
+    private final boolean fragment;
 
+    // array of the even length of the form { prefix0, uri0, prefix1, uri1, ... }
+    private final String[] inscopeNamespaces;
+
     /**
+     * @see #XMLStreamReaderToContentHandler(XMLStreamReader, ContentHandler, boolean, boolean, String[])
+     */
+    public XMLStreamReaderToContentHandler(XMLStreamReader staxCore, ContentHandler saxCore, boolean eagerQuit, boolean fragment) {
+        this(staxCore, saxCore, eagerQuit, fragment, new String[0]);
+    }
+
+    /**
      * Construct a new StAX to SAX adapter that will convert a StAX event
      * stream into a SAX event stream.
      *
@@ -69,14 +79,22 @@
      *                StAX event source
      * @param saxCore
      *                SAXevent sink
+     * @param eagerQuit
+     * @param fragment
+     * @param inscopeNamespaces
+     *                array of the even length of the form { prefix0, uri0, prefix1, uri1, ... }
      */
-    public XMLStreamReaderToContentHandler(XMLStreamReader staxCore, ContentHandler saxCore, boolean eagerQuit, boolean fragment) {
+    public XMLStreamReaderToContentHandler(XMLStreamReader staxCore, ContentHandler saxCore,
+            boolean eagerQuit, boolean fragment, String[] inscopeNamespaces) {
         this.staxStreamReader = staxCore;
         this.saxHandler = saxCore;
         this.eagerQuit = eagerQuit;
         this.fragment = fragment;
+        this.inscopeNamespaces = inscopeNamespaces;
+        assert inscopeNamespaces.length%2 == 0;
     }
 
+
     /*
      * @see StAXReaderToContentHandler#bridge()
      */
@@ -100,6 +118,10 @@
 
             handleStartDocument();
 
+            for(int i=0; i < inscopeNamespaces.length; i+=2) {
+                saxHandler.startPrefixMapping(inscopeNamespaces[i], inscopeNamespaces[i+1]);
+            }
+
             OUTER:
             do {
                 // These are all of the events listed in the javadoc for
@@ -156,6 +178,10 @@
                 event=staxStreamReader.next();
             } while (depth!=0);
 
+            for(int i=0; i < inscopeNamespaces.length; i+=2) {
+                saxHandler.endPrefixMapping(inscopeNamespaces[i]);
+            }
+
             handleEndDocument();
         } catch (SAXException e) {
             throw new XMLStreamException2(e);
--- old/src/share/classes/com/sun/istack/internal/ws/AnnotationProcessorFactoryImpl.java	Tue Aug  4 09:27:23 2009
+++ new/src/share/classes/com/sun/istack/internal/ws/AnnotationProcessorFactoryImpl.java	Tue Aug  4 09:27:23 2009
@@ -66,10 +66,7 @@
         types.add("javax.jws.soap.SOAPBinding");
         types.add("javax.jws.soap.SOAPMessageHandler");
         types.add("javax.jws.soap.SOAPMessageHandlers");
-        types.add("javax.xml.ws.BeginService");
-        types.add("javax.xml.ws.EndService");
         types.add("javax.xml.ws.BindingType");
-        types.add("javax.xml.ws.ParameterIndex");
         types.add("javax.xml.ws.RequestWrapper");
         types.add("javax.xml.ws.ResponseWrapper");
         types.add("javax.xml.ws.ServiceMode");
@@ -78,8 +75,6 @@
         types.add("javax.xml.ws.WebServiceClient");
         types.add("javax.xml.ws.WebServiceProvider");
         types.add("javax.xml.ws.WebServiceRef");
-
-        types.add("javax.xml.ws.security.MessageSecurity");
         supportedAnnotations = Collections.unmodifiableCollection(types);
     }
 
--- old/src/share/classes/com/sun/tools/internal/jxc/ConfigReader.java	Tue Aug  4 09:27:26 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/ConfigReader.java	Tue Aug  4 09:27:25 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc;
 
 import java.io.File;
--- old/src/share/classes/com/sun/tools/internal/jxc/MessageBundle.properties	Tue Aug  4 09:27:28 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/MessageBundle.properties	Tue Aug  4 09:27:27 2009
@@ -30,8 +30,8 @@
     Non-existent directory: {0}
 
 VERSION = \
-	schemagen version "JAXB 2.1.3" \n\
-	JavaTM Architecture for XML Binding(JAXB) Reference Implementation, (build JAXB 2.1.3 in JDK)	
+        schemagen version "JAXB 2.1.10 in JDK 6" \n\
+        JavaTM Architecture for XML Binding(JAXB) Reference Implementation, (build JAXB 2.1.10 in JDK 6)
 
 USAGE = \
 Usage: schemagen [-options ...] <java files> \n\
@@ -42,4 +42,3 @@
 \ \ \ \ -episode <file>   :  generate episode file for separate compilation\n\
 \ \ \ \ -version          :  display version information\n\
 \ \ \ \ -help             :  display this usage message
- 
--- old/src/share/classes/com/sun/tools/internal/jxc/Messages.java	Tue Aug  4 09:27:30 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/Messages.java	Tue Aug  4 09:27:30 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc;
 
 import java.text.MessageFormat;
--- old/src/share/classes/com/sun/tools/internal/jxc/SchemaGenerator.java	Tue Aug  4 09:27:32 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/SchemaGenerator.java	Tue Aug  4 09:27:32 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc;
 
 import java.io.File;
--- old/src/share/classes/com/sun/tools/internal/jxc/apt/AnnotationParser.java	Tue Aug  4 09:27:34 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/apt/AnnotationParser.java	Tue Aug  4 09:27:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc.apt;
 
 import java.io.File;
--- old/src/share/classes/com/sun/tools/internal/jxc/apt/AnnotationProcessorFactoryImpl.java	Tue Aug  4 09:27:36 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/apt/AnnotationProcessorFactoryImpl.java	Tue Aug  4 09:27:36 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc.apt;
 
 import java.util.Arrays;
--- old/src/share/classes/com/sun/tools/internal/jxc/apt/Const.java	Tue Aug  4 09:27:39 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/apt/Const.java	Tue Aug  4 09:27:38 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc.apt;
 
 import java.io.File;
--- old/src/share/classes/com/sun/tools/internal/jxc/apt/ErrorReceiverImpl.java	Tue Aug  4 09:27:41 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/apt/ErrorReceiverImpl.java	Tue Aug  4 09:27:40 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc.apt;
 
 import com.sun.mirror.apt.AnnotationProcessorEnvironment;
--- old/src/share/classes/com/sun/tools/internal/jxc/apt/InlineAnnotationReaderImpl.java	Tue Aug  4 09:27:43 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/apt/InlineAnnotationReaderImpl.java	Tue Aug  4 09:27:43 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc.apt;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/tools/internal/jxc/apt/MessageBundle.properties	Tue Aug  4 09:27:45 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/apt/MessageBundle.properties	Tue Aug  4 09:27:45 2009
@@ -31,4 +31,3 @@
 
 OPERAND_MISSING = \
     Option "{0}" is missing an operand.
- 
--- old/src/share/classes/com/sun/tools/internal/jxc/apt/Messages.java	Tue Aug  4 09:27:47 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/apt/Messages.java	Tue Aug  4 09:27:47 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc.apt;
 
 import java.text.MessageFormat;
--- old/src/share/classes/com/sun/tools/internal/jxc/apt/Options.java	Tue Aug  4 09:27:49 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/apt/Options.java	Tue Aug  4 09:27:49 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc.apt;
 
 import java.io.File;
--- old/src/share/classes/com/sun/tools/internal/jxc/apt/SchemaGenerator.java	Tue Aug  4 09:27:52 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/apt/SchemaGenerator.java	Tue Aug  4 09:27:51 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc.apt;
 
 import java.io.File;
--- old/src/share/classes/com/sun/tools/internal/jxc/gen/config/Classes.java	Tue Aug  4 09:27:54 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/gen/config/Classes.java	Tue Aug  4 09:27:53 2009
@@ -75,6 +75,11 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 0:
+            {
+                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
         case 12:
             {
                 if(($__uri == "" && $__local == "classes")) {
@@ -92,34 +97,29 @@
                 $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
-        case 2:
+        case 11:
             {
-                if(($__uri == "" && $__local == "excludes")) {
+                if(($__uri == "" && $__local == "includes")) {
                     $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    $_ngcc_current_state = 6;
+                    $_ngcc_current_state = 10;
                 }
                 else {
-                    $_ngcc_current_state = 1;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 11:
+        case 2:
             {
-                if(($__uri == "" && $__local == "includes")) {
+                if(($__uri == "" && $__local == "excludes")) {
                     $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    $_ngcc_current_state = 10;
+                    $_ngcc_current_state = 6;
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 1;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -133,6 +133,17 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 0:
+            {
+                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 4:
+            {
+                $_ngcc_current_state = 3;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 3:
             {
                 if(($__uri == "" && $__local == "excludes")) {
@@ -144,12 +155,6 @@
                 }
             }
             break;
-        case 4:
-            {
-                $_ngcc_current_state = 3;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 2:
             {
                 $_ngcc_current_state = 1;
@@ -156,11 +161,11 @@
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 1:
+        case 8:
             {
-                if(($__uri == "" && $__local == "classes")) {
+                if(($__uri == "" && $__local == "includes")) {
                     $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 0;
+                    $_ngcc_current_state = 2;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -167,11 +172,11 @@
                 }
             }
             break;
-        case 8:
+        case 1:
             {
-                if(($__uri == "" && $__local == "includes")) {
+                if(($__uri == "" && $__local == "classes")) {
                     $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 2;
+                    $_ngcc_current_state = 0;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -178,11 +183,6 @@
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         default:
             {
                 unexpectedLeaveElement($__qname);
@@ -196,6 +196,11 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 0:
+            {
+                revertToParentFromEnterAttribute(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 4:
             {
                 $_ngcc_current_state = 3;
@@ -208,11 +213,6 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 0:
-            {
-                revertToParentFromEnterAttribute(this, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -226,6 +226,11 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 0:
+            {
+                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 4:
             {
                 $_ngcc_current_state = 3;
@@ -238,11 +243,6 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 0:
-            {
-                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -253,6 +253,11 @@
 
     public void text(String $value) throws SAXException {
         switch($_ngcc_current_state) {
+        case 0:
+            {
+                revertToParentFromText(this, super._cookie, $value);
+            }
+            break;
         case 9:
             {
                 include_content = $value;
@@ -260,7 +265,7 @@
                 action2();
             }
             break;
-        case 3:
+        case 4:
             {
                 exclude_content = $value;
                 $_ngcc_current_state = 3;
@@ -267,7 +272,7 @@
                 action0();
             }
             break;
-        case 4:
+        case 3:
             {
                 exclude_content = $value;
                 $_ngcc_current_state = 3;
@@ -301,11 +306,6 @@
                 action1();
             }
             break;
-        case 0:
-            {
-                revertToParentFromText(this, super._cookie, $value);
-            }
-            break;
         }
     }
 
--- old/src/share/classes/com/sun/tools/internal/jxc/gen/config/Config.java	Tue Aug  4 09:27:56 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/gen/config/Config.java	Tue Aug  4 09:27:56 2009
@@ -70,15 +70,10 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 4:
             {
-                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 1:
-            {
-                if(($__uri == "" && $__local == "schema")) {
-                    NGCCHandler h = new Schema(this, super._source, $runtime, 3, baseDir);
+                if(($__uri == "" && $__local == "classes")) {
+                    NGCCHandler h = new Classes(this, super._source, $runtime, 34);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -97,10 +92,26 @@
                 }
             }
             break;
+        case 1:
+            {
+                if(($__uri == "" && $__local == "schema")) {
+                    NGCCHandler h = new Schema(this, super._source, $runtime, 31, baseDir);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
+            }
+            break;
+        case 0:
+            {
+                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
         case 2:
             {
                 if(($__uri == "" && $__local == "schema")) {
-                    NGCCHandler h = new Schema(this, super._source, $runtime, 4, baseDir);
+                    NGCCHandler h = new Schema(this, super._source, $runtime, 32, baseDir);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -120,17 +131,6 @@
                 }
             }
             break;
-        case 4:
-            {
-                if(($__uri == "" && $__local == "classes")) {
-                    NGCCHandler h = new Classes(this, super._source, $runtime, 6);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -145,11 +145,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
-            {
-                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 1:
             {
                 if(($__uri == "" && $__local == "config")) {
@@ -161,6 +156,11 @@
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 2:
             {
                 $_ngcc_current_state = 1;
@@ -257,13 +257,6 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 6:
-            {
-                bd = $value;
-                $_ngcc_current_state = 5;
-                action1();
-            }
-            break;
         case 0:
             {
                 revertToParentFromText(this, super._cookie, $value);
@@ -283,19 +276,32 @@
                 }
             }
             break;
+        case 6:
+            {
+                bd = $value;
+                $_ngcc_current_state = 5;
+                action1();
+            }
+            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 3:
+        case 34:
             {
+                classes = ((Classes)$__result__);
+                $_ngcc_current_state = 2;
+            }
+            break;
+        case 31:
+            {
                 _schema = ((Schema)$__result__);
                 action0();
                 $_ngcc_current_state = 1;
             }
             break;
-        case 4:
+        case 32:
             {
                 _schema = ((Schema)$__result__);
                 action0();
@@ -302,12 +308,6 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 6:
-            {
-                classes = ((Classes)$__result__);
-                $_ngcc_current_state = 2;
-            }
-            break;
         }
     }
 
--- old/src/share/classes/com/sun/tools/internal/jxc/gen/config/Schema.java	Tue Aug  4 09:27:58 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/gen/config/Schema.java	Tue Aug  4 09:27:58 2009
@@ -65,6 +65,23 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 0:
+            {
+                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
+        case 2:
+            {
+                if(($ai = $runtime.getAttributeIndex("","location"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 1;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+            }
+            break;
         case 6:
             {
                 if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
@@ -88,23 +105,6 @@
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 2:
-            {
-                if(($ai = $runtime.getAttributeIndex("","location"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    $_ngcc_current_state = 1;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-            }
-            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -119,23 +119,23 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 6:
+        case 0:
             {
-                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 2:
+            {
+                if(($ai = $runtime.getAttributeIndex("","location"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 2;
+                    $_ngcc_current_state = 1;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 1:
             {
                 if(($__uri == "" && $__local == "schema")) {
@@ -147,14 +147,14 @@
                 }
             }
             break;
-        case 2:
+        case 6:
             {
-                if(($ai = $runtime.getAttributeIndex("","location"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 1;
+                    $_ngcc_current_state = 2;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
@@ -172,17 +172,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 6:
-            {
-                if(($__uri == "" && $__local == "namespace")) {
-                    $_ngcc_current_state = 8;
-                }
-                else {
-                    $_ngcc_current_state = 2;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-                }
-            }
-            break;
         case 0:
             {
                 revertToParentFromEnterAttribute(this, super._cookie, $__uri, $__local, $__qname);
@@ -199,6 +188,17 @@
                 }
             }
             break;
+        case 6:
+            {
+                if(($__uri == "" && $__local == "namespace")) {
+                    $_ngcc_current_state = 8;
+                }
+                else {
+                    $_ngcc_current_state = 2;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                }
+            }
+            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -212,15 +212,15 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 6:
+        case 0:
             {
-                $_ngcc_current_state = 2;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 0:
+        case 2:
             {
-                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
         case 7:
@@ -233,6 +233,12 @@
                 }
             }
             break;
+        case 6:
+            {
+                $_ngcc_current_state = 2;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 3:
             {
                 if(($__uri == "" && $__local == "location")) {
@@ -243,12 +249,6 @@
                 }
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -260,24 +260,6 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 8:
-            {
-                namespace = $value;
-                $_ngcc_current_state = 7;
-            }
-            break;
-        case 6:
-            {
-                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 2;
-                    $runtime.sendText(super._cookie, $value);
-                }
-            }
-            break;
         case 0:
             {
                 revertToParentFromText(this, super._cookie, $value);
@@ -295,6 +277,12 @@
                 }
             }
             break;
+        case 8:
+            {
+                namespace = $value;
+                $_ngcc_current_state = 7;
+            }
+            break;
         case 4:
             {
                 loc = $value;
@@ -302,6 +290,18 @@
                 action0();
             }
             break;
+        case 6:
+            {
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 2;
+                    $runtime.sendText(super._cookie, $value);
+                }
+            }
+            break;
         }
     }
 
--- old/src/share/classes/com/sun/tools/internal/jxc/gen/config/config.xsd	Tue Aug  4 09:28:01 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/gen/config/config.xsd	Tue Aug  4 09:28:00 2009
@@ -23,6 +23,8 @@
  CA 95054 USA or visit www.sun.com if you need additional information or
  have any questions.
 -->
+
+
 <!-- THIS IS A GENERATED FILE. DO NOT MODIFY. -->
 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
   <xs:element name="config">
--- old/src/share/classes/com/sun/tools/internal/jxc/model/nav/APTNavigator.java	Tue Aug  4 09:28:03 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/model/nav/APTNavigator.java	Tue Aug  4 09:28:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.jxc.model.nav;
 
 import java.util.ArrayList;
@@ -306,7 +307,7 @@
     }
 
     public boolean isInnerClass(TypeDeclaration clazz) {
-        return clazz.getDeclaringType()!=null;
+        return clazz.getDeclaringType()!=null && !clazz.getModifiers().contains(Modifier.STATIC);
     }
 
     public boolean isArray(TypeMirror t) {
--- old/src/share/classes/com/sun/tools/internal/ws/Invoker.java	Tue Aug  4 09:28:05 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/Invoker.java	Tue Aug  4 09:28:05 2009
@@ -55,10 +55,12 @@
     static int invoke(String mainClass, String[] args) throws Throwable {
         // use the platform default proxy if available.
         // see sun.net.spi.DefaultProxySelector for details.
-        try {
-            System.setProperty("java.net.useSystemProxies","true");
-        } catch (SecurityException e) {
-            // failing to set this property isn't fatal
+        if(!noSystemProxies) {
+            try {
+                System.setProperty("java.net.useSystemProxies","true");
+            } catch (SecurityException e) {
+                // failing to set this property isn't fatal
+            }
         }
 
         ClassLoader oldcc = Thread.currentThread().getContextClassLoader();
@@ -220,4 +222,18 @@
         "com.sun.xml.internal.bind.",
         "com.sun.xml.internal.ws."
     };
+
+    /**
+     * Escape hatch to work around IBM JDK problem.
+     * See http://www-128.ibm.com/developerworks/forums/dw_thread.jsp?nav=false&forum=367&thread=164718&cat=10
+     */
+    public static boolean noSystemProxies = false;
+
+    static {
+        try {
+            noSystemProxies = Boolean.getBoolean(Invoker.class.getName()+".noSystemProxies");
+        } catch(SecurityException e) {
+            // ignore
+        }
+    }
 }
--- old/src/share/classes/com/sun/tools/internal/ws/api/TJavaGeneratorExtension.java	Tue Aug  4 09:28:07 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/api/TJavaGeneratorExtension.java	Tue Aug  4 09:28:07 2009
@@ -34,6 +34,7 @@
  *
  * @see JavaGeneratorExtensionFacade
  * @author Vivek Pandey
+ * @deprecated This class is deprecated, will be removed in JAX-WS 2.2 RI.
  */
 public abstract class TJavaGeneratorExtension {
     /**
--- old/src/share/classes/com/sun/tools/internal/ws/api/wsdl/TWSDLExtensible.java	Tue Aug  4 09:28:09 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/api/wsdl/TWSDLExtensible.java	Tue Aug  4 09:28:09 2009
@@ -32,6 +32,8 @@
  * A WSDL element or attribute that can be extended.
  *
  * @author Vivek Pandey
+ * @deprecated This interface is deprecated, will be removed in JAX-WS 2.2 RI.
+ *
  */
 public interface TWSDLExtensible {
     /**
--- old/src/share/classes/com/sun/tools/internal/ws/api/wsdl/TWSDLExtension.java	Tue Aug  4 09:28:12 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/api/wsdl/TWSDLExtension.java	Tue Aug  4 09:28:11 2009
@@ -29,6 +29,7 @@
  * A WSDL extension
  *
  * @author Vivek Pandey
+ * @deprecated This interface is deprecated, will be removed in JAX-WS 2.2 RI.
  */
 public interface TWSDLExtension {
     /**
--- old/src/share/classes/com/sun/tools/internal/ws/api/wsdl/TWSDLExtensionHandler.java	Tue Aug  4 09:28:14 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/api/wsdl/TWSDLExtensionHandler.java	Tue Aug  4 09:28:13 2009
@@ -33,6 +33,7 @@
  * with it for the WSDL extensibility elements thats not already defined in the WSDL 1.1 spec, such as SOAP or MIME.
  *
  * @author Vivek Pandey
+ * @deprecated This class is deprecated, will be removed in JAX-WS 2.2 RI.
  */
 public abstract class TWSDLExtensionHandler {
     /**
--- old/src/share/classes/com/sun/tools/internal/ws/api/wsdl/TWSDLOperation.java	Tue Aug  4 09:28:16 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/api/wsdl/TWSDLOperation.java	Tue Aug  4 09:28:15 2009
@@ -33,6 +33,7 @@
  * Abstracts wsdl:portType/wsdl:operation
  *
  * @author Vivek Pandey
+ * @deprecated This interface is deprecated, will be removed in JAX-WS 2.2 RI.
  */
 public interface TWSDLOperation extends TWSDLExtensible{
     /**
--- old/src/share/classes/com/sun/tools/internal/ws/api/wsdl/TWSDLParserContext.java	Tue Aug  4 09:28:18 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/api/wsdl/TWSDLParserContext.java	Tue Aug  4 09:28:18 2009
@@ -33,6 +33,7 @@
  * it can be latter used by other extensions to resolve the namespaces.
  *
  * @author Vivek Pandey
+ * @deprecated This interface is deprecated, will be removed in JAX-WS 2.2 RI.
  */
 public interface TWSDLParserContext {
 
--- old/src/share/classes/com/sun/tools/internal/ws/package-info.java	Tue Aug  4 09:28:20 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/package-info.java	Tue Aug  4 09:28:20 2009
@@ -24,7 +24,7 @@
  */
 
 /**
- * <h1>JAX-WS 2.0.1 Tools</h1>
+ * <h1>JAX-WS 2.1 Tools</h1>
  * This document describes the tools included with JAX-WS 2.0.1.
  *
  * {@DotDiagram
@@ -42,7 +42,7 @@
 
        // libraries
       node [style=filled,color=lightblue];
-      CompileTool; "WSAP"; WebServiceAP; Processor; Modeler; ProcessorActions;
+      WsimportTool; WsgenTool;"WSAP"; WebServiceAP; WSDLModeler;WSDLParser;SeiGenerator;ServiceGenerator;ExceptionGenerator;"JAXB XJC APIs";CodeModel;
 
        // aps
 #       node [style=filled,color=lightpink];
@@ -49,15 +49,17 @@
 #       "JAX-WS"; tools; runtime; SPI; "Annotation Processor";
 
        "Apt ANT Task" -> APT;
-       "WsGen ANT Task" -> wsgen -> CompileTool;
-       "WsImport ANT Task" -> wsimport -> CompileTool;
+       "WsGen ANT Task" -> wsgen -> WsgenTool;
+       "WsImport ANT Task" -> wsimport -> WsimportTool;
 
-       CompileTool -> APT -> WSAP -> WebServiceAP;
-       CompileTool -> Processor -> Modeler;
-       Processor -> ProcessorActions;
-       CompileTool -> WebServiceAP;
-
-       Modeler -> WSDLModeler;
+       WsgenTool -> APT -> WSAP -> WebServiceAP;
+       WsimportTool -> WSDLModeler;
+       WSDLModeler->WSDLParser;
+       WSDLModeler->"JAXB XJC APIs"
+       WsimportTool->SeiGenerator->CodeModel;
+       WsimportTool->ServiceGenerator->CodeModel;
+       WsimportTool->ExceptionGenerator->CodeModel;
+       WebServiceAP->CodeModel
      }
  * }
  * <div align=right>
--- old/src/share/classes/com/sun/tools/internal/ws/processor/generator/GeneratorBase.java	Tue Aug  4 09:28:23 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/generator/GeneratorBase.java	Tue Aug  4 09:28:22 2009
@@ -156,12 +156,14 @@
         return comments;
     }
 
-    protected JDefinedClass getClass(String className, ClassType type) {
+    protected JDefinedClass getClass(String className, ClassType type) throws JClassAlreadyExistsException {
         JDefinedClass cls;
         try {
             cls = cm._class(className, type);
         } catch (JClassAlreadyExistsException e){
             cls = cm._getClass(className);
+            if(cls == null)
+                throw e;
         }
         return cls;
     }
--- old/src/share/classes/com/sun/tools/internal/ws/processor/generator/SeiGenerator.java	Tue Aug  4 09:28:25 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/generator/SeiGenerator.java	Tue Aug  4 09:28:24 2009
@@ -36,7 +36,11 @@
 import com.sun.tools.internal.ws.wscompile.ErrorReceiver;
 import com.sun.tools.internal.ws.wscompile.Options;
 import com.sun.tools.internal.ws.wscompile.WsimportOptions;
+import com.sun.tools.internal.ws.wscompile.AbortException;
 import com.sun.tools.internal.ws.wsdl.document.soap.SOAPStyle;
+import com.sun.tools.internal.ws.wsdl.document.PortType;
+import com.sun.tools.internal.ws.wsdl.document.Kinds;
+import com.sun.tools.internal.ws.resources.GeneratorMessages;
 
 import javax.jws.WebMethod;
 import javax.jws.WebParam;
@@ -48,6 +52,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.xml.sax.Locator;
+
 public class SeiGenerator extends GeneratorBase{
     private String serviceNS;
     private TJavaGeneratorExtension extension;
@@ -83,10 +89,22 @@
         }
 
 
-        JDefinedClass cls = getClass(className, ClassType.INTERFACE);
-        if (cls == null)
+        JDefinedClass cls = null;
+        try {
+            cls = getClass(className, ClassType.INTERFACE);
+        } catch (JClassAlreadyExistsException e) {
+            QName portTypeName =
+                (QName) port.getProperty(
+                        ModelProperties.PROPERTY_WSDL_PORT_TYPE_NAME);
+            Locator loc = null;
+            if(portTypeName != null){
+                PortType pt = port.portTypes.get(portTypeName);
+                if(pt!=null)
+                    loc = pt.getLocator();
+            }
+            receiver.error(loc, GeneratorMessages.GENERATOR_SEI_CLASS_ALREADY_EXIST(intf.getName(), portTypeName));
             return;
-
+        }
         // If the class has methods it has already been defined
         // so skip it.
         if (!cls.methods().isEmpty())
@@ -441,15 +459,7 @@
         if (port.isProvider()) {
             return;                // Not generating for Provider based endpoint
         }
-
-
-        try {
-            write(port);
-        } catch (Exception e) {
-            throw new GeneratorException(
-                "generator.nestedGeneratorError",
-                e);
-        }
+        write(port);
     }
 
     private void register(TJavaGeneratorExtension h) {
--- old/src/share/classes/com/sun/tools/internal/ws/processor/generator/ServiceGenerator.java	Tue Aug  4 09:28:27 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/generator/ServiceGenerator.java	Tue Aug  4 09:28:27 2009
@@ -29,11 +29,13 @@
 import com.sun.tools.internal.ws.processor.model.Model;
 import com.sun.tools.internal.ws.processor.model.Port;
 import com.sun.tools.internal.ws.processor.model.Service;
+import com.sun.tools.internal.ws.processor.model.ModelProperties;
 import com.sun.tools.internal.ws.processor.model.java.JavaInterface;
 import com.sun.tools.internal.ws.wscompile.ErrorReceiver;
 import com.sun.tools.internal.ws.wscompile.Options;
 import com.sun.tools.internal.ws.wscompile.WsimportOptions;
 import com.sun.tools.internal.ws.resources.GeneratorMessages;
+import com.sun.tools.internal.ws.wsdl.document.PortType;
 import com.sun.xml.internal.bind.api.JAXBRIContext;
 import com.sun.xml.internal.ws.util.JAXWSUtils;
 
@@ -42,161 +44,174 @@
 import javax.xml.ws.WebServiceClient;
 import javax.xml.ws.WebServiceFeature;
 import java.io.IOException;
+import java.io.File;
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.util.logging.Logger;
 
+import org.xml.sax.Locator;
 
+
 /**
- *
  * @author WS Development Team
  */
-public class ServiceGenerator extends GeneratorBase{
+public class ServiceGenerator extends GeneratorBase {
 
-    public static void generate(Model model, WsimportOptions options, ErrorReceiver receiver){
+    public static void generate(Model model, WsimportOptions options, ErrorReceiver receiver) {
         ServiceGenerator serviceGenerator = new ServiceGenerator(model, options, receiver);
         serviceGenerator.doGeneration();
     }
+
     private ServiceGenerator(Model model, WsimportOptions options, ErrorReceiver receiver) {
         super(model, options, receiver);
     }
 
-    private JInvocation createURL(URL url) {
-        return JExpr._new(cm.ref(URL.class)).arg(url.toExternalForm());
-    }
-
     @Override
     public void visit(Service service) {
+        JavaInterface intf = service.getJavaInterface();
+        String className = Names.customJavaTypeClassName(intf);
+        if (donotOverride && GeneratorUtil.classExists(options, className)) {
+            log("Class " + className + " exists. Not overriding.");
+            return;
+        }
+
+        JDefinedClass cls;
         try {
-            JavaInterface intf = service.getJavaInterface();
-            String className = Names.customJavaTypeClassName(intf);
-            if (donotOverride && GeneratorUtil.classExists(options, className)) {
-                log("Class " + className + " exists. Not overriding.");
-                return;
-            }
+            cls = getClass(className, ClassType.CLASS);
+        } catch (JClassAlreadyExistsException e) {
+            receiver.error(service.getLocator(), GeneratorMessages.GENERATOR_SERVICE_CLASS_ALREADY_EXIST(className, service.getName()));
+            return;
+        }
 
-            JDefinedClass cls = getClass(className, ClassType.CLASS);
+        cls._extends(javax.xml.ws.Service.class);
+        String serviceFieldName = JAXBRIContext.mangleNameToClassName(service.getName().getLocalPart()).toUpperCase();
+        String wsdlLocationName = serviceFieldName + "_WSDL_LOCATION";
+        JFieldVar urlField = cls.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, URL.class, wsdlLocationName);
 
-            cls._extends(javax.xml.ws.Service.class);
-            String serviceFieldName = JAXBRIContext.mangleNameToClassName(service.getName().getLocalPart()).toUpperCase();
-            String wsdlLocationName = serviceFieldName+"_WSDL_LOCATION";
-            JFieldVar urlField = cls.field(JMod.PRIVATE|JMod.STATIC|JMod.FINAL, URL.class, wsdlLocationName);
-            JClass qNameCls = cm.ref(QName.class);
-            JInvocation inv;
-            inv = JExpr._new(qNameCls);
-            inv.arg("namespace");
-            inv.arg("localpart");
 
+        cls.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, Logger.class, "logger", cm.ref(Logger.class).staticInvoke("getLogger").arg(JExpr.dotclass(cm.ref(className)).invoke("getName")));
 
-            JBlock staticBlock = cls.init();
-            URL url = new URL(JAXWSUtils.absolutize(JAXWSUtils.getFileOrURLName(wsdlLocation)));
-            JVar urlVar = staticBlock.decl(cm.ref(URL.class),"url", JExpr._null());
-            JTryBlock tryBlock = staticBlock._try();
-            tryBlock.body().assign(urlVar, createURL(url));
-            JCatchBlock catchBlock = tryBlock._catch(cm.ref(MalformedURLException.class));
-            catchBlock.param("e");
-            catchBlock.body().directStatement("e.printStackTrace();");
-            staticBlock.assign(urlField, urlVar);
+        JClass qNameCls = cm.ref(QName.class);
+        JInvocation inv;
+        inv = JExpr._new(qNameCls);
+        inv.arg("namespace");
+        inv.arg("localpart");
 
-            //write class comment - JAXWS warning
-            JDocComment comment = cls.javadoc();
 
-            if(service.getJavaDoc() != null){
-                comment.add(service.getJavaDoc());
-                comment.add("\n\n");
-            }
+        JBlock staticBlock = cls.init();
+        JVar urlVar = staticBlock.decl(cm.ref(URL.class), "url", JExpr._null());
+        JTryBlock tryBlock = staticBlock._try();
+        JVar baseUrl = tryBlock.body().decl(cm.ref(URL.class), "baseUrl");
+        tryBlock.body().assign(baseUrl, JExpr.dotclass(cm.ref(className)).invoke("getResource").arg("."));
+        tryBlock.body().assign(urlVar, JExpr._new(cm.ref(URL.class)).arg(baseUrl).arg(wsdlLocation));
+        JCatchBlock catchBlock = tryBlock._catch(cm.ref(MalformedURLException.class));
+        catchBlock.param("e");
 
-            for (String doc : getJAXWSClassComment()) {
-                comment.add(doc);
-            }
+        catchBlock.body().directStatement("logger.warning(\"Failed to create URL for the wsdl Location: " + JExpr.quotify('\'', wsdlLocation) + ", retrying as a local file\");");
+        catchBlock.body().directStatement("logger.warning(e.getMessage());");
 
-            JMethod constructor = cls.constructor(JMod.PUBLIC);
-            constructor.param(URL.class, "wsdlLocation");
-            constructor.param(QName.class, "serviceName");
-            constructor.body().directStatement("super(wsdlLocation, serviceName);");
+        staticBlock.assign(urlField, urlVar);
 
-            constructor = cls.constructor(JMod.PUBLIC);
-            constructor.body().directStatement("super("+wsdlLocationName+", new QName(\""+service.getName().getNamespaceURI()+"\", \""+service.getName().getLocalPart()+"\"));");
+        //write class comment - JAXWS warning
+        JDocComment comment = cls.javadoc();
 
-            //@WebService
-            JAnnotationUse webServiceClientAnn = cls.annotate(cm.ref(WebServiceClient.class));
-            writeWebServiceClientAnnotation(service, webServiceClientAnn);
+        if (service.getJavaDoc() != null) {
+            comment.add(service.getJavaDoc());
+            comment.add("\n\n");
+        }
 
-            //@HandlerChain
-            writeHandlerConfig(Names.customJavaTypeClassName(service.getJavaInterface()), cls, options);
+        for (String doc : getJAXWSClassComment()) {
+            comment.add(doc);
+        }
 
-            for (Port port: service.getPorts()) {
-                if (port.isProvider()) {
-                    continue;  // No getXYZPort() for porvider based endpoint
-                }
+        JMethod constructor = cls.constructor(JMod.PUBLIC);
+        constructor.param(URL.class, "wsdlLocation");
+        constructor.param(QName.class, "serviceName");
+        constructor.body().directStatement("super(wsdlLocation, serviceName);");
 
-                //write getXyzPort()
-                writeDefaultGetPort(port, cls);
+        constructor = cls.constructor(JMod.PUBLIC);
+        constructor.body().directStatement("super(" + wsdlLocationName + ", new QName(\"" + service.getName().getNamespaceURI() + "\", \"" + service.getName().getLocalPart() + "\"));");
 
-                //write getXyzPort(WebServicesFeature...)
-                if(options.target.isLaterThan(Options.Target.V2_1))
-                    writeGetPort(port, cls);
+        //@WebService
+        JAnnotationUse webServiceClientAnn = cls.annotate(cm.ref(WebServiceClient.class));
+        writeWebServiceClientAnnotation(service, webServiceClientAnn);
+
+        //@HandlerChain
+        writeHandlerConfig(Names.customJavaTypeClassName(service.getJavaInterface()), cls, options);
+
+        for (Port port : service.getPorts()) {
+            if (port.isProvider()) {
+                continue;  // No getXYZPort() for porvider based endpoint
             }
-        } catch (IOException e) {
-            receiver.error(e);
+
+            //Get the SEI class
+            JType retType;
+            try {
+                retType = getClass(port.getJavaInterface().getName(), ClassType.INTERFACE);
+            } catch (JClassAlreadyExistsException e) {
+                QName portTypeName =
+                        (QName) port.getProperty(
+                                ModelProperties.PROPERTY_WSDL_PORT_TYPE_NAME);
+                Locator loc = null;
+                if (portTypeName != null) {
+                    PortType pt = port.portTypes.get(portTypeName);
+                    if (pt != null)
+                        loc = pt.getLocator();
+                }
+                receiver.error(loc, GeneratorMessages.GENERATOR_SEI_CLASS_ALREADY_EXIST(port.getJavaInterface().getName(), portTypeName));
+                return;
+            }
+
+            //write getXyzPort()
+            writeDefaultGetPort(port, retType, cls);
+
+            //write getXyzPort(WebServicesFeature...)
+            if (options.target.isLaterThan(Options.Target.V2_1))
+                writeGetPort(port, retType, cls);
         }
     }
 
-    private void writeGetPort(Port port, JDefinedClass cls) {
-        JType retType = getClass(port.getJavaInterface().getName(), ClassType.INTERFACE);
+    private void writeGetPort(Port port, JType retType, JDefinedClass cls) {
         JMethod m = cls.method(JMod.PUBLIC, retType, port.getPortGetter());
         JDocComment methodDoc = m.javadoc();
-        if(port.getJavaDoc() != null)
+        if (port.getJavaDoc() != null)
             methodDoc.add(port.getJavaDoc());
         JCommentPart ret = methodDoc.addReturn();
         JCommentPart paramDoc = methodDoc.addParam("features");
         paramDoc.append("A list of ");
-        paramDoc.append("{@link "+WebServiceFeature.class.getName()+"}");
+        paramDoc.append("{@link " + WebServiceFeature.class.getName() + "}");
         paramDoc.append("to configure on the proxy.  Supported features not in the <code>features</code> parameter will have their default values.");
-        ret.add("returns "+retType.name());
+        ret.add("returns " + retType.name());
         m.varParam(WebServiceFeature.class, "features");
         JBlock body = m.body();
-        StringBuffer statement = new StringBuffer("return (");
+        StringBuffer statement = new StringBuffer("return ");
+        statement.append("super.getPort(new QName(\"").append(port.getName().getNamespaceURI()).append("\", \"").append(port.getName().getLocalPart()).append("\"), ");
         statement.append(retType.name());
-        statement.append(")super.getPort(new QName(\"").append(port.getName().getNamespaceURI()).append("\", \"").append(port.getName().getLocalPart()).append("\"), ");
-        statement.append(retType.name());
         statement.append(".class, features);");
         body.directStatement(statement.toString());
         writeWebEndpoint(port, m);
     }
 
-    private void writeDefaultGetPort(Port port, JDefinedClass cls) {
-        JType retType = getClass(port.getJavaInterface().getName(), ClassType.INTERFACE);
+    private void writeDefaultGetPort(Port port, JType retType, JDefinedClass cls) {
         String portGetter = port.getPortGetter();
         JMethod m = cls.method(JMod.PUBLIC, retType, portGetter);
         JDocComment methodDoc = m.javadoc();
-        if(port.getJavaDoc() != null)
+        if (port.getJavaDoc() != null)
             methodDoc.add(port.getJavaDoc());
         JCommentPart ret = methodDoc.addReturn();
-        ret.add("returns "+retType.name());
+        ret.add("returns " + retType.name());
         JBlock body = m.body();
-        StringBuffer statement = new StringBuffer("return (");
+        StringBuffer statement = new StringBuffer("return ");
+        statement.append("super.getPort(new QName(\"").append(port.getName().getNamespaceURI()).append("\", \"").append(port.getName().getLocalPart()).append("\"), ");
         statement.append(retType.name());
-        statement.append(")super.getPort(new QName(\"").append(port.getName().getNamespaceURI()).append("\", \"").append(port.getName().getLocalPart()).append("\"), ");
-        statement.append(retType.name());
         statement.append(".class);");
         body.directStatement(statement.toString());
         writeWebEndpoint(port, m);
     }
 
-
-    protected JDefinedClass getClass(String className, ClassType type) {
-        JDefinedClass cls;
-        try {
-            cls = cm._class(className, type);
-        } catch (JClassAlreadyExistsException e){
-            cls = cm._getClass(className);
-        }
-        return cls;
-    }
-
     private void writeWebServiceClientAnnotation(Service service, JAnnotationUse wsa) {
         String serviceName = service.getName().getLocalPart();
-        String serviceNS= service.getName().getNamespaceURI();
+        String serviceNS = service.getName().getNamespaceURI();
         wsa.param("name", serviceName);
         wsa.param("targetNamespace", serviceNS);
         wsa.param("wsdlLocation", wsdlLocation);
--- old/src/share/classes/com/sun/tools/internal/ws/processor/generator/W3CAddressingJavaGeneratorExtension.java	Tue Aug  4 09:28:29 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/generator/W3CAddressingJavaGeneratorExtension.java	Tue Aug  4 09:28:29 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: W3CAddressingJavaGeneratorExtension.java,v 1.1.2.4 2006/10/31 19:57:28 vivekp Exp $
- */
 
 package com.sun.tools.internal.ws.processor.generator;
 
--- old/src/share/classes/com/sun/tools/internal/ws/processor/model/Port.java	Tue Aug  4 09:28:31 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/model/Port.java	Tue Aug  4 09:28:31 2009
@@ -26,6 +26,7 @@
 package com.sun.tools.internal.ws.processor.model;
 
 import com.sun.tools.internal.ws.processor.model.java.JavaInterface;
+import com.sun.tools.internal.ws.wsdl.document.PortType;
 import com.sun.tools.internal.ws.wsdl.document.soap.SOAPStyle;
 import com.sun.tools.internal.ws.wsdl.framework.Entity;
 
@@ -174,4 +175,5 @@
     private String _address;
     private String _serviceImplName;
     private Map<String, Operation> operationsByName = new HashMap<String, Operation>();
+    public Map<QName, PortType> portTypes = new HashMap<QName, PortType>();
 }
--- old/src/share/classes/com/sun/tools/internal/ws/processor/model/java/JavaMethod.java	Tue Aug  4 09:28:34 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/model/java/JavaMethod.java	Tue Aug  4 09:28:33 2009
@@ -27,6 +27,7 @@
 
 import com.sun.tools.internal.ws.resources.ModelMessages;
 import com.sun.tools.internal.ws.wscompile.ErrorReceiver;
+import com.sun.tools.internal.ws.wscompile.WsimportOptions;
 import com.sun.tools.internal.ws.processor.model.Parameter;
 
 import java.util.ArrayList;
@@ -42,12 +43,14 @@
     private final String name;
     private final List<JavaParameter> parameters = new ArrayList<JavaParameter>();
     private final List<String> exceptions = new ArrayList<String>();
+    private final WsimportOptions options;
     private JavaType returnType;
 
-    public JavaMethod(String name, ErrorReceiver receiver) {
+    public JavaMethod(String name, WsimportOptions options, ErrorReceiver receiver) {
         this.name = name;
         this.returnType = null;
         this.errorReceiver = receiver;
+        this.options = options;
     }
 
     public String getName() {
@@ -83,10 +86,19 @@
     public void addParameter(JavaParameter param) {
         // verify that this member does not already exist
         if (hasParameter(param.getName())) {
-            errorReceiver.error(param.getParameter().getLocator(), ModelMessages.MODEL_PARAMETER_NOTUNIQUE(param.getName(), param.getParameter().getEntityName()));
-            Parameter duplicParam = getParameter(param.getName());
-            errorReceiver.error(duplicParam.getLocator(), ModelMessages.MODEL_PARAMETER_NOTUNIQUE(param.getName(), duplicParam.getEntityName()));
-            return;
+            if(options.isExtensionMode()){
+                param.setName(getUniqueName(param.getName()));
+            }else{
+                Parameter duplicParam = getParameter(param.getName());
+                if(param.getParameter().isEmbedded()){
+                    errorReceiver.error(param.getParameter().getLocator(), ModelMessages.MODEL_PARAMETER_NOTUNIQUE_WRAPPER(param.getName(), param.getParameter().getEntityName()));
+                    errorReceiver.error(duplicParam.getLocator(), ModelMessages.MODEL_PARAMETER_NOTUNIQUE_WRAPPER(param.getName(), duplicParam.getEntityName()));
+                }else{
+                    errorReceiver.error(param.getParameter().getLocator(), ModelMessages.MODEL_PARAMETER_NOTUNIQUE(param.getName(), param.getParameter().getEntityName()));
+                    errorReceiver.error(duplicParam.getLocator(), ModelMessages.MODEL_PARAMETER_NOTUNIQUE(param.getName(), duplicParam.getEntityName()));
+                }
+                return;
+            }
         }
         parameters.add(param);
     }
@@ -106,4 +118,12 @@
     public Iterator<String> getExceptions() {
         return exceptions.iterator();
     }
+
+    private String getUniqueName(String param){
+        int parmNum = 0;
+        while(hasParameter(param)){
+            param = param + Integer.toString(parmNum++);
+        }
+        return param;
+    }
 }
--- old/src/share/classes/com/sun/tools/internal/ws/processor/model/jaxb/JAXBType.java	Tue Aug  4 09:28:36 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/model/jaxb/JAXBType.java	Tue Aug  4 09:28:35 2009
@@ -71,11 +71,11 @@
     }
 
     public boolean isUnwrappable(){
-        return getJaxbMapping().getWrapperStyleDrilldown() != null;
+        return jaxbMapping != null && jaxbMapping.getWrapperStyleDrilldown() != null;
     }
 
     public boolean hasWrapperChildren(){
-        return (getWrapperChildren().size() > 0) ? true : false;
+        return wrapperChildren.size() > 0;
     }
 
     public boolean isLiteralType() {
--- old/src/share/classes/com/sun/tools/internal/ws/processor/modeler/annotation/WebServiceAP.java	Tue Aug  4 09:28:38 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/modeler/annotation/WebServiceAP.java	Tue Aug  4 09:28:38 2009
@@ -210,6 +210,7 @@
     public void onError(String message) {
         if (messager != null) {
             messager.printError(message);
+            throw new AbortException();
         } else {
             throw new ModelerException(message);
         }
--- old/src/share/classes/com/sun/tools/internal/ws/processor/modeler/annotation/WebServiceVisitor.java	Tue Aug  4 09:28:40 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/modeler/annotation/WebServiceVisitor.java	Tue Aug  4 09:28:40 2009
@@ -441,10 +441,21 @@
 
     protected boolean shouldProcessMethod(MethodDeclaration method, WebMethod webMethod) {
         builder.log("should process method: "+method.getSimpleName()+" hasWebMethods: "+ hasWebMethods+" ");
+        /*
+        Fix for https://jax-ws.dev.java.net/issues/show_bug.cgi?id=577
         if (hasWebMethods && webMethod == null) {
             builder.log("webMethod == null");
             return false;
         }
+        */
+        Collection<Modifier> modifiers = method.getModifiers();
+        boolean staticFinal = modifiers.contains(Modifier.STATIC) || modifiers.contains(Modifier.FINAL);
+        if (staticFinal) {
+            if (webMethod != null) {
+                builder.onError(method.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_WEBSERVICE_METHOD_IS_STATIC_OR_FINAL(method.getDeclaringType(), method));
+            }
+            return false;
+        }
         boolean retval = (endpointReferencesInterface ||
                 method.getDeclaringType().equals(typeDecl) ||
                 (method.getDeclaringType().getAnnotation(WebService.class) != null));
@@ -474,10 +485,6 @@
             builder.onError(classDecl.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_ABSTRACT(classDecl.getQualifiedName()));
             return false;
         }
-        if (classDecl.getDeclaringType() != null && !modifiers.contains(Modifier.STATIC) && !isStateful) {
-            builder.onError(classDecl.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_INNERCLASS_NOT_STATIC(classDecl.getQualifiedName()));
-            return false;
-        }
         boolean hasDefaultConstructor = false;
         for (ConstructorDeclaration constructor : classDecl.getConstructors()) {
             if (constructor.getModifiers().contains(Modifier.PUBLIC) &&
@@ -487,6 +494,11 @@
             }
         }
         if (!hasDefaultConstructor && !isStateful) {
+            if (classDecl.getDeclaringType() != null && !modifiers.contains(Modifier.STATIC)) {
+                builder.onError(classDecl.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_INNERCLASS_NOT_STATIC(classDecl.getQualifiedName()));
+                return false;
+            }
+
             builder.onError(classDecl.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_WEBSERVICE_NO_DEFAULT_CONSTRUCTOR(classDecl.getQualifiedName()));
             return false;
         }
@@ -578,7 +590,7 @@
         }
         ClassType superClass = classDecl.getSuperclass();
 
-        if (!superClass.getDeclaration().getQualifiedName().equals(JAVA_LANG_OBJECT) && superClass != null && !methodsAreLegal(superClass.getDeclaration())) {
+        if (!superClass.getDeclaration().getQualifiedName().equals(JAVA_LANG_OBJECT) && !methodsAreLegal(superClass.getDeclaration())) {
             return false;
         }
         return true;
@@ -596,11 +608,13 @@
         if (!hasWebMethods && (webMethod !=null) && webMethod.exclude()) {
             return true;
         }
+        /*
+        This check is not needed as Impl class is already checked that it is not abstract.
         if (typeDecl instanceof ClassDeclaration && method.getModifiers().contains(Modifier.ABSTRACT)) {
             builder.onError(method.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_WEBSERVICE_METHOD_IS_ABSTRACT(typeDecl.getQualifiedName(), method.getSimpleName()));
             return false;
         }
-
+        */
         if (!isLegalType(method.getReturnType())) {
             builder.onError(method.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_METHOD_RETURN_TYPE_CANNOT_IMPLEMENT_REMOTE(typeDecl.getQualifiedName(),
                 method.getSimpleName(),
@@ -750,7 +764,12 @@
     protected boolean isLegalType(TypeMirror type) {
         if (!(type instanceof DeclaredType))
             return true;
-        return !builder.isRemote(((DeclaredType)type).getDeclaration());
+        TypeDeclaration typeDecl = ((DeclaredType)type).getDeclaration();
+        if(typeDecl == null) {
+            // can be null, if this type's declaration is unknown. This may be the result of a processing error, such as a missing class file.
+            builder.onError(WebserviceapMessages.WEBSERVICEAP_COULD_NOT_FIND_TYPEDECL(typeDecl.toString(), context.getRound()));
+        }
+        return !builder.isRemote(typeDecl);
     }
 
     protected ParameterDeclaration getOutParameter(MethodDeclaration method) {
--- old/src/share/classes/com/sun/tools/internal/ws/processor/modeler/annotation/WebServiceWrapperGenerator.java	Tue Aug  4 09:28:43 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/modeler/annotation/WebServiceWrapperGenerator.java	Tue Aug  4 09:28:42 2009
@@ -127,8 +127,10 @@
         boolean beanGenerated = false;
         for (ReferenceType thrownType : method.getThrownTypes()) {
             ClassDeclaration typeDecl = ((ClassType)thrownType).getDeclaration();
-            if (typeDecl == null)
+            if (typeDecl == null){
                 builder.onError(WebserviceapMessages.WEBSERVICEAP_COULD_NOT_FIND_TYPEDECL(thrownType.toString(), context.getRound()));
+                return false;
+            }
             boolean tmp = generateExceptionBean(typeDecl, beanPackage);
             beanGenerated = beanGenerated || tmp;
         }
@@ -195,7 +197,7 @@
                 if (resWrapper.targetNamespace().length() > 0)
                     resNamespace = resWrapper.targetNamespace();
             }
-            canOverwriteResponse = builder.canOverWriteClass(requestClassName);
+            canOverwriteResponse = builder.canOverWriteClass(responseClassName);
             if (!canOverwriteResponse) {
                 builder.log("Class " + responseClassName + " exists. Not overwriting.");
             }
@@ -593,7 +595,7 @@
             return;
 
         String accessorName =JAXBRIContext.mangleNameToPropertyName(paramName);
-        String getterPrefix = paramType.equals("boolean") || paramType.equals("java.lang.Boolean") ? "is" : "get";
+        String getterPrefix = paramType.toString().equals("boolean")? "is" : "get";
         JType propType = getType(paramType);
         JMethod m = cls.method(JMod.PUBLIC, propType, getterPrefix+ accessorName);
         JDocComment methodDoc = m.javadoc();
--- old/src/share/classes/com/sun/tools/internal/ws/processor/modeler/wsdl/ConsoleErrorReporter.java	Tue Aug  4 09:28:45 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/modeler/wsdl/ConsoleErrorReporter.java	Tue Aug  4 09:28:45 2009
@@ -57,6 +57,8 @@
         print(WscompileMessages.WSIMPORT_ERROR_MESSAGE(e.getMessage()), e);
     }
 
+
+
     public void fatalError(SAXParseException e) {
         if(debug)
             e.printStackTrace();
@@ -76,6 +78,11 @@
         print(WscompileMessages.WSIMPORT_INFO_MESSAGE(e.getMessage()), e);
     }
 
+    public void debug(SAXParseException e){
+        print(WscompileMessages.WSIMPORT_DEBUG_MESSAGE(e.getMessage()), e);
+    }
+
+
     private void print(String message, SAXParseException e) {
         output.println(message);
         output.println(getLocationString(e));
--- old/src/share/classes/com/sun/tools/internal/ws/processor/modeler/wsdl/PseudoSchemaBuilder.java	Tue Aug  4 09:28:47 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/modeler/wsdl/PseudoSchemaBuilder.java	Tue Aug  4 09:28:47 2009
@@ -28,6 +28,7 @@
 import static com.sun.tools.internal.ws.processor.modeler.wsdl.WSDLModelerBase.getExtensionOfType;
 import com.sun.tools.internal.ws.wscompile.ErrorReceiver;
 import com.sun.tools.internal.ws.wscompile.WsimportOptions;
+import com.sun.tools.internal.ws.wscompile.Options;
 import com.sun.tools.internal.ws.wsdl.document.*;
 import com.sun.tools.internal.ws.wsdl.document.jaxws.JAXWSBinding;
 import com.sun.tools.internal.ws.wsdl.document.schema.SchemaKinds;
@@ -101,7 +102,7 @@
             is.setSystemId(sysId+(i + 1));
         }
         //add w3c EPR binding
-        if(!(options.noAddressingBbinding && options.isExtensionMode())){
+        if(!(options.noAddressingBbinding) && options.target.isLaterThan(Options.Target.V2_1)){
             InputSource is = new InputSource(new ByteArrayInputStream(w3ceprSchemaBinding.getBytes()));
             is.setSystemId(sysId+(++i +1));
             b.schemas.add(is);
--- old/src/share/classes/com/sun/tools/internal/ws/processor/modeler/wsdl/WSDLModeler.java	Tue Aug  4 09:28:49 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/modeler/wsdl/WSDLModeler.java	Tue Aug  4 09:28:49 2009
@@ -74,7 +74,7 @@
 public class WSDLModeler extends WSDLModelerBase {
 
     //map of wsdl:operation QName to <soapenv:Body> child, as per BP it must be unique in a port
-    private final Map<QName, QName> uniqueBodyBlocks = new HashMap<QName, QName>();
+    private final Map<QName, Operation> uniqueBodyBlocks = new HashMap<QName, Operation>();
     private final QName VOID_BODYBLOCK = new QName("");
     private ClassNameCollector classNameCollector;
     private final String explicitDefaultPackage;
@@ -334,11 +334,12 @@
                         || (!soapBinding.getTransport().equals(
                         SOAPConstants.URI_SOAP_TRANSPORT_HTTP) && !soapBinding.getTransport().equals(
                         SOAP12Constants.URI_SOAP_TRANSPORT_HTTP)))) {
-                    warning(wsdlPort, ModelerMessages.WSDLMODELER_WARNING_IGNORING_SOAP_BINDING_NON_HTTP_TRANSPORT(wsdlPort.getName()));
                     if (!options.isExtensionMode()) {
                         // cannot deal with non-HTTP ports
+                        warning(wsdlPort, ModelerMessages.WSDLMODELER_WARNING_IGNORING_SOAP_BINDING_NON_HTTP_TRANSPORT(wsdlPort.getName()));
                         return false;
                     }
+
                 }
 
                 /**
@@ -679,7 +680,12 @@
 
         if (soapStyle == SOAPStyle.RPC) {
             if (soapRequestBody.isEncoded()) {
-                error(soapRequestBody, ModelerMessages.WSDLMODELER_20_RPCENC_NOT_SUPPORTED());
+                if(options.isExtensionMode()){
+                    warning(soapRequestBody, ModelerMessages.WSDLMODELER_20_RPCENC_NOT_SUPPORTED());
+                    processNonSOAPOperation();
+                }else{
+                    error(soapRequestBody, ModelerMessages.WSDLMODELER_20_RPCENC_NOT_SUPPORTED());
+                }
             }
             return processLiteralSOAPOperation(StyleAndUse.RPC_LITERAL);
         }
@@ -815,20 +821,71 @@
         QName body = VOID_BODYBLOCK;
         QName opName = null;
 
+        Operation thatOp;
         if (bb.hasNext()) {
             body = bb.next().getName();
-            opName = uniqueBodyBlocks.get(body);
+            thatOp = uniqueBodyBlocks.get(body);
         } else {
             //there is no body block
             body = VOID_BODYBLOCK;
-            opName = uniqueBodyBlocks.get(VOID_BODYBLOCK);
+            thatOp = uniqueBodyBlocks.get(VOID_BODYBLOCK);
         }
-        if (opName != null) {
-            error(info.port, ModelerMessages.WSDLMODELER_NON_UNIQUE_BODY(info.port.getName(), info.operation.getName(), opName, body));
-        } else {
-            uniqueBodyBlocks.put(body, info.operation.getName());
+
+        if(thatOp != null){
+            if(options.isExtensionMode()){
+                warning(info.port, ModelerMessages.WSDLMODELER_NON_UNIQUE_BODY_WARNING(info.port.getName(), info.operation.getName(), thatOp.getName(), body));
+            }else{
+                error(info.port, ModelerMessages.WSDLMODELER_NON_UNIQUE_BODY_ERROR(info.port.getName(), info.operation.getName(), thatOp.getName(), body));
+            }
+        }else{
+            uniqueBodyBlocks.put(body, info.operation);
         }
 
+        //Add additional headers
+        if (options.additionalHeaders) {
+            List<Parameter> additionalHeaders = new ArrayList<Parameter>();
+            if (inputMessage != null) {
+                for (MessagePart part : getAdditionHeaderParts(inputMessage, true)) {
+                    QName name = part.getDescriptor();
+                    JAXBType jaxbType = getJAXBType(part);
+                    Block block = new Block(name, jaxbType, part);
+                    Parameter param = ModelerUtils.createParameter(part.getName(), jaxbType, block);
+                    additionalHeaders.add(param);
+                    request.addHeaderBlock(block);
+                    request.addParameter(param);
+                    definitiveParameterList.add(param);
+                }
+            }
+
+            if (isRequestResponse && outputMessage != null) {
+                List<Parameter> outParams = new ArrayList<Parameter>();
+                for (MessagePart part : getAdditionHeaderParts(outputMessage, false)) {
+                    QName name = part.getDescriptor();
+                    JAXBType jaxbType = getJAXBType(part);
+                    Block block = new Block(name, jaxbType, part);
+                    Parameter param = ModelerUtils.createParameter(part.getName(), jaxbType, block);
+                    param.setMode(Mode.OUT);
+                    outParams.add(param);
+                    response.addHeaderBlock(block);
+                    response.addParameter(param);
+                }
+                for (Parameter outParam : outParams) {
+                    for (Parameter inParam : additionalHeaders) {
+                        if (inParam.getName().equals(outParam.getName()) &&
+                                inParam.getBlock().getName().equals(outParam.getBlock().getName())) {
+                            //it is INOUT
+                            inParam.setMode(Mode.INOUT);
+                            outParam.setMode(Mode.INOUT);
+                            break;
+                        }
+                    }
+                    if (outParam.isOUT()) {
+                        definitiveParameterList.add(outParam);
+                    }
+                }
+            }
+        }
+
         // faults with duplicate names
         Set duplicateNames = getDuplicateFaultNames();
 
@@ -848,6 +905,7 @@
         return info.operation;
     }
 
+
     private boolean validateParameterName(List<Parameter> params) {
         if (options.isExtensionMode())
             return true;
@@ -1460,6 +1518,19 @@
         return null;
     }
 
+    private List<MessagePart> getAdditionHeaderParts(Message message, boolean isInput){
+        List<MessagePart> headerParts = new ArrayList<MessagePart>();
+        List<MessagePart> parts = message.getParts();
+        List<MessagePart> headers = getHeaderParts(isInput);
+
+        for(MessagePart part: headers){
+            if(parts.contains(part))
+                continue;
+            headerParts.add(part);
+        }
+        return headerParts;
+    }
+
     private List<MessagePart> getHeaderPartsFromMessage(Message message, boolean isInput) {
         List<MessagePart> headerParts = new ArrayList<MessagePart>();
         Iterator<MessagePart> parts = message.parts();
@@ -1490,19 +1561,6 @@
         return null;
     }
 
-    private List<MessagePart> getHeaderPartsNotFromMessage(Message message, boolean isInput) {
-        List<MessagePart> headerParts = new ArrayList<MessagePart>();
-        List<MessagePart> parts = message.getParts();
-        Iterator<MessagePart> headers = getHeaderParts(isInput).iterator();
-        while (headers.hasNext()) {
-            MessagePart part = headers.next();
-            if (!parts.contains(part)) {
-                headerParts.add(part);
-            }
-        }
-        return headerParts;
-    }
-
     private List<MessagePart> getHeaderParts(boolean isInput) {
         TWSDLExtensible ext;
         if (isInput) {
@@ -2247,6 +2305,10 @@
                 (QName) port.getProperty(
                         ModelProperties.PROPERTY_WSDL_PORT_TYPE_NAME);
         PortType pt = (PortType) document.find(Kinds.PORT_TYPE, portTypeName);
+        //populate the portType map here. We should get rid of all these properties
+        // lets not do it as it may break NB
+        //TODO: clean all these stuff part of NB RFE
+        port.portTypes.put(portTypeName, pt);
         JAXWSBinding jaxwsCust = (JAXWSBinding) getExtensionOfType(pt, JAXWSBinding.class);
         if (jaxwsCust != null && jaxwsCust.getClassName() != null) {
             CustomName name = jaxwsCust.getClassName();
@@ -2271,7 +2333,7 @@
     private void createJavaMethodForAsyncOperation(Port port, Operation operation,
                                                    JavaInterface intf) {
         String candidateName = getJavaNameForOperation(operation);
-        JavaMethod method = new JavaMethod(candidateName, errReceiver);
+        JavaMethod method = new JavaMethod(candidateName, options, errReceiver);
         Request request = operation.getRequest();
         Iterator requestBodyBlocks = request.getBodyBlocks();
         Block requestBlock =
@@ -2338,7 +2400,7 @@
             return;
         }
         String candidateName = getJavaNameForOperation(operation);
-        JavaMethod method = new JavaMethod(candidateName, errReceiver);
+        JavaMethod method = new JavaMethod(candidateName, options, errReceiver);
         Request request = operation.getRequest();
         Parameter returnParam = (Parameter) operation.getProperty(WSDL_RESULT_PARAMETER);
         if (returnParam != null) {
@@ -2718,7 +2780,7 @@
 
     private void reportError(Entity entity,
         String formattedMsg, Exception nestedException ) {
-        Locator locator = (entity == null)?NULL_LOCATOR:entity.getLocator();
+        Locator locator = (entity == null)?null:entity.getLocator();
 
         SAXParseException e = new SAXParseException2( formattedMsg,
             locator,
--- old/src/share/classes/com/sun/tools/internal/ws/processor/modeler/wsdl/WSDLModelerBase.java	Tue Aug  4 09:28:52 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/modeler/wsdl/WSDLModelerBase.java	Tue Aug  4 09:28:52 2009
@@ -288,23 +288,11 @@
     private boolean validateMimeContentPartNames(List<MIMEContent> mimeContents) {
         //validate mime:content(s) in the mime:part as per R2909
         for (MIMEContent mimeContent : mimeContents) {
-            String mimeContnetPart = null;
+            String mimeContnetPart;
+            mimeContnetPart = getMimeContentPartName(mimeContent);
             if(mimeContnetPart == null) {
-                mimeContnetPart = getMimeContentPartName(mimeContent);
-                if(mimeContnetPart == null) {
-                    warning(mimeContent, ModelerMessages.MIMEMODELER_INVALID_MIME_CONTENT_MISSING_PART_ATTRIBUTE(info.operation.getName().getLocalPart()));
-                    return false;
-                }
-            }else {
-                String newMimeContnetPart = getMimeContentPartName(mimeContent);
-                if(newMimeContnetPart == null) {
-                    warning(mimeContent, ModelerMessages.MIMEMODELER_INVALID_MIME_CONTENT_MISSING_PART_ATTRIBUTE(info.operation.getName().getLocalPart()));
-                    return false;
-                }else if(!newMimeContnetPart.equals(mimeContnetPart)) {
-                    //throw new ModelerException("mimemodeler.invalidMimeContent.differentPart");
-                    warning(mimeContent, ModelerMessages.MIMEMODELER_INVALID_MIME_CONTENT_DIFFERENT_PART());
-                    return false;
-                }
+                warning(mimeContent, ModelerMessages.MIMEMODELER_INVALID_MIME_CONTENT_MISSING_PART_ATTRIBUTE(info.operation.getName().getLocalPart()));
+                return false;
             }
         }
         return true;
@@ -386,6 +374,9 @@
     protected String getRequestNamespaceURI(SOAPBody body) {
         String namespaceURI = body.getNamespace();
         if (namespaceURI == null) {
+            if(options.isExtensionMode()){
+                return info.modelPort.getName().getNamespaceURI();
+            }
             // the WSDL document is invalid
             // at least, that's my interpretation of section 3.5 of the WSDL 1.1 spec!
             error(body, ModelerMessages.WSDLMODELER_INVALID_BINDING_OPERATION_INPUT_SOAP_BODY_MISSING_NAMESPACE(info.bindingOperation.getName()));
@@ -396,6 +387,9 @@
     protected String getResponseNamespaceURI(SOAPBody body) {
         String namespaceURI = body.getNamespace();
         if (namespaceURI == null) {
+            if(options.isExtensionMode()){
+                return info.modelPort.getName().getNamespaceURI();
+            }
             // the WSDL document is invalid
             // at least, that's my interpretation of section 3.5 of the WSDL 1.1 spec!
             error(body, ModelerMessages.WSDLMODELER_INVALID_BINDING_OPERATION_OUTPUT_SOAP_BODY_MISSING_NAMESPACE(info.bindingOperation.getName()));
@@ -703,7 +697,7 @@
         if(numPasses > 1)
             return;
         if(entity == null)
-            errReceiver.warning(NULL_LOCATOR, message);
+            errReceiver.warning(null, message);
         else
             errReceiver.warning(entity.getLocator(), message);
     }
@@ -710,7 +704,7 @@
 
     protected void error(Entity entity, String message){
         if(entity == null)
-            errReceiver.error(NULL_LOCATOR, message);
+            errReceiver.error(null, message);
         else
             errReceiver.error(entity.getLocator(), message);
         throw new AbortException();
--- old/src/share/classes/com/sun/tools/internal/ws/processor/util/ClassNameCollector.java	Tue Aug  4 09:28:55 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/processor/util/ClassNameCollector.java	Tue Aug  4 09:28:54 2009
@@ -80,8 +80,10 @@
     protected void preVisit(Service service) throws Exception {
         registerClassName(
             ((JavaInterface)service.getJavaInterface()).getName());
-        registerClassName(
-            ((JavaInterface)service.getJavaInterface()).getImpl());
+        // We don't generate Impl classes, commenting it out.
+        // Otherwise, it would cause naming conflicts
+        //registerClassName(
+        //    ((JavaInterface)service.getJavaInterface()).getImpl());
     }
 
     protected void processPort11x(Port port){
--- old/src/share/classes/com/sun/tools/internal/ws/resources/GeneratorMessages.java	Tue Aug  4 09:28:57 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/GeneratorMessages.java	Tue Aug  4 09:28:56 2009
@@ -38,6 +38,30 @@
     private final static LocalizableMessageFactory messageFactory = new LocalizableMessageFactory("com.sun.tools.internal.ws.resources.generator");
     private final static Localizer localizer = new Localizer();
 
+    public static Localizable localizableGENERATOR_SERVICE_CLASS_ALREADY_EXIST(Object arg0, Object arg1) {
+        return messageFactory.getMessage("generator.service.classAlreadyExist", arg0, arg1);
+    }
+
+    /**
+     * Could not generate Service, class: {0} already exists. Rename wsdl:Service "{1}" using JAX-WS customization
+     *
+     */
+    public static String GENERATOR_SERVICE_CLASS_ALREADY_EXIST(Object arg0, Object arg1) {
+        return localizer.localize(localizableGENERATOR_SERVICE_CLASS_ALREADY_EXIST(arg0, arg1));
+    }
+
+    public static Localizable localizableGENERATOR_SEI_CLASS_ALREADY_EXIST(Object arg0, Object arg1) {
+        return messageFactory.getMessage("generator.sei.classAlreadyExist", arg0, arg1);
+    }
+
+    /**
+     * Could not generate SEI, class: {0} already exists. Rename wsdl:portType "{1}" using JAX-WS customization
+     *
+     */
+    public static String GENERATOR_SEI_CLASS_ALREADY_EXIST(Object arg0, Object arg1) {
+        return localizer.localize(localizableGENERATOR_SEI_CLASS_ALREADY_EXIST(arg0, arg1));
+    }
+
     public static Localizable localizableGENERATOR_NESTED_GENERATOR_ERROR(Object arg0) {
         return messageFactory.getMessage("generator.nestedGeneratorError", arg0);
     }
--- old/src/share/classes/com/sun/tools/internal/ws/resources/ModelMessages.java	Tue Aug  4 09:28:59 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/ModelMessages.java	Tue Aug  4 09:28:59 2009
@@ -255,18 +255,6 @@
         return localizer.localize(localizableMODEL_SAXPARSER_EXCEPTION(arg0, arg1));
     }
 
-    public static Localizable localizable_002F_002F_JAXWS() {
-        return messageFactory.getMessage("//JAXWS");
-    }
-
-    /**
-     *  2.0
-     *
-     */
-    public static String _002F_002F_JAXWS() {
-        return localizer.localize(localizable_002F_002F_JAXWS());
-    }
-
     public static Localizable localizableMODEL_DUPLICATE_FAULTMESSAGE(Object arg0) {
         return messageFactory.getMessage("model.duplicate.faultmessage", arg0);
     }
@@ -536,7 +524,9 @@
     }
 
     /**
-     * Failed to generate Java signature: duplicate parameter names {0}. Use JAXWS binding customization to rename the wsdl:part "{1}"
+     * Failed to generate Java signature: duplicate parameter name "{0}". Try one of these
+     *  1. Use JAXWS binding customization to rename the wsdl:part "{1}"
+     *  2. Run wsimport with -extension switch.
      *
      */
     public static String MODEL_PARAMETER_NOTUNIQUE(Object arg0, Object arg1) {
@@ -639,6 +629,21 @@
         return localizer.localize(localizableMODEL_IMPORTER_INVALID_LITERAL(arg0));
     }
 
+    public static Localizable localizableMODEL_PARAMETER_NOTUNIQUE_WRAPPER(Object arg0, Object arg1) {
+        return messageFactory.getMessage("model.parameter.notunique.wrapper", arg0, arg1);
+    }
+
+    /**
+     * Failed to generate Java signature: duplicate parameter name "{0}". Try one of these
+     *  1. Use JAXWS binding customization to rename the wsdl:part "{1}"
+     *  2. Run wsimport with -extension switch.
+     *  3. This is wrapper style operation, to resolve parameter name conflict, you can also try disabling wrapper style by using <jaxws:enableWrapperStyle>false</jaxws:enableWrapperStyle> wsdl customization.
+     *
+     */
+    public static String MODEL_PARAMETER_NOTUNIQUE_WRAPPER(Object arg0, Object arg1) {
+        return localizer.localize(localizableMODEL_PARAMETER_NOTUNIQUE_WRAPPER(arg0, arg1));
+    }
+
     public static Localizable localizableMODEL_SCHEMA_NOT_IMPLEMENTED(Object arg0) {
         return messageFactory.getMessage("model.schema.notImplemented", arg0);
     }
--- old/src/share/classes/com/sun/tools/internal/ws/resources/ModelerMessages.java	Tue Aug  4 09:29:01 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/ModelerMessages.java	Tue Aug  4 09:29:01 2009
@@ -331,7 +331,7 @@
     }
 
     /**
-     * Schema descriptor {0} in message part "{1}" could not be bound to Java!
+     * Schema descriptor {0} in message part "{1}" is not defined and could not be bound to Java. Perhaps the schema descriptor {0} is not defined in the schema imported/included in the WSDL. You can either add such imports/includes or run wsimport and provide the schema location using -b switch.
      *
      */
     public static String WSDLMODELER_JAXB_JAVATYPE_NOTFOUND(Object arg0, Object arg1) {
@@ -590,6 +590,18 @@
         return localizer.localize(localizableWSDLMODELER_WARNING_IGNORING_OPERATION_CANNOT_HANDLE_BODY_PARTS_ATTRIBUTE(arg0));
     }
 
+    public static Localizable localizableWSDLMODELER_NON_UNIQUE_BODY_ERROR(Object arg0, Object arg1, Object arg2, Object arg3) {
+        return messageFactory.getMessage("wsdlmodeler.nonUnique.body.error", arg0, arg1, arg2, arg3);
+    }
+
+    /**
+     * Non unique body parts! In a port, as per BP 1.1 R2710 operations must have unique operation signaure on the wire for successful dispatch. In port {0}, Operations "{1}" and "{2}" have the same request body block {3}. Try running wsimport with -extension switch, runtime will try to dispatch using SOAPAction
+     *
+     */
+    public static String WSDLMODELER_NON_UNIQUE_BODY_ERROR(Object arg0, Object arg1, Object arg2, Object arg3) {
+        return localizer.localize(localizableWSDLMODELER_NON_UNIQUE_BODY_ERROR(arg0, arg1, arg2, arg3));
+    }
+
     public static Localizable localizableWSDLMODELER_WARNING_IGNORING_SOAP_BINDING_MIXED_STYLE(Object arg0) {
         return messageFactory.getMessage("wsdlmodeler.warning.ignoringSOAPBinding.mixedStyle", arg0);
     }
@@ -818,18 +830,6 @@
         return localizer.localize(localizableWSDLMODELER_INVALID_BINDING_OPERATION_MULTIPLE_MATCHING_OPERATIONS(arg0, arg1));
     }
 
-    public static Localizable localizableWSDLMODELER_NON_UNIQUE_BODY(Object arg0, Object arg1, Object arg2, Object arg3) {
-        return messageFactory.getMessage("wsdlmodeler.nonUnique.body", arg0, arg1, arg2, arg3);
-    }
-
-    /**
-     * Non unique body parts! In a port, operations must have unique operation signaure on the wire for successful dispatch. In port {0}, Operations "{1}" and "{2}" have the same request body block {3}
-     *
-     */
-    public static String WSDLMODELER_NON_UNIQUE_BODY(Object arg0, Object arg1, Object arg2, Object arg3) {
-        return localizer.localize(localizableWSDLMODELER_NON_UNIQUE_BODY(arg0, arg1, arg2, arg3));
-    }
-
     public static Localizable localizableWSDLMODELER_WARNING_IGNORING_HEADER_CANT_RESOLVE_MESSAGE(Object arg0, Object arg1) {
         return messageFactory.getMessage("wsdlmodeler.warning.ignoringHeader.cant.resolve.message", arg0, arg1);
     }
@@ -1238,6 +1238,18 @@
         return localizer.localize(localizableWSDLMODELER_WARNING_IGNORING_HEADER_FAULT_NOT_FOUND(arg0, arg1, arg2));
     }
 
+    public static Localizable localizableWSDLMODELER_NON_UNIQUE_BODY_WARNING(Object arg0, Object arg1, Object arg2, Object arg3) {
+        return messageFactory.getMessage("wsdlmodeler.nonUnique.body.warning", arg0, arg1, arg2, arg3);
+    }
+
+    /**
+     * Non unique body parts! In a port, as per BP 1.1 R2710 operations must have unique operation signaure on the wire for successful dispatch. In port {0}, Operations "{1}" and "{2}" have the same request body block {3}. Method dispatching may fail, runtime will try to dispatch using SOAPAction
+     *
+     */
+    public static String WSDLMODELER_NON_UNIQUE_BODY_WARNING(Object arg0, Object arg1, Object arg2, Object arg3) {
+        return localizer.localize(localizableWSDLMODELER_NON_UNIQUE_BODY_WARNING(arg0, arg1, arg2, arg3));
+    }
+
     public static Localizable localizableWSDLMODELER_INVALID_OPERATION_JAVA_RESERVED_WORD_NOT_ALLOWED_WRAPPER_STYLE(Object arg0, Object arg1, Object arg2) {
         return messageFactory.getMessage("wsdlmodeler.invalid.operation.javaReservedWordNotAllowed.wrapperStyle", arg0, arg1, arg2);
     }
--- old/src/share/classes/com/sun/tools/internal/ws/resources/WebserviceapMessages.java	Tue Aug  4 09:29:04 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/WebserviceapMessages.java	Tue Aug  4 09:29:03 2009
@@ -38,184 +38,184 @@
     private final static LocalizableMessageFactory messageFactory = new LocalizableMessageFactory("com.sun.tools.internal.ws.resources.webserviceap");
     private final static Localizer localizer = new Localizer();
 
-    public static Localizable localizableWEBSERVICEAP_RPC_LITERAL_MUST_NOT_BE_BARE(Object arg0) {
-        return messageFactory.getMessage("webserviceap.rpc.literal.must.not.be.bare", arg0);
+    public static Localizable localizableWEBSERVICEAP_ENDPOINTINTERFACES_DO_NOT_MATCH(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.endpointinterfaces.do.not.match", arg0, arg1);
     }
 
     /**
-     * RPC literal SOAPBindings must have parameterStyle WRAPPPED. Class: {0}.
+     * The endpoint interface {0} does not match the interface {1}.
      *
      */
-    public static String WEBSERVICEAP_RPC_LITERAL_MUST_NOT_BE_BARE(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_RPC_LITERAL_MUST_NOT_BE_BARE(arg0));
+    public static String WEBSERVICEAP_ENDPOINTINTERFACES_DO_NOT_MATCH(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_ENDPOINTINTERFACES_DO_NOT_MATCH(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT_EXCLUDE(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.invalid.sei.annotation.element.exclude", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_INVALID_WEBMETHOD_ELEMENT_WITH_EXCLUDE(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.invalid.webmethod.element.with.exclude", arg0, arg1, arg2);
     }
 
     /**
-     * The @javax.jws.WebMethod({0}) cannot be used on a service endpoint interface. Class: {1} method: {2}
+     * The @javax.jws.WebMethod.{0} element cannot be specified with the @javax.jws.WebMethod.exclude element. Class: {1} method: {2}
      *
      */
-    public static String WEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT_EXCLUDE(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT_EXCLUDE(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_INVALID_WEBMETHOD_ELEMENT_WITH_EXCLUDE(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_INVALID_WEBMETHOD_ELEMENT_WITH_EXCLUDE(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_INNERCLASS_NOT_STATIC(Object arg0) {
-        return messageFactory.getMessage("webserviceap.webservice.class.is.innerclass.not.static", arg0);
+    public static Localizable localizableWEBSERVICEAP_SEI_CANNOT_CONTAIN_CONSTANT_VALUES(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.sei.cannot.contain.constant.values", arg0, arg1);
     }
 
     /**
-     * Inner classes annotated with @javax.jws.WebService must be static. Class: {0}
+     * An service endpoint interface cannot contain constant declaration: Interface: {0} field: {1}.
      *
      */
-    public static String WEBSERVICEAP_WEBSERVICE_CLASS_IS_INNERCLASS_NOT_STATIC(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_INNERCLASS_NOT_STATIC(arg0));
+    public static String WEBSERVICEAP_SEI_CANNOT_CONTAIN_CONSTANT_VALUES(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_SEI_CANNOT_CONTAIN_CONSTANT_VALUES(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_METHOD_IS_ABSTRACT(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.webservice.method.is.abstract", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_RPC_LITERAL_PARAMETERS_MUST_HAVE_WEBPARAM(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.rpc.literal.parameters.must.have.webparam", arg0, arg1, arg2);
     }
 
     /**
-     * Classes annotated with @javax.jws.WebService must not have abstract methods. Class: {0} Method: {1}
+     * All rpc literal parameters must have a WebParam annotation.  Class: {0} method: {1} parameter {2}
      *
      */
-    public static String WEBSERVICEAP_WEBSERVICE_METHOD_IS_ABSTRACT(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_METHOD_IS_ABSTRACT(arg0, arg1));
+    public static String WEBSERVICEAP_RPC_LITERAL_PARAMETERS_MUST_HAVE_WEBPARAM(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_RPC_LITERAL_PARAMETERS_MUST_HAVE_WEBPARAM(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_RETURN_TYPE(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.oneway.operation.cannot.have.return.type", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_METHOD_EXCEPTION_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.method.exception.bean.name.not.unique", arg0, arg1);
     }
 
     /**
-     * The method {1} of class {0} is annotated @Oneway but has a return type.
+     * Exception bean names must be unique and must not clash with other generated classes.  Class: {0} exception {1}
      *
      */
-    public static String WEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_RETURN_TYPE(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_RETURN_TYPE(arg0, arg1));
+    public static String WEBSERVICEAP_METHOD_EXCEPTION_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_METHOD_EXCEPTION_BEAN_NAME_NOT_UNIQUE(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_WARNING(Object arg0) {
-        return messageFactory.getMessage("webserviceap.warning", arg0);
+    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_AND_WEBSERVICEPROVIDER(Object arg0) {
+        return messageFactory.getMessage("webserviceap.webservice.and.webserviceprovider", arg0);
     }
 
     /**
-     * warning: {0}
+     * Classes cannot be annotated with both @javax.jws.WebService and @javax.xml.ws.WebServiceProvider.  Class: {0}
      *
      */
-    public static String WEBSERVICEAP_WARNING(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_WARNING(arg0));
+    public static String WEBSERVICEAP_WEBSERVICE_AND_WEBSERVICEPROVIDER(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_AND_WEBSERVICEPROVIDER(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_RPC_SOAPBINDING_NOT_ALLOWED_ON_METHOD(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.rpc.soapbinding.not.allowed.on.method", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_NO_DEFAULT_CONSTRUCTOR(Object arg0) {
+        return messageFactory.getMessage("webserviceap.webservice.no.default.constructor", arg0);
     }
 
     /**
-     * SOAPBinding.Style.RPC binding annotations are not allowed on methods.  Class: {0} Method: {1}
+     * Classes annotated with @javax.jws.WebService must have a public default constructor. Class: {0}
      *
      */
-    public static String WEBSERVICEAP_RPC_SOAPBINDING_NOT_ALLOWED_ON_METHOD(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_RPC_SOAPBINDING_NOT_ALLOWED_ON_METHOD(arg0, arg1));
+    public static String WEBSERVICEAP_WEBSERVICE_NO_DEFAULT_CONSTRUCTOR(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_NO_DEFAULT_CONSTRUCTOR(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_COULD_NOT_FIND_HANDLERCHAIN(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.could.not.find.handlerchain", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_DOC_BARE_NO_OUT(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.doc.bare.no.out", arg0, arg1);
     }
 
     /**
-     * Could not find the handlerchain {0} in the handler file {1}
+     * Document/literal bare methods with no return type or OUT/INOUT parameters must be annotated as @Oneway. Class: {0}, method: {1}
      *
      */
-    public static String WEBSERVICEAP_COULD_NOT_FIND_HANDLERCHAIN(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_COULD_NOT_FIND_HANDLERCHAIN(arg0, arg1));
+    public static String WEBSERVICEAP_DOC_BARE_NO_OUT(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_DOC_BARE_NO_OUT(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_NO_PACKAGE_CLASS_MUST_HAVE_TARGETNAMESPACE(Object arg0) {
-        return messageFactory.getMessage("webserviceap.no.package.class.must.have.targetnamespace", arg0);
+    public static Localizable localizableWEBSERVICEAP_FAILED_TO_PARSE_HANDLERCHAIN_FILE(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.failed.to.parse.handlerchain.file", arg0, arg1);
     }
 
     /**
-     * @javax.jws.Webservice annotated classes that do not belong to a package must have the @javax.jws.Webservice.targetNamespace element.  Class: {0}
+     * Failed to parse HandlerChain file. Class: {0}, file: {1}
      *
      */
-    public static String WEBSERVICEAP_NO_PACKAGE_CLASS_MUST_HAVE_TARGETNAMESPACE(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_NO_PACKAGE_CLASS_MUST_HAVE_TARGETNAMESPACE(arg0));
+    public static String WEBSERVICEAP_FAILED_TO_PARSE_HANDLERCHAIN_FILE(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_FAILED_TO_PARSE_HANDLERCHAIN_FILE(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_CLASS_NOT_FOUND(Object arg0) {
-        return messageFactory.getMessage("webserviceap.class.not.found", arg0);
+    public static Localizable localizableWEBSERVICEAP_JAVA_TYPE_NOT_FOUND(Object arg0) {
+        return messageFactory.getMessage("webserviceap.java.typeNotFound", arg0);
     }
 
     /**
-     * Class Not Found: {0}
+     * The type: {0} was not found in the mapping
      *
      */
-    public static String WEBSERVICEAP_CLASS_NOT_FOUND(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_CLASS_NOT_FOUND(arg0));
+    public static String WEBSERVICEAP_JAVA_TYPE_NOT_FOUND(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_JAVA_TYPE_NOT_FOUND(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_DOC_BARE_NO_RETURN_AND_NO_OUT(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.doc.bare.no.return.and.no.out", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_DECLARE_EXCEPTIONS(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.oneway.operation.cannot.declare.exceptions", arg0, arg1, arg2);
     }
 
     /**
-     * Document literal bare methods that do not have a return value must have a single OUT/INOUT parameter.  Class: {0} Method: {1}
+     * The method {1} of class {0} is annotated @Oneway but declares the exception {2}
      *
      */
-    public static String WEBSERVICEAP_DOC_BARE_NO_RETURN_AND_NO_OUT(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_DOC_BARE_NO_RETURN_AND_NO_OUT(arg0, arg1));
+    public static String WEBSERVICEAP_ONEWAY_OPERATION_CANNOT_DECLARE_EXCEPTIONS(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_DECLARE_EXCEPTIONS(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_RETURN_NOT_UNIQUE(Object arg0, Object arg1, Object arg2, Object arg3) {
-        return messageFactory.getMessage("webserviceap.document.literal.bare.method.return.not.unique", arg0, arg1, arg2, arg3);
+    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_METHOD_IS_STATIC_OR_FINAL(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.webservice.method.is.static.or.final", arg0, arg1);
     }
 
     /**
-     * Document literal bare methods must have a unique result name return type combination.  Class {0} method: {1}, result name: {2} return type: {3}
+     * Method annotated with @javax.jws.WebMethod must not be static or final. Class: {0} Method: {1}
      *
      */
-    public static String WEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_RETURN_NOT_UNIQUE(Object arg0, Object arg1, Object arg2, Object arg3) {
-        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_RETURN_NOT_UNIQUE(arg0, arg1, arg2, arg3));
+    public static String WEBSERVICEAP_WEBSERVICE_METHOD_IS_STATIC_OR_FINAL(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_METHOD_IS_STATIC_OR_FINAL(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_DOC_BARE_NO_OUT(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.doc.bare.no.out", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_RETURN_TYPE(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.oneway.operation.cannot.have.return.type", arg0, arg1);
     }
 
     /**
-     * Document/literal bare methods with no return type or OUT/INOUT parameters must be annotated as @Oneway. Class: {0}, method: {1}
+     * The method {1} of class {0} is annotated @Oneway but has a return type.
      *
      */
-    public static String WEBSERVICEAP_DOC_BARE_NO_OUT(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_DOC_BARE_NO_OUT(arg0, arg1));
+    public static String WEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_RETURN_TYPE(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_RETURN_TYPE(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_RPC_LITERAL_PARAMETERS_MUST_HAVE_WEBPARAM(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.rpc.literal.parameters.must.have.webparam", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_WARNING(Object arg0) {
+        return messageFactory.getMessage("webserviceap.warning", arg0);
     }
 
     /**
-     * All rpc literal parameters must have a WebParam annotation.  Class: {0} method: {1} parameter {2}
+     * warning: {0}
      *
      */
-    public static String WEBSERVICEAP_RPC_LITERAL_PARAMETERS_MUST_HAVE_WEBPARAM(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_RPC_LITERAL_PARAMETERS_MUST_HAVE_WEBPARAM(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_WARNING(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_WARNING(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_MODEL_ALREADY_EXISTS() {
-        return messageFactory.getMessage("webserviceap.model.already.exists");
+    public static Localizable localizableWEBSERVICEAP_METHOD_RESPONSE_WRAPPER_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.method.response.wrapper.bean.name.not.unique", arg0, arg1);
     }
 
     /**
-     * model already exists
+     * Response wrapper bean names must be unique and must not clash with other generated classes.  Class: {0} method {1}
      *
      */
-    public static String WEBSERVICEAP_MODEL_ALREADY_EXISTS() {
-        return localizer.localize(localizableWEBSERVICEAP_MODEL_ALREADY_EXISTS());
+    public static String WEBSERVICEAP_METHOD_RESPONSE_WRAPPER_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_METHOD_RESPONSE_WRAPPER_BEAN_NAME_NOT_UNIQUE(arg0, arg1));
     }
 
     public static Localizable localizableWEBSERVICEAP_ENDPOINTINTERFACE_ON_INTERFACE(Object arg0, Object arg1) {
@@ -230,376 +230,376 @@
         return localizer.localize(localizableWEBSERVICEAP_ENDPOINTINTERFACE_ON_INTERFACE(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_METHOD_NOT_ANNOTATED(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.method.not.annotated", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_NESTED_MODEL_ERROR(Object arg0) {
+        return messageFactory.getMessage("webserviceap.nestedModelError", arg0);
     }
 
     /**
-     * The method {0} on class {1} is not annotated.
+     * modeler error: {0}
      *
      */
-    public static String WEBSERVICEAP_METHOD_NOT_ANNOTATED(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_METHOD_NOT_ANNOTATED(arg0, arg1));
+    public static String WEBSERVICEAP_NESTED_MODEL_ERROR(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_NESTED_MODEL_ERROR(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_NON_IN_PARAMETERS_MUST_BE_HOLDER(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.non.in.parameters.must.be.holder", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_ONEWAY_AND_OUT(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.oneway.and.out", arg0, arg1);
     }
 
     /**
-     * Class: {0}, method: {1}, parameter: {2} is not WebParam.Mode.IN and is not of type javax.xml.ws.Holder.
+     * @Oneway methods cannot have out parameters. Class: {0} method {1}
      *
      */
-    public static String WEBSERVICEAP_NON_IN_PARAMETERS_MUST_BE_HOLDER(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_NON_IN_PARAMETERS_MUST_BE_HOLDER(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_ONEWAY_AND_OUT(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_ONEWAY_AND_OUT(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_FAILED_TO_FIND_HANDLERCHAIN_FILE(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.failed.to.find.handlerchain.file", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_RPC_LITERAL_WEBPARAMS_MUST_SPECIFY_NAME(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.rpc.literal.webparams.must.specify.name", arg0, arg1, arg2);
     }
 
     /**
-     * Cannot find HandlerChain file. class: {0}, file: {1}
+     * All rpc literal WebParams must specify a name.  Class: {0} method {1} paramter {2}
      *
      */
-    public static String WEBSERVICEAP_FAILED_TO_FIND_HANDLERCHAIN_FILE(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_FAILED_TO_FIND_HANDLERCHAIN_FILE(arg0, arg1));
+    public static String WEBSERVICEAP_RPC_LITERAL_WEBPARAMS_MUST_SPECIFY_NAME(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_RPC_LITERAL_WEBPARAMS_MUST_SPECIFY_NAME(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_OPERATION_NAME_NOT_UNIQUE(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.operation.name.not.unique", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT_EXCLUDE(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.invalid.sei.annotation.element.exclude", arg0, arg1, arg2);
     }
 
     /**
-     * Operation names must be unique.  Class: {0} method: {1} operation name: {2}
+     * The @javax.jws.WebMethod({0}) cannot be used on a service endpoint interface. Class: {1} method: {2}
      *
      */
-    public static String WEBSERVICEAP_OPERATION_NAME_NOT_UNIQUE(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_OPERATION_NAME_NOT_UNIQUE(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT_EXCLUDE(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT_EXCLUDE(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_METHOD_NOT_IMPLEMENTED(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.method.not.implemented", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_CLASS_NOT_FOUND(Object arg0) {
+        return messageFactory.getMessage("webserviceap.class.not.found", arg0);
     }
 
     /**
-     * Methods in an endpointInterface must be implemented in the implementation class.  Interface Class:{0} Implementation Class:{1} Method: {2}
+     * Class Not Found: {0}
      *
      */
-    public static String WEBSERVICEAP_METHOD_NOT_IMPLEMENTED(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_METHOD_NOT_IMPLEMENTED(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_CLASS_NOT_FOUND(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_CLASS_NOT_FOUND(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_HEADER_PARAMETERS_MUST_HAVE_WEBPARAM_NAME(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.header.parameters.must.have.webparam.name", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ELEMENT(Object arg0) {
+        return messageFactory.getMessage("webserviceap.endpointinteface.plus.element", arg0);
     }
 
     /**
-     * All WebParam annotations on header parameters must specify a name.  Class: {0} method {1} paramter {2}
+     * The @javax.jws.WebService.{0} element cannot be used in with @javax.jws.WebService.endpointInterface element.
      *
      */
-    public static String WEBSERVICEAP_HEADER_PARAMETERS_MUST_HAVE_WEBPARAM_NAME(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_HEADER_PARAMETERS_MUST_HAVE_WEBPARAM_NAME(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ELEMENT(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ELEMENT(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_INVALID_HANDLERCHAIN_FILE_NOHANDLER_CONFIG(Object arg0) {
-        return messageFactory.getMessage("webserviceap.invalid.handlerchain.file.nohandler-config", arg0);
+    public static Localizable localizableWEBSERVICEAP_CANNOT_COMBINE_HANDLERCHAIN_SOAPMESSAGEHANDLERS() {
+        return messageFactory.getMessage("webserviceap.cannot.combine.handlerchain.soapmessagehandlers");
     }
 
     /**
-     * The handlerchain file {0} is invalid, it does not contain a handler-config element
+     * You cannot specify both HanlderChain and SOAPMessageHandlers annotations
      *
      */
-    public static String WEBSERVICEAP_INVALID_HANDLERCHAIN_FILE_NOHANDLER_CONFIG(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_INVALID_HANDLERCHAIN_FILE_NOHANDLER_CONFIG(arg0));
+    public static String WEBSERVICEAP_CANNOT_COMBINE_HANDLERCHAIN_SOAPMESSAGEHANDLERS() {
+        return localizer.localize(localizableWEBSERVICEAP_CANNOT_COMBINE_HANDLERCHAIN_SOAPMESSAGEHANDLERS());
     }
 
-    public static Localizable localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_DECLARE_EXCEPTIONS(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.oneway.operation.cannot.declare.exceptions", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_INNERCLASS_NOT_STATIC(Object arg0) {
+        return messageFactory.getMessage("webserviceap.webservice.class.is.innerclass.not.static", arg0);
     }
 
     /**
-     * The method {1} of class {0} is annotated @Oneway but declares the exception {2}
+     * Inner classes annotated with @javax.jws.WebService must be static. Class: {0}
      *
      */
-    public static String WEBSERVICEAP_ONEWAY_OPERATION_CANNOT_DECLARE_EXCEPTIONS(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_DECLARE_EXCEPTIONS(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_WEBSERVICE_CLASS_IS_INNERCLASS_NOT_STATIC(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_INNERCLASS_NOT_STATIC(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_HOLDERS(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.oneway.operation.cannot.have.holders", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_NON_IN_PARAMETERS_MUST_BE_HOLDER(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.non.in.parameters.must.be.holder", arg0, arg1, arg2);
     }
 
     /**
-     * The method {1} of class {0} is annotated @Oneway but contains inout or out paramerters (javax.xml.ws.Holder)
+     * Class: {0}, method: {1}, parameter: {2} is not WebParam.Mode.IN and is not of type javax.xml.ws.Holder.
      *
      */
-    public static String WEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_HOLDERS(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_HOLDERS(arg0, arg1));
+    public static String WEBSERVICEAP_NON_IN_PARAMETERS_MUST_BE_HOLDER(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_NON_IN_PARAMETERS_MUST_BE_HOLDER(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_ONEWAY_AND_NOT_ONE_IN(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.oneway.and.not.one.in", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.invalid.sei.annotation.element", arg0, arg1);
     }
 
     /**
-     * Document literal bare methods annotated with @javax.jws.Oneway must have one non-header IN parameter.  Class: {0} Method: {1}
+     * The @javax.jws.WebService.{0} element cannot be specified on a service endpoint interface. Class: {1}
      *
      */
-    public static String WEBSERVICEAP_ONEWAY_AND_NOT_ONE_IN(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_ONEWAY_AND_NOT_ONE_IN(arg0, arg1));
+    public static String WEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_RPC_ENCODED_NOT_SUPPORTED(Object arg0) {
-        return messageFactory.getMessage("webserviceap.rpc.encoded.not.supported", arg0);
+    public static Localizable localizableWEBSERVICEAP_SUCCEEDED() {
+        return messageFactory.getMessage("webserviceap.succeeded");
     }
 
     /**
-     * The {0} class has a rpc/encoded SOAPBinding.  Rpc/encoded SOAPBindings are not supported in JAXWS 2.0.
+     * Success
      *
      */
-    public static String WEBSERVICEAP_RPC_ENCODED_NOT_SUPPORTED(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_RPC_ENCODED_NOT_SUPPORTED(arg0));
+    public static String WEBSERVICEAP_SUCCEEDED() {
+        return localizer.localize(localizableWEBSERVICEAP_SUCCEEDED());
     }
 
-    public static Localizable localizableWEBSERVICEAP_JAVA_TYPE_NOT_FOUND(Object arg0) {
-        return messageFactory.getMessage("webserviceap.java.typeNotFound", arg0);
+    public static Localizable localizableWEBSERVICEAP_DOC_BARE_AND_NO_ONE_IN(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.doc.bare.and.no.one.in", arg0, arg1);
     }
 
     /**
-     * The type: {0} was not found in the mapping
+     * Document literal bare methods must have one non-header, IN/INOUT parameter.  Class: {0} Method: {1}
      *
      */
-    public static String WEBSERVICEAP_JAVA_TYPE_NOT_FOUND(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_JAVA_TYPE_NOT_FOUND(arg0));
+    public static String WEBSERVICEAP_DOC_BARE_AND_NO_ONE_IN(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_DOC_BARE_AND_NO_ONE_IN(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.invalid.sei.annotation", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_METHOD_IS_ABSTRACT(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.webservice.method.is.abstract", arg0, arg1);
     }
 
     /**
-     * The @{0} annotation cannot be used on a service endpoint interface. Class: {1}
+     * Classes annotated with @javax.jws.WebService must not have abstract methods. Class: {0} Method: {1}
      *
      */
-    public static String WEBSERVICEAP_INVALID_SEI_ANNOTATION(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION(arg0, arg1));
+    public static String WEBSERVICEAP_WEBSERVICE_METHOD_IS_ABSTRACT(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_METHOD_IS_ABSTRACT(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_NO_WEBSERVICE_ENDPOINT_FOUND() {
-        return messageFactory.getMessage("webserviceap.no.webservice.endpoint.found");
+    public static Localizable localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_RETURN_NOT_UNIQUE(Object arg0, Object arg1, Object arg2, Object arg3) {
+        return messageFactory.getMessage("webserviceap.document.literal.bare.method.return.not.unique", arg0, arg1, arg2, arg3);
     }
 
     /**
-     * A web service endpoint could not be found
+     * Document literal bare methods must have a unique result name return type combination.  Class {0} method: {1}, result name: {2} return type: {3}
      *
      */
-    public static String WEBSERVICEAP_NO_WEBSERVICE_ENDPOINT_FOUND() {
-        return localizer.localize(localizableWEBSERVICEAP_NO_WEBSERVICE_ENDPOINT_FOUND());
+    public static String WEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_RETURN_NOT_UNIQUE(Object arg0, Object arg1, Object arg2, Object arg3) {
+        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_RETURN_NOT_UNIQUE(arg0, arg1, arg2, arg3));
     }
 
-    public static Localizable localizableWEBSERVICEAP_INVALID_WEBMETHOD_ELEMENT_WITH_EXCLUDE(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.invalid.webmethod.element.with.exclude", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_NO_WEBSERVICE_ENDPOINT_FOUND() {
+        return messageFactory.getMessage("webserviceap.no.webservice.endpoint.found");
     }
 
     /**
-     * The @javax.jws.WebMethod.{0} element cannot be specified with the @javax.jws.WebMethod.exclude element. Class: {1} method: {2}
+     * A web service endpoint could not be found
      *
      */
-    public static String WEBSERVICEAP_INVALID_WEBMETHOD_ELEMENT_WITH_EXCLUDE(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_INVALID_WEBMETHOD_ELEMENT_WITH_EXCLUDE(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_NO_WEBSERVICE_ENDPOINT_FOUND() {
+        return localizer.localize(localizableWEBSERVICEAP_NO_WEBSERVICE_ENDPOINT_FOUND());
     }
 
-    public static Localizable localizableWEBSERVICEAP_COULD_NOT_FIND_TYPEDECL(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.could.not.find.typedecl", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_FILE_NOT_FOUND(Object arg0) {
+        return messageFactory.getMessage("webserviceap.fileNotFound", arg0);
     }
 
     /**
-     * Could not get TypeDeclaration for: {0} in apt round: {1}
+     * error: file not found: {0}
      *
      */
-    public static String WEBSERVICEAP_COULD_NOT_FIND_TYPEDECL(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_COULD_NOT_FIND_TYPEDECL(arg0, arg1));
+    public static String WEBSERVICEAP_FILE_NOT_FOUND(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_FILE_NOT_FOUND(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_CANNOT_HAVE_MORE_THAN_ONE_OUT(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.document.literal.bare.cannot.have.more.than.one.out", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_INVALID_HANDLERCHAIN_FILE_NOHANDLER_CONFIG(Object arg0) {
+        return messageFactory.getMessage("webserviceap.invalid.handlerchain.file.nohandler-config", arg0);
     }
 
     /**
-     * Document literal bare methods must have a return value or one out parameter.  Class: {0} Method: {1}
+     * The handlerchain file {0} is invalid, it does not contain a handler-config element
      *
      */
-    public static String WEBSERVICEAP_DOCUMENT_LITERAL_BARE_CANNOT_HAVE_MORE_THAN_ONE_OUT(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_CANNOT_HAVE_MORE_THAN_ONE_OUT(arg0, arg1));
+    public static String WEBSERVICEAP_INVALID_HANDLERCHAIN_FILE_NOHANDLER_CONFIG(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_INVALID_HANDLERCHAIN_FILE_NOHANDLER_CONFIG(arg0));
     }
 
-    public static Localizable localizableWEBSERVICE_ENCODED_NOT_SUPPORTED(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webservice.encoded.not.supported", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_HEADER_PARAMETERS_MUST_HAVE_WEBPARAM_NAME(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.header.parameters.must.have.webparam.name", arg0, arg1, arg2);
     }
 
     /**
-     * The {0} class has invalid SOAPBinding annotation. {1}/encoded SOAPBinding is not supported
+     * All WebParam annotations on header parameters must specify a name.  Class: {0} method {1} paramter {2}
      *
      */
-    public static String WEBSERVICE_ENCODED_NOT_SUPPORTED(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICE_ENCODED_NOT_SUPPORTED(arg0, arg1));
+    public static String WEBSERVICEAP_HEADER_PARAMETERS_MUST_HAVE_WEBPARAM_NAME(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_HEADER_PARAMETERS_MUST_HAVE_WEBPARAM_NAME(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_FINAL(Object arg0) {
-        return messageFactory.getMessage("webserviceap.webservice.class.is.final", arg0);
+    public static Localizable localizableWEBSERVICEAP_METHOD_RETURN_TYPE_CANNOT_IMPLEMENT_REMOTE(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.method.return.type.cannot.implement.remote", arg0, arg1, arg2);
     }
 
     /**
-     * Classes annotated with @javax.jws.WebService must not be final. Class: {0}
+     * Method return types cannot implement java.rmi.Remote.  Class: {0} method: {1} return type: {2}
      *
      */
-    public static String WEBSERVICEAP_WEBSERVICE_CLASS_IS_FINAL(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_FINAL(arg0));
+    public static String WEBSERVICEAP_METHOD_RETURN_TYPE_CANNOT_IMPLEMENT_REMOTE(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_METHOD_RETURN_TYPE_CANNOT_IMPLEMENT_REMOTE(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_NO_DEFAULT_CONSTRUCTOR(Object arg0) {
-        return messageFactory.getMessage("webserviceap.webservice.no.default.constructor", arg0);
+    public static Localizable localizableWEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ANNOTATION(Object arg0) {
+        return messageFactory.getMessage("webserviceap.endpointinteface.plus.annotation", arg0);
     }
 
     /**
-     * Classes annotated with @javax.jws.WebService must have a public default constructor. Class: {0}
+     * The @{0} annotation cannot be used in with @javax.jws.WebService.endpointInterface element.
      *
      */
-    public static String WEBSERVICEAP_WEBSERVICE_NO_DEFAULT_CONSTRUCTOR(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_NO_DEFAULT_CONSTRUCTOR(arg0));
+    public static String WEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ANNOTATION(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ANNOTATION(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_SEI_CANNOT_CONTAIN_CONSTANT_VALUES(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.sei.cannot.contain.constant.values", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_HOLDER_PARAMETERS_MUST_NOT_BE_IN_ONLY(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.holder.parameters.must.not.be.in.only", arg0, arg1, arg2);
     }
 
     /**
-     * An service endpoint interface cannot contain constant declaration: Interface: {0} field: {1}.
+     * javax.xml.ws.Holder parameters must not be annotated with the WebParam.Mode.IN property.  Class: {0} method: {1} parameter: {2}
      *
      */
-    public static String WEBSERVICEAP_SEI_CANNOT_CONTAIN_CONSTANT_VALUES(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_SEI_CANNOT_CONTAIN_CONSTANT_VALUES(arg0, arg1));
+    public static String WEBSERVICEAP_HOLDER_PARAMETERS_MUST_NOT_BE_IN_ONLY(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_HOLDER_PARAMETERS_MUST_NOT_BE_IN_ONLY(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_ENDPOINTINTERFACE_CLASS_NOT_FOUND(Object arg0) {
-        return messageFactory.getMessage("webserviceap.endpointinterface.class.not.found", arg0);
+    public static Localizable localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONLY_ONE_IN_PARAMETER(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.document.literal.bare.must.have.only.one.in.parameter", arg0, arg1, arg2);
     }
 
     /**
-     * The endpointInterface class {0} could not be found
+     * Document literal bare methods must have no more than 1 non-header in parameter. Class: {0} method: {1} number of non-header parameters: {2}
      *
      */
-    public static String WEBSERVICEAP_ENDPOINTINTERFACE_CLASS_NOT_FOUND(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_ENDPOINTINTERFACE_CLASS_NOT_FOUND(arg0));
+    public static String WEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONLY_ONE_IN_PARAMETER(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONLY_ONE_IN_PARAMETER(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONLY_ONE_IN_PARAMETER(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.document.literal.bare.must.have.only.one.in.parameter", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_DOC_BARE_RETURN_AND_OUT(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.doc.bare.return.and.out", arg0, arg1);
     }
 
     /**
-     * Document literal bare methods must have no more than 1 non-header in parameter. Class: {0} method: {1} number of non-header parameters: {2}
+     * Document/literal bare methods cannot have a return type and out parameters. Class: {0}, method: {1}
      *
      */
-    public static String WEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONLY_ONE_IN_PARAMETER(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONLY_ONE_IN_PARAMETER(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_DOC_BARE_RETURN_AND_OUT(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_DOC_BARE_RETURN_AND_OUT(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_INFO(Object arg0) {
-        return messageFactory.getMessage("webserviceap.info", arg0);
+    public static Localizable localizableWEBSERVICEAP_METHOD_PARAMETER_TYPES_CANNOT_IMPLEMENT_REMOTE(Object arg0, Object arg1, Object arg2, Object arg3) {
+        return messageFactory.getMessage("webserviceap.method.parameter.types.cannot.implement.remote", arg0, arg1, arg2, arg3);
     }
 
     /**
-     * info: {0}
+     * Method parameter types cannot implement java.rmi.Remote.  Class: {0} method: {1} parameter: {2} type: {3}
      *
      */
-    public static String WEBSERVICEAP_INFO(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_INFO(arg0));
+    public static String WEBSERVICEAP_METHOD_PARAMETER_TYPES_CANNOT_IMPLEMENT_REMOTE(Object arg0, Object arg1, Object arg2, Object arg3) {
+        return localizer.localize(localizableWEBSERVICEAP_METHOD_PARAMETER_TYPES_CANNOT_IMPLEMENT_REMOTE(arg0, arg1, arg2, arg3));
     }
 
-    public static Localizable localizableWEBSERVICEAP_HANDLERCLASS_NOTSPECIFIED(Object arg0) {
-        return messageFactory.getMessage("webserviceap.handlerclass.notspecified", arg0);
+    public static Localizable localizableWEBSERVICEAP_COMPILATION_FAILED() {
+        return messageFactory.getMessage("webserviceap.compilationFailed");
     }
 
     /**
-     * A handler in the HandlerChain file: {0} does not specify a handler-class
+     * compilation failed, errors should have been reported
      *
      */
-    public static String WEBSERVICEAP_HANDLERCLASS_NOTSPECIFIED(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_HANDLERCLASS_NOTSPECIFIED(arg0));
+    public static String WEBSERVICEAP_COMPILATION_FAILED() {
+        return localizer.localize(localizableWEBSERVICEAP_COMPILATION_FAILED());
     }
 
-    public static Localizable localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.invalid.sei.annotation.element", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_MODEL_ALREADY_EXISTS() {
+        return messageFactory.getMessage("webserviceap.model.already.exists");
     }
 
     /**
-     * The @javax.jws.WebService.{0} element cannot be specified on a service endpoint interface. Class: {1}
+     * model already exists
      *
      */
-    public static String WEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION_ELEMENT(arg0, arg1));
+    public static String WEBSERVICEAP_MODEL_ALREADY_EXISTS() {
+        return localizer.localize(localizableWEBSERVICEAP_MODEL_ALREADY_EXISTS());
     }
 
-    public static Localizable localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_NOT_UNIQUE(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.document.literal.bare.method.not.unique", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_COULD_NOT_FIND_TYPEDECL(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.could.not.find.typedecl", arg0, arg1);
     }
 
     /**
-     * Document literal bare methods must have unique parameter names.  Class: {0} method: {1} parameter name: {2}
+     * Could not get TypeDeclaration for: {0} in apt round: {1}
      *
      */
-    public static String WEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_NOT_UNIQUE(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_NOT_UNIQUE(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_COULD_NOT_FIND_TYPEDECL(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_COULD_NOT_FIND_TYPEDECL(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_METHOD_EXCEPTION_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.method.exception.bean.name.not.unique", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_CLASS_NOT_PUBLIC(Object arg0) {
+        return messageFactory.getMessage("webserviceap.webservice.class.not.public", arg0);
     }
 
     /**
-     * Exception bean names must be unique and must not clash with other generated classes.  Class: {0} exception {1}
+     * Classes annotated with @javax.jws.WebService must be public. Class: {0}
      *
      */
-    public static String WEBSERVICEAP_METHOD_EXCEPTION_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_METHOD_EXCEPTION_BEAN_NAME_NOT_UNIQUE(arg0, arg1));
+    public static String WEBSERVICEAP_WEBSERVICE_CLASS_NOT_PUBLIC(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_CLASS_NOT_PUBLIC(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_HOLDER_PARAMETERS_MUST_NOT_BE_IN_ONLY(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.holder.parameters.must.not.be.in.only", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_NOT_UNIQUE(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.document.literal.bare.method.not.unique", arg0, arg1, arg2);
     }
 
     /**
-     * javax.xml.ws.Holder parameters must not be annotated with the WebParam.Mode.IN property.  Class: {0} method: {1} parameter: {2}
+     * Document literal bare methods must have unique parameter names.  Class: {0} method: {1} parameter name: {2}
      *
      */
-    public static String WEBSERVICEAP_HOLDER_PARAMETERS_MUST_NOT_BE_IN_ONLY(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_HOLDER_PARAMETERS_MUST_NOT_BE_IN_ONLY(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_NOT_UNIQUE(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_METHOD_NOT_UNIQUE(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_DOC_BARE_AND_NO_ONE_IN(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.doc.bare.and.no.one.in", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_RPC_SOAPBINDING_NOT_ALLOWED_ON_METHOD(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.rpc.soapbinding.not.allowed.on.method", arg0, arg1);
     }
 
     /**
-     * Document literal bare methods must have one non-header, IN/INOUT parameter.  Class: {0} Method: {1}
+     * SOAPBinding.Style.RPC binding annotations are not allowed on methods.  Class: {0} Method: {1}
      *
      */
-    public static String WEBSERVICEAP_DOC_BARE_AND_NO_ONE_IN(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_DOC_BARE_AND_NO_ONE_IN(arg0, arg1));
+    public static String WEBSERVICEAP_RPC_SOAPBINDING_NOT_ALLOWED_ON_METHOD(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_RPC_SOAPBINDING_NOT_ALLOWED_ON_METHOD(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_RPC_LITERAL_WEBPARAMS_MUST_SPECIFY_NAME(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.rpc.literal.webparams.must.specify.name", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_NO_PACKAGE_CLASS_MUST_HAVE_TARGETNAMESPACE(Object arg0) {
+        return messageFactory.getMessage("webserviceap.no.package.class.must.have.targetnamespace", arg0);
     }
 
     /**
-     * All rpc literal WebParams must specify a name.  Class: {0} method {1} paramter {2}
+     * @javax.jws.Webservice annotated classes that do not belong to a package must have the @javax.jws.Webservice.targetNamespace element.  Class: {0}
      *
      */
-    public static String WEBSERVICEAP_RPC_LITERAL_WEBPARAMS_MUST_SPECIFY_NAME(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_RPC_LITERAL_WEBPARAMS_MUST_SPECIFY_NAME(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_NO_PACKAGE_CLASS_MUST_HAVE_TARGETNAMESPACE(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_NO_PACKAGE_CLASS_MUST_HAVE_TARGETNAMESPACE(arg0));
     }
 
     public static Localizable localizableWEBSERVICEAP_ENDPOINTINTERFACE_HAS_NO_WEBSERVICE_ANNOTATION(Object arg0) {
@@ -614,280 +614,292 @@
         return localizer.localize(localizableWEBSERVICEAP_ENDPOINTINTERFACE_HAS_NO_WEBSERVICE_ANNOTATION(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_CANNOT_COMBINE_HANDLERCHAIN_SOAPMESSAGEHANDLERS() {
-        return messageFactory.getMessage("webserviceap.cannot.combine.handlerchain.soapmessagehandlers");
+    public static Localizable localizableWEBSERVICEAP_INFO(Object arg0) {
+        return messageFactory.getMessage("webserviceap.info", arg0);
     }
 
     /**
-     * You cannot specify both HanlderChain and SOAPMessageHandlers annotations
+     * info: {0}
      *
      */
-    public static String WEBSERVICEAP_CANNOT_COMBINE_HANDLERCHAIN_SOAPMESSAGEHANDLERS() {
-        return localizer.localize(localizableWEBSERVICEAP_CANNOT_COMBINE_HANDLERCHAIN_SOAPMESSAGEHANDLERS());
+    public static String WEBSERVICEAP_INFO(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_INFO(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_NESTED_MODEL_ERROR(Object arg0) {
-        return messageFactory.getMessage("webserviceap.nestedModelError", arg0);
+    public static Localizable localizableWEBSERVICEAP_RPC_LITERAL_MUST_NOT_BE_BARE(Object arg0) {
+        return messageFactory.getMessage("webserviceap.rpc.literal.must.not.be.bare", arg0);
     }
 
     /**
-     * modeler error: {0}
+     * RPC literal SOAPBindings must have parameterStyle WRAPPPED. Class: {0}.
      *
      */
-    public static String WEBSERVICEAP_NESTED_MODEL_ERROR(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_NESTED_MODEL_ERROR(arg0));
+    public static String WEBSERVICEAP_RPC_LITERAL_MUST_NOT_BE_BARE(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_RPC_LITERAL_MUST_NOT_BE_BARE(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_METHOD_REQUEST_WRAPPER_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.method.request.wrapper.bean.name.not.unique", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_COULD_NOT_FIND_HANDLERCHAIN(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.could.not.find.handlerchain", arg0, arg1);
     }
 
     /**
-     * Request wrapper bean names must be unique and must not clash with other generated classes.  Class: {0} method {1}
+     * Could not find the handlerchain {0} in the handler file {1}
      *
      */
-    public static String WEBSERVICEAP_METHOD_REQUEST_WRAPPER_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_METHOD_REQUEST_WRAPPER_BEAN_NAME_NOT_UNIQUE(arg0, arg1));
+    public static String WEBSERVICEAP_COULD_NOT_FIND_HANDLERCHAIN(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_COULD_NOT_FIND_HANDLERCHAIN(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_CLASS_NOT_PUBLIC(Object arg0) {
-        return messageFactory.getMessage("webserviceap.webservice.class.not.public", arg0);
+    public static Localizable localizableWEBSERVICEAP_RPC_ENCODED_NOT_SUPPORTED(Object arg0) {
+        return messageFactory.getMessage("webserviceap.rpc.encoded.not.supported", arg0);
     }
 
     /**
-     * Classes annotated with @javax.jws.WebService must be public. Class: {0}
+     * The {0} class has a rpc/encoded SOAPBinding.  Rpc/encoded SOAPBindings are not supported in JAXWS 2.0.
      *
      */
-    public static String WEBSERVICEAP_WEBSERVICE_CLASS_NOT_PUBLIC(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_CLASS_NOT_PUBLIC(arg0));
+    public static String WEBSERVICEAP_RPC_ENCODED_NOT_SUPPORTED(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_RPC_ENCODED_NOT_SUPPORTED(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_MIXED_BINDING_STYLE(Object arg0) {
-        return messageFactory.getMessage("webserviceap.mixed.binding.style", arg0);
+    public static Localizable localizableWEBSERVICEAP_ERROR(Object arg0) {
+        return messageFactory.getMessage("webserviceap.error", arg0);
     }
 
     /**
-     * Class: {0} contains mixed bindings.  SOAPBinding.Style.RPC and SOAPBinding.Style.DOCUMENT cannot be mixed.
+     * error: {0}
      *
      */
-    public static String WEBSERVICEAP_MIXED_BINDING_STYLE(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_MIXED_BINDING_STYLE(arg0));
+    public static String WEBSERVICEAP_ERROR(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_ERROR(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_FILE_NOT_FOUND(Object arg0) {
-        return messageFactory.getMessage("webserviceap.fileNotFound", arg0);
+    public static Localizable localizableWEBSERVICEAP_ENDPOINTINTERFACE_CLASS_NOT_FOUND(Object arg0) {
+        return messageFactory.getMessage("webserviceap.endpointinterface.class.not.found", arg0);
     }
 
     /**
-     * error: file not found: {0}
+     * The endpointInterface class {0} could not be found
      *
      */
-    public static String WEBSERVICEAP_FILE_NOT_FOUND(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_FILE_NOT_FOUND(arg0));
+    public static String WEBSERVICEAP_ENDPOINTINTERFACE_CLASS_NOT_FOUND(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_ENDPOINTINTERFACE_CLASS_NOT_FOUND(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_ONEWAY_AND_OUT(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.oneway.and.out", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_METHOD_NOT_IMPLEMENTED(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.method.not.implemented", arg0, arg1, arg2);
     }
 
     /**
-     * @Oneway methods cannot have out parameters. Class: {0} method {1}
+     * Methods in an endpointInterface must be implemented in the implementation class.  Interface Class:{0} Implementation Class:{1} Method: {2}
      *
      */
-    public static String WEBSERVICEAP_ONEWAY_AND_OUT(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_ONEWAY_AND_OUT(arg0, arg1));
+    public static String WEBSERVICEAP_METHOD_NOT_IMPLEMENTED(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_METHOD_NOT_IMPLEMENTED(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_METHOD_RESPONSE_WRAPPER_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.method.response.wrapper.bean.name.not.unique", arg0, arg1);
+    public static Localizable localizableWEBSERVICE_ENCODED_NOT_SUPPORTED(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webservice.encoded.not.supported", arg0, arg1);
     }
 
     /**
-     * Response wrapper bean names must be unique and must not clash with other generated classes.  Class: {0} method {1}
+     * The {0} class has invalid SOAPBinding annotation. {1}/encoded SOAPBinding is not supported
      *
      */
-    public static String WEBSERVICEAP_METHOD_RESPONSE_WRAPPER_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_METHOD_RESPONSE_WRAPPER_BEAN_NAME_NOT_UNIQUE(arg0, arg1));
+    public static String WEBSERVICE_ENCODED_NOT_SUPPORTED(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICE_ENCODED_NOT_SUPPORTED(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_COMPILATION_FAILED() {
-        return messageFactory.getMessage("webserviceap.compilationFailed");
+    public static Localizable localizableWEBSERVICEAP_HANDLERCLASS_NOTSPECIFIED(Object arg0) {
+        return messageFactory.getMessage("webserviceap.handlerclass.notspecified", arg0);
     }
 
     /**
-     * compilation failed, errors should have been reported
+     * A handler in the HandlerChain file: {0} does not specify a handler-class
      *
      */
-    public static String WEBSERVICEAP_COMPILATION_FAILED() {
-        return localizer.localize(localizableWEBSERVICEAP_COMPILATION_FAILED());
+    public static String WEBSERVICEAP_HANDLERCLASS_NOTSPECIFIED(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_HANDLERCLASS_NOTSPECIFIED(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONE_IN_OR_OUT(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.document.literal.bare.must.have.one.in.or.out", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_FAILED_TO_FIND_HANDLERCHAIN_FILE(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.failed.to.find.handlerchain.file", arg0, arg1);
     }
 
     /**
-     * Document literal bare methods must have at least one of: a return, an in parameter or an out parameter.  Class: {0} Method: {1}
+     * Cannot find HandlerChain file. class: {0}, file: {1}
      *
      */
-    public static String WEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONE_IN_OR_OUT(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONE_IN_OR_OUT(arg0, arg1));
+    public static String WEBSERVICEAP_FAILED_TO_FIND_HANDLERCHAIN_FILE(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_FAILED_TO_FIND_HANDLERCHAIN_FILE(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ELEMENT(Object arg0) {
-        return messageFactory.getMessage("webserviceap.endpointinteface.plus.element", arg0);
+    public static Localizable localizableWEBSERVICEAP_DOC_BARE_NO_RETURN_AND_NO_OUT(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.doc.bare.no.return.and.no.out", arg0, arg1);
     }
 
     /**
-     * The @javax.jws.WebService.{0} element cannot be used in with @javax.jws.WebService.endpointInterface element.
+     * Document literal bare methods that do not have a return value must have a single OUT/INOUT parameter.  Class: {0} Method: {1}
      *
      */
-    public static String WEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ELEMENT(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ELEMENT(arg0));
+    public static String WEBSERVICEAP_DOC_BARE_NO_RETURN_AND_NO_OUT(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_DOC_BARE_NO_RETURN_AND_NO_OUT(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_DOC_BARE_RETURN_AND_OUT(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.doc.bare.return.and.out", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_ABSTRACT(Object arg0) {
+        return messageFactory.getMessage("webserviceap.webservice.class.is.abstract", arg0);
     }
 
     /**
-     * Document/literal bare methods cannot have a return type and out parameters. Class: {0}, method: {1}
+     * Classes annotated with @javax.jws.WebService must not be abstract. Class: {0}
      *
      */
-    public static String WEBSERVICEAP_DOC_BARE_RETURN_AND_OUT(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_DOC_BARE_RETURN_AND_OUT(arg0, arg1));
+    public static String WEBSERVICEAP_WEBSERVICE_CLASS_IS_ABSTRACT(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_ABSTRACT(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_SUCCEEDED() {
-        return messageFactory.getMessage("webserviceap.succeeded");
+    public static Localizable localizableWEBSERVICEAP_INIT_PARAM_FORMAT_ERROR() {
+        return messageFactory.getMessage("webserviceap.init_param.format.error");
     }
 
     /**
-     * Success
+     * a <init-param> element must have exactly 1 <param-name> and 1 <param-value>
      *
      */
-    public static String WEBSERVICEAP_SUCCEEDED() {
-        return localizer.localize(localizableWEBSERVICEAP_SUCCEEDED());
+    public static String WEBSERVICEAP_INIT_PARAM_FORMAT_ERROR() {
+        return localizer.localize(localizableWEBSERVICEAP_INIT_PARAM_FORMAT_ERROR());
     }
 
-    public static Localizable localizableWEBSERVICEAP_DOCUMENT_BARE_HOLDER_PARAMETERS_MUST_NOT_BE_INOUT(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.document.bare.holder.parameters.must.not.be.inout", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_MIXED_BINDING_STYLE(Object arg0) {
+        return messageFactory.getMessage("webserviceap.mixed.binding.style", arg0);
     }
 
     /**
-     * javax.xml.ws.Holder parameters in document bare operations must be WebParam.Mode.INOUT;  Class: {0} method: {1} parameter: {2}
+     * Class: {0} contains mixed bindings.  SOAPBinding.Style.RPC and SOAPBinding.Style.DOCUMENT cannot be mixed.
      *
      */
-    public static String WEBSERVICEAP_DOCUMENT_BARE_HOLDER_PARAMETERS_MUST_NOT_BE_INOUT(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_BARE_HOLDER_PARAMETERS_MUST_NOT_BE_INOUT(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_MIXED_BINDING_STYLE(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_MIXED_BINDING_STYLE(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_AND_WEBSERVICEPROVIDER(Object arg0) {
-        return messageFactory.getMessage("webserviceap.webservice.and.webserviceprovider", arg0);
+    public static Localizable localizableWEBSERVICEAP_METHOD_NOT_ANNOTATED(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.method.not.annotated", arg0, arg1);
     }
 
     /**
-     * Classes cannot be annotated with both @javax.jws.WebService and @javax.xml.ws.WebServiceProvider.  Class: {0}
+     * The method {0} on class {1} is not annotated.
      *
      */
-    public static String WEBSERVICEAP_WEBSERVICE_AND_WEBSERVICEPROVIDER(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_AND_WEBSERVICEPROVIDER(arg0));
+    public static String WEBSERVICEAP_METHOD_NOT_ANNOTATED(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_METHOD_NOT_ANNOTATED(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_ENDPOINTINTERFACES_DO_NOT_MATCH(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.endpointinterfaces.do.not.match", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_HOLDERS(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.oneway.operation.cannot.have.holders", arg0, arg1);
     }
 
     /**
-     * The endpoint interface {0} does not match the interface {1}.
+     * The method {1} of class {0} is annotated @Oneway but contains inout or out paramerters (javax.xml.ws.Holder)
      *
      */
-    public static String WEBSERVICEAP_ENDPOINTINTERFACES_DO_NOT_MATCH(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_ENDPOINTINTERFACES_DO_NOT_MATCH(arg0, arg1));
+    public static String WEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_HOLDERS(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_ONEWAY_OPERATION_CANNOT_HAVE_HOLDERS(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ANNOTATION(Object arg0) {
-        return messageFactory.getMessage("webserviceap.endpointinteface.plus.annotation", arg0);
+    public static Localizable localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_CANNOT_HAVE_MORE_THAN_ONE_OUT(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.document.literal.bare.cannot.have.more.than.one.out", arg0, arg1);
     }
 
     /**
-     * The @{0} annotation cannot be used in with @javax.jws.WebService.endpointInterface element.
+     * Document literal bare methods must have a return value or one out parameter.  Class: {0} Method: {1}
      *
      */
-    public static String WEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ANNOTATION(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_ENDPOINTINTEFACE_PLUS_ANNOTATION(arg0));
+    public static String WEBSERVICEAP_DOCUMENT_LITERAL_BARE_CANNOT_HAVE_MORE_THAN_ONE_OUT(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_CANNOT_HAVE_MORE_THAN_ONE_OUT(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_FAILED_TO_PARSE_HANDLERCHAIN_FILE(Object arg0, Object arg1) {
-        return messageFactory.getMessage("webserviceap.failed.to.parse.handlerchain.file", arg0, arg1);
+    public static Localizable localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.invalid.sei.annotation", arg0, arg1);
     }
 
     /**
-     * Failed to parse HandlerChain file. Class: {0}, file: {1}
+     * The @{0} annotation cannot be used on a service endpoint interface. Class: {1}
      *
      */
-    public static String WEBSERVICEAP_FAILED_TO_PARSE_HANDLERCHAIN_FILE(Object arg0, Object arg1) {
-        return localizer.localize(localizableWEBSERVICEAP_FAILED_TO_PARSE_HANDLERCHAIN_FILE(arg0, arg1));
+    public static String WEBSERVICEAP_INVALID_SEI_ANNOTATION(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_INVALID_SEI_ANNOTATION(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_METHOD_PARAMETER_TYPES_CANNOT_IMPLEMENT_REMOTE(Object arg0, Object arg1, Object arg2, Object arg3) {
-        return messageFactory.getMessage("webserviceap.method.parameter.types.cannot.implement.remote", arg0, arg1, arg2, arg3);
+    public static Localizable localizableWEBSERVICEAP_OPERATION_NAME_NOT_UNIQUE(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.operation.name.not.unique", arg0, arg1, arg2);
     }
 
     /**
-     * Method parameter types cannot implement java.rmi.Remote.  Class: {0} method: {1} parameter: {2} type: {3}
+     * Operation names must be unique.  Class: {0} method: {1} operation name: {2}
      *
      */
-    public static String WEBSERVICEAP_METHOD_PARAMETER_TYPES_CANNOT_IMPLEMENT_REMOTE(Object arg0, Object arg1, Object arg2, Object arg3) {
-        return localizer.localize(localizableWEBSERVICEAP_METHOD_PARAMETER_TYPES_CANNOT_IMPLEMENT_REMOTE(arg0, arg1, arg2, arg3));
+    public static String WEBSERVICEAP_OPERATION_NAME_NOT_UNIQUE(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_OPERATION_NAME_NOT_UNIQUE(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableWEBSERVICEAP_METHOD_RETURN_TYPE_CANNOT_IMPLEMENT_REMOTE(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("webserviceap.method.return.type.cannot.implement.remote", arg0, arg1, arg2);
+    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_FINAL(Object arg0) {
+        return messageFactory.getMessage("webserviceap.webservice.class.is.final", arg0);
     }
 
     /**
-     * Method return types cannot implement java.rmi.Remote.  Class: {0} method: {1} return type: {2}
+     * Classes annotated with @javax.jws.WebService must not be final. Class: {0}
      *
      */
-    public static String WEBSERVICEAP_METHOD_RETURN_TYPE_CANNOT_IMPLEMENT_REMOTE(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableWEBSERVICEAP_METHOD_RETURN_TYPE_CANNOT_IMPLEMENT_REMOTE(arg0, arg1, arg2));
+    public static String WEBSERVICEAP_WEBSERVICE_CLASS_IS_FINAL(Object arg0) {
+        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_FINAL(arg0));
     }
 
-    public static Localizable localizableWEBSERVICEAP_ERROR(Object arg0) {
-        return messageFactory.getMessage("webserviceap.error", arg0);
+    public static Localizable localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONE_IN_OR_OUT(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.document.literal.bare.must.have.one.in.or.out", arg0, arg1);
     }
 
     /**
-     * error: {0}
+     * Document literal bare methods must have at least one of: a return, an in parameter or an out parameter.  Class: {0} Method: {1}
      *
      */
-    public static String WEBSERVICEAP_ERROR(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_ERROR(arg0));
+    public static String WEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONE_IN_OR_OUT(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_LITERAL_BARE_MUST_HAVE_ONE_IN_OR_OUT(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_ABSTRACT(Object arg0) {
-        return messageFactory.getMessage("webserviceap.webservice.class.is.abstract", arg0);
+    public static Localizable localizableWEBSERVICEAP_METHOD_REQUEST_WRAPPER_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.method.request.wrapper.bean.name.not.unique", arg0, arg1);
     }
 
     /**
-     * Classes annotated with @javax.jws.WebService must not be abstract. Class: {0}
+     * Request wrapper bean names must be unique and must not clash with other generated classes.  Class: {0} method {1}
      *
      */
-    public static String WEBSERVICEAP_WEBSERVICE_CLASS_IS_ABSTRACT(Object arg0) {
-        return localizer.localize(localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_ABSTRACT(arg0));
+    public static String WEBSERVICEAP_METHOD_REQUEST_WRAPPER_BEAN_NAME_NOT_UNIQUE(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_METHOD_REQUEST_WRAPPER_BEAN_NAME_NOT_UNIQUE(arg0, arg1));
     }
 
-    public static Localizable localizableWEBSERVICEAP_INIT_PARAM_FORMAT_ERROR() {
-        return messageFactory.getMessage("webserviceap.init_param.format.error");
+    public static Localizable localizableWEBSERVICEAP_DOCUMENT_BARE_HOLDER_PARAMETERS_MUST_NOT_BE_INOUT(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("webserviceap.document.bare.holder.parameters.must.not.be.inout", arg0, arg1, arg2);
     }
 
     /**
-     * a <init-param> element must have exactly 1 <param-name> and 1 <param-value>
+     * javax.xml.ws.Holder parameters in document bare operations must be WebParam.Mode.INOUT;  Class: {0} method: {1} parameter: {2}
      *
      */
-    public static String WEBSERVICEAP_INIT_PARAM_FORMAT_ERROR() {
-        return localizer.localize(localizableWEBSERVICEAP_INIT_PARAM_FORMAT_ERROR());
+    public static String WEBSERVICEAP_DOCUMENT_BARE_HOLDER_PARAMETERS_MUST_NOT_BE_INOUT(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWEBSERVICEAP_DOCUMENT_BARE_HOLDER_PARAMETERS_MUST_NOT_BE_INOUT(arg0, arg1, arg2));
     }
 
+    public static Localizable localizableWEBSERVICEAP_ONEWAY_AND_NOT_ONE_IN(Object arg0, Object arg1) {
+        return messageFactory.getMessage("webserviceap.oneway.and.not.one.in", arg0, arg1);
+    }
+
+    /**
+     * Document literal bare methods annotated with @javax.jws.Oneway must have one non-header IN parameter.  Class: {0} Method: {1}
+     *
+     */
+    public static String WEBSERVICEAP_ONEWAY_AND_NOT_ONE_IN(Object arg0, Object arg1) {
+        return localizer.localize(localizableWEBSERVICEAP_ONEWAY_AND_NOT_ONE_IN(arg0, arg1));
+    }
+
 }
--- old/src/share/classes/com/sun/tools/internal/ws/resources/WscompileMessages.java	Tue Aug  4 09:29:06 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/WscompileMessages.java	Tue Aug  4 09:29:06 2009
@@ -62,6 +62,30 @@
         return localizer.localize(localizableWSGEN_CLASS_NOT_FOUND(arg0));
     }
 
+    public static Localizable localizableWSIMPORT_HTTP_REDIRECT(Object arg0, Object arg1) {
+        return messageFactory.getMessage("wsimport.httpRedirect", arg0, arg1);
+    }
+
+    /**
+     * Server returned HTTP Status code: "{0}", retrying with "{1}"
+     *
+     */
+    public static String WSIMPORT_HTTP_REDIRECT(Object arg0, Object arg1) {
+        return localizer.localize(localizableWSIMPORT_HTTP_REDIRECT(arg0, arg1));
+    }
+
+    public static Localizable localizableWSIMPORT_AUTH_INFO_NEEDED(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("wsimport.authInfoNeeded", arg0, arg1, arg2);
+    }
+
+    /**
+     * {0},  "{1}" needs authorization, please provide authorization file with read access at {2} or use -Xauthfile to give the authorization file and on each line provide authorization information using this format : http[s]://user:password@host:port//<url-path>
+     *
+     */
+    public static String WSIMPORT_AUTH_INFO_NEEDED(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWSIMPORT_AUTH_INFO_NEEDED(arg0, arg1, arg2));
+    }
+
     public static Localizable localizableWSGEN_USAGE_EXAMPLES() {
         return messageFactory.getMessage("wsgen.usage.examples");
     }
@@ -142,6 +166,27 @@
         return localizer.localize(localizableWSIMPORT_MISSING_FILE());
     }
 
+    public static Localizable localizableWSIMPORT_USAGE_EXTENSIONS() {
+        return messageFactory.getMessage("wsimport.usage.extensions");
+    }
+
+    /**
+     *
+     * Extensions:
+     *   -XadditionalHeaders         map headers not bound to request or response message to
+     *                               Java method parameters
+     *   -Xauthfile                  file to carry authorization information in the format
+     *                               http://username:password@example.org/stock?wsdl
+     *   -Xdebug                     print debug information
+     *   -Xno-addressing-databinding enable binding of W3C EndpointReferenceType to Java
+     *   -Xnocompile                 do not compile generated Java files
+     *
+     *
+     */
+    public static String WSIMPORT_USAGE_EXTENSIONS() {
+        return localizer.localize(localizableWSIMPORT_USAGE_EXTENSIONS());
+    }
+
     public static Localizable localizableWSIMPORT_USAGE(Object arg0) {
         return messageFactory.getMessage("wsimport.usage", arg0);
     }
@@ -221,8 +266,8 @@
      *   -p <pkg>                  specifies the target package
      *   -quiet                    suppress wsimport output
      *   -s <directory>            specify where to place generated source files
-     *   -target <version>         generate code as per the given JAXWS specification version.
-     *                             version 2.0 will generate compliant code for JAXWS 2.0 spec.
+     *   -target <version>         generate code as per the given JAXWS spec version
+     *                             e.g. 2.0 will generate compliant code for JAXWS 2.0 spec
      *   -verbose                  output messages about what the compiler is doing
      *   -version                  print version information
      *   -wsdllocation <location>  @WebServiceClient.wsdlLocation value
@@ -245,6 +290,44 @@
         return localizer.localize(localizableWSCOMPILE_ERROR(arg0));
     }
 
+    public static Localizable localizableWSGEN_PROTOCOL_WITHOUT_EXTENSION(Object arg0) {
+        return messageFactory.getMessage("wsgen.protocol.without.extension", arg0);
+    }
+
+    /**
+     * The optional protocol "{0}" must be used in conjunction with the "-extension" option.
+     *
+     */
+    public static String WSGEN_PROTOCOL_WITHOUT_EXTENSION(Object arg0) {
+        return localizer.localize(localizableWSGEN_PROTOCOL_WITHOUT_EXTENSION(arg0));
+    }
+
+    public static Localizable localizableWSIMPORT_COMPILING_CODE() {
+        return messageFactory.getMessage("wsimport.CompilingCode");
+    }
+
+    /**
+     *
+     * compiling code...
+     *
+     *
+     */
+    public static String WSIMPORT_COMPILING_CODE() {
+        return localizer.localize(localizableWSIMPORT_COMPILING_CODE());
+    }
+
+    public static Localizable localizableWSIMPORT_READING_AUTH_FILE(Object arg0) {
+        return messageFactory.getMessage("wsimport.readingAuthFile", arg0);
+    }
+
+    /**
+     * Trying to read authorization file : "{0}"...
+     *
+     */
+    public static String WSIMPORT_READING_AUTH_FILE(Object arg0) {
+        return localizer.localize(localizableWSIMPORT_READING_AUTH_FILE(arg0));
+    }
+
     public static Localizable localizableWSGEN_NO_WEBSERVICES_CLASS(Object arg0) {
         return messageFactory.getMessage("wsgen.no.webservices.class", arg0);
     }
@@ -281,6 +364,18 @@
         return localizer.localize(localizableWSCOMPILE_INFO(arg0));
     }
 
+    public static Localizable localizableWSIMPORT_MAX_REDIRECT_ATTEMPT() {
+        return messageFactory.getMessage("wsimport.maxRedirectAttempt");
+    }
+
+    /**
+     * Can not get a WSDL maximum number of redirects(5) reached
+     *
+     */
+    public static String WSIMPORT_MAX_REDIRECT_ATTEMPT() {
+        return localizer.localize(localizableWSIMPORT_MAX_REDIRECT_ATTEMPT());
+    }
+
     public static Localizable localizableWSIMPORT_WARNING_MESSAGE(Object arg0) {
         return messageFactory.getMessage("wsimport.WarningMessage", arg0);
     }
@@ -324,6 +419,7 @@
     /**
      * generating code...
      *
+     *
      */
     public static String WSIMPORT_GENERATING_CODE() {
         return localizer.localize(localizableWSIMPORT_GENERATING_CODE());
@@ -389,6 +485,30 @@
         return localizer.localize(localizableWSIMPORT_NO_SUCH_JAXB_OPTION(arg0));
     }
 
+    public static Localizable localizableWSIMPORT_AUTH_FILE_NOT_FOUND(Object arg0, Object arg1) {
+        return messageFactory.getMessage("wsimport.authFileNotFound", arg0, arg1);
+    }
+
+    /**
+     * Authorization file "{0}" not found. If the WSDL access needs Basic Authentication, please provide authorization file with read access at {1} or use -Xauthfile to give the authorization file and on each line provide authorization information using this format : http[s]://user:password@host:port//<url-path>
+     *
+     */
+    public static String WSIMPORT_AUTH_FILE_NOT_FOUND(Object arg0, Object arg1) {
+        return localizer.localize(localizableWSIMPORT_AUTH_FILE_NOT_FOUND(arg0, arg1));
+    }
+
+    public static Localizable localizableWSIMPORT_DEBUG_MESSAGE(Object arg0) {
+        return messageFactory.getMessage("wsimport.DebugMessage", arg0);
+    }
+
+    /**
+     * [DEBUG] {0}
+     *
+     */
+    public static String WSIMPORT_DEBUG_MESSAGE(Object arg0) {
+        return localizer.localize(localizableWSIMPORT_DEBUG_MESSAGE(arg0));
+    }
+
     public static Localizable localizableWSGEN_COULD_NOT_CREATE_FILE(Object arg0) {
         return messageFactory.getMessage("wsgen.could.not.create.file", arg0);
     }
@@ -413,8 +533,8 @@
         return localizer.localize(localizableWSGEN_WSDL_ARG_NO_GENWSDL(arg0));
     }
 
-    public static Localizable localizableWSGEN_HELP(Object arg0) {
-        return messageFactory.getMessage("wsgen.help", arg0);
+    public static Localizable localizableWSGEN_HELP(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("wsgen.help", arg0, arg1, arg2);
     }
 
     /**
@@ -436,10 +556,12 @@
      *   -s <directory>             specify where to place generated source files
      *   -verbose                   output messages about what the compiler is doing
      *   -version                   print version information
-     *   -wsdl[:protocol]           generate a WSDL file.  The protocol is optional.
-     *                              Valid protocols are soap1.1 and Xsoap1.2, the default
-     *                              is soap1.1.  Xsoap1.2 is not standard and can only be
-     *                              used in conjunction with the -extension option
+     *   -wsdl[:protocol]           generate a WSDL file. The protocol is optional.
+     *                              Valid protocols are {1},
+     *                              the default is soap1.1.
+     *                              The non stanadard protocols {2}
+     *                              can only be used in conjunction with the
+     *                              -extension option.
      *   -servicename <name>        specify the Service name to use in the generated WSDL
      *                              Used in conjunction with the -wsdl option.
      *   -portname <name>           specify the Port name to use in the generated WSDL
@@ -446,8 +568,8 @@
      *                              Used in conjunction with the -wsdl option.
      *
      */
-    public static String WSGEN_HELP(Object arg0) {
-        return localizer.localize(localizableWSGEN_HELP(arg0));
+    public static String WSGEN_HELP(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableWSGEN_HELP(arg0, arg1, arg2));
     }
 
     public static Localizable localizableWSIMPORT_INFO_MESSAGE(Object arg0) {
@@ -474,6 +596,18 @@
         return localizer.localize(localizableWSGEN_SOAP_12_WITHOUT_EXTENSION());
     }
 
+    public static Localizable localizableWSIMPORT_ILLEGAL_AUTH_INFO(Object arg0) {
+        return messageFactory.getMessage("wsimport.ILLEGAL_AUTH_INFO", arg0);
+    }
+
+    /**
+     * "{0}" is not a valid authorization information format. The format is http[s]://user:password@host:port//<url-path>.
+     *
+     */
+    public static String WSIMPORT_ILLEGAL_AUTH_INFO(Object arg0) {
+        return localizer.localize(localizableWSIMPORT_ILLEGAL_AUTH_INFO(arg0));
+    }
+
     public static Localizable localizableWSCOMPILE_COMPILATION_FAILED() {
         return messageFactory.getMessage("wscompile.compilationFailed");
     }
@@ -546,6 +680,18 @@
         return localizer.localize(localizableWSIMPORT_NO_WSDL(arg0));
     }
 
+    public static Localizable localizableWSIMPORT_AUTH_INFO_LINENO(Object arg0, Object arg1) {
+        return messageFactory.getMessage("wsimport.AUTH_INFO_LINENO", arg0, arg1);
+    }
+
+    /**
+     * "line {0} of {1}
+     *
+     */
+    public static String WSIMPORT_AUTH_INFO_LINENO(Object arg0, Object arg1) {
+        return localizer.localize(localizableWSIMPORT_AUTH_INFO_LINENO(arg0, arg1));
+    }
+
     public static Localizable localizableWSGEN_USAGE(Object arg0) {
         return messageFactory.getMessage("wsgen.usage", arg0);
     }
--- old/src/share/classes/com/sun/tools/internal/ws/resources/WsdlMessages.java	Tue Aug  4 09:29:09 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/WsdlMessages.java	Tue Aug  4 09:29:08 2009
@@ -55,7 +55,7 @@
     }
 
     /**
-     * wsdl:binding "{0}" referenced by wsdl:port "{1}", but its not found in the wsdl
+     * wsdl:binding "{0}" referenced by wsdl:port "{1}", but it's not found in the wsdl
      *
      */
     public static String ENTITY_NOT_FOUND_BINDING(Object arg0, Object arg1) {
@@ -62,28 +62,30 @@
         return localizer.localize(localizableENTITY_NOT_FOUND_BINDING(arg0, arg1));
     }
 
-    public static Localizable localizablePARSING_PARSE_FAILED() {
-        return messageFactory.getMessage("Parsing.ParseFailed");
+    public static Localizable localizablePARSING_UNABLE_TO_GET_METADATA(Object arg0, Object arg1) {
+        return messageFactory.getMessage("parsing.unableToGetMetadata", arg0, arg1);
     }
 
     /**
-     * Failed to parse the WSDL.
+     * {0}
      *
+     * {1}
+     *
      */
-    public static String PARSING_PARSE_FAILED() {
-        return localizer.localize(localizablePARSING_PARSE_FAILED());
+    public static String PARSING_UNABLE_TO_GET_METADATA(Object arg0, Object arg1) {
+        return localizer.localize(localizablePARSING_UNABLE_TO_GET_METADATA(arg0, arg1));
     }
 
-    public static Localizable localizablePARSING_UNABLE_TO_GET_METADATA(Object arg0) {
-        return messageFactory.getMessage("parsing.unableToGetMetadata", arg0);
+    public static Localizable localizablePARSING_PARSE_FAILED() {
+        return messageFactory.getMessage("Parsing.ParseFailed");
     }
 
     /**
-     * Unable to get Metadata from: {0}
+     *  Failed to parse the WSDL.
      *
      */
-    public static String PARSING_UNABLE_TO_GET_METADATA(Object arg0) {
-        return localizer.localize(localizablePARSING_UNABLE_TO_GET_METADATA(arg0));
+    public static String PARSING_PARSE_FAILED() {
+        return localizer.localize(localizablePARSING_PARSE_FAILED());
     }
 
     public static Localizable localizableVALIDATION_INVALID_PREFIX(Object arg0) {
@@ -151,7 +153,7 @@
     }
 
     /**
-     * wsdl:portType "{0}" referenced by wsdl:binding "{1}", but its not found in the wsdl
+     * wsdl:portType "{0}" referenced by wsdl:binding "{1}", but it's not found in the wsdl
      *
      */
     public static String ENTITY_NOT_FOUND_PORT_TYPE(Object arg0, Object arg1) {
@@ -199,7 +201,7 @@
     }
 
     /**
-     * Both jaxws:version and version are present
+     *  Both jaxws:version and version are present
      *
      */
     public static String INTERNALIZER_TWO_VERSION_ATTRIBUTES() {
@@ -212,7 +214,7 @@
 
     /**
      * Invalid WSDL, duplicate parts in a wsdl:message is not allowed.
-     * wsdl:message {0} has duplicated part name: "{1}"
+     * wsdl:message {0} has a duplicated part name: "{1}"
      *
      */
     public static String VALIDATION_DUPLICATE_PART_NAME(Object arg0, Object arg1) {
@@ -248,7 +250,7 @@
     }
 
     /**
-     * found unexpected non whitespace text: "{0}"
+     * found unexpected non-whitespace text: "{0}"
      *
      */
     public static String PARSING_NON_WHITESPACE_TEXT_FOUND(Object arg0) {
@@ -260,7 +262,7 @@
     }
 
     /**
-     * No target found for the wsdlLocation: {0}
+     *  No target found for the wsdlLocation: {0}
      *
      */
     public static String INTERNALIZER_TARGET_NOT_FOUND(Object arg0) {
@@ -344,7 +346,7 @@
     }
 
     /**
-     * JAXWS version attribute must be "2.0"
+     *  JAXWS version attribute must be "2.0"
      *
      */
     public static String INTERNALIZER_INCORRECT_VERSION() {
@@ -399,6 +401,20 @@
         return localizer.localize(localizablePARSING_INCORRECT_ROOT_ELEMENT(arg0, arg1, arg2, arg3));
     }
 
+    public static Localizable localizableTRY_WITH_MEX(Object arg0) {
+        return messageFactory.getMessage("try.with.mex", arg0);
+    }
+
+    /**
+     * {0}
+     *
+     * retrying with MEX...
+     *
+     */
+    public static String TRY_WITH_MEX(Object arg0) {
+        return localizer.localize(localizableTRY_WITH_MEX(arg0));
+    }
+
     public static Localizable localizableVALIDATION_MISSING_REQUIRED_ATTRIBUTE(Object arg0, Object arg1) {
         return messageFactory.getMessage("validation.missingRequiredAttribute", arg0, arg1);
     }
@@ -440,7 +456,7 @@
     }
 
     /**
-     * not an external binding file. The root element must be '{'http://java.sun.com/xml/ns/jaxws'}'bindings but it is '{'{0}'}'{1}
+     *  not an external binding file. The root element must be '{'http://java.sun.com/xml/ns/jaxws'}'bindings but it is '{'{0}'}'{1}
      *
      */
     public static String PARSER_NOT_A_BINDING_FILE(Object arg0, Object arg1) {
@@ -548,7 +564,7 @@
     }
 
     /**
-     * Unable to parse "{0}" : {1}
+     *  Unable to parse "{0}" : {1}
      *
      */
     public static String ABSTRACT_REFERENCE_FINDER_IMPL_UNABLE_TO_PARSE(Object arg0, Object arg1) {
@@ -596,7 +612,7 @@
     }
 
     /**
-     * XPath evaluation of "{0}" results in empty target node
+     * XPath evaluation of "{0}" results in an empty target node
      *
      */
     public static String INTERNALIZER_X_PATH_EVALUATES_TO_NO_TARGET(Object arg0) {
@@ -620,7 +636,7 @@
     }
 
     /**
-     * Ignoring customization: "{0}", it has no namespace. It must belong to the customization namespace.
+     * Ignoring customization: "{0}", because it has no namespace. It must belong to the customization namespace.
      *
      */
     public static String INVALID_CUSTOMIZATION_NAMESPACE(Object arg0) {
@@ -687,28 +703,28 @@
         return localizer.localize(localizableVALIDATION_INCORRECT_TARGET_NAMESPACE(arg0, arg1));
     }
 
-    public static Localizable localizableENTITY_NOT_FOUND_BY_Q_NAME(Object arg0, Object arg1) {
-        return messageFactory.getMessage("entity.notFoundByQName", arg0, arg1);
+    public static Localizable localizableENTITY_NOT_FOUND_BY_Q_NAME(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("entity.notFoundByQName", arg0, arg1, arg2);
     }
 
     /**
-     * invalid entity name: "{0}" (in namespace: "{1}")
+     * {0} "{1}" not found in the wsdl: {2}
      *
      */
-    public static String ENTITY_NOT_FOUND_BY_Q_NAME(Object arg0, Object arg1) {
-        return localizer.localize(localizableENTITY_NOT_FOUND_BY_Q_NAME(arg0, arg1));
+    public static String ENTITY_NOT_FOUND_BY_Q_NAME(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableENTITY_NOT_FOUND_BY_Q_NAME(arg0, arg1, arg2));
     }
 
-    public static Localizable localizableINVALID_WSDL(Object arg0) {
-        return messageFactory.getMessage("invalid.wsdl", arg0);
+    public static Localizable localizableINVALID_WSDL(Object arg0, Object arg1, Object arg2, Object arg3) {
+        return messageFactory.getMessage("invalid.wsdl", arg0, arg1, arg2, arg3);
     }
 
     /**
-     * "{0} does not look like a WSDL document, retrying with MEX..."
+     * Invalid WSDL {0}, expected {1} found {2} at (line {3})
      *
      */
-    public static String INVALID_WSDL(Object arg0) {
-        return localizer.localize(localizableINVALID_WSDL(arg0));
+    public static String INVALID_WSDL(Object arg0, Object arg1, Object arg2, Object arg3) {
+        return localizer.localize(localizableINVALID_WSDL(arg0, arg1, arg2, arg3));
     }
 
     public static Localizable localizableVALIDATION_UNSUPPORTED_SCHEMA_FEATURE(Object arg0) {
@@ -788,7 +804,7 @@
     }
 
     /**
-     * Target node is not an element
+     *  Target node is not an element
      *
      */
     public static String INTERNALIZER_TARGET_NOT_AN_ELEMENT() {
@@ -860,7 +876,7 @@
     }
 
     /**
-     * Not a WSI-BP compliant WSDL (R2001, R2004). xsd:import must not import XML Schema definition emmbedded inline within WSDLDocument.
+     * Not a WSI-BP compliant WSDL (R2001, R2004). xsd:import must not import XML Schema definitions embedded inline within the WSDL document.
      *
      */
     public static String WARNING_WSI_R_2004() {
@@ -872,7 +888,7 @@
     }
 
     /**
-     * Not a WSI-BP compliant WSDL (R2003). xsd:import must only be used inside xsd:schema element.
+     * Not a WSI-BP compliant WSDL (R2003). xsd:import must only be used inside xsd:schema elements.
      *
      */
     public static String WARNING_WSI_R_2003() {
@@ -884,7 +900,7 @@
     }
 
     /**
-     * Not a WSI-BP compliant WSDL (R2002). wsdl:import must not be used to import XML Schema embedded in the WSDL document. Expected wsdl namesapce: {0}, found: {1}
+     * Not a WSI-BP compliant WSDL (R2002). wsdl:import must not be used to import XML Schema embedded in the WSDL document. Expected wsdl namespace: {0}, found: {1}
      *
      */
     public static String WARNING_WSI_R_2002(Object arg0, Object arg1) {
@@ -903,18 +919,30 @@
         return localizer.localize(localizablePARSING_ELEMENT_OR_TYPE_REQUIRED(arg0));
     }
 
-    public static Localizable localizableWARNING_WSI_R_2001(Object arg0) {
-        return messageFactory.getMessage("warning.wsi.r2001", arg0);
+    public static Localizable localizableWARNING_WSI_R_2001() {
+        return messageFactory.getMessage("warning.wsi.r2001");
     }
 
     /**
-     * Not a WSI-BP compliant WSDL (R2001, R2002). wsdl:import must only import WSDL document. Its trying to import: "{0}"
+     * Not a WSI-BP compliant WSDL (R2001, R2002). wsdl:import must import only WSDL documents. It's trying to import: "{0}"
      *
      */
-    public static String WARNING_WSI_R_2001(Object arg0) {
-        return localizer.localize(localizableWARNING_WSI_R_2001(arg0));
+    public static String WARNING_WSI_R_2001() {
+        return localizer.localize(localizableWARNING_WSI_R_2001());
     }
 
+    public static Localizable localizableFILE_NOT_FOUND(Object arg0) {
+        return messageFactory.getMessage("file.not.found", arg0);
+    }
+
+    /**
+     * {0} is unreachable
+     *
+     */
+    public static String FILE_NOT_FOUND(Object arg0) {
+        return localizer.localize(localizableFILE_NOT_FOUND(arg0));
+    }
+
     public static Localizable localizableVALIDATION_INVALID_SIMPLE_TYPE_IN_ELEMENT(Object arg0, Object arg1) {
         return messageFactory.getMessage("validation.invalidSimpleTypeInElement", arg0, arg1);
     }
@@ -944,7 +972,7 @@
     }
 
     /**
-     * JAXWS version attribute must be present
+     *  JAXWS version attribute must be present
      *
      */
     public static String INTERNALIZER_VERSION_NOT_PRESENT() {
@@ -951,6 +979,20 @@
         return localizer.localize(localizableINTERNALIZER_VERSION_NOT_PRESENT());
     }
 
+    public static Localizable localizableFAILED_NOSERVICE(Object arg0) {
+        return messageFactory.getMessage("failed.noservice", arg0);
+    }
+
+    /**
+     * failed.noservice=Could not find wsdl:service in the provided WSDL(s):
+     *
+     * {0} At least one WSDL with at least one service definition needs to be provided.
+     *
+     */
+    public static String FAILED_NOSERVICE(Object arg0) {
+        return localizer.localize(localizableFAILED_NOSERVICE(arg0));
+    }
+
     public static Localizable localizablePARSING_TOO_MANY_ELEMENTS(Object arg0, Object arg1, Object arg2) {
         return messageFactory.getMessage("parsing.tooManyElements", arg0, arg1, arg2);
     }
@@ -968,7 +1010,7 @@
     }
 
     /**
-     * "{0}" is not a part of this compilation. Is this a mistake for "{1}"?
+     *  "{0}" is not a part of this compilation. Is this a mistake for "{1}"?
      *
      */
     public static String INTERNALIZER_INCORRECT_SCHEMA_REFERENCE(Object arg0, Object arg1) {
--- old/src/share/classes/com/sun/tools/internal/ws/resources/configuration.properties	Tue Aug  4 09:29:11 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/configuration.properties	Tue Aug  4 09:29:10 2009
@@ -25,4 +25,3 @@
 
 configuration.invalidElement=invalid element \"{2}\" in file \"{0}\" (line {1})
 configuration.notBindingFile=Ignoring: binding file "\"{0}\". It is not a jaxws or a jaxb binding file.
- 
--- old/src/share/classes/com/sun/tools/internal/ws/resources/generator.properties	Tue Aug  4 09:29:13 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/generator.properties	Tue Aug  4 09:29:13 2009
@@ -32,4 +32,5 @@
 
 #IndentingWriter
 generator.indentingwriter.charset.cantencode=WSDL has some characters which native java encoder can''t encode: \"{0}\"
- 
+generator.sei.classAlreadyExist=Could not generate SEI, class: {0} already exists. Rename wsdl:portType \"{1}\" using JAX-WS customization
+generator.service.classAlreadyExist=Could not generate Service, class: {0} already exists. Rename wsdl:Service \"{1}\" using JAX-WS customization
--- old/src/share/classes/com/sun/tools/internal/ws/resources/javacompiler.properties	Tue Aug  4 09:29:15 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/javacompiler.properties	Tue Aug  4 09:29:15 2009
@@ -29,4 +29,3 @@
 javacompiler.classpath.error={0} is not available in the classpath, requires Sun's JDK version 5.0 or latter.
 javacompiler.nosuchmethod.error=There is no such method {0} available, requires Sun's JDK version 5.0 or latter.
 javacompiler.error=error : {0}.
- 
--- old/src/share/classes/com/sun/tools/internal/ws/resources/model.properties	Tue Aug  4 09:29:17 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/model.properties	Tue Aug  4 09:29:17 2009
@@ -58,7 +58,6 @@
 
 model.uniqueness=uniqueness constraint violation
 model.part.notUnique=parts in wsdl:message \"{0}\", reference \"{1}\", they must reference unique global elements.
-model.parameter.notunique=Failed to generate Java signature: duplicate parameter names {0}. Use JAXWS binding customization to rename the wsdl:part \"{1}\"
 model.exception.notunique=Failed to generate Java signature: duplicate exception names {0}. Use JAXWS binding customization to rename the wsdl:part \"{1}\"
 model.uniqueness.javastructuretype=uniqueness constraint violation, duplicate member \"{0}\" added to JavaStructureType \"{1}\"
 model.parent.type.already.set=parent of type \"{0}\" already set to \"{1}\", new value = \"{2}\"
@@ -78,15 +77,16 @@
 model.arraywrapper.no.subtypes=LiteralArrayWrapper cannot have subtypes
 model.arraywrapper.no.content.member=LiteralArrayWrapper cannot have a content member
 model.complexType.simpleContent.reservedName=invalid attribute name: "_value" in complexType: \"{0}\", _value is JAXWS reserved name, this name is generated in the generated javabean class to hold content value in the generated javabean class for complexType/simpleContent.
+model.parameter.notunique.wrapper=Failed to generate Java signature: duplicate parameter name \"{0}\". Try one of these\n\t1. Use JAXWS binding customization to rename the wsdl:part \"{1}\"\n\t2. Run wsimport with -extension switch.\n\t3. This is wrapper style operation, to resolve parameter name conflict, you can also try disabling wrapper style by using <jaxws:enableWrapperStyle>false</jaxws:enableWrapperStyle> wsdl customization.
+model.parameter.notunique=Failed to generate Java signature: duplicate parameter name \"{0}\". Try one of these\n\t1. Use JAXWS binding customization to rename the wsdl:part \"{1}\"\n\t2. Run wsimport with -extension switch.
 
-//JAXWS 2.0
+#JAXWS 2.0
 model.schema.elementNotFound=Element \"{0}\" not found.
 model.schema.jaxbException.message="{0}"
 model.saxparser.exception:{0}\n{1}
 
 ConsoleErrorReporter.UnknownLocation = \
-	unknown location
+        unknown location
 
 ConsoleErrorReporter.LineXOfY = \
-	\ \ line {0} of {1}
- 
+        \ \ line {0} of {1}
--- old/src/share/classes/com/sun/tools/internal/ws/resources/modeler.properties	Tue Aug  4 09:29:20 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/modeler.properties	Tue Aug  4 09:29:19 2009
@@ -65,9 +65,9 @@
 wsdlmodeler.warning.noPortsInService=Service \"{0}\" does not contain any usable ports. try running wsimport with -extension switch.
 wsdlmodeler.warning.noOperationsInPort=Port \"{0}\" does not contain any usable operations
 wsdlmodeler.warning.ignoringNonSOAPPort=ignoring port \"{0}\": not a standard SOAP port. try running wsimport with -extension switch.
-wsdlmodeler.warning.nonSOAPPort=port \"{0}\": not a standard SOAP port. The generated artifacts may not work with JAXWS runtime. 
+wsdlmodeler.warning.nonSOAPPort=port \"{0}\": not a standard SOAP port. The generated artifacts may not work with JAXWS runtime.
 wsdlmodeler.warning.ignoringNonSOAPPort.noAddress=ignoring port \"{0}\": no SOAP address specified. try running wsimport with -extension switch.
-wsdlmodeler.warning.noSOAPAddress=port \"{0}\" is not a SOAP port, it has no soap:address 
+wsdlmodeler.warning.noSOAPAddress=port \"{0}\" is not a SOAP port, it has no soap:address
 wsdlmodeler.warning.ignoringSOAPBinding.nonHTTPTransport:ignoring SOAP port \"{0}\": unrecognized transport. try running wsimport with -extension switch.
 
 #BP1.1 R2705
@@ -189,7 +189,7 @@
 mimemodeler.invalidMimePart.nameNotAllowed=name attribute on wsdl:part in Operation \"{0}\" is ignored. Its not allowed as per WS-I AP 1.0.
 
 
-wsdlmodeler20.rpcenc.not.supported=rpc/encoded wsdl's are not supported in JAXWS 2.0. 
+wsdlmodeler20.rpcenc.not.supported=rpc/encoded wsdl's are not supported in JAXWS 2.0.
 wsdlmodeler.warning.ignoringOperation.notNCName=Ignoring operation \"{0}\", it has illegal character ''{1}'' in its name. Its rpc-literal operation - jaxws won't be able to serialize it!
 
 wsdlmodeler.warning.ignoringOperation.javaReservedWordNotAllowed.nonWrapperStyle=Ignoring operation \"{0}\", can''t generate java method. Parameter: part "{2}\" in wsdl:message \"{1}\", is a java keyword. Use customization to change the parameter name or change the wsdl:part name.
@@ -207,11 +207,12 @@
 wsdlmodeler.warning.ignoringOperation.javaReservedWordNotAllowed.customizedOperationName=Ignoring operation \"{0}\", can''t generate java method ,customized name \"{1}\" of the wsdl:operation is a java keyword.
 wsdlmodeler.invalid.operation.javaReservedWordNotAllowed.customizedOperationName=Invalid operation \"{0}\", can''t generate java method ,customized name \"{1}\" of the wsdl:operation is a java keyword.
 
-wsdlmodeler.jaxb.javatype.notfound=Schema descriptor {0} in message part \"{1}\" could not be bound to Java!
+wsdlmodeler.jaxb.javatype.notfound=Schema descriptor {0} in message part \"{1}\" is not defined and could not be bound to Java. Perhaps the schema descriptor {0} is not defined in the schema imported/included in the WSDL. You can either add such imports/includes or run wsimport and provide the schema location using -b switch.
 wsdlmodeler.unsupportedBinding.mime=WSDL MIME binding is not currently supported!
 
-wsdlmodeler.nonUnique.body=Non unique body parts! In a port, operations must have unique operation signaure on the wire for successful dispatch. In port {0}, Operations \"{1}\" and \"{2}\" have the same request body block {3}
-wsdlmodeler.rpclit.unkownschematype=XML type \"{0}\" could not be resolved, XML to JAVA binding failed! Please check the wsdl:part \"{1}\" in the wsdl:message \"{2}\".    
+wsdlmodeler.nonUnique.body.error=Non unique body parts! In a port, as per BP 1.1 R2710 operations must have unique operation signaure on the wire for successful dispatch. In port {0}, Operations \"{1}\" and \"{2}\" have the same request body block {3}. Try running wsimport with -extension switch, runtime will try to dispatch using SOAPAction
+wsdlmodeler.nonUnique.body.warning=Non unique body parts! In a port, as per BP 1.1 R2710 operations must have unique operation signaure on the wire for successful dispatch. In port {0}, Operations \"{1}\" and \"{2}\" have the same request body block {3}. Method dispatching may fail, runtime will try to dispatch using SOAPAction
 
+wsdlmodeler.rpclit.unkownschematype=XML type \"{0}\" could not be resolved, XML to JAVA binding failed! Please check the wsdl:part \"{1}\" in the wsdl:message \"{2}\".
+
 wsdlmodeler.responsebean.notfound=wsimport failed to generate async response bean for operation: {0}
- 
--- old/src/share/classes/com/sun/tools/internal/ws/resources/processor.properties	Tue Aug  4 09:29:22 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/processor.properties	Tue Aug  4 09:29:21 2009
@@ -24,4 +24,3 @@
 #
 
 processor.missing.model=model is missing
- 
--- old/src/share/classes/com/sun/tools/internal/ws/resources/util.properties	Tue Aug  4 09:29:24 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/util.properties	Tue Aug  4 09:29:24 2009
@@ -26,4 +26,3 @@
 holder.valuefield.not.found=Could not find the field in the Holder that contains the Holder''s value: {0}
 null.namespace.found=Encountered error in wsdl. Check namespace of element <{0}>
 sax2dom.notsupported.createelement=SAX2DOMEx.DomImplDoesntSupportCreateElementNs: {0}
- 
--- old/src/share/classes/com/sun/tools/internal/ws/resources/webserviceap.properties	Tue Aug  4 09:29:26 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/webserviceap.properties	Tue Aug  4 09:29:26 2009
@@ -50,7 +50,7 @@
 webserviceap.oneway.operation.cannot.have.holders=The method {1} of class {0} is annotated @Oneway but contains inout or out paramerters (javax.xml.ws.Holder)
 
 webserviceap.oneway.operation.cannot.declare.exceptions=The method {1} of class {0} is annotated @Oneway but declares the exception {2}
-  
+
 webserviceap.cannot.combine.handlerchain.soapmessagehandlers=You cannot specify both HanlderChain and SOAPMessageHandlers annotations
 
 webserviceap.invalid.handlerchain.file.nohandler-config=The handlerchain file {0} is invalid, it does not contain a handler-config element
@@ -109,19 +109,19 @@
 
 webserviceap.mixed.binding.style=Class\: {0} contains mixed bindings.  SOAPBinding.Style.RPC and SOAPBinding.Style.DOCUMENT cannot be mixed.
 
-webserviceap.endpointinteface.plus.annotation=The @{0} annotation cannot be used in with @javax.jws.WebService.endpointInterface element. 
+webserviceap.endpointinteface.plus.annotation=The @{0} annotation cannot be used in with @javax.jws.WebService.endpointInterface element.
 
-webserviceap.endpointinteface.plus.element=The @javax.jws.WebService.{0} element cannot be used in with @javax.jws.WebService.endpointInterface element. 
+webserviceap.endpointinteface.plus.element=The @javax.jws.WebService.{0} element cannot be used in with @javax.jws.WebService.endpointInterface element.
 
-webserviceap.non.in.parameters.must.be.holder=Class:\ {0}, method: {1}, parameter: {2} is not WebParam.Mode.IN and is not of type javax.xml.ws.Holder. 
+webserviceap.non.in.parameters.must.be.holder=Class:\ {0}, method: {1}, parameter: {2} is not WebParam.Mode.IN and is not of type javax.xml.ws.Holder.
 
-webserviceap.invalid.sei.annotation.element=The @javax.jws.WebService.{0} element cannot be specified on a service endpoint interface. Class\: {1} 
+webserviceap.invalid.sei.annotation.element=The @javax.jws.WebService.{0} element cannot be specified on a service endpoint interface. Class\: {1}
 
-webserviceap.invalid.sei.annotation=The @{0} annotation cannot be used on a service endpoint interface. Class\: {1} 
+webserviceap.invalid.sei.annotation=The @{0} annotation cannot be used on a service endpoint interface. Class\: {1}
 
 webserviceap.invalid.sei.annotation.element.exclude=The @javax.jws.WebMethod({0}) cannot be used on a service endpoint interface. Class\: {1} method\: {2}
 
-webserviceap.invalid.webmethod.element.with.exclude=The @javax.jws.WebMethod.{0} element cannot be specified with the @javax.jws.WebMethod.exclude element. Class\: {1} method\: {2} 
+webserviceap.invalid.webmethod.element.with.exclude=The @javax.jws.WebMethod.{0} element cannot be specified with the @javax.jws.WebMethod.exclude element. Class\: {1} method\: {2}
 
 webserviceap.doc.bare.no.out=Document/literal bare methods with no return type or OUT/INOUT parameters must be annotated as @Oneway. Class\: {0}, method: {1}
 webserviceap.doc.bare.return.and.out=Document/literal bare methods cannot have a return type and out parameters. Class\: {0}, method: {1}
@@ -137,15 +137,17 @@
 
 webserviceap.webservice.method.is.abstract=Classes annotated with @javax.jws.WebService must not have abstract methods. Class\: {0} Method: {1}
 
-#webserviceap.doc.bare.return.and.out=Document literal bare methods must not have a return value and an OUT/INOUT parameter.  Class\: {0} Method\: {1} 
+webserviceap.webservice.method.is.static.or.final=Method annotated with @javax.jws.WebMethod must not be static or final. Class\: {0} Method: {1}
 
+#webserviceap.doc.bare.return.and.out=Document literal bare methods must not have a return value and an OUT/INOUT parameter.  Class\: {0} Method\: {1}
+
 webserviceap.webservice.no.default.constructor=Classes annotated with @javax.jws.WebService must have a public default constructor. Class\: {0}
 
-webserviceap.oneway.and.not.one.in=Document literal bare methods annotated with @javax.jws.Oneway must have one non-header IN parameter.  Class\: {0} Method\: {1} 
+webserviceap.oneway.and.not.one.in=Document literal bare methods annotated with @javax.jws.Oneway must have one non-header IN parameter.  Class\: {0} Method\: {1}
 
-webserviceap.doc.bare.no.return.and.no.out=Document literal bare methods that do not have a return value must have a single OUT/INOUT parameter.  Class\: {0} Method\: {1} 
+webserviceap.doc.bare.no.return.and.no.out=Document literal bare methods that do not have a return value must have a single OUT/INOUT parameter.  Class\: {0} Method\: {1}
 
-webserviceap.doc.bare.and.no.one.in=Document literal bare methods must have one non-header, IN/INOUT parameter.  Class\: {0} Method\: {1} 
+webserviceap.doc.bare.and.no.one.in=Document literal bare methods must have one non-header, IN/INOUT parameter.  Class\: {0} Method\: {1}
 
 webserviceap.method.not.implemented=Methods in an endpointInterface must be implemented in the implementation class.  Interface Class\:{0} Implementation Class\:{1} Method\: {2}
 
@@ -152,4 +154,3 @@
 webserviceap.no.package.class.must.have.targetnamespace=@javax.jws.Webservice annotated classes that do not belong to a package must have the @javax.jws.Webservice.targetNamespace element.  Class\: {0}
 
 webserviceap.webservice.and.webserviceprovider=Classes cannot be annotated with both @javax.jws.WebService and @javax.xml.ws.WebServiceProvider.  Class\: {0}
- 
--- old/src/share/classes/com/sun/tools/internal/ws/resources/wscompile.properties	Tue Aug  4 09:29:28 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/wscompile.properties	Tue Aug  4 09:29:28 2009
@@ -44,13 +44,23 @@
 \  -p <pkg>                  specifies the target package\n\
 \  -quiet                    suppress wsimport output\n\
 \  -s <directory>            specify where to place generated source files\n\
-\  -target <version>         generate code as per the given JAXWS specification version.\n\
-\                            version 2.0 will generate compliant code for JAXWS 2.0 spec.\n\
+\  -target <version>         generate code as per the given JAXWS spec version\n\
+\                            e.g. 2.0 will generate compliant code for JAXWS 2.0 spec\n\
 \  -verbose                  output messages about what the compiler is doing\n\
 \  -version                  print version information\n\
 \  -wsdllocation <location>  @WebServiceClient.wsdlLocation value\n\
 
+wsimport.usage.extensions=\n\
+\Extensions:\n\
+\  -XadditionalHeaders         map headers not bound to request or response message to \n\
+\                              Java method parameters\n\
+\  -Xauthfile                  file to carry authorization information in the format \n\
+\                              http://username:password@example.org/stock?wsdl\n\
+\  -Xdebug                     print debug information\n\
+\  -Xno-addressing-databinding enable binding of W3C EndpointReferenceType to Java\n\
+\  -Xnocompile                 do not compile generated Java files\n\
 
+
 wsimport.usage.examples=\n\
 \Examples:\n\
 \  wsimport stock.wsdl -b stock.xml -b stock.xjb\n\
@@ -76,15 +86,18 @@
 \  -s <directory>             specify where to place generated source files\n\
 \  -verbose                   output messages about what the compiler is doing\n\
 \  -version                   print version information\n\
-\  -wsdl[:protocol]           generate a WSDL file.  The protocol is optional.\n\
-\                             Valid protocols are soap1.1 and Xsoap1.2, the default\n\
-\                             is soap1.1.  Xsoap1.2 is not standard and can only be\n\
-\                             used in conjunction with the -extension option\n\
+\  -wsdl[:protocol]           generate a WSDL file. The protocol is optional.\n\
+\                             Valid protocols are {1},\n\
+\                             the default is soap1.1.\n\
+\                             The non stanadard protocols {2}\n\
+\                             can only be used in conjunction with the\n\
+\                             -extension option.\n\
 \  -servicename <name>        specify the Service name to use in the generated WSDL\n\
 \                             Used in conjunction with the -wsdl option.\n\
 \  -portname <name>           specify the Port name to use in the generated WSDL\n\
 \                             Used in conjunction with the -wsdl option.
 
+
 wsgen.usage.examples=\n\
 \Examples:\n\
 \  wsgen -cp . example.Stock\n\
@@ -93,7 +106,7 @@
 wrapperTask.needEndorsed=\
 You are running on JDK6 which comes with JAX-WS 2.0 API, but this tool requires JAX-WS 2.1 API. \
 Use the endorsed standards override mechanism (http://java.sun.com/javase/6/docs/technotes/guides/standards/), \
-or set xendorsed="true" on <{0}>. 
+or set xendorsed="true" on <{0}>.
 
 wrapperTask.loading20Api=\
 You are loading JAX-WS 2.0 API from {0} but this tool requires JAX-WS 2.1 API.
@@ -126,7 +139,8 @@
 wsgen.could.not.create.file="Could not create file: "\{0}\"
 wsgen.missingFile=Missing SEI
 wsgen.soap12.without.extension=The optional protocol \"Xsoap1.2\" must be used in conjunction with the \"-extension\" option.
-wsgen.wsdl.arg.no.genwsdl=The \"{0}\" option can only be in conjunction with the "-wsdl" option. 
+wsgen.protocol.without.extension=The optional protocol \"{0}\" must be used in conjunction with the \"-extension\" option.
+wsgen.wsdl.arg.no.genwsdl=The \"{0}\" option can only be in conjunction with the "-wsdl" option.
 wsgen.servicename.missing.namespace=The service name \"{0}\" is missing a namespace.
 wsgen.servicename.missing.localname=The service name \"{0}\" is missing a localname.
 wsgen.portname.missing.namespace=The port name \"{0}\" is missing a namespace.
@@ -151,17 +165,41 @@
     Failed to parse "{0}": {1}
 
 wsimport.ParsingWSDL=parsing WSDL...\n\n
-wsimport.GeneratingCode=generating code...
-
+wsimport.GeneratingCode=generating code...\n
+wsimport.CompilingCode=\ncompiling code...\n
 wsimport.ILLEGAL_TARGET_VERSION = \
     "{0}" is not a valid target version. "2.0" and "2.1" are supported.
 
+wsimport.ILLEGAL_AUTH_INFO = \
+    "{0}" is not a valid authorization information format. The format is http[s]://user:password@host:port//<url-path>.
+
+wsimport.readingAuthFile = \
+  Trying to read authorization file : "{0}"...
+
+wsimport.authFileNotFound = \
+  Authorization file "{0}" not found. If the WSDL access needs Basic Authentication, please provide authorization file with read access at {1} or use -Xauthfile to give the authorization file and on each line provide authorization information using this format : http[s]://user:password@host:port//<url-path>
+
+wsimport.authInfoNeeded = \
+  {0},  "{1}" needs authorization, please provide authorization file with read access at {2} or use -Xauthfile to give the authorization file and on each line provide authorization information using this format : http[s]://user:password@host:port//<url-path>
+
+wsimport.AUTH_INFO_LINENO = \
+  "line {0} of {1}
+
+
 wsimport.ErrorMessage = \
-	[ERROR] {0}
+        [ERROR] {0}
 
 wsimport.WarningMessage = \
-	[WARNING] {0}
+        [WARNING] {0}
 
 wsimport.InfoMessage = \
-	[INFO] {0}
- 
+        [INFO] {0}
+
+wsimport.DebugMessage = \
+        [DEBUG] {0}
+
+wsimport.httpRedirect = \
+  Server returned HTTP Status code: "{0}", retrying with "{1}"
+
+wsimport.maxRedirectAttempt = \
+  Can not get a WSDL maximum number of redirects(5) reached
--- old/src/share/classes/com/sun/tools/internal/ws/resources/wsdl.properties	Tue Aug  4 09:29:31 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/resources/wsdl.properties	Tue Aug  4 09:29:30 2009
@@ -41,7 +41,6 @@
 parsing.unknownNamespacePrefix=undeclared namespace prefix: \"{0}\"
 parsing.invalidURI=invalid URI: {0}
 parsing.ioExceptionWithSystemId=failed to parse document at \"{0}\"
-parsing.unableToGetMetadata= Unable to get Metadata from: {0}
 parsing.ioException=parsing failed: {0}
 parsing.saxExceptionWithSystemId=invalid WSDL file! failed to parse document at \"{0}\"
 parsing.saxException=invalid WSDL file! parsing failed: {0}
@@ -52,7 +51,7 @@
 parsing.missingRequiredAttribute=missing required attribute \"{1}\" of element \"{0}\"
 parsing.invalidTag=expected element \"{1}\", found \"{0}\"
 parsing.invalidTagNS=Invalid WSDL at {4}: expected element \"{2}\" (in namespace \"{3}\"), found element \"{0}\" (in namespace \"{1}\")
-parsing.nonWhitespaceTextFound=found unexpected non whitespace text: \"{0}\"
+parsing.nonWhitespaceTextFound=found unexpected non-whitespace text: \"{0}\"
 parsing.elementExpected=unexpected non-element found
 #
 entity.duplicate=duplicate entity: \"{0}\"
@@ -59,9 +58,9 @@
 entity.duplicateWithType=duplicate \"{0}\" entity: \"{1}\"
 
 entity.notFoundByID=invalid entity id: \"{0}\"
-entity.notFoundByQName=invalid entity name: \"{0}\" (in namespace: \"{1}\")
-entity.notFound.portType=wsdl:portType \"{0}\" referenced by wsdl:binding \"{1}\", but its not found in the wsdl
-entity.notFound.binding=wsdl:binding \"{0}" referenced by wsdl:port \"{1}\", but its not found in the wsdl
+entity.notFoundByQName={0} \"{1}\" not found in the wsdl: {2}
+entity.notFound.portType=wsdl:portType \"{0}\" referenced by wsdl:binding \"{1}\", but it's not found in the wsdl
+entity.notFound.binding=wsdl:binding \"{0}" referenced by wsdl:port \"{1}\", but it's not found in the wsdl
 
 #
 validation.missingRequiredAttribute=missing required attribute \"{0}\" of element \"{1}\"
@@ -71,7 +70,7 @@
 validation.invalidComplexTypeInElement=invalid element: \"{1}\", has named complexType: \"{0}\"
 validation.invalidSimpleTypeInElement=invalid element: \"{1}\", has named simpleType: \"{0}\"
 validation.duplicatedElement=duplicated element: \"{0}\"
-validation.duplicatePartName=Invalid WSDL, duplicate parts in a wsdl:message is not allowed. \nwsdl:message {0} has duplicated part name: \"{1}\"
+validation.duplicatePartName=Invalid WSDL, duplicate parts in a wsdl:message is not allowed. \nwsdl:message {0} has a duplicated part name: \"{1}\"
 validation.invalidSubEntity=invalid sub-element \"{0}\" of element \"{1}\"
 validation.invalidAttribute=invalid attribute \"{0}\" of element \"{1}\"
 validation.invalidAttributeValue=invalid value \"{1}\" for attribute \"{0}\"
@@ -88,51 +87,54 @@
 warning.inputOutputEmptyAction=ignoring empty Action in {0} element of \"{1}\" operation, using default instead
 
 #wsi compliant WSDL warnings
-warning.wsi.r2001=Not a WSI-BP compliant WSDL (R2001, R2002). wsdl:import must only import WSDL document. Its trying to import: \"{0}\"
-warning.wsi.r2002=Not a WSI-BP compliant WSDL (R2002). wsdl:import must not be used to import XML Schema embedded in the WSDL document. Expected wsdl namesapce: {0}, found: {1}
-warning.wsi.r2003=Not a WSI-BP compliant WSDL (R2003). xsd:import must only be used inside xsd:schema element.
-warning.wsi.r2004=Not a WSI-BP compliant WSDL (R2001, R2004). xsd:import must not import XML Schema definition emmbedded inline within WSDLDocument.
+warning.wsi.r2001=Not a WSI-BP compliant WSDL (R2001, R2002). wsdl:import must import only WSDL documents. It's trying to import: \"{0}\"
+warning.wsi.r2002=Not a WSI-BP compliant WSDL (R2002). wsdl:import must not be used to import XML Schema embedded in the WSDL document. Expected wsdl namespace: {0}, found: {1}
+warning.wsi.r2003=Not a WSI-BP compliant WSDL (R2003). xsd:import must only be used inside xsd:schema elements.
+warning.wsi.r2004=Not a WSI-BP compliant WSDL (R2001, R2004). xsd:import must not import XML Schema definitions embedded inline within the WSDL document.
 
 #Parser
 Parsing.ParseFailed = \
-	Failed to parse the WSDL.
+\tFailed to parse the WSDL.
 
 Parsing.NotAWSDL=Failed to get WSDL components, probably {0} is not a valid WSDL file.
 
 AbstractReferenceFinderImpl.UnableToParse = \
-	Unable to parse "{0}" : {1}
+\tUnable to parse "{0}" : {1}
 
 Parser.NotABindingFile = \
-	not an external binding file. The root element must be '{'http://java.sun.com/xml/ns/jaxws'}'bindings but it is '{'{0}'}'{1}
+\tnot an external binding file. The root element must be '{'http://java.sun.com/xml/ns/jaxws'}'bindings but it is '{'{0}'}'{1}
 
 
 #Internalizer
 Internalizer.TwoVersionAttributes = \
-	Both jaxws:version and version are present
+\tBoth jaxws:version and version are present
 Internalizer.IncorrectVersion = \
-	JAXWS version attribute must be "2.0"
+\tJAXWS version attribute must be "2.0"
 
 Internalizer.VersionNotPresent = \
-	JAXWS version attribute must be present
+\tJAXWS version attribute must be present
 
 internalizer.targetNotAnElement= \
-    Target node is not an element
+\tTarget node is not an element
 internalizer.targetNotFound= \
-    No target found for the wsdlLocation: {0}
+\tNo target found for the wsdlLocation: {0}
 
 Internalizer.IncorrectSchemaReference= \
-	"{0}" is not a part of this compilation. Is this a mistake for "{1}"?
+\t"{0}" is not a part of this compilation. Is this a mistake for "{1}"?
 
 internalizer.XPathEvaluationError = \
     XPath error: {0}
 internalizer.XPathEvaluatesToNoTarget = \
-    XPath evaluation of "{0}" results in empty target node
+    XPath evaluation of "{0}" results in an empty target node
 internalizer.XPathEvaulatesToTooManyTargets = \
     XPath evaluation of "{0}" results in too many ({1}) target nodes
 internalizer.XPathEvaluatesToNonElement = \
     XPath evaluation of "{0}" needs to result in an element.
-invalid.customization.namespace=Ignoring customization: \"{0}\", it has no namespace. It must belong to the customization namespace.    
+invalid.customization.namespace=Ignoring customization: \"{0}\", because it has no namespace. It must belong to the customization namespace.
 
 invalid.wsdl.with.dooc="Not a WSDL document: {0}, it gives \"{1}\", retrying with MEX..."
-invalid.wsdl="{0} does not look like a WSDL document, retrying with MEX..."
- 
+invalid.wsdl=Invalid WSDL {0}, expected {1} found {2} at (line {3})
+try.with.mex= {0} \n\nretrying with MEX...
+file.not.found={0} is unreachable
+parsing.unableToGetMetadata= {0}\n\n{1}
+failed.noservice=failed.noservice=Could not find wsdl:service in the provided WSDL(s): \n\n{0} At least one WSDL with at least one service definition needs to be provided.
--- old/src/share/classes/com/sun/tools/internal/ws/version.properties	Tue Aug  4 09:29:33 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/version.properties	Tue Aug  4 09:29:33 2009
@@ -23,7 +23,7 @@
 # have any questions.
 #
 
-build-id=JAX-WS RI 2.1.1
-build-version=JAX-WS RI 2.1.1
-major-version=2.1.1
- 
+#Fri May 15 16:16:14 CEST 2009
+build-id=JAX-WS RI 2.1.6
+major-version=2.1.6
+build-version=JAX-WS RI 2.1.6
--- old/src/share/classes/com/sun/tools/internal/ws/wscompile/AbortException.java	Tue Aug  4 09:29:35 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/AbortException.java	Tue Aug  4 09:29:35 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wscompile;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/ws/wscompile/BadCommandLineException.java	Tue Aug  4 09:29:37 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/BadCommandLineException.java	Tue Aug  4 09:29:37 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wscompile;
 
 import com.sun.istack.internal.Nullable;
--- old/src/share/classes/com/sun/tools/internal/ws/wscompile/ErrorReceiver.java	Tue Aug  4 09:29:39 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/ErrorReceiver.java	Tue Aug  4 09:29:39 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wscompile;
 
 import com.sun.istack.internal.Nullable;
@@ -126,6 +125,8 @@
         info( new SAXParseException(msg,null) );
     }
 
+    public abstract void debug(SAXParseException exception);
+
 //
 //
 // convenience methods for derived classes
@@ -145,7 +146,7 @@
           return ModelMessages.CONSOLE_ERROR_REPORTER_LINE_X_OF_Y(line==-1?"?":Integer.toString( line ),
               getShortName( e.getSystemId()));
       } else {
-          return ModelMessages.CONSOLE_ERROR_REPORTER_UNKNOWN_LOCATION();
+          return ""; //for unkown location just return empty string
       }
   }
 
--- old/src/share/classes/com/sun/tools/internal/ws/wscompile/ErrorReceiverFilter.java	Tue Aug  4 09:29:42 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/ErrorReceiverFilter.java	Tue Aug  4 09:29:41 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wscompile;
 
 import com.sun.tools.internal.xjc.api.ErrorListener;
@@ -66,6 +65,10 @@
         if(core!=null)  core.info(exception);
     }
 
+    public void debug(SAXParseException exception) {
+
+    }
+
     public void warning(SAXParseException exception) {
         if(core!=null)  core.warning(exception);
     }
--- old/src/share/classes/com/sun/tools/internal/ws/wscompile/JavaCompilerHelper.java	Tue Aug  4 09:29:44 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/JavaCompilerHelper.java	Tue Aug  4 09:29:43 2009
@@ -35,6 +35,7 @@
 import java.lang.reflect.Method;
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.net.URISyntaxException;
 
 /**
  * A helper class to invoke javac.
@@ -43,9 +44,10 @@
  */
 class JavaCompilerHelper{
     static File getJarFile(Class clazz) {
+        URL url = null;
         try {
-            URL url = ParallelWorldClassLoader.toJarUrl(clazz.getResource('/'+clazz.getName().replace('.','/')+".class"));
-            return new File(url.getPath());   // this code is assuming that url is a file URL
+            url = ParallelWorldClassLoader.toJarUrl(clazz.getResource('/'+clazz.getName().replace('.','/')+".class"));
+            return new File(url.toURI());
         } catch (ClassNotFoundException e) {
             // if we can't figure out where JAXB/JAX-WS API are, we couldn't have been executing this code.
             throw new Error(e);
@@ -52,6 +54,9 @@
         } catch (MalformedURLException e) {
             // if we can't figure out where JAXB/JAX-WS API are, we couldn't have been executing this code.
             throw new Error(e);
+        } catch (URISyntaxException e) {
+            // url.toURI() is picky and doesn't like ' ' in URL, so this is the fallback
+            return new File(url.getPath());
         }
     }
 
--- old/src/share/classes/com/sun/tools/internal/ws/wscompile/Options.java	Tue Aug  4 09:29:46 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/Options.java	Tue Aug  4 09:29:46 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wscompile;
 
 import com.sun.tools.internal.ws.resources.WscompileMessages;
@@ -150,6 +149,10 @@
 
 
     public boolean debug = false;
+
+    /**
+     * -Xdebug - gives complete stack trace
+     */
     public boolean debugMode = false;
 
 
@@ -206,7 +209,7 @@
      * @exception BadCommandLineException
      *      thrown when there's a problem in the command-line arguments
      */
-    public final void parseArguments( String[] args ) throws BadCommandLineException {
+    public void parseArguments( String[] args ) throws BadCommandLineException {
 
         for (int i = 0; i < args.length; i++) {
             if(args[i].length()==0)
--- old/src/share/classes/com/sun/tools/internal/ws/wscompile/WsgenOptions.java	Tue Aug  4 09:29:48 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/WsgenOptions.java	Tue Aug  4 09:29:48 2009
@@ -24,18 +24,20 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wscompile;
 
 import com.sun.mirror.apt.Filer;
 import com.sun.tools.internal.ws.resources.WscompileMessages;
+import com.sun.tools.internal.ws.api.WsgenExtension;
+import com.sun.tools.internal.ws.api.WsgenProtocol;
 import com.sun.xml.internal.ws.api.BindingID;
+import com.sun.xml.internal.ws.util.ServiceFinder;
+import com.sun.xml.internal.ws.binding.SOAPBindingImpl;
 
 import javax.jws.WebService;
 import javax.xml.namespace.QName;
 import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
+import java.util.*;
 
 /**
  * @author Vivek Pandey
@@ -66,8 +68,10 @@
      * protocol value
      */
     public String protocol = "soap1.1";
-    public String transport;
 
+    public Set<String> protocols = new LinkedHashSet<String>();
+    public Map<String, String> nonstdProtocols = new LinkedHashMap<String, String>();
+
     /**
      * -XwsgenReport
      */
@@ -92,8 +96,22 @@
     private static final String SOAP11 = "soap1.1";
     public static final String X_SOAP12 = "Xsoap1.2";
 
+    public WsgenOptions() {
+        protocols.add(SOAP11);
+        protocols.add(X_SOAP12);
+        nonstdProtocols.put(X_SOAP12, SOAPBindingImpl.X_SOAP12HTTP_BINDING);
+        ServiceFinder<WsgenExtension> extn = ServiceFinder.find(WsgenExtension.class);
+        for(WsgenExtension ext : extn) {
+            Class clazz = ext.getClass();
+            WsgenProtocol pro = (WsgenProtocol)clazz.getAnnotation(WsgenProtocol.class);
+            protocols.add(pro.token());
+            nonstdProtocols.put(pro.token(), pro.lexical());
+        }
+    }
+
     @Override
     protected int parseArguments(String[] args, int i) throws BadCommandLineException {
+
         int j = super.parseArguments(args, i);
         if (args[i].equals(SERVICENAME_OPTION)) {
             serviceName = QName.valueOf(requireArgument(SERVICENAME_OPTION, args, ++i));
@@ -132,10 +150,8 @@
                 index = value.indexOf('/');
                 if (index == -1) {
                     protocol = value;
-                    transport = HTTP;
                 } else {
                     protocol = value.substring(0, index);
-                    transport = value.substring(index + 1);
                 }
                 protocolSet = true;
             }
@@ -168,13 +184,9 @@
     public void validate() throws BadCommandLineException {
         if(nonclassDestDir == null)
             nonclassDestDir = destDir;
-        if (!protocol.equalsIgnoreCase(SOAP11) &&
-                !protocol.equalsIgnoreCase(X_SOAP12)) {
-            throw new BadCommandLineException(WscompileMessages.WSGEN_INVALID_PROTOCOL(protocol, SOAP11 + ", " + X_SOAP12));
-        }
 
-        if (transport != null && !transport.equalsIgnoreCase(HTTP)) {
-            throw new BadCommandLineException(WscompileMessages.WSGEN_INVALID_TRANSPORT(transport, HTTP));
+        if (!protocols.contains(protocol)) {
+            throw new BadCommandLineException(WscompileMessages.WSGEN_INVALID_PROTOCOL(protocol, protocols));
         }
 
         if (endpoints.isEmpty()) {
@@ -184,6 +196,10 @@
             throw new BadCommandLineException(WscompileMessages.WSGEN_SOAP_12_WITHOUT_EXTENSION());
         }
 
+        if (nonstdProtocols.containsKey(protocol) && !isExtensionMode()) {
+            throw new BadCommandLineException(WscompileMessages.WSGEN_PROTOCOL_WITHOUT_EXTENSION(protocol));
+        }
+
         validateEndpointClass();
         validateArguments();
     }
@@ -245,12 +261,13 @@
         }
     }
 
-    public static BindingID getBindingID(String protocol) {
+    BindingID getBindingID(String protocol) {
         if (protocol.equals(SOAP11))
             return BindingID.SOAP11_HTTP;
         if (protocol.equals(X_SOAP12))
             return BindingID.SOAP12_HTTP;
-        return null;
+        String lexical = nonstdProtocols.get(protocol);
+        return (lexical != null) ? BindingID.parse(lexical) : null;
     }
 
 
--- old/src/share/classes/com/sun/tools/internal/ws/wscompile/WsgenTool.java	Tue Aug  4 09:29:50 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/WsgenTool.java	Tue Aug  4 09:29:50 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wscompile;
 
 import com.sun.mirror.apt.AnnotationProcessor;
@@ -32,6 +31,8 @@
 import com.sun.mirror.apt.AnnotationProcessorFactory;
 import com.sun.mirror.declaration.AnnotationTypeDeclaration;
 import com.sun.tools.internal.ws.ToolVersion;
+import com.sun.tools.internal.ws.api.WsgenExtension;
+import com.sun.tools.internal.ws.api.WsgenProtocol;
 import com.sun.tools.internal.ws.processor.modeler.annotation.AnnotationProcessorContext;
 import com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP;
 import com.sun.tools.internal.ws.processor.modeler.wsdl.ConsoleErrorReporter;
@@ -46,11 +47,13 @@
 import com.sun.xml.internal.ws.api.server.Container;
 import com.sun.xml.internal.ws.api.wsdl.writer.WSDLGeneratorExtension;
 import com.sun.xml.internal.ws.binding.WebServiceFeatureList;
+import com.sun.xml.internal.ws.binding.SOAPBindingImpl;
 import com.sun.xml.internal.ws.model.AbstractSEIModelImpl;
 import com.sun.xml.internal.ws.model.RuntimeModeler;
 import com.sun.xml.internal.ws.util.ServiceFinder;
 import com.sun.xml.internal.ws.wsdl.writer.WSDLGenerator;
 import com.sun.xml.internal.ws.wsdl.writer.WSDLResolver;
+import com.sun.istack.internal.tools.ParallelWorldClassLoader;
 import org.xml.sax.SAXParseException;
 
 import javax.xml.bind.annotation.XmlSeeAlso;
@@ -110,14 +113,16 @@
                 return false;
             }
         }catch (Options.WeAreDone done){
-            usage(done.getOptions());
+            usage((WsgenOptions)done.getOptions());
         }catch (BadCommandLineException e) {
             if(e.getMessage()!=null) {
                 System.out.println(e.getMessage());
                 System.out.println();
             }
-            usage(e.getOptions());
+            usage((WsgenOptions)e.getOptions());
             return false;
+        }catch(AbortException e){
+            //error might have been reported
         }finally{
             if(!options.keep){
                 options.removeGeneratedFiles();
@@ -161,12 +166,27 @@
         }
     }
 
+    /*
+     * To take care of JDK6-JDK6u3, where 2.1 API classes are not there
+     */
+    private static boolean useBootClasspath(Class clazz) {
+        try {
+            ParallelWorldClassLoader.toJarUrl(clazz.getResource('/'+clazz.getName().replace('.','/')+".class"));
+            return true;
+        } catch(Exception e) {
+            return false;
+        }
+    }
+
+
     public boolean buildModel(String endpoint, Listener listener) throws BadCommandLineException {
         final ErrorReceiverFilter errReceiver = new ErrorReceiverFilter(listener);
         context = new AnnotationProcessorContext();
         webServiceAP = new WebServiceAP(options, context, errReceiver, out);
 
-        String[] args = new String[9];
+        boolean bootCP = useBootClasspath(EndpointReference.class) || useBootClasspath(XmlSeeAlso.class);
+
+        String[] args = new String[8 + (bootCP ? 1 :0)];
         args[0] = "-d";
         args[1] = options.destDir.getAbsolutePath();
         args[2] = "-classpath";
@@ -175,7 +195,9 @@
         args[5] = options.sourceDir.getAbsolutePath();
         args[6] = "-XclassesAsDecls";
         args[7] = endpoint;
-        args[8] = "-Xbootclasspath/p:"+JavaCompilerHelper.getJarFile(EndpointReference.class)+File.pathSeparator+JavaCompilerHelper.getJarFile(XmlSeeAlso.class);
+        if (bootCP) {
+            args[8] = "-Xbootclasspath/p:"+JavaCompilerHelper.getJarFile(EndpointReference.class)+File.pathSeparator+JavaCompilerHelper.getJarFile(XmlSeeAlso.class);
+        }
 
         // Workaround for bug 6499165: issue with javac debug option
         workAroundJavacDebug();
@@ -195,11 +217,12 @@
                 throw new BadCommandLineException(WscompileMessages.WSGEN_CLASS_NOT_FOUND(endpoint));
             }
 
-            BindingID bindingID = WsgenOptions.getBindingID(options.protocol);
+            BindingID bindingID = options.getBindingID(options.protocol);
             if (!options.protocolSet) {
                 bindingID = BindingID.parse(endpointClass);
             }
-            RuntimeModeler rtModeler = new RuntimeModeler(endpointClass, options.serviceName, bindingID);
+            WebServiceFeatureList wsfeatures = new WebServiceFeatureList(endpointClass);
+            RuntimeModeler rtModeler = new RuntimeModeler(endpointClass, options.serviceName, bindingID, wsfeatures.toArray());
             rtModeler.setClassLoader(classLoader);
             if (options.portName != null)
                 rtModeler.setPortName(options.portName);
@@ -207,7 +230,7 @@
 
             final File[] wsdlFileName = new File[1]; // used to capture the generated WSDL file.
             final Map<String,File> schemaFiles = new HashMap<String,File>();
-            WebServiceFeatureList wsfeatures = new WebServiceFeatureList(endpointClass);
+
             WSDLGenerator wsdlGenerator = new WSDLGenerator(rtModel,
                     new WSDLResolver() {
                         private File toFile(String suggestedFilename) {
@@ -327,8 +350,12 @@
         }
     }
 
-    protected void usage(Options options) {
-        System.out.println(WscompileMessages.WSGEN_HELP("WSGEN"));
+    protected void usage(WsgenOptions options) {
+        // Just don't see any point in passing WsgenOptions
+        // BadCommandLineException also shouldn't have options
+        if (options == null)
+            options = this.options;
+        System.out.println(WscompileMessages.WSGEN_HELP("WSGEN", options.protocols, options.nonstdProtocols.keySet()));
         System.out.println(WscompileMessages.WSGEN_USAGE_EXAMPLES());
     }
 
--- old/src/share/classes/com/sun/tools/internal/ws/wscompile/WsimportListener.java	Tue Aug  4 09:29:53 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/WsimportListener.java	Tue Aug  4 09:29:52 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wscompile;
 
 import com.sun.tools.internal.xjc.api.ErrorListener;
@@ -75,6 +74,8 @@
 
     }
 
+    public void debug(SAXParseException exception){}
+
     /**
      * wsimport will periodically invoke this method to see if it should cancel a compilation.
      *
--- old/src/share/classes/com/sun/tools/internal/ws/wscompile/WsimportOptions.java	Tue Aug  4 09:29:55 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/WsimportOptions.java	Tue Aug  4 09:29:54 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wscompile;
 
 import com.sun.codemodel.internal.JCodeModel;
@@ -50,6 +49,7 @@
 import javax.xml.stream.XMLStreamReader;
 import java.io.File;
 import java.io.IOException;
+import java.net.Authenticator;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.ArrayList;
@@ -78,11 +78,27 @@
     public String defaultPackage = null;
 
     /**
+     * -XadditionalHeaders
+     */
+    public boolean additionalHeaders;
+
+    /**
+     * Setting disableSSLHostVerification to true disables the SSL Hostname verification while fetching the wsdls.
+     * -XdisableSSLHostVerification
+     */
+    public boolean disableSSLHostnameVerification;
+
+    /**
      * JAXB's {@link SchemaCompiler} to be used for handling the schema portion.
      * This object is also configured through options.
      */
     private SchemaCompiler schemaCompiler = XJC.createSchemaCompiler();
 
+    /**
+     * Authentication file
+     */
+    public File authFile;
+
     public JCodeModel getCodeModel() {
         if(codeModel == null)
             codeModel = new JCodeModel();
@@ -101,6 +117,50 @@
 
     private JCodeModel codeModel;
 
+    /**
+     * This captures jars passed on the commandline and passes them to XJC and puts them in the classpath for compilation
+     */
+    public List<String> cmdlineJars = new ArrayList<String>();
+
+    /**
+     * Parses arguments and fill fields of this object.
+     *
+     * @exception BadCommandLineException
+     *      thrown when there's a problem in the command-line arguments
+     */
+    @Override
+    public final void parseArguments( String[] args ) throws BadCommandLineException {
+
+        for (int i = 0; i < args.length; i++) {
+            if(args[i].length()==0)
+                throw new BadCommandLineException();
+            if (args[i].charAt(0) == '-') {
+                int j = parseArguments(args,i);
+                if(j==0)
+                    throw new BadCommandLineException(WscompileMessages.WSCOMPILE_INVALID_OPTION(args[i]));
+                i += (j-1);
+            } else {
+                if(args[i].endsWith(".jar")) {
+
+                    try {
+                cmdlineJars.add(args[i]);
+                schemaCompiler.getOptions().scanEpisodeFile(new File(args[i]));
+
+            } catch (com.sun.tools.internal.xjc.BadCommandLineException e) {
+                //Driver.usage(jaxbOptions,false);
+                throw new BadCommandLineException(e.getMessage(), e);
+            }
+                } else{
+                    addFile(args[i]);
+                }
+            }
+        }
+        if(destDir == null)
+            destDir = new File(".");
+        if(sourceDir == null)
+            sourceDir = destDir;
+    }
+
     /** -Xno-addressing-databinding option to disable addressing namespace data binding. This is
      * experimental switch and will be working as a temporary workaround till
      * jaxb can provide a better way to selelctively disable compiling of an
@@ -119,6 +179,12 @@
         } else if (args[i].equals("-wsdllocation")) {
             wsdlLocation = requireArgument("-wsdllocation", args, ++i);
             return 2;
+        } else if (args[i].equals("-XadditionalHeaders")) {
+            additionalHeaders = true;
+            return 1;
+        } else if (args[i].equals("-XdisableSSLHostnameVerification")) {
+            disableSSLHostnameVerification = true;
+            return 1;
         } else if (args[i].equals("-p")) {
             defaultPackage = requireArgument("-p", args, ++i);
             return 2;
@@ -173,6 +239,10 @@
                 //Driver.usage(jaxbOptions,false);
                 throw new BadCommandLineException(e.getMessage(),e);
             }
+        } else if (args[i].equals("-Xauthfile")) {
+            String authfile = requireArgument("-Xauthfile", args, ++i);
+            authFile = new File(authfile);
+            return 2;
         }
 
         return 0; // what's this option?
@@ -182,12 +252,12 @@
         if (wsdls.isEmpty()) {
             throw new BadCommandLineException(WscompileMessages.WSIMPORT_MISSING_FILE());
         }
+
         if(wsdlLocation == null){
             wsdlLocation = wsdls.get(0).getSystemId();
         }
     }
 
-
     @Override
     protected void addFile(String arg) throws BadCommandLineException {
         addFile(arg, wsdls, "*.wsdl");
@@ -360,5 +430,4 @@
             }
         }
     }
-
 }
--- old/src/share/classes/com/sun/tools/internal/ws/wscompile/WsimportTool.java	Tue Aug  4 09:29:57 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/WsimportTool.java	Tue Aug  4 09:29:57 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wscompile;
 
 import com.sun.codemodel.internal.CodeWriter;
@@ -42,6 +41,7 @@
 import com.sun.tools.internal.xjc.util.NullStream;
 import com.sun.xml.internal.ws.api.server.Container;
 import com.sun.xml.internal.ws.util.ServiceFinder;
+import com.sun.istack.internal.tools.ParallelWorldClassLoader;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.SAXParseException;
 
@@ -53,6 +53,7 @@
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.List;
+import java.net.Authenticator;
 
 /**
  * @author Vivek Pandey
@@ -76,7 +77,6 @@
         this.container = container;
     }
 
-
     public boolean run(String[] args) {
         class Listener extends WsimportListener {
             ConsoleErrorReporter cer = new ConsoleErrorReporter(out == null ? new PrintStream(new NullStream()) : out);
@@ -107,6 +107,11 @@
             }
 
             @Override
+            public void debug(SAXParseException exception) {
+                cer.debug(exception);
+            }
+
+            @Override
             public void info(SAXParseException exception) {
                 cer.info(exception);
             }
@@ -132,6 +137,13 @@
                 if (listener.isCanceled())
                     throw new AbortException();
             }
+
+            @Override
+            public void debug(SAXParseException exception){
+                if(options.debugMode){
+                    listener.debug(exception);
+                }
+            }
         };
 
         for (String arg : args) {
@@ -151,6 +163,11 @@
                 if( !options.quiet )
                     listener.message(WscompileMessages.WSIMPORT_PARSING_WSDL());
 
+                //set auth info
+                //if(options.authFile != null)
+                    Authenticator.setDefault(new DefaultAuthenticator(receiver, options.authFile));
+
+
                 WSDLModeler wsdlModeler = new WSDLModeler(options, receiver);
                 Model wsdlModel = wsdlModeler.buildModel();
                 if (wsdlModel == null) {
@@ -165,10 +182,13 @@
                 TJavaGeneratorExtension[] genExtn = ServiceFinder.find(TJavaGeneratorExtension.class).toArray();
                 CustomExceptionGenerator.generate(wsdlModel,  options, receiver);
                 SeiGenerator.generate(wsdlModel, options, receiver, genExtn);
+                if(receiver.hadError()){
+                    throw new AbortException();
+                }
                 ServiceGenerator.generate(wsdlModel, options, receiver);
                 CodeWriter cw = new WSCodeWriter(options.sourceDir, options);
                 if (options.verbose)
-                    cw = new ProgressCodeWriter(cw, System.out);
+                    cw = new ProgressCodeWriter(cw, out);
                 options.getCodeModel().build(cw);
             } catch(AbortException e){
                 //error might have been reported
@@ -177,7 +197,7 @@
             }
 
             if (!options.nocompile){
-                if(!compileGeneratedClasses(receiver)){
+                if(!compileGeneratedClasses(receiver, listener)){
                     listener.message(WscompileMessages.WSCOMPILE_COMPILATION_FAILED());
                     return false;
                 }
@@ -204,7 +224,20 @@
         this.options.entityResolver = resolver;
     }
 
-    protected boolean compileGeneratedClasses(ErrorReceiver receiver){
+    /*
+     * To take care of JDK6-JDK6u3, where 2.1 API classes are not there
+     */
+    private static boolean useBootClasspath(Class clazz) {
+        try {
+            ParallelWorldClassLoader.toJarUrl(clazz.getResource('/'+clazz.getName().replace('.','/')+".class"));
+            return true;
+        } catch(Exception e) {
+            return false;
+        }
+    }
+
+
+    protected boolean compileGeneratedClasses(ErrorReceiver receiver, WsimportListener listener){
         List<String> sourceFiles = new ArrayList<String>();
 
         for (File f : options.getGeneratedFiles()) {
@@ -216,14 +249,18 @@
         if (sourceFiles.size() > 0) {
             String classDir = options.destDir.getAbsolutePath();
             String classpathString = createClasspathString();
-            String[] args = new String[5 + (options.debug ? 1 : 0)
+            boolean bootCP = useBootClasspath(EndpointReference.class) || useBootClasspath(XmlSeeAlso.class);
+            String[] args = new String[4 + (bootCP ? 1 : 0) + (options.debug ? 1 : 0)
                     + sourceFiles.size()];
             args[0] = "-d";
             args[1] = classDir;
             args[2] = "-classpath";
             args[3] = classpathString;
-            args[4] = "-Xbootclasspath/p:"+JavaCompilerHelper.getJarFile(EndpointReference.class)+File.pathSeparator+JavaCompilerHelper.getJarFile(XmlSeeAlso.class);
-            int baseIndex = 5;
+            int baseIndex = 4;
+            if (bootCP) {
+                args[baseIndex++] = "-Xbootclasspath/p:"+JavaCompilerHelper.getJarFile(EndpointReference.class)+File.pathSeparator+JavaCompilerHelper.getJarFile(XmlSeeAlso.class);
+            }
+
             if (options.debug) {
                 args[baseIndex++] = "-g";
             }
@@ -231,6 +268,15 @@
                 args[baseIndex + i] = sourceFiles.get(i);
             }
 
+            listener.message(WscompileMessages.WSIMPORT_COMPILING_CODE());
+            if(options.verbose){
+                StringBuffer argstr = new StringBuffer();
+                for(String arg:args){
+                    argstr.append(arg).append(" ");
+                }
+                listener.message("javac "+ argstr.toString());
+            }
+
             return JavaCompilerHelper.compile(args, out, receiver);
         }
         //there are no files to compile, so return true?
@@ -238,11 +284,16 @@
     }
 
     private String createClasspathString() {
-        return System.getProperty("java.class.path");
+        String classpathStr = System.getProperty("java.class.path");
+        for(String s: options.cmdlineJars) {
+            classpathStr = classpathStr+File.pathSeparator+new File(s);
+        }
+        return classpathStr;
     }
 
     protected void usage(Options options) {
         System.out.println(WscompileMessages.WSIMPORT_HELP(WSIMPORT));
+        System.out.println(WscompileMessages.WSIMPORT_USAGE_EXTENSIONS());
         System.out.println(WscompileMessages.WSIMPORT_USAGE_EXAMPLES());
     }
 }
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/document/Message.java	Tue Aug  4 09:29:59 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/document/Message.java	Tue Aug  4 09:29:59 2009
@@ -53,8 +53,11 @@
             throw new AbortException();
         }
 
-        _partsByName.put(part.getName(), part);
-        _parts.add(part);
+        if(part.getDescriptor() != null && part.getDescriptorKind() != null) {
+            _partsByName.put(part.getName(), part);
+            _parts.add(part);
+        } else
+            errorReceiver.warning(part.getLocator(), WsdlMessages.PARSING_ELEMENT_OR_TYPE_REQUIRED(part.getName()));
     }
 
     public Iterator<MessagePart> parts() {
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/document/jaxws/JAXWSBinding.java	Tue Aug  4 09:30:02 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/document/jaxws/JAXWSBinding.java	Tue Aug  4 09:30:01 2009
@@ -232,15 +232,6 @@
         this.isProvider = isProvider;
     }
 
-    /* (non-Javadoc)
-     * @see Entity#getProperty(java.lang.String)
-     */
-    public Object getProperty(String key) {
-        if(key.equals(JAXWSBindingsConstants.JAXB_BINDINGS))
-            return jaxbBindings;
-        return null;
-    }
-
     /**
      * @return Returns the methodName.
      */
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/framework/AbstractDocument.java	Tue Aug  4 09:30:04 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/framework/AbstractDocument.java	Tue Aug  4 09:30:03 2009
@@ -134,26 +134,11 @@
         }
     }
 
-    public void undefine(GloballyKnown e) {
-        Map map = getMap(e.getKind());
-        if (e.getName() == null)
-            return;
-        QName name =
-            new QName(e.getDefining().getTargetNamespaceURI(), e.getName());
-
-        if (map.containsKey(name)){
-            errReceiver.error(e.getLocator(), WsdlMessages.ENTITY_NOT_FOUND_BY_Q_NAME(e.getElementName().getLocalPart(), e.getElementName().getNamespaceURI()));
-            throw new AbortException();
-        } else{
-            map.remove(name);
-        }
-    }
-
     public GloballyKnown find(Kind k, QName name) {
         Map map = getMap(k);
         Object result = map.get(name);
         if (result == null){
-            errReceiver.error(new LocatorImpl(), WsdlMessages.ENTITY_NOT_FOUND_BY_Q_NAME(name.getLocalPart(), name.getNamespaceURI()));
+            errReceiver.error(null, WsdlMessages.ENTITY_NOT_FOUND_BY_Q_NAME(k.getName(), name, _systemId));
             throw new AbortException();
         }
         return (GloballyKnown) result;
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/AbstractReferenceFinderImpl.java	Tue Aug  4 09:30:06 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/AbstractReferenceFinderImpl.java	Tue Aug  4 09:30:06 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wsdl.parser;
 
 import com.sun.istack.internal.SAXParseException2;
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/DOMBuilder.java	Tue Aug  4 09:30:08 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/DOMBuilder.java	Tue Aug  4 09:30:08 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wsdl.parser;
 
 import com.sun.tools.internal.ws.wsdl.document.jaxws.JAXWSBindingsConstants;
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/DOMForest.java	Tue Aug  4 09:30:10 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/DOMForest.java	Tue Aug  4 09:30:10 2009
@@ -24,22 +24,23 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wsdl.parser;
 
+import com.sun.istack.internal.NotNull;
+import com.sun.tools.internal.ws.resources.WscompileMessages;
+import com.sun.tools.internal.ws.wscompile.AbortException;
+import com.sun.tools.internal.ws.wscompile.DefaultAuthenticator;
 import com.sun.tools.internal.ws.wscompile.ErrorReceiver;
 import com.sun.tools.internal.ws.wscompile.WsimportOptions;
 import com.sun.tools.internal.ws.wsdl.document.schema.SchemaConstants;
-import com.sun.tools.internal.ws.resources.WscompileMessages;
 import com.sun.tools.internal.xjc.reader.internalizer.LocatorTable;
 import com.sun.xml.internal.bind.marshaller.DataWriter;
+import com.sun.xml.internal.ws.util.JAXWSUtils;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.NodeList;
 import org.xml.sax.ContentHandler;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
+import org.xml.sax.*;
 import org.xml.sax.helpers.XMLFilterImpl;
 
 import javax.xml.parsers.DocumentBuilder;
@@ -51,17 +52,15 @@
 import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.sax.SAXResult;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
+import java.net.*;
+import java.util.*;
 
 /**
  * @author Vivek Pandey
@@ -134,10 +133,9 @@
         return inlinedSchemaElements;
     }
 
-    public Document parse(InputSource source, boolean root) throws SAXException {
+    public @NotNull Document parse(InputSource source, boolean root) throws SAXException, IOException {
         if (source.getSystemId() == null)
             throw new IllegalArgumentException();
-
         return parse(source.getSystemId(), source, root);
     }
 
@@ -148,7 +146,7 @@
      *
      * @return the parsed DOM document object.
      */
-    public Document parse(String systemId, boolean root) throws SAXException, IOException {
+    public Document parse(String systemId, boolean root) throws SAXException, IOException{
 
         systemId = normalizeSystemId(systemId);
 
@@ -179,13 +177,11 @@
      *
      * @return null if there was a parse error. otherwise non-null.
      */
-    public Document parse(String systemId, InputSource inputSource, boolean root) throws SAXException {
+    public @NotNull Document parse(String systemId, InputSource inputSource, boolean root) throws SAXException, IOException{
         Document dom = documentBuilder.newDocument();
 
         systemId = normalizeSystemId(systemId);
 
-        boolean retryMex = false;
-        Exception exception = null;
         // put into the map before growing a tree, to
         // prevent recursive reference from causing infinite loop.
         core.put(systemId, dom);
@@ -201,8 +197,70 @@
                 reader.setErrorHandler(errorReceiver);
             if (options.entityResolver != null)
                 reader.setEntityResolver(options.entityResolver);
+
+            InputStream is = null;
+            if(inputSource.getByteStream() != null){
+                is = inputSource.getByteStream();
+            }
+            if(is == null){
+                int redirects=0;
+                boolean redirect;
+                URL url = JAXWSUtils.getFileOrURL(inputSource.getSystemId());
+                URLConnection conn = url.openConnection();
+                if (conn instanceof HttpsURLConnection) {
+                    if (options.disableSSLHostnameVerification) {
+                        ((HttpsURLConnection) conn).setHostnameVerifier(new HttpClientVerifier());
+                    }
+                }
+
+                do {
+                    redirect = false;
+                    try {
+                        is = conn.getInputStream();
+                        //is = sun.net.www.protocol.http.HttpURLConnection.openConnectionCheckRedirects(conn);
+                    } catch (IOException e) {
+                        if (conn instanceof HttpURLConnection) {
+                            HttpURLConnection httpConn = ((HttpURLConnection) conn);
+                            int code = httpConn.getResponseCode();
+                            if (code == 401) {
+                                errorReceiver.error(new SAXParseException(WscompileMessages.WSIMPORT_AUTH_INFO_NEEDED(e.getMessage(), systemId, DefaultAuthenticator.defaultAuthfile), null, e));
+                                throw new AbortException();
+                            }
+                            //FOR other code we will retry with MEX
+                        }
+                        throw e;
+                    }
+
+                    //handle 302 or 303, JDK does not seem to handle 302 very well.
+                    //Need to redesign this a bit as we need to throw better error message for IOException in this case
+                    if (conn instanceof HttpURLConnection) {
+                        HttpURLConnection httpConn = ((HttpURLConnection) conn);
+                        int code = httpConn.getResponseCode();
+                        if (code == 302 || code == 303) {
+                            //retry with the value in Location header
+                            List<String> seeOther = httpConn.getHeaderFields().get("Location");
+                            if (seeOther != null && seeOther.size() > 0) {
+                                URL newurl = new URL(url, seeOther.get(0));
+                                if (!newurl.equals(url)){
+                                    errorReceiver.info(new SAXParseException(WscompileMessages.WSIMPORT_HTTP_REDIRECT(code, seeOther.get(0)), null));
+                                    url = newurl;
+                                    httpConn.disconnect();
+                                    if(redirects >= 5){
+                                        errorReceiver.error(new SAXParseException(WscompileMessages.WSIMPORT_MAX_REDIRECT_ATTEMPT(), null));
+                                        throw new AbortException();
+                                    }
+                                    conn = url.openConnection();
+                                    redirects++;
+                                    redirect = true;
+                                }
+                            }
+                        }
+                    }
+                } while (redirect);
+            }
+            inputSource.setByteStream(is);
             reader.parse(inputSource);
-             Element doc = dom.getDocumentElement();
+            Element doc = dom.getDocumentElement();
             if (doc == null) {
                 return null;
             }
@@ -211,18 +269,10 @@
                 inlinedSchemaElements.add((Element) schemas.item(i));
             }
         } catch (ParserConfigurationException e) {
-            exception = e;
-        } catch (IOException e) {
-            exception = e;
-        } catch (SAXException e) {
-            exception = e;
+            errorReceiver.error(e);
+            throw new SAXException(e.getMessage());
         }
 
-        if (exception != null) {
-            errorReceiver.error(WscompileMessages.WSIMPORT_NO_WSDL(systemId), exception);
-            core.remove(systemId);
-            rootDocuments.remove(systemId);
-        }
         return dom;
     }
 
@@ -236,6 +286,14 @@
         return externalReferences;
     }
 
+    // overide default SSL HttpClientVerifier to always return true
+    // effectively overiding Hostname client verification when using SSL
+    private static class HttpClientVerifier implements HostnameVerifier {
+        public boolean verify(String s, SSLSession sslSession) {
+            return true;
+        }
+    }
+
     public interface Handler extends ContentHandler {
         /**
          * Gets the DOM that was built.
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/DOMForestScanner.java	Tue Aug  4 09:30:13 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/DOMForestScanner.java	Tue Aug  4 09:30:12 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wsdl.parser;
 
 import com.sun.xml.internal.bind.unmarshaller.DOMScanner;
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/InternalizationLogic.java	Tue Aug  4 09:30:15 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/InternalizationLogic.java	Tue Aug  4 09:30:14 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wsdl.parser;
 
 import org.w3c.dom.Element;
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/Internalizer.java	Tue Aug  4 09:30:17 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/Internalizer.java	Tue Aug  4 09:30:17 2009
@@ -33,9 +33,14 @@
 import com.sun.tools.internal.ws.wsdl.document.jaxws.JAXWSBindingsConstants;
 import com.sun.tools.internal.xjc.util.DOMUtils;
 import com.sun.xml.internal.bind.v2.util.EditDistance;
-import com.sun.xml.internal.ws.util.JAXWSUtils;
 import com.sun.xml.internal.ws.util.DOMUtil;
-import org.w3c.dom.*;
+import com.sun.xml.internal.ws.util.JAXWSUtils;
+import org.w3c.dom.Attr;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
 import org.xml.sax.SAXParseException;
 
 import javax.xml.namespace.NamespaceContext;
@@ -45,11 +50,17 @@
 import javax.xml.xpath.XPathFactory;
 import java.net.MalformedURLException;
 import java.net.URL;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
 
 
 /**
  * Internalizes external binding declarations.
+ *
  * @author Vivek Pandey
  */
 public class Internalizer {
@@ -66,13 +77,13 @@
         this.errorReceiver = errorReceiver;
     }
 
-    public void transform(){
-        Map<Element,Node> targetNodes = new HashMap<Element,Node>();
-        for(Element jaxwsBinding : forest.outerMostBindings){
-            buildTargetNodeMap(jaxwsBinding, jaxwsBinding, targetNodes );
+    public void transform() {
+        Map<Element, Node> targetNodes = new HashMap<Element, Node>();
+        for (Element jaxwsBinding : forest.outerMostBindings) {
+            buildTargetNodeMap(jaxwsBinding, jaxwsBinding, targetNodes);
         }
-        for(Element jaxwsBinding : forest.outerMostBindings){
-            move(jaxwsBinding, targetNodes );
+        for (Element jaxwsBinding : forest.outerMostBindings) {
+            move(jaxwsBinding, targetNodes);
         }
     }
 
@@ -79,15 +90,15 @@
     /**
      * Validates attributes of a &lt;JAXWS:bindings> element.
      */
-    private void validate( Element bindings ) {
+    private void validate(Element bindings) {
         NamedNodeMap atts = bindings.getAttributes();
-        for( int i=0; i<atts.getLength(); i++ ) {
-            Attr a = (Attr)atts.item(i);
-            if( a.getNamespaceURI()!=null )
+        for (int i = 0; i < atts.getLength(); i++) {
+            Attr a = (Attr) atts.item(i);
+            if (a.getNamespaceURI() != null)
                 continue;   // all foreign namespace OK.
-            if( a.getLocalName().equals("node") )
+            if (a.getLocalName().equals("node"))
                 continue;
-            if( a.getLocalName().equals("wsdlLocation"))
+            if (a.getLocalName().equals("wsdlLocation"))
                 continue;
 
             // TODO: flag error for this undefined attribute
@@ -99,7 +110,7 @@
      * by using the inherited target node, then put
      * the result into the "result" map.
      */
-    private void buildTargetNodeMap( Element bindings, Node inheritedTarget, Map<Element, Node> result ) {
+    private void buildTargetNodeMap(Element bindings, Node inheritedTarget, Map<Element, Node> result) {
         // start by the inherited target
         Node target = inheritedTarget;
 
@@ -106,22 +117,27 @@
         validate(bindings); // validate this node
 
         // look for @wsdlLocation
-        if( bindings.getAttributeNode("wsdlLocation")!=null ) {
-            String wsdlLocation = bindings.getAttribute("wsdlLocation");
+        if (isTopLevelBinding(bindings)) {
+            String wsdlLocation;
+            if (bindings.getAttributeNode("wsdlLocation") != null) {
+                wsdlLocation = bindings.getAttribute("wsdlLocation");
 
-            try {
-                // absolutize this URI.
-                // TODO: use the URI class
-                // TODO: honor xml:base
-                wsdlLocation = new URL(new URL(forest.getSystemId(bindings.getOwnerDocument())),
-                        wsdlLocation ).toExternalForm();
-            } catch( MalformedURLException e ) {
-                wsdlLocation = JAXWSUtils.absolutize(JAXWSUtils.getFileOrURLName(wsdlLocation));
+                try {
+                    // absolutize this URI.
+                    // TODO: use the URI class
+                    // TODO: honor xml:base
+                    wsdlLocation = new URL(new URL(forest.getSystemId(bindings.getOwnerDocument())),
+                            wsdlLocation).toExternalForm();
+                } catch (MalformedURLException e) {
+                    wsdlLocation = JAXWSUtils.absolutize(JAXWSUtils.getFileOrURLName(wsdlLocation));
+                }
+            } else {
+                //the node does not have
+                wsdlLocation = forest.getFirstRootDocument();
             }
-
-            //target = wsdlDocuments.get(wsdlLocation);
             target = forest.get(wsdlLocation);
-            if(target==null) {
+
+            if (target == null) {
                 reportError(bindings, WsdlMessages.INTERNALIZER_INCORRECT_SCHEMA_REFERENCE(wsdlLocation, EditDistance.findNearest(wsdlLocation, forest.listSystemIDs())));
                 return; // abort processing this <JAXWS:bindings>
             }
@@ -134,7 +150,7 @@
         if (element != null && element.getNamespaceURI().equals(Constants.NS_WSDL) && element.getLocalName().equals("definitions")) {
             //get all schema elements
             Element type = DOMUtils.getFirstChildElement(element, Constants.NS_WSDL, "types");
-            if(type != null){
+            if (type != null) {
                 for (Element schemaElement : DOMUtils.getChildElements(type, Constants.NS_XSD, "schema")) {
                     if (!schemaElement.hasAttributeNS(Constants.NS_XMLNS, "jaxb")) {
                         schemaElement.setAttributeNS(Constants.NS_XMLNS, "xmlns:jaxb", JAXWSBindingsConstants.NS_JAXB_BINDINGS);
@@ -150,45 +166,50 @@
 
 
         boolean hasNode = true;
-        if((isJAXWSBindings(bindings) || isJAXBBindings(bindings)) && bindings.getAttributeNode("node")!=null ) {
+        if ((isJAXWSBindings(bindings) || isJAXBBindings(bindings)) && bindings.getAttributeNode("node") != null) {
             target = evaluateXPathNode(bindings, target, bindings.getAttribute("node"), new NamespaceContextImpl(bindings));
-        }else if(isJAXWSBindings(bindings) && (bindings.getAttributeNode("node")==null) && !isTopLevelBinding(bindings)) {
+        } else
+        if (isJAXWSBindings(bindings) && (bindings.getAttributeNode("node") == null) && !isTopLevelBinding(bindings)) {
             hasNode = false;
-        }else if(isGlobalBinding(bindings) && !isWSDLDefinition(target) && isTopLevelBinding(bindings.getParentNode())){
+        } else
+        if (isGlobalBinding(bindings) && !isWSDLDefinition(target) && isTopLevelBinding(bindings.getParentNode())) {
             target = getWSDLDefintionNode(bindings, target);
         }
 
         //if target is null it means the xpath evaluation has some problem,
         // just return
-        if(target == null)
+        if (target == null)
             return;
 
         // update the result map
-        if(hasNode)
-            result.put( bindings, target );
+        if (hasNode)
+            result.put(bindings, target);
 
         // look for child <JAXWS:bindings> and process them recursively
-        Element[] children = getChildElements( bindings);
+        Element[] children = getChildElements(bindings);
         for (Element child : children)
             buildTargetNodeMap(child, target, result);
     }
 
-    private Node getWSDLDefintionNode(Node bindings, Node target){
+    private Node getWSDLDefintionNode(Node bindings, Node target) {
         return evaluateXPathNode(bindings, target, "wsdl:definitions",
-            new NamespaceContext(){
-                public String getNamespaceURI(String prefix){
-                    return "http://schemas.xmlsoap.org/wsdl/";
-                }
-                public String getPrefix(String nsURI){
-                    throw new UnsupportedOperationException();
-                }
-                public Iterator getPrefixes(String namespaceURI) {
-                    throw new UnsupportedOperationException();
-                }});
+                new NamespaceContext() {
+                    public String getNamespaceURI(String prefix) {
+                        return "http://schemas.xmlsoap.org/wsdl/";
+                    }
+
+                    public String getPrefix(String nsURI) {
+                        throw new UnsupportedOperationException();
+                    }
+
+                    public Iterator getPrefixes(String namespaceURI) {
+                        throw new UnsupportedOperationException();
+                    }
+                });
     }
 
-    private boolean isWSDLDefinition(Node target){
-        if(target == null)
+    private boolean isWSDLDefinition(Node target) {
+        if (target == null)
             return false;
         String localName = target.getLocalName();
         String nsURI = target.getNamespaceURI();
@@ -195,43 +216,41 @@
         return fixNull(localName).equals("definitions") && fixNull(nsURI).equals("http://schemas.xmlsoap.org/wsdl/");
     }
 
-    private boolean isTopLevelBinding(Node node){
-        if(node instanceof Document)
-            node = ((Document)node).getDocumentElement();
-        return ((node != null) && (((Element)node).getAttributeNode("wsdlLocation") != null));
+    private boolean isTopLevelBinding(Node node) {
+        return node.getOwnerDocument().getDocumentElement() == node;
     }
 
-    private boolean isJAXWSBindings(Node bindings){
+    private boolean isJAXWSBindings(Node bindings) {
         return (bindings.getNamespaceURI().equals(JAXWSBindingsConstants.NS_JAXWS_BINDINGS) && bindings.getLocalName().equals("bindings"));
     }
 
-    private boolean isJAXBBindings(Node bindings){
+    private boolean isJAXBBindings(Node bindings) {
         return (bindings.getNamespaceURI().equals(JAXWSBindingsConstants.NS_JAXB_BINDINGS) && bindings.getLocalName().equals("bindings"));
     }
 
-    private boolean isGlobalBinding(Node bindings){
-        if(bindings.getNamespaceURI() == null){
+    private boolean isGlobalBinding(Node bindings) {
+        if (bindings.getNamespaceURI() == null) {
             errorReceiver.warning(forest.locatorTable.getStartLocation((Element) bindings), WsdlMessages.INVALID_CUSTOMIZATION_NAMESPACE(bindings.getLocalName()));
             return false;
         }
-        return  (bindings.getNamespaceURI().equals(JAXWSBindingsConstants.NS_JAXWS_BINDINGS) &&
+        return (bindings.getNamespaceURI().equals(JAXWSBindingsConstants.NS_JAXWS_BINDINGS) &&
                 (bindings.getLocalName().equals("package") ||
-                bindings.getLocalName().equals("enableAsyncMapping") ||
-                bindings.getLocalName().equals("enableAdditionalSOAPHeaderMapping") ||
-                bindings.getLocalName().equals("enableWrapperStyle") ||
-                bindings.getLocalName().equals("enableMIMEContent")));
+                        bindings.getLocalName().equals("enableAsyncMapping") ||
+                        bindings.getLocalName().equals("enableAdditionalSOAPHeaderMapping") ||
+                        bindings.getLocalName().equals("enableWrapperStyle") ||
+                        bindings.getLocalName().equals("enableMIMEContent")));
     }
 
     private static Element[] getChildElements(Element parent) {
         ArrayList<Element> a = new ArrayList<Element>();
         NodeList children = parent.getChildNodes();
-        for( int i=0; i<children.getLength(); i++ ) {
+        for (int i = 0; i < children.getLength(); i++) {
             Node item = children.item(i);
-            if(!(item instanceof Element ))     continue;
+            if (!(item instanceof Element)) continue;
 
-            if(JAXWSBindingsConstants.NS_JAXWS_BINDINGS.equals(item.getNamespaceURI()) ||
+            if (JAXWSBindingsConstants.NS_JAXWS_BINDINGS.equals(item.getNamespaceURI()) ||
                     JAXWSBindingsConstants.NS_JAXB_BINDINGS.equals(item.getNamespaceURI()))
-                a.add((Element)item);
+                a.add((Element) item);
         }
         return a.toArray(new Element[a.size()]);
     }
@@ -240,24 +259,24 @@
         NodeList nlst;
         try {
             xpath.setNamespaceContext(namespaceContext);
-            nlst = (NodeList)xpath.evaluate(expression, target, XPathConstants.NODESET);
+            nlst = (NodeList) xpath.evaluate(expression, target, XPathConstants.NODESET);
         } catch (XPathExpressionException e) {
             reportError((Element) bindings, WsdlMessages.INTERNALIZER_X_PATH_EVALUATION_ERROR(e.getMessage()), e);
             return null; // abort processing this <jaxb:bindings>
         }
 
-        if( nlst.getLength()==0 ) {
+        if (nlst.getLength() == 0) {
             reportError((Element) bindings, WsdlMessages.INTERNALIZER_X_PATH_EVALUATES_TO_NO_TARGET(expression));
             return null; // abort
         }
 
-        if( nlst.getLength()!=1 ) {
+        if (nlst.getLength() != 1) {
             reportError((Element) bindings, WsdlMessages.INTERNALIZER_X_PATH_EVAULATES_TO_TOO_MANY_TARGETS(expression, nlst.getLength()));
             return null; // abort
         }
 
         Node rnode = nlst.item(0);
-        if(!(rnode instanceof Element )) {
+        if (!(rnode instanceof Element)) {
             reportError((Element) bindings, WsdlMessages.INTERNALIZER_X_PATH_EVALUATES_TO_NON_ELEMENT(expression));
             return null; // abort
         }
@@ -267,9 +286,9 @@
     /**
      * Moves JAXWS customizations under their respective target nodes.
      */
-    private void move( Element bindings, Map<Element, Node> targetNodes ) {
+    private void move(Element bindings, Map<Element, Node> targetNodes) {
         Node target = targetNodes.get(bindings);
-        if(target==null)
+        if (target == null)
             // this must be the result of an error on the external binding.
             // recover from the error by ignoring this node
             return;
@@ -277,27 +296,27 @@
         Element[] children = DOMUtils.getChildElements(bindings);
 
         for (Element item : children) {
-            if ("bindings".equals(item.getLocalName())){
-            // process child <jaxws:bindings> recursively
+            if ("bindings".equals(item.getLocalName())) {
+                // process child <jaxws:bindings> recursively
                 move(item, targetNodes);
-            }else if(isGlobalBinding(item)){
+            } else if (isGlobalBinding(item)) {
                 target = targetNodes.get(item);
-                moveUnder(item,(Element)target);
-            }else {
+                moveUnder(item, (Element) target);
+            } else {
                 if (!(target instanceof Element)) {
                     return; // abort
                 }
                 // move this node under the target
-                moveUnder(item,(Element)target);
+                moveUnder(item, (Element) target);
             }
         }
     }
 
-    private boolean isJAXBBindingElement(Element e){
+    private boolean isJAXBBindingElement(Element e) {
         return fixNull(e.getNamespaceURI()).equals(JAXWSBindingsConstants.NS_JAXB_BINDINGS);
     }
 
-    private boolean isJAXWSBindingElement(Element e){
+    private boolean isJAXWSBindingElement(Element e) {
         return fixNull(e.getNamespaceURI()).equals(JAXWSBindingsConstants.NS_JAXWS_BINDINGS);
     }
 
@@ -304,25 +323,22 @@
     /**
      * Moves the "decl" node under the "target" node.
      *
-     * @param decl
-     *      A JAXWS customization element (e.g., &lt;JAXWS:class>)
-     *
-     * @param target
-     *      XML wsdl element under which the declaration should move.
-     *      For example, &lt;xs:element>
+     * @param decl   A JAXWS customization element (e.g., &lt;JAXWS:class>)
+     * @param target XML wsdl element under which the declaration should move.
+     *               For example, &lt;xs:element>
      */
-    private void moveUnder( Element decl, Element target ) {
+    private void moveUnder(Element decl, Element target) {
 
         //if there is @node on decl and has a child element jaxb:bindings, move it under the target
         //Element jaxb = getJAXBBindingElement(decl);
-        if(isJAXBBindingElement(decl)){
+        if (isJAXBBindingElement(decl)) {
             //add jaxb namespace declaration
-            if(!target.hasAttributeNS(Constants.NS_XMLNS, "jaxb")){
+            if (!target.hasAttributeNS(Constants.NS_XMLNS, "jaxb")) {
                 target.setAttributeNS(Constants.NS_XMLNS, "xmlns:jaxb", JAXWSBindingsConstants.NS_JAXB_BINDINGS);
             }
 
             //add jaxb:bindings version info. Lets put it to 1.0, may need to change latter
-            if(!target.hasAttributeNS(JAXWSBindingsConstants.NS_JAXB_BINDINGS, "version")){
+            if (!target.hasAttributeNS(JAXWSBindingsConstants.NS_JAXB_BINDINGS, "version")) {
                 target.setAttributeNS(JAXWSBindingsConstants.NS_JAXB_BINDINGS, "jaxb:version", JAXWSBindingsConstants.JAXB_BINDING_VERSION);
             }
 
@@ -334,7 +350,7 @@
             // it can't support user-defined extensions. This needs more careful thought.
 
             //JAXB doesn't allow writing jaxb:extensionbindingPrefix anywhere other than root element so lets write only on <xs:schema>
-            if(target.getLocalName().equals("schema") && target.getNamespaceURI().equals(Constants.NS_XSD)&& !target.hasAttributeNS(JAXWSBindingsConstants.NS_JAXB_BINDINGS, "extensionBindingPrefixes")){
+            if (target.getLocalName().equals("schema") && target.getNamespaceURI().equals(Constants.NS_XSD) && !target.hasAttributeNS(JAXWSBindingsConstants.NS_JAXB_BINDINGS, "extensionBindingPrefixes")) {
                 target.setAttributeNS(JAXWSBindingsConstants.NS_JAXB_BINDINGS, "jaxb:extensionBindingPrefixes", "xjc");
                 target.setAttributeNS(Constants.NS_XMLNS, "xmlns:xjc", JAXWSBindingsConstants.NS_XJC_BINDINGS);
             }
@@ -342,9 +358,9 @@
             //insert xs:annotation/xs:appinfo where in jaxb:binding will be put
             target = refineSchemaTarget(target);
             copyInscopeNSAttributes(decl);
-        }else if(isJAXWSBindingElement(decl)){
+        } else if (isJAXWSBindingElement(decl)) {
             //add jaxb namespace declaration
-            if(!target.hasAttributeNS(Constants.NS_XMLNS, "JAXWS")){
+            if (!target.hasAttributeNS(Constants.NS_XMLNS, "JAXWS")) {
                 target.setAttributeNS(Constants.NS_XMLNS, "xmlns:JAXWS", JAXWSBindingsConstants.NS_JAXWS_BINDINGS);
             }
 
@@ -351,59 +367,59 @@
             //insert xs:annotation/xs:appinfo where in jaxb:binding will be put
             target = refineWSDLTarget(target);
             copyInscopeNSAttributes(decl);
-        }else{
+        } else {
             return;
         }
 
         // finally move the declaration to the target node.
-        if( target.getOwnerDocument()!=decl.getOwnerDocument() ) {
+        if (target.getOwnerDocument() != decl.getOwnerDocument()) {
             // if they belong to different DOM documents, we need to clone them
-            decl = (Element)target.getOwnerDocument().importNode(decl,true);
+            decl = (Element) target.getOwnerDocument().importNode(decl, true);
 
         }
 
-        target.appendChild( decl );
+        target.appendChild(decl);
     }
 
     /**
-     *  Copy in-scope namespace declarations of the decl node
-     *  to the decl node itself so that this move won't change
-     *  the in-scope namespace bindings.
+     * Copy in-scope namespace declarations of the decl node
+     * to the decl node itself so that this move won't change
+     * the in-scope namespace bindings.
      */
-    private void copyInscopeNSAttributes(Element e){
+    private void copyInscopeNSAttributes(Element e) {
         Element p = e;
         Set<String> inscopes = new HashSet<String>();
-        while(true) {
+        while (true) {
             NamedNodeMap atts = p.getAttributes();
-            for( int i=0; i<atts.getLength(); i++ ) {
-                Attr a = (Attr)atts.item(i);
-                if( Constants.NS_XMLNS.equals(a.getNamespaceURI()) ) {
+            for (int i = 0; i < atts.getLength(); i++) {
+                Attr a = (Attr) atts.item(i);
+                if (Constants.NS_XMLNS.equals(a.getNamespaceURI())) {
                     String prefix;
-                    if( a.getName().indexOf(':')==-1 )  prefix = "";
-                    else                                prefix = a.getLocalName();
+                    if (a.getName().indexOf(':') == -1) prefix = "";
+                    else prefix = a.getLocalName();
 
-                    if( inscopes.add(prefix) && p!=e ) {
+                    if (inscopes.add(prefix) && p != e) {
                         // if this is the first time we see this namespace bindings,
                         // copy the declaration.
                         // if p==decl, there's no need to. Note that
                         // we want to add prefix to inscopes even if p==Decl
 
-                        e.setAttributeNodeNS( (Attr)a.cloneNode(true) );
+                        e.setAttributeNodeNS((Attr) a.cloneNode(true));
                     }
                 }
             }
 
-            if( p.getParentNode() instanceof Document )
+            if (p.getParentNode() instanceof Document)
                 break;
 
-            p = (Element)p.getParentNode();
+            p = (Element) p.getParentNode();
         }
 
-        if( !inscopes.contains("") ) {
+        if (!inscopes.contains("")) {
             // if the default namespace was undeclared in the context of decl,
             // it must be explicitly set to "" since the new environment might
             // have a different default namespace URI.
-            e.setAttributeNS(Constants.NS_XMLNS,"xmlns","");
+            e.setAttributeNS(Constants.NS_XMLNS, "xmlns", "");
         }
     }
 
@@ -410,15 +426,15 @@
     public Element refineSchemaTarget(Element target) {
         // look for existing xs:annotation
         Element annotation = DOMUtils.getFirstChildElement(target, Constants.NS_XSD, "annotation");
-        if(annotation==null)
+        if (annotation == null)
             // none exists. need to make one
-            annotation = insertXMLSchemaElement( target, "annotation" );
+            annotation = insertXMLSchemaElement(target, "annotation");
 
         // then look for appinfo
-        Element appinfo = DOMUtils.getFirstChildElement(annotation, Constants.NS_XSD, "appinfo" );
-        if(appinfo==null)
+        Element appinfo = DOMUtils.getFirstChildElement(annotation, Constants.NS_XSD, "appinfo");
+        if (appinfo == null)
             // none exists. need to make one
-            appinfo = insertXMLSchemaElement( annotation, "appinfo" );
+            appinfo = insertXMLSchemaElement(annotation, "appinfo");
 
         return appinfo;
     }
@@ -426,9 +442,9 @@
     public Element refineWSDLTarget(Element target) {
         // look for existing xs:annotation
         Element JAXWSBindings = DOMUtils.getFirstChildElement(target, JAXWSBindingsConstants.NS_JAXWS_BINDINGS, "bindings");
-        if(JAXWSBindings==null)
+        if (JAXWSBindings == null)
             // none exists. need to make one
-            JAXWSBindings = insertJAXWSBindingsElement(target, "bindings" );
+            JAXWSBindings = insertJAXWSBindingsElement(target, "bindings");
         return JAXWSBindings;
     }
 
@@ -436,63 +452,63 @@
      * Creates a new XML Schema element of the given local name
      * and insert it as the first child of the given parent node.
      *
-     * @return
-     *      Newly create element.
+     * @return Newly create element.
      */
-    private Element insertXMLSchemaElement( Element parent, String localName ) {
+    private Element insertXMLSchemaElement(Element parent, String localName) {
         // use the same prefix as the parent node to avoid modifying
         // the namespace binding.
         String qname = parent.getTagName();
         int idx = qname.indexOf(':');
-        if(idx==-1)     qname = localName;
-        else            qname = qname.substring(0,idx+1)+localName;
+        if (idx == -1) qname = localName;
+        else qname = qname.substring(0, idx + 1) + localName;
 
-        Element child = parent.getOwnerDocument().createElementNS( Constants.NS_XSD, qname );
+        Element child = parent.getOwnerDocument().createElementNS(Constants.NS_XSD, qname);
 
         NodeList children = parent.getChildNodes();
 
-        if( children.getLength()==0 )
+        if (children.getLength() == 0)
             parent.appendChild(child);
         else
-            parent.insertBefore( child, children.item(0) );
+            parent.insertBefore(child, children.item(0));
 
         return child;
     }
 
-    private Element insertJAXWSBindingsElement( Element parent, String localName ) {
-        String qname = "JAXWS:"+localName;
+    private Element insertJAXWSBindingsElement(Element parent, String localName) {
+        String qname = "JAXWS:" + localName;
 
-        Element child = parent.getOwnerDocument().createElementNS(JAXWSBindingsConstants.NS_JAXWS_BINDINGS, qname );
+        Element child = parent.getOwnerDocument().createElementNS(JAXWSBindingsConstants.NS_JAXWS_BINDINGS, qname);
 
         NodeList children = parent.getChildNodes();
 
-        if( children.getLength()==0 )
+        if (children.getLength() == 0)
             parent.appendChild(child);
         else
-            parent.insertBefore( child, children.item(0) );
+            parent.insertBefore(child, children.item(0));
 
         return child;
     }
 
-    private static @NotNull String fixNull(@Nullable String s) {
-        if(s==null) return "";
-        else        return s;
+    private static
+    @NotNull
+    String fixNull(@Nullable String s) {
+        if (s == null) return "";
+        else return s;
     }
 
 
-    private void reportError( Element errorSource, String formattedMsg ) {
-        reportError( errorSource, formattedMsg, null );
+    private void reportError(Element errorSource, String formattedMsg) {
+        reportError(errorSource, formattedMsg, null);
     }
 
-    private void reportError( Element errorSource,
-        String formattedMsg, Exception nestedException ) {
+    private void reportError(Element errorSource,
+                             String formattedMsg, Exception nestedException) {
 
-        SAXParseException e = new SAXParseException2( formattedMsg,
-            forest.locatorTable.getStartLocation(errorSource),
-            nestedException );
+        SAXParseException e = new SAXParseException2(formattedMsg,
+                forest.locatorTable.getStartLocation(errorSource),
+                nestedException);
         errorReceiver.error(e);
     }
 
 
-
 }
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/MemberSubmissionAddressingExtensionHandler.java	Tue Aug  4 09:30:19 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/MemberSubmissionAddressingExtensionHandler.java	Tue Aug  4 09:30:19 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: MemberSubmissionAddressingExtensionHandler.java,v 1.1.2.6 2006/10/31 19:52:07 vivekp Exp $
- */
 
 package com.sun.tools.internal.ws.wsdl.parser;
 
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/MetadataFinder.java	Tue Aug  4 09:30:22 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/MetadataFinder.java	Tue Aug  4 09:30:21 2009
@@ -24,9 +24,11 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wsdl.parser;
 
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
+import com.sun.tools.internal.ws.resources.WscompileMessages;
 import com.sun.tools.internal.ws.resources.WsdlMessages;
 import com.sun.tools.internal.ws.wscompile.ErrorReceiver;
 import com.sun.tools.internal.ws.wscompile.WsimportOptions;
@@ -38,8 +40,6 @@
 import com.sun.xml.internal.ws.api.wsdl.parser.ServiceDescriptor;
 import com.sun.xml.internal.ws.util.DOMUtil;
 import com.sun.xml.internal.ws.util.ServiceFinder;
-import com.sun.istack.internal.Nullable;
-import com.sun.istack.internal.NotNull;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
@@ -46,16 +46,17 @@
 import org.w3c.dom.NodeList;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.helpers.LocatorImpl;
+import org.xml.sax.SAXParseException;
 
 import javax.xml.transform.Source;
 import javax.xml.transform.dom.DOMSource;
+import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.HashSet;
-import java.io.IOException;
 
 /**
  * @author Vivek Pandey
@@ -72,36 +73,47 @@
 
     }
 
-    public void parseWSDL() throws SAXException, IOException {
+    public void parseWSDL(){
         // parse source grammars
         for (InputSource value : options.getWSDLs()) {
             String systemID = value.getSystemId();
             errorReceiver.pollAbort();
 
+            Document dom ;
+            Element doc = null;
+
+            try {
             //if there is entity resolver use it
             if (options.entityResolver != null)
                 value = options.entityResolver.resolveEntity(null, systemID);
             if (value == null)
                 value = new InputSource(systemID);
+                dom = parse(value, true);
 
+                doc = dom.getDocumentElement();
+                if (doc == null) {
+                    continue;
+                }
+                //if its not a WSDL document, retry with MEX
+                if (doc.getNamespaceURI() == null || !doc.getNamespaceURI().equals(WSDLConstants.NS_WSDL) || !doc.getLocalName().equals("definitions")) {
+                    throw new SAXParseException(WsdlMessages.INVALID_WSDL(systemID,
+                        com.sun.xml.internal.ws.wsdl.parser.WSDLConstants.QNAME_DEFINITIONS, doc.getNodeName(), locatorTable.getStartLocation(doc).getLineNumber()), locatorTable.getStartLocation(doc));
+                }
+            } catch(FileNotFoundException e){
+                errorReceiver.error(WsdlMessages.FILE_NOT_FOUND(systemID), e);
+                return;
+            } catch (IOException e) {
+                doc = getFromMetadataResolver(systemID, e);
+            } catch (SAXParseException e) {
+                doc = getFromMetadataResolver(systemID, e);
+            } catch (SAXException e) {
+                doc = getFromMetadataResolver(systemID, e);
+            }
 
-            Document dom = parse(value, true);
-            if (dom == null)
-                continue;
-            Element doc = dom.getDocumentElement();
             if (doc == null) {
                 continue;
             }
-            //if its not a WSDL document, retry with MEX
-            if (doc.getNamespaceURI() == null || !doc.getNamespaceURI().equals(WSDLConstants.NS_WSDL) || !doc.getLocalName().equals("definitions")) {
-                core.remove(systemID);
-                rootDocuments.remove(systemID);
-                errorReceiver.warning(locatorTable.getStartLocation(doc), WsdlMessages.INVALID_WSDL_WITH_DOOC(systemID, "{" + fixNull(doc.getNamespaceURI()) + "}" + doc.getLocalName()));
-                dom = getFromMetadataResolver(systemID);
-                if(dom == null)
-                    continue;
-                doc = dom.getDocumentElement();
-            }
+
             NodeList schemas = doc.getElementsByTagNameNS(SchemaConstants.NS_XSD, "schema");
             for (int i = 0; i < schemas.getLength(); i++) {
                 if(!inlinedSchemaElements.contains(schemas.item(i)))
@@ -137,7 +149,7 @@
             Document doc = get(location);
             if(doc!=null){
                 Element definition = doc.getDocumentElement();
-                if(definition == null)
+                if(definition == null || definition.getLocalName() == null || definition.getNamespaceURI() == null)
                     continue;
                 if(definition.getNamespaceURI().equals(WSDLConstants.NS_WSDL) && definition.getLocalName().equals("definitions")){
                     rootWsdls.add(location);
@@ -151,17 +163,17 @@
                 }
             }
         }
+        //no wsdl with wsdl:service found, throw error
+        if(rootWSDL == null){
+            StringBuffer strbuf = new StringBuffer();
+            for(String str : rootWsdls){
+                strbuf.append(str);
+                strbuf.append('\n');
+            }
+            errorReceiver.error(null, WsdlMessages.FAILED_NOSERVICE(strbuf.toString()));
+        }
     }
 
-
-
-
-    private String fixNull(String s) {
-        if (s == null) return "";
-        else return s;
-    }
-
-
     /*
     * If source and target namespace are also passed in,
     * then if the mex resolver is found and it cannot get
@@ -170,10 +182,9 @@
     * This behavior should only happen when trying a
     * mex request first.
     */
-    private Document getFromMetadataResolver(String systemId) {
-
+    private @Nullable Element getFromMetadataResolver(String systemId, Exception ex) {
         //try MEX
-        MetaDataResolver resolver = null;
+        MetaDataResolver resolver;
         ServiceDescriptor serviceDescriptor = null;
         for (MetadataResolverFactory resolverFactory : ServiceFinder.find(MetadataResolverFactory.class)) {
             resolver = resolverFactory.metadataResolver(options.entityResolver);
@@ -188,14 +199,15 @@
         }
 
         if (serviceDescriptor != null) {
+            errorReceiver.warning(new SAXParseException(WsdlMessages.TRY_WITH_MEX(ex.getMessage()), null, ex));
             return parseMetadata(systemId, serviceDescriptor);
         } else {
-            errorReceiver.error(new LocatorImpl(), WsdlMessages.PARSING_UNABLE_TO_GET_METADATA(systemId));
+            errorReceiver.error(null, WsdlMessages.PARSING_UNABLE_TO_GET_METADATA(ex.getMessage(), WscompileMessages.WSIMPORT_NO_WSDL(systemId)), ex);
         }
         return null;
     }
 
-    private Document parseMetadata(String systemId, ServiceDescriptor serviceDescriptor) {
+    private Element parseMetadata(@NotNull String systemId, @NotNull ServiceDescriptor serviceDescriptor) {
         List<? extends Source> mexWsdls = serviceDescriptor.getWSDLs();
         List<? extends Source> mexSchemas = serviceDescriptor.getSchemas();
         Document root = null;
@@ -220,8 +232,8 @@
                     }
                 }
                 NodeList nl = doc.getDocumentElement().getElementsByTagNameNS(WSDLConstants.NS_WSDL, "import");
-                if (nl.getLength() > 0) {
-                    Element imp = (Element) nl.item(0);
+                for(int i = 0; i < nl.getLength(); i++){
+                    Element imp = (Element) nl.item(i);
                     String loc = imp.getAttribute("location");
                     if (loc != null) {
                         if (!externalReferences.contains(loc))
@@ -247,6 +259,6 @@
             //TODO:handle SAXSource
             //TODO:handler StreamSource
         }
-        return root;
+        return root.getDocumentElement();
     }
 }
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/NamespaceContextImpl.java	Tue Aug  4 09:30:24 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/NamespaceContextImpl.java	Tue Aug  4 09:30:24 2009
@@ -2,7 +2,7 @@
  * reserved comment block
  * DO NOT REMOVE OR ALTER!
  */
-/*
+ /*
  * Portions Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
@@ -29,6 +29,22 @@
  * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
  */
 
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.sun.tools.internal.ws.wsdl.parser;
 
 import com.sun.xml.internal.bind.v2.WellKnownNamespace;
@@ -47,21 +63,6 @@
         this.e = e;
     }
 
-    /*
-     * Copyright 1999-2004 The Apache Software Foundation.
-     *
-     * Licensed under the Apache License, Version 2.0 (the "License");
-     * you may not use this file except in compliance with the License.
-     * You may obtain a copy of the License at
-     *
-     *     http://www.apache.org/licenses/LICENSE-2.0
-     *
-     * Unless required by applicable law or agreed to in writing, software
-     * distributed under the License is distributed on an "AS IS" BASIS,
-     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     * See the License for the specific language governing permissions and
-     * limitations under the License.
-     */
     public String getNamespaceURI(String prefix) {
         Node parent = e;
         String namespace = null;
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/VersionChecker.java	Tue Aug  4 09:30:26 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/VersionChecker.java	Tue Aug  4 09:30:26 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wsdl.parser;
 
 import com.sun.tools.internal.ws.resources.WsdlMessages;
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/W3CAddressingExtensionHandler.java	Tue Aug  4 09:30:28 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/W3CAddressingExtensionHandler.java	Tue Aug  4 09:30:28 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: W3CAddressingExtensionHandler.java,v 1.1.2.9 2007/02/06 00:33:38 kohsuke Exp $
- */
 
 package com.sun.tools.internal.ws.wsdl.parser;
 
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/WSDLInternalizationLogic.java	Tue Aug  4 09:30:31 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/WSDLInternalizationLogic.java	Tue Aug  4 09:30:30 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wsdl.parser;
 
 import com.sun.tools.internal.ws.wsdl.document.WSDLConstants;
@@ -56,9 +55,14 @@
                     //TODO: add support for importing schema using wsdl:import
                 }
                 return atts.getValue("location");
-            }else if(SchemaConstants.NS_XSD.equals(nsURI) && "import".equals(localName)){
+            }
+            /*
+            We don't need to do this anymore, JAXB handles the schema imports, includes etc.
+
+            else if(SchemaConstants.NS_XSD.equals(nsURI) && "import".equals(localName)){
                 return atts.getValue("schemaLocation");
             }
+            */
             return null;
         }
     }
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/WSDLParser.java	Tue Aug  4 09:30:33 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/WSDLParser.java	Tue Aug  4 09:30:32 2009
@@ -29,9 +29,8 @@
 import com.sun.tools.internal.ws.api.wsdl.TWSDLExtensionHandler;
 import com.sun.tools.internal.ws.resources.WsdlMessages;
 import com.sun.tools.internal.ws.util.xml.XmlUtil;
-import com.sun.tools.internal.ws.wscompile.ErrorReceiver;
-import com.sun.tools.internal.ws.wscompile.WsimportOptions;
 import com.sun.tools.internal.ws.wscompile.ErrorReceiverFilter;
+import com.sun.tools.internal.ws.wscompile.WsimportOptions;
 import com.sun.tools.internal.ws.wsdl.document.Binding;
 import com.sun.tools.internal.ws.wsdl.document.BindingFault;
 import com.sun.tools.internal.ws.wsdl.document.BindingInput;
@@ -68,11 +67,11 @@
 import org.xml.sax.Locator;
 import org.xml.sax.SAXException;
 
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
-import java.io.IOException;
 
 /**
  * A parser for WSDL documents. This parser is used only at the tool time.
@@ -135,7 +134,7 @@
         // parse external binding files
         for (InputSource value : options.getWSDLBindings()) {
             errReceiver.pollAbort();
-            Document root = forest.parse(value, true); // TODO: I think this should be false - KK
+            Document root = forest.parse(value, false);
             if(root==null)       continue;   // error must have been reported
             Element binding = root.getDocumentElement();
             if (!fixNull(binding.getNamespaceURI()).equals(JAXWSBindingsConstants.NS_JAXWS_BINDINGS)
@@ -168,7 +167,7 @@
     private WSDLDocument buildWSDLDocument(){
         /**
          * Currently we are working off first WSDL document
-         * TODO: add support of creating WSDLDocument from collection of WSDL documents
+         * TODO: add support of creating WSDLDocument from fromjava.collection of WSDL documents
          */
 
         String location = forest.getRootWSDL();
--- old/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/WhitespaceStripper.java	Tue Aug  4 09:30:35 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/WhitespaceStripper.java	Tue Aug  4 09:30:35 2009
@@ -24,7 +24,6 @@
  */
 
 
-
 package com.sun.tools.internal.ws.wsdl.parser;
 
 import com.sun.xml.internal.bind.WhiteSpaceProcessor;
--- old/src/share/classes/com/sun/tools/internal/xjc/Driver.java	Tue Aug  4 09:30:37 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/Driver.java	Tue Aug  4 09:30:37 2009
@@ -24,6 +24,7 @@
  */
 package com.sun.tools.internal.xjc;
 
+import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -101,7 +102,7 @@
 
     private static void _main( String[] args ) throws Exception {
         try {
-            System.exit(run( args, System.err, System.out ));
+            System.exit(run( args, System.out, System.out ));
         } catch (BadCommandLineException e) {
             // there was an error in the command line.
             // print usage and abort.
@@ -240,6 +241,8 @@
                 listener.message(Messages.format(Messages.PARSING_SCHEMA));
             }
 
+            final boolean[] hadWarning = new boolean[1];
+
             ErrorReceiver receiver = new ErrorReceiverFilter(listener) {
                 public void info(SAXParseException exception) {
                     if(opt.verbose)
@@ -246,6 +249,7 @@
                         super.info(exception);
                 }
                 public void warning(SAXParseException exception) {
+                    hadWarning[0] = true;
                     if(!opt.quiet)
                         super.warning(exception);
                 }
@@ -367,6 +371,15 @@
                 assert false;
             }
 
+            if(opt.debugMode) {
+                try {
+                    new FileOutputStream(new File(opt.targetDir,hadWarning[0]?"hadWarning":"noWarning")).close();
+                } catch (IOException e) {
+                    receiver.error(e);
+                    return -1;
+                }
+            }
+
             return 0;
         } catch( StackOverflowError e ) {
             if(opt.verbose)
--- old/src/share/classes/com/sun/tools/internal/xjc/Language.java	Tue Aug  4 09:30:40 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/Language.java	Tue Aug  4 09:30:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/xjc/MessageBundle.properties	Tue Aug  4 09:30:42 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/MessageBundle.properties	Tue Aug  4 09:30:41 2009
@@ -24,20 +24,20 @@
 #
 
 ConsoleErrorReporter.UnknownLocation = \
-	unknown location
-	
+        unknown location
+
 ConsoleErrorReporter.LineXOfY = \
-	\ \ line {0} of {1}
+        \ \ line {0} of {1}
 
 ConsoleErrorReporter.UnknownFile = \
-	unknown file
-	
+        unknown file
+
 Driver.Private.Usage = \
 Usage: xjc [-options ...] <schema file/URL/dir/jar> ... [-b <bindinfo>] ...\n\
 If dir is specified, all schema files in it will be compiled.\n\
 If jar is specified, /META-INF/sun-jaxb.episode binding file will be compiled.\n\
 Options:\n\
-\ \ -debug             :  run in the debug mode\n\
+\ \ -debug             :  run in debug mode (includes -verbose)\n\
 \ \ -nv                :  do not perform strict validation of the input schema(s)\n\
 \ \ -extension         :  allow vendor extensions - do not strictly follow the\n\
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Compatibility Rules and App E.2 from the JAXB Spec\n\
@@ -106,27 +106,30 @@
 Driver.AddonUsage = \nExtensions:
 
 Driver.ExperimentalLanguageWarning = \
-	Are you trying to compile {0}? Support for {0} is experimental. \
-	You may enable it by using the {1} option.
+        Are you trying to compile {0}? Support for {0} is experimental. \
+        You may enable it by using the {1} option.
 
 Driver.NonExistentDir = \
     cowardly refuses to write to a non-existent directory "{0}"
-	
+
 Driver.MissingRuntimePackageName = \
-	the -use-runtime option is missing a package name
-	
+        the -use-runtime option is missing a package name
+
 Driver.MissingModeOperand = \
-	the -mode option is missing an operand
-	
+        the -mode option is missing an operand
+
 Driver.MissingCompatibilityOperand = \
-	the -compatibility option is missing an operand
+        the -compatibility option is missing an operand
 
+Driver.MissingOperand = \
+        an operand is missing
+
 Driver.MissingProxyHost = \
-	either the -host option is missing an operand \n\
+        either the -host option is missing an operand \n\
         or -port was specified but not -host
-	
+
 Driver.MissingProxyPort = \
-	either the -port option is missing an operand \n\
+        either the -port option is missing an operand \n\
         or -host was specified but not -port
 
 Driver.ILLEGAL_PROXY = \
@@ -145,77 +148,80 @@
     "{0}" is not a valid proxy format. The format is [user[:password]@]proxyHost:proxyPort
 
 Driver.UnrecognizedMode = \
-	unrecognized mode {0}
+        unrecognized mode {0}
 
 Driver.UnrecognizedParameter = \
-	unrecognized parameter {0}
-	
+        unrecognized parameter {0}
+
 Driver.MissingGrammar = \
-	grammar is not specified
+        grammar is not specified
 
 Driver.NotABindingFile = \
-	not an external binding file. The root element must be '{'http://java.sun.com/xml/ns/jaxb'}'bindings but it is '{'{0}'}'{1}
-		
+        not an external binding file. The root element must be '{'http://java.sun.com/xml/ns/jaxb'}'bindings but it is '{'{0}'}'{1}
+
 Driver.ParsingSchema = \
-	parsing a schema...
-	
+        parsing a schema...
+
 Driver.ParseFailed = \
-	Failed to parse a schema.
+        Failed to parse a schema.
 
 Driver.StackOverflow = \
-	Stack overflow. Either you are compiling a large schema that requires more resource, or \
-	XJC has a bug. First, please extend the stack size by using the -Xss JVM option. If this \
-	doesn'''t solve the problem, please use the -debug option to obtain the stack trace and \
-	contact Sun. 
-		
+        Stack overflow. Either you are compiling a large schema that requires more resources, or \
+        XJC has a bug. First, please extend the stack size by using the -Xss JVM option. If this \
+        doesn'''t solve the problem, please use the -debug option to obtain the stack trace and \
+        contact Sun.
+
 Driver.CompilingSchema = \
-	compiling a schema...
+        compiling a schema...
 
 Driver.FailedToGenerateCode = \
-	Failed to produce code.
+        Failed to produce code.
 
-# DO NOT localize the JAXB 2.1.3 in JDK string - it is a token for an ant <replaceFilter>	
+# DO NOT localize the JAXB 2.1.10 string - it is a token for an ant <replaceFilter>
 Driver.FilePrologComment = \
-	This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.3 in JDK \n\
-	See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> \n\
-	Any modifications to this file will be lost upon recompilation of the source schema. \n\
-	Generated on: {0} \n
+        This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 \n\
+        See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> \n\
+        Any modifications to this file will be lost upon recompilation of the source schema. \n\
+        Generated on: {0} \n
 
 Driver.Version = \
-	xjc version "JAXB 2.1.3" \n\
-	JavaTM Architecture for XML Binding(JAXB) Reference Implementation, (build JAXB 2.1.3 in JDK)	
+        xjc version "JAXB 2.1.10" \n\
+        JavaTM Architecture for XML Binding(JAXB) Reference Implementation, (build JAXB 2.1.10)
 
-Driver.BuildID = JAXB 2.1.3 in JDK
-	
+Driver.BuildID = JAXB 2.1.10
+
+# for JDK integration - include version in source zip
+jaxb.jdk.version=2.1.10
+
 # see java.text.SimpleDateFormat for format syntax
 Driver.DateFormat = \
-	yyyy.MM.dd
+        yyyy.MM.dd
 
 # see java.text.SimpleDateFormat for format syntax
 Driver.TimeFormat = \
-	hh:mm:ss a z
+        hh:mm:ss a z
 
-# as in: "generated on <date> at <time>"	
+# as in: "generated on <date> at <time>"
 Driver.At = \
-	at
+        at
 
 Driver.ErrorMessage = \
-	[ERROR] {0}
+        [ERROR] {0}
 
 Driver.WarningMessage = \
-	[WARNING] {0}
+        [WARNING] {0}
 
 Driver.InfoMessage = \
-	[INFO] {0}
+        [INFO] {0}
 
 ModelLoader.TooManySchema = \
-	Too many schema files for this schema language. Compile one file at a time.
+        Too many schema files for this schema language. Compile one file at a time.
 
 ModelLoader.BindingFileNotSupportedForRNC = \
     External binding files are not supported for the RELAX NG compact syntax.
 
 Driver.DefaultVersion = \
-	Defaulting the version to JAXB 2.0
+        Defaulting the version to JAXB 2.0
 
 Driver.DefaultPackageWarning = \
     Default Java package specified.  You will not be able to access the generated code from classes in any other package.
@@ -227,10 +233,10 @@
     Failed to parse "{0}": {1}
 
 Driver.NotAFileNorURL = \
-    "{0}" is neither a file name nor an URL
+    "{0}" is neither a file name nor a URL
 
 FIELD_RENDERER_CONFLICT = \
-    "-{0}" and "-{1}" are mutually exclusive since both affect the code generation 
+    "-{0}" and "-{1}" are mutually exclusive since both affect the code generation
 
 NAME_CONVERTER_CONFLICT = \
     "-{0}" and "-{1}" are mutually exclusive since both affect the code generation
@@ -241,4 +247,3 @@
 PLUGIN_LOAD_FAILURE = \
     Failure to load a plugin: "{0}". Use the system property ''-Dcom.sun.tools.internal.xjc.Options.findServices=true'' to \
     diagnose it further
- 
--- old/src/share/classes/com/sun/tools/internal/xjc/ModelLoader.java	Tue Aug  4 09:30:44 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/ModelLoader.java	Tue Aug  4 09:30:44 2009
@@ -35,8 +35,8 @@
 import com.sun.tools.internal.xjc.reader.internalizer.DOMForest;
 import com.sun.tools.internal.xjc.reader.internalizer.DOMForestScanner;
 import com.sun.tools.internal.xjc.reader.internalizer.InternalizationLogic;
-import com.sun.tools.internal.xjc.reader.internalizer.VersionChecker;
 import com.sun.tools.internal.xjc.reader.internalizer.SCDBasedBindingSet;
+import com.sun.tools.internal.xjc.reader.internalizer.VersionChecker;
 import com.sun.tools.internal.xjc.reader.relaxng.RELAXNGCompiler;
 import com.sun.tools.internal.xjc.reader.relaxng.RELAXNGInternalizationLogic;
 import com.sun.tools.internal.xjc.reader.xmlschema.BGMBuilder;
@@ -489,6 +489,9 @@
 
     /**
      * Parses a {@link DOMForest} into a {@link XSSchemaSet}.
+     *
+     * @return
+     *      null if the parsing failed.
      */
     public XSSchemaSet createXSOM(DOMForest forest, SCDBasedBindingSet scdBasedBindingSet) throws SAXException {
         // set up other parameters to XSOMParser
@@ -504,7 +507,8 @@
 
         XSSchemaSet result = reader.getResult();
 
-        scdBasedBindingSet.apply(result,errorReceiver);
+        if(result!=null)
+            scdBasedBindingSet.apply(result,errorReceiver);
 
         return result;
     }
--- old/src/share/classes/com/sun/tools/internal/xjc/Options.java	Tue Aug  4 09:30:46 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/Options.java	Tue Aug  4 09:30:46 2009
@@ -33,6 +33,7 @@
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.lang.reflect.Array;
+import java.lang.reflect.InvocationTargetException;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLClassLoader;
@@ -47,6 +48,7 @@
 import java.util.regex.Pattern;
 
 import com.sun.codemodel.internal.CodeWriter;
+import com.sun.codemodel.internal.JPackage;
 import com.sun.codemodel.internal.writer.FileCodeWriter;
 import com.sun.codemodel.internal.writer.PrologCodeWriter;
 import com.sun.org.apache.xml.internal.resolver.CatalogManager;
@@ -129,10 +131,32 @@
     /**
      * Generates output for the specified version of the runtime.
      */
-    public SpecVersion target = SpecVersion.V2_1;
+    public SpecVersion target = SpecVersion.LATEST;
 
+    private boolean is2_2 = true;
 
-    /** Target direcoty when producing files. */
+    public Options() {
+        if (is2_2) {
+            try {
+                Class.forName("javax.xml.bind.JAXBPermission");
+            } catch (ClassNotFoundException cnfe) {
+                is2_2 = false;
+            }
+            if (!is2_2) {
+                target = SpecVersion.V2_1;
+            } else {
+                target = SpecVersion.LATEST;
+            }
+        }
+    }
+
+    /**
+     * Target directory when producing files.
+     * <p>
+     * This field is not used when XJC is driven through the XJC API.
+     * Plugins that need to generate extra files should do so by using
+     * {@link JPackage#addResourceFile(JResourceFile)}.
+     */
     public File targetDir = new File(".");
 
     /**
@@ -437,12 +461,15 @@
      */
     public int parseArgument( String[] args, int i ) throws BadCommandLineException {
         if (args[i].equals("-classpath") || args[i].equals("-cp")) {
-            File file = new File(requireArgument(args[i],args,++i));
-            try {
-                classpaths.add(file.toURL());
-            } catch (MalformedURLException e) {
-                throw new BadCommandLineException(
-                    Messages.format(Messages.NOT_A_VALID_FILENAME,file),e);
+            String a = requireArgument(args[i], args, ++i);
+            for (String p : a.split(File.pathSeparator)) {
+                File file = new File(p);
+                try {
+                    classpaths.add(file.toURL());
+                } catch (MalformedURLException e) {
+                    throw new BadCommandLineException(
+                        Messages.format(Messages.NOT_A_VALID_FILENAME,file),e);
+                }
             }
             return 2;
         }
@@ -760,6 +787,11 @@
         if( schemaLanguage==null )
             schemaLanguage = guessSchemaLanguage();
 
+//        if(target==SpecVersion.V2_2 && !isExtensionMode())
+//            throw new BadCommandLineException(
+//                "Currently 2.2 is still not finalized yet, so using it requires the -extension switch." +
+//                "NOTE THAT 2.2 SPEC MAY CHANGE BEFORE IT BECOMES FINAL.");
+
         if(pluginLoadFailure!=null)
             throw new BadCommandLineException(
                 Messages.format(Messages.PLUGIN_LOAD_FAILURE,pluginLoadFailure));
@@ -768,7 +800,7 @@
     /**
      * Finds the <tt>META-INF/sun-jaxb.episode</tt> file to add as a binding customization.
      */
-    private void scanEpisodeFile(File jar) throws BadCommandLineException {
+    public void scanEpisodeFile(File jar) throws BadCommandLineException {
         try {
             URLClassLoader ucl = new URLClassLoader(new URL[]{jar.toURL()});
             Enumeration<URL> resources = ucl.findResources("META-INF/sun-jaxb.episode");
@@ -787,18 +819,21 @@
      * Guesses the schema language.
      */
     public Language guessSchemaLanguage() {
+
         // otherwise, use the file extension.
         // not a good solution, but very easy.
-        String name = grammars.get(0).getSystemId().toLowerCase();
+        if ((grammars != null) && (grammars.size() > 0)) {
+            String name = grammars.get(0).getSystemId().toLowerCase();
 
-        if (name.endsWith(".rng"))
-            return Language.RELAXNG;
-        if (name.endsWith(".rnc"))
-            return Language.RELAXNG_COMPACT;
-        if (name.endsWith(".dtd"))
-            return Language.DTD;
-        if (name.endsWith(".wsdl"))
-            return Language.WSDL;
+            if (name.endsWith(".rng"))
+                return Language.RELAXNG;
+            if (name.endsWith(".rnc"))
+                return Language.RELAXNG_COMPACT;
+            if (name.endsWith(".dtd"))
+                return Language.DTD;
+            if (name.endsWith(".wsdl"))
+                return Language.WSDL;
+        }
 
         // by default, assume XML Schema
         return Language.XMLSCHEMA;
@@ -853,6 +888,36 @@
         // if true, print debug output
         final boolean debug = com.sun.tools.internal.xjc.util.Util.getSystemProperty(Options.class,"findServices")!=null;
 
+        // if we are running on Mustang or Dolphin, use ServiceLoader
+        // so that we can take advantage of JSR-277 module system.
+        try {
+            Class<?> serviceLoader = Class.forName("java.util.ServiceLoader");
+            if(debug)
+                System.out.println("Using java.util.ServiceLoader");
+            Iterable<T> itr = (Iterable<T>)serviceLoader.getMethod("load",Class.class,ClassLoader.class).invoke(null,clazz,classLoader);
+            List<T> r = new ArrayList<T>();
+            for (T t : itr)
+                r.add(t);
+            return r.toArray((T[])Array.newInstance(clazz,r.size()));
+        } catch (ClassNotFoundException e) {
+            // fall through
+        } catch (IllegalAccessException e) {
+            Error x = new IllegalAccessError();
+            x.initCause(e);
+            throw x;
+        } catch (InvocationTargetException e) {
+            Throwable x = e.getTargetException();
+            if (x instanceof RuntimeException)
+                throw (RuntimeException) x;
+            if (x instanceof Error)
+                throw (Error) x;
+            throw new Error(x);
+        } catch (NoSuchMethodException e) {
+            Error x = new NoSuchMethodError();
+            x.initCause(e);
+            throw x;
+        }
+
         String serviceId = "META-INF/services/" + clazz.getName();
 
         // used to avoid creating the same instance twice
--- old/src/share/classes/com/sun/tools/internal/xjc/ProgressCodeWriter.java	Tue Aug  4 09:30:49 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/ProgressCodeWriter.java	Tue Aug  4 09:30:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc;
 
 import java.io.File;
--- old/src/share/classes/com/sun/tools/internal/xjc/SchemaCache.java	Tue Aug  4 09:30:51 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/SchemaCache.java	Tue Aug  4 09:30:50 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/tools/internal/xjc/XJCListener.java	Tue Aug  4 09:30:53 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/XJCListener.java	Tue Aug  4 09:30:53 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc;
 
 import java.io.PrintStream;
--- old/src/share/classes/com/sun/tools/internal/xjc/addon/at_generated/PluginImpl.java	Tue Aug  4 09:30:55 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/addon/at_generated/PluginImpl.java	Tue Aug  4 09:30:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.addon.at_generated;
 
 import java.text.SimpleDateFormat;
--- old/src/share/classes/com/sun/tools/internal/xjc/addon/code_injector/Const.java	Tue Aug  4 09:30:57 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/addon/code_injector/Const.java	Tue Aug  4 09:30:57 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.addon.code_injector;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/xjc/addon/code_injector/PluginImpl.java	Tue Aug  4 09:30:59 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/addon/code_injector/PluginImpl.java	Tue Aug  4 09:30:59 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.addon.code_injector;
 
 import java.util.Collections;
--- old/src/share/classes/com/sun/tools/internal/xjc/addon/episode/PluginImpl.java	Tue Aug  4 09:31:02 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/addon/episode/PluginImpl.java	Tue Aug  4 09:31:01 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.addon.episode;
 
 import java.io.File;
--- old/src/share/classes/com/sun/tools/internal/xjc/addon/episode/package-info.java	Tue Aug  4 09:31:04 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/addon/episode/package-info.java	Tue Aug  4 09:31:04 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 @XmlNamespace(Const.JAXB_NSURI)
 package com.sun.tools.internal.xjc.addon.episode;
 
--- old/src/share/classes/com/sun/tools/internal/xjc/api/ClassNameAllocator.java	Tue Aug  4 09:31:06 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/ClassNameAllocator.java	Tue Aug  4 09:31:06 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/xjc/api/J2SJAXBModel.java	Tue Aug  4 09:31:08 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/J2SJAXBModel.java	Tue Aug  4 09:31:08 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/Reference.java	Tue Aug  4 09:31:10 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/Reference.java	Tue Aug  4 09:31:10 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api;
 
 import com.sun.mirror.apt.AnnotationProcessorEnvironment;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/S2JJAXBModel.java	Tue Aug  4 09:31:13 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/S2JJAXBModel.java	Tue Aug  4 09:31:12 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api;
 
 import java.util.Collection;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/SchemaCompiler.java	Tue Aug  4 09:31:15 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/SchemaCompiler.java	Tue Aug  4 09:31:14 2009
@@ -238,6 +238,10 @@
      * then tweak settings on it. The updated settings will be used when the
      * {@link #bind()} method is invoked.
      *
+     * <p>
+     * The returned {@link Options} object is useful for example to specify
+     * command-line arguments.
+     *
      * @since 2.0.2
      * @deprecated
      *      This method is not really "deprecated" (in the sense of being removed
--- old/src/share/classes/com/sun/tools/internal/xjc/api/SpecVersion.java	Tue Aug  4 09:31:17 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/SpecVersion.java	Tue Aug  4 09:31:17 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api;
 
 /**
@@ -30,7 +31,7 @@
  * @author Kohsuke Kawaguchi
  */
 public enum SpecVersion {
-    V2_0, V2_1;
+    V2_0, V2_1, V2_2;
 
     /**
      * Returns true if this version is equal or later than the given one.
@@ -40,7 +41,7 @@
     }
 
     /**
-     * Parses "2.0" and "2.1" into the {@link SpecVersion} object.
+     * Parses "2.0", "2.1", and "2.2" into the {@link SpecVersion} object.
      *
      * @return null for parsing failure.
      */
@@ -47,11 +48,12 @@
     public static SpecVersion parse(String token) {
         if(token.equals("2.0"))
             return V2_0;
-        else
         if(token.equals("2.1"))
             return V2_1;
+        if(token.equals("2.2"))
+            return V2_2;
         return null;
     }
 
-    public static final SpecVersion LATEST = V2_1;
+    public static final SpecVersion LATEST = V2_2;
 }
--- old/src/share/classes/com/sun/tools/internal/xjc/api/TypeAndAnnotation.java	Tue Aug  4 09:31:19 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/TypeAndAnnotation.java	Tue Aug  4 09:31:19 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api;
 
 import com.sun.codemodel.internal.JAnnotatable;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/j2s/JAXBModelImpl.java	Tue Aug  4 09:31:21 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/j2s/JAXBModelImpl.java	Tue Aug  4 09:31:21 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.impl.j2s;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/j2s/JavaCompilerImpl.java	Tue Aug  4 09:31:24 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/j2s/JavaCompilerImpl.java	Tue Aug  4 09:31:23 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.impl.j2s;
 
 import java.util.Collection;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/AbstractMappingImpl.java	Tue Aug  4 09:31:26 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/AbstractMappingImpl.java	Tue Aug  4 09:31:26 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.impl.s2j;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/BeanMappingImpl.java	Tue Aug  4 09:31:28 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/BeanMappingImpl.java	Tue Aug  4 09:31:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.impl.s2j;
 
 import java.util.List;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/DowngradingErrorHandler.java	Tue Aug  4 09:31:30 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/DowngradingErrorHandler.java	Tue Aug  4 09:31:30 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.impl.s2j;
 
 import org.xml.sax.ErrorHandler;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/ElementAdapter.java	Tue Aug  4 09:31:33 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/ElementAdapter.java	Tue Aug  4 09:31:32 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.impl.s2j;
 
 import javax.xml.bind.JAXBElement;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/ElementCollectionAdapter.java	Tue Aug  4 09:31:35 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/ElementCollectionAdapter.java	Tue Aug  4 09:31:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.impl.s2j;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/ElementMappingImpl.java	Tue Aug  4 09:31:37 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/ElementMappingImpl.java	Tue Aug  4 09:31:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.impl.s2j;
 
 import java.util.List;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/ElementSingleAdapter.java	Tue Aug  4 09:31:39 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/ElementSingleAdapter.java	Tue Aug  4 09:31:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.impl.s2j;
 
 import javax.xml.bind.JAXBElement;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/PropertyImpl.java	Tue Aug  4 09:31:41 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/PropertyImpl.java	Tue Aug  4 09:31:41 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.impl.s2j;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/SchemaCompilerImpl.java	Tue Aug  4 09:31:44 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/SchemaCompilerImpl.java	Tue Aug  4 09:31:43 2009
@@ -201,6 +201,11 @@
 //        if(!forest.checkSchemaCorrectness(this))
 //            return null;
 
+        // parse all the binding files given via XJC -b options.
+        // this also takes care of the binding files given in the -episode option.
+        for (InputSource is : opts.getBindFiles())
+            parseSchema(is);
+
         // internalization
         SCDBasedBindingSet scdBasedBindingSet = forest.transform(opts.isExtensionMode());
 
@@ -283,7 +288,7 @@
 
     static {
         try {
-            NO_CORRECTNESS_CHECK = Boolean.getBoolean(SchemaCompilerImpl.class+".noCorrectnessCheck");
+            NO_CORRECTNESS_CHECK = Boolean.getBoolean(SchemaCompilerImpl.class.getName()+".noCorrectnessCheck");
         } catch( Throwable t) {
             // ignore
         }
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/TypeAndAnnotationImpl.java	Tue Aug  4 09:31:46 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/impl/s2j/TypeAndAnnotationImpl.java	Tue Aug  4 09:31:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.impl.s2j;
 
 import javax.xml.bind.annotation.XmlAttachmentRef;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/package.html	Tue Aug  4 09:31:48 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/package.html	Tue Aug  4 09:31:48 2009
@@ -58,4 +58,4 @@
 <h2>Implementation Note</h2>
 <p>
 This package shouldn't contain any implementation code.
-</body></html> 
+</body></html>
--- old/src/share/classes/com/sun/tools/internal/xjc/api/util/APTClassLoader.java	Tue Aug  4 09:31:50 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/util/APTClassLoader.java	Tue Aug  4 09:31:50 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.util;
 
 import java.io.ByteArrayOutputStream;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/util/FilerCodeWriter.java	Tue Aug  4 09:31:52 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/util/FilerCodeWriter.java	Tue Aug  4 09:31:52 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.util;
 
 import java.io.File;
--- old/src/share/classes/com/sun/tools/internal/xjc/api/util/Messages.properties	Tue Aug  4 09:31:55 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/util/Messages.properties	Tue Aug  4 09:31:54 2009
@@ -25,5 +25,3 @@
 
 TOOLS_JAR_NOT_FOUND = \
     JDK''s tools.jar was not found in {0}. Usually this means you are running JRE, not JDK. Please use the java command in JDK 5.0 or later (not JRE.)
- 
- 
--- old/src/share/classes/com/sun/tools/internal/xjc/api/util/ToolsJarNotFoundException.java	Tue Aug  4 09:31:57 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/api/util/ToolsJarNotFoundException.java	Tue Aug  4 09:31:56 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.api.util;
 
 import java.io.File;
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/annotation/spec/XmlElementRefWriter.java	Tue Aug  4 09:31:59 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/annotation/spec/XmlElementRefWriter.java	Tue Aug  4 09:31:59 2009
@@ -41,4 +41,6 @@
 
     XmlElementRefWriter namespace(String value);
 
+    XmlElementRefWriter required(boolean value);
+
 }
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/BeanGenerator.java	Tue Aug  4 09:32:01 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/BeanGenerator.java	Tue Aug  4 09:32:01 2009
@@ -101,6 +101,7 @@
 import com.sun.xml.internal.bind.v2.runtime.SwaRefAdapter;
 import com.sun.xml.internal.xsom.XmlString;
 import com.sun.istack.internal.NotNull;
+import com.sun.tools.internal.xjc.model.CReferencePropertyInfo;
 
 /**
  * Generates fields and accessors.
@@ -456,7 +457,6 @@
     private void generateClassBody( ClassOutlineImpl cc ) {
         CClassInfo target = cc.target;
 
-
         // if serialization support is turned on, generate
         // [RESULT]
         // class ... implements Serializable {
@@ -509,7 +509,10 @@
         if(target.isOrdered()) {
             for(CPropertyInfo p : target.getProperties() ) {
                 if( ! (p instanceof CAttributePropertyInfo )) {
-                    xtw.propOrder(p.getName(false));
+                    if (!( (p instanceof CReferencePropertyInfo) &&
+                           ((CReferencePropertyInfo)p).isDummy())) {
+                        xtw.propOrder(p.getName(false));
+                    }
                 }
             }
         } else {
@@ -730,10 +733,9 @@
             // none is specified. use the default factory
             fr = model.options.getFieldRendererFactory().getDefault();
 
-        FieldOutline field = fr.generate(cc,prop);
+        FieldOutline field = fr.generate(cc, prop);
         fields.put(prop,field);
 
-
         return field;
     }
 
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/DualObjectFactoryGenerator.java	Tue Aug  4 09:32:03 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/DualObjectFactoryGenerator.java	Tue Aug  4 09:32:03 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.generator.bean;
 
 import com.sun.codemodel.internal.JDefinedClass;
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/ElementOutlineImpl.java	Tue Aug  4 09:32:06 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/ElementOutlineImpl.java	Tue Aug  4 09:32:05 2009
@@ -22,8 +22,10 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.generator.bean;
 
+
 import javax.xml.bind.JAXBElement;
 import javax.xml.namespace.QName;
 
@@ -31,6 +33,7 @@
 import com.sun.codemodel.internal.JCodeModel;
 import com.sun.codemodel.internal.JExpr;
 import com.sun.codemodel.internal.JExpression;
+import com.sun.codemodel.internal.JFieldVar;
 import com.sun.codemodel.internal.JInvocation;
 import com.sun.codemodel.internal.JMethod;
 import com.sun.codemodel.internal.JMod;
@@ -71,15 +74,24 @@
             if(ei.getScope()!=null)
                 scope = parent.getClazz(ei.getScope()).implRef;
             JExpression scopeClass = scope==null?JExpr._null():scope.dotclass();
+            JFieldVar valField = implClass.field(JMod.PROTECTED|JMod.FINAL|JMod.STATIC,QName.class,"NAME",createQName(cm,ei.getElementName()));
 
             // take this opportunity to generate a constructor in the element class
             JMethod cons = implClass.constructor(JMod.PUBLIC);
             cons.body().invoke("super")
-                .arg(implClass.field(JMod.PROTECTED|JMod.FINAL|JMod.STATIC,QName.class,"NAME",createQName(cm,ei.getElementName())))
+                .arg(valField)
                 .arg(declaredType)
                 .arg(scopeClass)
                 .arg(cons.param(implType,"value"));
 
+            // generate no-arg constructor in the element class (bug #391; section 5.6.2 in JAXB spec 2.1)
+            JMethod noArgCons = implClass.constructor(JMod.PUBLIC);
+            noArgCons.body().invoke("super")
+                .arg(valField)
+                .arg(declaredType)
+                .arg(scopeClass)
+                .arg(JExpr._null());
+
         }
     }
 
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/ImplStructureStrategy.java	Tue Aug  4 09:32:08 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/ImplStructureStrategy.java	Tue Aug  4 09:32:08 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /*
  * Use is subject to the license terms.
  */
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/MessageBundle.properties	Tue Aug  4 09:32:10 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/MessageBundle.properties	Tue Aug  4 09:32:10 2009
@@ -24,14 +24,14 @@
 #
 
 METHOD_COLLISION = \
-	The "{0}" method is defined on both "{1}" and "{2}" and is causing a collision.
+        The "{0}" method is defined on both "{1}" and "{2}" and is causing a collision.
 
 ERR_UNUSABLE_NAME = \
-	Cannot derive a valid Java identifier from "{0}". Specify a customization to change the name.
+        Cannot derive a valid Java identifier from "{0}". Specify a customization to change the name.
 
 ERR_NAME_COLLISION = \
-	Type-safe enum has more than one values that share the same name "{0}". \
-	Use a typesafeEnumMemberName customization to resolve this conflict.
+        Type-safe enum has more than one values that share the same name "{0}". \
+        Use a typesafeEnumMemberName customization to resolve this conflict.
 
 ILLEGAL_CONSTRUCTOR_PARAM = \
     Illegal constructor parameter {0}
@@ -40,5 +40,4 @@
     Two declarations cause a collision in the ObjectFactory class.
 
 OBJECT_FACTORY_CONFLICT_RELATED = \
-    (Related to above error) This is the other declaration.   
- 
+    (Related to above error) This is the other declaration.
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/MethodWriter.java	Tue Aug  4 09:32:12 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/MethodWriter.java	Tue Aug  4 09:32:12 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /*
  * Use is subject to the license terms.
  */
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/ObjectFactoryGeneratorImpl.java	Tue Aug  4 09:32:15 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/ObjectFactoryGeneratorImpl.java	Tue Aug  4 09:32:14 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.generator.bean;
 
 import java.util.Collection;
@@ -29,6 +30,7 @@
 import java.util.Map;
 
 import javax.xml.bind.JAXBException;
+import javax.xml.bind.annotation.XmlInlineBinaryData;
 import javax.xml.namespace.QName;
 
 import com.sun.codemodel.internal.JClass;
@@ -157,7 +159,7 @@
 
         JClass scope=null;
         if(ei.getScope()!=null)
-            scope = outline.getClazz(ei.getScope()).implRef;
+            scope = outline.getClazz(ei.getScope()).implClass;
 
 
         JMethod m;
@@ -244,7 +246,10 @@
         if(ei.getDefaultValue()!=null)
             xemw.defaultValue(ei.getDefaultValue());
 
-        // if the element is adapter, put that annotation on the factory method
+        if(ei.getProperty().inlineBinaryData())
+            m.annotate(XmlInlineBinaryData.class);
+
+                    // if the element is adapter, put that annotation on the factory method
         outline.generateAdapterIfNecessary(ei.getProperty(),m);
     }
 
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/PackageOutlineImpl.java	Tue Aug  4 09:32:17 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/PackageOutlineImpl.java	Tue Aug  4 09:32:16 2009
@@ -216,6 +216,11 @@
      * Iterate through the hash map looking for the namespace used
      * most frequently.  Ties are arbitrarily broken by the order
      * in which the map keys are iterated over.
+     *
+     * <p>
+     * Because JAX-WS often reassigns the "" namespace URI,
+     * and when that happens it unintentionally also renames (normally
+     * unqualified) local elements, prefer non-"" URI when there's a tie.
      */
     private String getMostUsedURI(HashMap<String, Integer> map) {
         String mostPopular = null;
@@ -228,7 +233,7 @@
                 mostPopular = uri;
                 count = uriCount;
             } else {
-                if (uriCount > count) {
+                if (uriCount > count || (uriCount==count && mostPopular.equals(""))) {
                     mostPopular = uri;
                     count = uriCount;
                 }
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/PrivateObjectFactoryGenerator.java	Tue Aug  4 09:32:19 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/PrivateObjectFactoryGenerator.java	Tue Aug  4 09:32:19 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.generator.bean;
 
 import javax.xml.bind.JAXBContext;
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/PublicObjectFactoryGenerator.java	Tue Aug  4 09:32:21 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/PublicObjectFactoryGenerator.java	Tue Aug  4 09:32:21 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.generator.bean;
 
 import com.sun.codemodel.internal.JPackage;
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/AbstractField.java	Tue Aug  4 09:32:23 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/AbstractField.java	Tue Aug  4 09:32:23 2009
@@ -33,6 +33,7 @@
 import javax.xml.bind.annotation.XmlMixed;
 import javax.xml.bind.annotation.XmlNsForm;
 import javax.xml.bind.annotation.XmlValue;
+import javax.xml.bind.annotation.XmlInlineBinaryData;
 import javax.xml.namespace.QName;
 
 import com.sun.codemodel.internal.JAnnotatable;
@@ -67,6 +68,9 @@
 import com.sun.tools.internal.xjc.outline.FieldAccessor;
 import com.sun.tools.internal.xjc.outline.FieldOutline;
 import com.sun.tools.internal.xjc.reader.TypeUtil;
+import com.sun.tools.internal.xjc.Options;
+import com.sun.tools.internal.xjc.api.SpecVersion;
+import com.sun.xml.internal.bind.api.impl.NameConverter;
 import com.sun.xml.internal.bind.v2.TODO;
 
 /**
@@ -148,6 +152,9 @@
             field.annotate2(XmlSchemaTypeWriter.class)
                 .name(st.getLocalPart())
                 .namespace(st.getNamespaceURI());
+
+        if(prop.inlineBinaryData())
+            field.annotate(XmlInlineBinaryData.class);
     }
 
     private void annotateReference(JAnnotatable field) {
@@ -165,6 +172,8 @@
             refw.name(e.getElementName().getLocalPart())
                 .namespace(e.getElementName().getNamespaceURI())
                 .type(e.getType().toType(outline.parent(),IMPLEMENTATION));
+            if(getOptions().target.isLaterThan(SpecVersion.V2_2))
+                refw.required(rp.isRequired());
         } else
         if(elements.size()>1) {
             XmlElementRefsWriter refsw = field.annotate2(XmlElementRefsWriter.class);
@@ -173,6 +182,8 @@
                 refw.name(e.getElementName().getLocalPart())
                     .namespace(e.getElementName().getNamespaceURI())
                     .type(e.getType().toType(outline.parent(),IMPLEMENTATION));
+                if(getOptions().target.isLaterThan(SpecVersion.V2_2))
+                    refw.required(rp.isRequired());
             }
         }
 
@@ -244,9 +255,15 @@
 
         // these values are used to determine how to optimize the generated annotation
         XmlNsForm formDefault = parent()._package().getElementFormDefault();
-        String mostUsedURI = parent()._package().getMostUsedNamespaceURI();
         String propName = prop.getName(false);
 
+        String enclosingTypeNS;
+
+        if(parent().target.getTypeName()==null)
+            enclosingTypeNS = parent()._package().getMostUsedNamespaceURI();
+        else
+            enclosingTypeNS = parent().target.getTypeName().getNamespaceURI();
+
         // generate the name property?
         String generatedName = ctype.getTagName().getLocalPart();
         if(!generatedName.equals(propName)) {
@@ -256,7 +273,7 @@
 
         // generate the namespace property?
         String generatedNS = ctype.getTagName().getNamespaceURI();
-        if (((formDefault == XmlNsForm.QUALIFIED) && !generatedNS.equals(mostUsedURI)) ||
+        if (((formDefault == XmlNsForm.QUALIFIED) && !generatedNS.equals(enclosingTypeNS)) ||
                 ((formDefault == XmlNsForm.UNQUALIFIED) && !generatedNS.equals(""))) {
             if(xew == null) xew = getXew(checkWrapper, field);
             xew.namespace(generatedNS);
@@ -281,7 +298,7 @@
         // when generating code for 1.4, the runtime can't infer that ArrayList<Foo> derives
         // from Collection<Foo> (because List isn't parameterized), so always expclitly
         // generate @XmlElement(type=...)
-        if( !jtype.equals(exposedType) || (parent().parent().getModel().options.runtime14 && prop.isCollection())) {
+        if( !jtype.equals(exposedType) || (getOptions().runtime14 && prop.isCollection())) {
             if(xew == null) xew = getXew(checkWrapper, field);
             xew.type(jtype);
         }
@@ -300,6 +317,13 @@
         }
     }
 
+    /**
+     * Gets the {@link Options} in the current compilation context.
+     */
+    protected final Options getOptions() {
+        return parent().parent().getModel().options;
+    }
+
     // ugly hack to lazily create
     private XmlElementsWriter xesw = null;
 
@@ -330,8 +354,9 @@
         final String generatedName = attName.getLocalPart();
         final String generatedNS = attName.getNamespaceURI();
 
+        // Issue 570; always force generating name="" when do it when globalBindings underscoreBinding is set to non default value
         // generate name property?
-        if(!generatedName.equals(ap.getName(false))) {
+        if(!generatedName.equals(ap.getName(false)) || (outline.parent().getModel().getNameConverter() != NameConverter.standard)) {
             xaw.name(generatedName);
         }
 
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/AbstractFieldWithVar.java	Tue Aug  4 09:32:26 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/AbstractFieldWithVar.java	Tue Aug  4 09:32:25 2009
@@ -31,6 +31,7 @@
 import com.sun.codemodel.internal.JMod;
 import com.sun.codemodel.internal.JType;
 import com.sun.codemodel.internal.JVar;
+import com.sun.tools.internal.xjc.api.SpecVersion;
 import com.sun.tools.internal.xjc.generator.bean.ClassOutlineImpl;
 import com.sun.tools.internal.xjc.model.CPropertyInfo;
 
@@ -71,7 +72,13 @@
      * {@code isXXXX} as the method name.
      */
     protected String getGetterMethod() {
-        return (getFieldType().boxify().getPrimitiveType()==codeModel.BOOLEAN?"is":"get")+prop.getName(true);
+        if (getOptions().target.isLaterThan(SpecVersion.V2_2)) {
+            return ((getFieldType().isPrimitive() &&
+                     getFieldType().boxify().getPrimitiveType()==codeModel.BOOLEAN) ?
+                         "is":"get") + prop.getName(true);
+        } else {
+            return (getFieldType().boxify().getPrimitiveType()==codeModel.BOOLEAN?"is":"get")+prop.getName(true);
+        }
     }
 
     /**
@@ -98,7 +105,11 @@
         protected final JFieldRef $ref;
 
         public final void toRawValue(JBlock block, JVar $var) {
-            block.assign($var,$target.invoke(getGetterMethod()));
+            if (getOptions().target.isLaterThan(SpecVersion.V2_2)) {
+                block.assign($var,$target.invoke(getGetterMethod()));
+            } else {
+                block.assign($var,$target.invoke(getGetterMethod()));
+            }
         }
 
         public final void fromRawValue(JBlock block, String uniqueName, JExpression $var) {
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/AbstractListField.java	Tue Aug  4 09:32:28 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/AbstractListField.java	Tue Aug  4 09:32:28 2009
@@ -45,7 +45,7 @@
  * its underlying data structure.
  *
  * <p>
- * For performance reaons, the actual list object used to store
+ * For performance reasons, the actual list object used to store
  * data is lazily created.
  *
  * @author
@@ -136,7 +136,7 @@
             .assign(field,newCoreList());
     }
 
-    public final JType getRawType() {
+    public JType getRawType() {
         return codeModel.ref(List.class).narrow(exposedType.boxify());
     }
 
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/ArrayField.java	Tue Aug  4 09:32:30 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/ArrayField.java	Tue Aug  4 09:32:30 2009
@@ -24,10 +24,8 @@
  */
 package com.sun.tools.internal.xjc.generator.bean.field;
 
-import java.util.ArrayList;
-import java.util.Arrays;
+import com.sun.codemodel.internal.JAssignmentTarget;
 import java.util.List;
-
 import com.sun.codemodel.internal.JBlock;
 import com.sun.codemodel.internal.JClass;
 import com.sun.codemodel.internal.JExpr;
@@ -34,6 +32,7 @@
 import com.sun.codemodel.internal.JExpression;
 import com.sun.codemodel.internal.JForLoop;
 import com.sun.codemodel.internal.JMethod;
+import com.sun.codemodel.internal.JMod;
 import com.sun.codemodel.internal.JOp;
 import com.sun.codemodel.internal.JType;
 import com.sun.codemodel.internal.JVar;
@@ -69,12 +68,18 @@
         }
 
         public void toRawValue(JBlock block, JVar $var) {
-            block.assign($var,codeModel.ref(Arrays.class).staticInvoke("asList").arg($target.invoke($getAll)));
+            block.assign($var,$target.invoke($getAll));
         }
 
         public void fromRawValue(JBlock block, String uniqueName, JExpression $var) {
-            block.invoke($target,$setAll).arg($var.invoke("toArray").arg(JExpr.newArray(exposedType,$var.invoke("size"))));
+            block.invoke($target,$setAll).arg($var);
         }
+
+        @Override
+        public JExpression hasSetValue() {
+            return field.ne(JExpr._null()).cand(field.ref("length").gt(JExpr.lit(0)));
+        }
+
     }
 
     private JMethod $setAll;
@@ -83,20 +88,28 @@
 
     ArrayField(ClassOutlineImpl context, CPropertyInfo prop) {
         super(context,prop,false);
-        generate();
+        generateArray();
     }
 
+    protected final void generateArray() {
+        field = outline.implClass.field( JMod.PROTECTED, getCoreListType(), prop.getName(false) );
+        annotate(field);
+
+        // generate the rest of accessors
+        generateAccessors();
+    }
+
     public void generateAccessors() {
 
         MethodWriter writer = outline.createMethodWriter();
         Accessor acc = create(JExpr._this());
-
         JVar $idx,$value; JBlock body;
-        JType arrayType = exposedType.array();
 
         // [RESULT] T[] getX() {
         //     if( <var>==null )    return new T[0];
-        //     return (T[]) <var>.toArray(new T[<var>.size()]);
+        //     T[] retVal = new T[this._return.length] ;
+        //     System.arraycopy(this._return, 0, "retVal", 0, this._return.length);
+        //     return (retVal);
         // }
         $getAll = writer.declareMethod( exposedType.array(),"get"+prop.getName(true));
         writer.javadoc().append(prop.javadoc);
@@ -104,26 +117,13 @@
 
         body._if( acc.ref(true).eq(JExpr._null()) )._then()
             ._return(JExpr.newArray(exposedType,0));
+        JVar var = body.decl(exposedType.array(), "retVal", JExpr.newArray(implType,acc.ref(true).ref("length")));
+        body.add(codeModel.ref(System.class).staticInvoke("arraycopy")
+                        .arg(acc.ref(true)).arg(JExpr.lit(0))
+                        .arg(var)
+                        .arg(JExpr.lit(0)).arg(acc.ref(true).ref("length")));
+        body._return(JExpr.direct("retVal"));
 
-        if(primitiveType==null) {
-            body._return(JExpr.cast(arrayType,
-                acc.ref(true).invoke("toArray").arg( JExpr.newArray(implType,acc.ref(true).invoke("size")) )));
-        } else {
-            // need to copy them manually to unbox values
-            // [RESULT]
-            // T[] r = new T[<ref>.size()];
-            // for( int i=0; i<r.length; i++ )
-            //     r[i] = unbox(<ref>.get(i));
-            JVar $r = body.decl(exposedType.array(),"r",JExpr.newArray(exposedType, acc.ref(true).invoke("size")));
-            JForLoop loop = body._for();
-            JVar $i = loop.init(codeModel.INT,"__i",JExpr.lit(0));
-            loop.test($i.lt($r.ref("length")));
-            loop.update($i.incr());
-            loop.body().assign( $r.component($i),
-                primitiveType.unwrap(acc.ref(true).invoke("get").arg($i)) );
-            body._return($r);
-        }
-
         List<Object> returnTypes = listPossibleTypes(prop);
         writer.javadoc().addReturn().append("array of\n").append(returnTypes);
 
@@ -139,26 +139,23 @@
             ._throw(JExpr._new(codeModel.ref(IndexOutOfBoundsException.class)));
 
         writer.javadoc().append(prop.javadoc);
-        $get.body()._return(acc.unbox(acc.ref(true).invoke("get").arg($idx) ));
+        $get.body()._return(acc.ref(true).component($idx));
 
         writer.javadoc().addReturn().append("one of\n").append(returnTypes);
 
-
         // [RESULT] int getXLength() {
         //     if( <var>==null )    throw new IndexOutOfBoundsException();
-        //     return <ref>.size();
+        //     return <ref>.length;
         // }
         JMethod $getLength = writer.declareMethod(codeModel.INT,"get"+prop.getName(true)+"Length");
         $getLength.body()._if(acc.ref(true).eq(JExpr._null()))._then()
                 ._return(JExpr.lit(0));
-        $getLength.body()._return(acc.ref(true).invoke("size"));
+        $getLength.body()._return(acc.ref(true).ref("length"));
 
-
         // [RESULT] void setX(ET[] values) {
-        //     clear();
         //     int len = values.length;
         //     for( int i=0; i<len; i++ )
-        //         <ref>.add(values[i]);
+        //         <ref>[i] = values[i];
         // }
         $setAll = writer.declareMethod(
             codeModel.VOID,
@@ -165,21 +162,27 @@
             "set"+prop.getName(true));
 
         writer.javadoc().append(prop.javadoc);
-
         $value = writer.addParameter(exposedType.array(),"values");
-        $setAll.body().invoke(acc.ref(false),"clear");
         JVar $len = $setAll.body().decl(codeModel.INT,"len", $value.ref("length"));
+
+        $setAll.body().assign(
+                (JAssignmentTarget) acc.ref(true),
+                castToImplTypeArray(JExpr.newArray(
+                    codeModel.ref(exposedType.erasure().fullName()),
+                    $len)));
+
         JForLoop _for = $setAll.body()._for();
         JVar $i = _for.init( codeModel.INT, "i", JExpr.lit(0) );
         _for.test( JOp.lt($i,$len) );
         _for.update( $i.incr() );
-        _for.body().invoke(acc.ref(true),"add").arg(castToImplType(acc.box($value.component($i))));
+        _for.body().assign(acc.ref(true).component($i), castToImplType(acc.box($value.component($i))));
 
         writer.javadoc().addParam($value)
             .append("allowed objects are\n")
             .append(returnTypes);
 
-        // [RESULT] ET setX(int,ET)
+        // [RESULT] ET setX(int idx, ET value)
+        // <ref>[idx] = value
         JMethod $set = writer.declareMethod(
             exposedType,
             "set"+prop.getName(true));
@@ -189,19 +192,33 @@
         writer.javadoc().append(prop.javadoc);
 
         body = $set.body();
-        body._return( acc.unbox(
-            acc.ref(true).invoke("set").arg($idx).arg(castToImplType(acc.box($value)))));
+        body._return( JExpr.assign(acc.ref(true).component($idx),
+                                   castToImplType(acc.box($value))));
 
         writer.javadoc().addParam($value)
             .append("allowed object is\n")
             .append(returnTypes);
+
     }
 
+    @Override
+    public JType getRawType() {
+        return exposedType.array();
+    }
+
     protected JClass getCoreListType() {
-        return codeModel.ref(ArrayList.class).narrow(exposedType.boxify());
+        return exposedType.array();
     }
 
     public Accessor create(JExpression targetObject) {
         return new Accessor(targetObject);
     }
+
+    /**
+     * Case from {@link #exposedType} to array of {@link #implType} .
+     */
+    protected final JExpression castToImplTypeArray( JExpression exp ) {
+        return JExpr.cast(implType.array(), exp);
+    }
+
 }
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/ConstFieldRenderer.java	Tue Aug  4 09:32:32 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/ConstFieldRenderer.java	Tue Aug  4 09:32:32 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.generator.bean.field;
 
 import com.sun.tools.internal.xjc.generator.bean.ClassOutlineImpl;
@@ -48,7 +49,7 @@
 
     public FieldOutline generate(ClassOutlineImpl outline, CPropertyInfo prop) {
         if(prop.defaultValue.compute(outline.parent())==null)
-            return fallback.generate(outline,prop);
+            return fallback.generate(outline, prop);
         else
             return new ConstField(outline,prop);
     }
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/DefaultFieldRenderer.java	Tue Aug  4 09:32:35 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/DefaultFieldRenderer.java	Tue Aug  4 09:32:34 2009
@@ -27,8 +27,12 @@
 import java.util.ArrayList;
 
 import com.sun.tools.internal.xjc.generator.bean.ClassOutlineImpl;
+import com.sun.tools.internal.xjc.model.CElement;
 import com.sun.tools.internal.xjc.model.CPropertyInfo;
+import com.sun.tools.internal.xjc.model.CReferencePropertyInfo;
 import com.sun.tools.internal.xjc.outline.FieldOutline;
+import java.io.Serializable;
+import java.util.Set;
 
 /**
  * Default implementation of the FieldRendererFactory
@@ -64,7 +68,18 @@
         return decideRenderer(outline,prop).generate(outline,prop);
     }
 
-    private FieldRenderer decideRenderer(ClassOutlineImpl outline,CPropertyInfo prop) {
+    private FieldRenderer decideRenderer(ClassOutlineImpl outline, CPropertyInfo prop) {
+
+        if (prop instanceof CReferencePropertyInfo) {
+            CReferencePropertyInfo p = (CReferencePropertyInfo)prop;
+            if (p.isDummy()) {
+                return frf.getDummyList(outline.parent().getCodeModel().ref(ArrayList.class));
+            }
+            if (p.isContent() && (p.isMixedExtendedCust())) {
+                return frf.getContentList(outline.parent().getCodeModel().ref(ArrayList.class).narrow(Serializable.class));
+            }
+        }
+
         if(!prop.isCollection()) {
             // non-collection field
 
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/FieldRenderer.java	Tue Aug  4 09:32:37 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/FieldRenderer.java	Tue Aug  4 09:32:37 2009
@@ -59,7 +59,7 @@
      * class, then return {@link FieldOutline} for accessing
      * the generated field.
      */
-    public FieldOutline generate( ClassOutlineImpl context, CPropertyInfo prop );
+    public FieldOutline generate( ClassOutlineImpl context, CPropertyInfo prop);
 
 //    //
 //    // field renderers
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/FieldRendererFactory.java	Tue Aug  4 09:32:39 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/FieldRendererFactory.java	Tue Aug  4 09:32:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.generator.bean.field;
 
 import com.sun.tools.internal.xjc.Options;
@@ -67,6 +68,12 @@
     public FieldRenderer getList(JClass coreList) {
         return new UntypedListFieldRenderer(coreList);
     }
+    public FieldRenderer getContentList(JClass coreList) {
+        return new UntypedListFieldRenderer(coreList, false, true);
+    }
+    public FieldRenderer getDummyList(JClass coreList) {
+        return new UntypedListFieldRenderer(coreList, true, false);
+    }
     public FieldRenderer getConst(FieldRenderer fallback) {
         return new ConstFieldRenderer(fallback);
     }
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/IsSetFieldRenderer.java	Tue Aug  4 09:32:41 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/IsSetFieldRenderer.java	Tue Aug  4 09:32:41 2009
@@ -56,7 +56,7 @@
 
     public FieldOutline generate(ClassOutlineImpl context, CPropertyInfo prop) {
         return new IsSetField(context,prop,
-            core.generate(context,prop),
+            core.generate(context, prop),
             generateUnSetMethod,generateIsSetMethod);
     }
 }
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/MessageBundle.properties	Tue Aug  4 09:32:44 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/MessageBundle.properties	Tue Aug  4 09:32:43 2009
@@ -28,4 +28,3 @@
 
 DEFAULT_GETTER_JAVADOC = \
         Gets the value of the {0} property.
- 
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/Messages.java	Tue Aug  4 09:32:46 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/Messages.java	Tue Aug  4 09:32:45 2009
@@ -31,7 +31,7 @@
 /**
  * Message resources
  */
-enum Messages {
+public enum Messages {
     DEFAULT_GETTER_JAVADOC,     // 1 arg
     DEFAULT_SETTER_JAVADOC,     // 1 arg
     ;
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/SingleField.java	Tue Aug  4 09:32:48 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/SingleField.java	Tue Aug  4 09:32:48 2009
@@ -131,10 +131,8 @@
         JBlock body = $set.body();
         body.assign(JExpr._this().ref(ref()),castToImplType($value));
 
-        javadoc = prop.javadoc;
-        if(javadoc.length()==0)
-            javadoc = Messages.DEFAULT_SETTER_JAVADOC.format(nc.toVariableName(prop.getName(true)));
-        writer.javadoc().append(javadoc);
+        // setter always get the default javadoc. See issue #381
+        writer.javadoc().append(Messages.DEFAULT_SETTER_JAVADOC.format(nc.toVariableName(prop.getName(true))));
         writer.javadoc().addParam($value)
             .append("allowed object is\n")
             .append(possibleTypes);
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/SinglePrimitiveAccessField.java	Tue Aug  4 09:32:50 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/SinglePrimitiveAccessField.java	Tue Aug  4 09:32:50 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.generator.bean.field;
 
 import com.sun.tools.internal.xjc.generator.bean.ClassOutlineImpl;
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/UnboxedField.java	Tue Aug  4 09:32:52 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/UnboxedField.java	Tue Aug  4 09:32:52 2009
@@ -92,10 +92,8 @@
         JVar $value = writer.addParameter( ptype, "value" );
         body = $set.body();
         body.assign(JExpr._this().ref(ref()),$value);
-        javadoc = prop.javadoc;
-        if(javadoc.length()==0)
-            javadoc = Messages.DEFAULT_SETTER_JAVADOC.format(nc.toVariableName(prop.getName(true)));
-        writer.javadoc().append(javadoc);
+        // setter always get the default javadoc. See issue #381
+        writer.javadoc().append(Messages.DEFAULT_SETTER_JAVADOC.format(nc.toVariableName(prop.getName(true))));
 
     }
 
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/UntypedListFieldRenderer.java	Tue Aug  4 09:32:55 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/UntypedListFieldRenderer.java	Tue Aug  4 09:32:54 2009
@@ -38,12 +38,26 @@
 public final class UntypedListFieldRenderer implements FieldRenderer {
 
     private JClass coreList;
+    private boolean dummy;
+    private boolean content;
 
-    protected UntypedListFieldRenderer( JClass coreList ) {
+    protected UntypedListFieldRenderer( JClass coreList) {
+        this(coreList, false, false);
+    }
+
+    protected UntypedListFieldRenderer( JClass coreList, boolean dummy, boolean content) {
         this.coreList = coreList;
+        this.dummy = dummy;
+        this.content = content;
     }
 
     public FieldOutline generate(ClassOutlineImpl context, CPropertyInfo prop) {
-        return new UntypedListField(context,prop,coreList);
+        if (dummy) {
+            return new DummyListField(context, prop, coreList);
+        }
+        if (content) {
+            return new ContentListField(context, prop, coreList);
+        }
+        return new UntypedListField(context, prop, coreList);
     }
 }
--- old/src/share/classes/com/sun/tools/internal/xjc/generator/package-info.java	Tue Aug  4 09:32:57 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/package-info.java	Tue Aug  4 09:32:56 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /**
  * <h1>Code Generator</h1>.
  *
--- old/src/share/classes/com/sun/tools/internal/xjc/model/AbstractCElement.java	Tue Aug  4 09:32:59 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/AbstractCElement.java	Tue Aug  4 09:32:59 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import javax.xml.bind.annotation.XmlTransient;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/AbstractCTypeInfoImpl.java	Tue Aug  4 09:33:01 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/AbstractCTypeInfoImpl.java	Tue Aug  4 09:33:01 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import javax.activation.MimeType;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/AutoClassNameAllocator.java	Tue Aug  4 09:33:03 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/AutoClassNameAllocator.java	Tue Aug  4 09:33:03 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import java.util.Set;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CAdapter.java	Tue Aug  4 09:33:06 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CAdapter.java	Tue Aug  4 09:33:05 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CArrayInfo.java	Tue Aug  4 09:33:08 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CArrayInfo.java	Tue Aug  4 09:33:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import javax.xml.namespace.QName;
@@ -38,7 +39,12 @@
 import org.xml.sax.Locator;
 
 /**
- * TODO: Because s2j doesn't generate the array binding, this is unnecessary.
+ * Because XJC doesn't generate the array binding, this class will
+ * never show up in the model constructed by XJC.
+ *
+ * <p>
+ * This class is nevertheless defined to make the type checker happy.
+ *
  * @author Kohsuke Kawaguchi
  */
 public final class CArrayInfo extends AbstractCTypeInfoImpl implements ArrayInfo<NType,NClass>, CNonElement, NType {
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CAttributePropertyInfo.java	Tue Aug  4 09:33:10 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CAttributePropertyInfo.java	Tue Aug  4 09:33:10 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CBuiltinLeafInfo.java	Tue Aug  4 09:33:12 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CBuiltinLeafInfo.java	Tue Aug  4 09:33:12 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import java.awt.*;
@@ -261,7 +262,9 @@
         }
     };
     // XMLGregorianCalendar is mutable, so we can't support default values anyhow.
-    public static final CBuiltinLeafInfo CALENDAR = new NoConstantBuiltin(XMLGregorianCalendar.class,"dateTime");
+        // For CALENAR we are uses a most unlikely name so as to avoid potential name
+        // conflicts in the furture.
+        public static final CBuiltinLeafInfo CALENDAR = new NoConstantBuiltin(XMLGregorianCalendar.class,"\u0000");
     public static final CBuiltinLeafInfo DURATION = new NoConstantBuiltin(Duration.class,"duration");
 
     public static final CBuiltinLeafInfo BIG_INTEGER = new Builtin(BigInteger.class,"integer") {
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CClass.java	Tue Aug  4 09:33:14 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CClass.java	Tue Aug  4 09:33:14 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CClassInfo.java	Tue Aug  4 09:33:16 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CClassInfo.java	Tue Aug  4 09:33:16 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import java.util.ArrayList;
@@ -41,10 +42,15 @@
 import com.sun.codemodel.internal.JCodeModel;
 import com.sun.codemodel.internal.JPackage;
 import com.sun.istack.internal.Nullable;
+import com.sun.tools.internal.xjc.Language;
+import com.sun.tools.internal.xjc.Options;
 import com.sun.tools.internal.xjc.model.nav.NClass;
 import com.sun.tools.internal.xjc.model.nav.NType;
 import com.sun.tools.internal.xjc.outline.Aspect;
 import com.sun.tools.internal.xjc.outline.Outline;
+import com.sun.tools.internal.xjc.reader.Ring;
+import com.sun.tools.internal.xjc.reader.xmlschema.BGMBuilder;
+import com.sun.tools.internal.xjc.reader.xmlschema.bindinfo.BIFactoryMethod;
 import com.sun.xml.internal.bind.v2.model.core.ClassInfo;
 import com.sun.xml.internal.bind.v2.model.core.Element;
 import com.sun.xml.internal.xsom.XSComponent;
@@ -84,6 +90,11 @@
     private final QName typeName;
 
     /**
+     * Custom {@link #getSqueezedName() squeezed name}, if any.
+     */
+    private /*almost final*/ @Nullable String squeezedName;
+
+    /**
      * If this class also gets {@link XmlRootElement}, the class name.
      */
     private final @Nullable QName elementName;
@@ -136,6 +147,16 @@
         this.typeName = typeName;
         this.elementName = elementName;
 
+        Language schemaLanguage = model.options.getSchemaLanguage();
+        if ((schemaLanguage != null) &&
+            (schemaLanguage.equals(Language.XMLSCHEMA) || schemaLanguage.equals(Language.WSDL))) {
+            BIFactoryMethod factoryMethod = Ring.get(BGMBuilder.class).getBindInfo(source).get(BIFactoryMethod.class);
+            if(factoryMethod!=null) {
+                factoryMethod.markAsAcknowledged();
+                this.squeezedName = factoryMethod.name;
+            }
+        }
+
         model.add(this);
     }
 
@@ -182,7 +203,7 @@
      */
     public boolean inheritsAttributeWildcard() {
         for( CClassInfo c=getBaseClass(); c!=null; c=c.getBaseClass() ) {
-            if(hasAttributeWildcard)
+            if(c.hasAttributeWildcard)
                 return true;
         }
         return false;
@@ -215,6 +236,7 @@
      */
     @XmlElement
     public String getSqueezedName() {
+        if (squeezedName != null)  return squeezedName;
         return calcSqueezedName.onBean(this);
     }
 
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CClassInfoParent.java	Tue Aug  4 09:33:19 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CClassInfoParent.java	Tue Aug  4 09:33:18 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import com.sun.codemodel.internal.JPackage;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CClassRef.java	Tue Aug  4 09:33:21 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CClassRef.java	Tue Aug  4 09:33:20 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CCustomizable.java	Tue Aug  4 09:33:23 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CCustomizable.java	Tue Aug  4 09:33:23 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import com.sun.tools.internal.xjc.Plugin;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CCustomizations.java	Tue Aug  4 09:33:25 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CCustomizations.java	Tue Aug  4 09:33:25 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CDefaultValue.java	Tue Aug  4 09:33:28 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CDefaultValue.java	Tue Aug  4 09:33:27 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import com.sun.codemodel.internal.JExpression;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CElement.java	Tue Aug  4 09:33:30 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CElement.java	Tue Aug  4 09:33:29 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import com.sun.tools.internal.xjc.model.nav.NClass;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CElementInfo.java	Tue Aug  4 09:33:32 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CElementInfo.java	Tue Aug  4 09:33:31 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import java.util.Collection;
@@ -44,6 +45,10 @@
 import com.sun.tools.internal.xjc.model.nav.NavigatorImpl;
 import com.sun.tools.internal.xjc.outline.Aspect;
 import com.sun.tools.internal.xjc.outline.Outline;
+import com.sun.tools.internal.xjc.reader.xmlschema.bindinfo.BIInlineBinaryData;
+import com.sun.tools.internal.xjc.reader.xmlschema.bindinfo.BIFactoryMethod;
+import com.sun.tools.internal.xjc.reader.xmlschema.BGMBuilder;
+import com.sun.tools.internal.xjc.reader.Ring;
 import com.sun.xml.internal.bind.v2.model.core.ElementInfo;
 import com.sun.xml.internal.xsom.XSElementDecl;
 import com.sun.xml.internal.xsom.XmlString;
@@ -100,6 +105,11 @@
     private CElementPropertyInfo property;
 
     /**
+     * Custom {@link #getSqueezedName() squeezed name}, if any.
+     */
+    private /*almost final*/ @Nullable String squeezedName;
+
+    /**
      * Creates an element in the given parent.
      *
      * <p>
@@ -143,10 +153,18 @@
                 contentType.getExpectedMimeType(),
                 source,null,getLocator(),true);
         this.property.setAdapter(contentType.getAdapterUse());
+        BIInlineBinaryData.handle(source,property);
         property.getTypes().add(new CTypeRef(contentType.getInfo(),tagName,CTypeRef.getSimpleTypeName(source), true,defaultValue));
         this.type = NavigatorImpl.createParameterizedType(
             NavigatorImpl.theInstance.ref(JAXBElement.class),
             getContentInMemoryType() );
+
+        BIFactoryMethod factoryMethod = Ring.get(BGMBuilder.class).getBindInfo(source).get(BIFactoryMethod.class);
+        if(factoryMethod!=null) {
+            factoryMethod.markAsAcknowledged();
+            this.squeezedName = factoryMethod.name;
+        }
+
     }
 
     public final String getDefaultValue() {
@@ -208,6 +226,8 @@
      */
     @XmlElement
     public String getSqueezedName() {
+        if(squeezedName!=null)  return squeezedName;
+
         StringBuilder b = new StringBuilder();
         CClassInfo s = getScope();
         if(s!=null)
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CElementPropertyInfo.java	Tue Aug  4 09:33:34 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CElementPropertyInfo.java	Tue Aug  4 09:33:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import java.util.AbstractList;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CEnumConstant.java	Tue Aug  4 09:33:36 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CEnumConstant.java	Tue Aug  4 09:33:36 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import com.sun.tools.internal.xjc.model.nav.NClass;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CNonElement.java	Tue Aug  4 09:33:38 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CNonElement.java	Tue Aug  4 09:33:38 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import com.sun.tools.internal.xjc.model.nav.NClass;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CPluginCustomization.java	Tue Aug  4 09:33:41 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CPluginCustomization.java	Tue Aug  4 09:33:40 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import com.sun.tools.internal.xjc.Plugin;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CPropertyInfo.java	Tue Aug  4 09:33:43 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CPropertyInfo.java	Tue Aug  4 09:33:42 2009
@@ -22,14 +22,15 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
+import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.Map;
-import java.lang.annotation.Annotation;
 
-import javax.xml.bind.annotation.XmlTransient;
 import javax.xml.bind.annotation.XmlSchemaType;
+import javax.xml.bind.annotation.XmlTransient;
 import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
 import javax.xml.namespace.QName;
 
@@ -41,12 +42,11 @@
 import com.sun.tools.internal.xjc.model.nav.NClass;
 import com.sun.tools.internal.xjc.model.nav.NType;
 import com.sun.xml.internal.bind.api.impl.NameConverter;
+import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 import com.sun.xml.internal.bind.v2.model.core.PropertyInfo;
 import com.sun.xml.internal.bind.v2.runtime.RuntimeUtil;
-import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 import com.sun.xml.internal.xsom.XSComponent;
 
-import org.xml.sax.ErrorHandler;
 import org.xml.sax.Locator;
 
 /**
@@ -82,8 +82,13 @@
     public String javadoc="";
 
     /**
-     * Specifies how the field is generated by the backedn.
+     * Property with {@link @XmlInlineBinaryData}.
      */
+    public boolean inlineBinaryData;
+
+    /**
+     * Specifies how the field is generated by the backend.
+     */
     @XmlJavaTypeAdapter(RuntimeUtil.ToStringAdapter.class)
     public FieldRenderer realization;
 
@@ -271,11 +276,8 @@
         return customizations;
     }
 
-    /**
-     * @deprecated if you are calling this method directly, there's something wrong.
-     */
     public boolean inlineBinaryData() {
-        return false;
+        return inlineBinaryData;
     }
 
     public abstract <V> V accept( CPropertyVisitor<V> visitor );
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CPropertyVisitor.java	Tue Aug  4 09:33:45 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CPropertyVisitor.java	Tue Aug  4 09:33:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CReferencePropertyInfo.java	Tue Aug  4 09:33:47 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CReferencePropertyInfo.java	Tue Aug  4 09:33:47 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import java.util.Collection;
@@ -52,6 +53,11 @@
 public final class CReferencePropertyInfo extends CPropertyInfo implements ReferencePropertyInfo<NType,NClass> {
 
     /**
+     * True if this property can never be absent legally.
+     */
+    private final boolean required;
+
+    /**
      * List of referenced elements.
      */
     private final Set<CElement> elements = new HashSet<CElement>();
@@ -58,11 +64,18 @@
 
     private final boolean isMixed;
     private WildcardMode wildcard;
+    private boolean dummy;
+    private boolean content;
+    private boolean isMixedExtendedCust = false;
 
-    public CReferencePropertyInfo(String name, boolean collection, boolean isMixed, XSComponent source,
-                                  CCustomizations customizations, Locator locator) {
-        super(name, collection||isMixed, source, customizations, locator );
+    public CReferencePropertyInfo(String name, boolean collection, boolean required, boolean isMixed, XSComponent source,
+                                  CCustomizations customizations, Locator locator, boolean dummy, boolean content, boolean isMixedExtended) {   // 'dummy' and 'content' here for NHIN fix - a hack in order to be able to handle extended mixed types better
+        super(name, (collection||isMixed) && (!dummy), source, customizations, locator);
         this.isMixed = isMixed;
+        this.required = required;
+        this.dummy = dummy;
+        this.content = content;
+        this.isMixedExtendedCust = isMixedExtended;
     }
 
     public Set<? extends CTypeInfo> ref() {
@@ -108,7 +121,6 @@
         if(isMixed())
             r.add(CBuiltinLeafInfo.STRING);
 
-
         return r;
     }
 
@@ -120,6 +132,18 @@
         return isMixed;
     }
 
+    public boolean isDummy() {
+        return dummy;
+    }
+
+    public boolean isContent() {
+        return content;
+    }
+
+    public boolean isMixedExtendedCust() {
+        return isMixedExtendedCust;
+    }
+
     /**
      * We'll never use a wrapper element in XJC. Always return null.
      */
@@ -198,6 +222,10 @@
         return null;
     }
 
+    public boolean isRequired() {
+        return required;
+    }
+
     @Override
     public QName collectElementNames(Map<QName, CPropertyInfo> table) {
         for (CElement e : elements) {
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CSingleTypePropertyInfo.java	Tue Aug  4 09:33:49 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CSingleTypePropertyInfo.java	Tue Aug  4 09:33:49 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import java.util.Collections;
@@ -30,7 +31,6 @@
 import javax.activation.MimeType;
 import javax.xml.namespace.QName;
 
-import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 import com.sun.xml.internal.bind.v2.model.core.ID;
 import com.sun.xml.internal.xsom.XSComponent;
 
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CTypeInfo.java	Tue Aug  4 09:33:52 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CTypeInfo.java	Tue Aug  4 09:33:51 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import com.sun.codemodel.internal.JClass;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CTypeRef.java	Tue Aug  4 09:33:54 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CTypeRef.java	Tue Aug  4 09:33:53 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CValuePropertyInfo.java	Tue Aug  4 09:33:56 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CValuePropertyInfo.java	Tue Aug  4 09:33:56 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/CWildcardTypeInfo.java	Tue Aug  4 09:33:58 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/CWildcardTypeInfo.java	Tue Aug  4 09:33:58 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import com.sun.codemodel.internal.JType;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/ClassNameAllocatorWrapper.java	Tue Aug  4 09:34:00 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/ClassNameAllocatorWrapper.java	Tue Aug  4 09:34:00 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import com.sun.codemodel.internal.JPackage;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/Model.java	Tue Aug  4 09:34:02 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/Model.java	Tue Aug  4 09:34:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import java.util.Collections;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/Populatable.java	Tue Aug  4 09:34:05 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/Populatable.java	Tue Aug  4 09:34:04 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import com.sun.tools.internal.xjc.outline.Outline;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/TypeUse.java	Tue Aug  4 09:34:07 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/TypeUse.java	Tue Aug  4 09:34:06 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import javax.activation.MimeType;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/TypeUseFactory.java	Tue Aug  4 09:34:09 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/TypeUseFactory.java	Tue Aug  4 09:34:09 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import javax.activation.MimeType;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/TypeUseImpl.java	Tue Aug  4 09:34:11 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/TypeUseImpl.java	Tue Aug  4 09:34:11 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model;
 
 import javax.activation.MimeType;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/nav/EagerNClass.java	Tue Aug  4 09:34:13 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/nav/EagerNClass.java	Tue Aug  4 09:34:13 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model.nav;
 
 import java.lang.reflect.Modifier;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/nav/EagerNType.java	Tue Aug  4 09:34:16 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/nav/EagerNType.java	Tue Aug  4 09:34:15 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model.nav;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/nav/NClass.java	Tue Aug  4 09:34:18 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/nav/NClass.java	Tue Aug  4 09:34:17 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model.nav;
 
 import com.sun.codemodel.internal.JClass;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/nav/NClassByJClass.java	Tue Aug  4 09:34:20 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/nav/NClassByJClass.java	Tue Aug  4 09:34:19 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model.nav;
 
 import com.sun.codemodel.internal.JClass;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/nav/NParameterizedType.java	Tue Aug  4 09:34:22 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/nav/NParameterizedType.java	Tue Aug  4 09:34:22 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model.nav;
 
 import com.sun.codemodel.internal.JClass;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/nav/NType.java	Tue Aug  4 09:34:24 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/nav/NType.java	Tue Aug  4 09:34:24 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model.nav;
 
 import com.sun.codemodel.internal.JType;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/nav/NavigatorImpl.java	Tue Aug  4 09:34:27 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/nav/NavigatorImpl.java	Tue Aug  4 09:34:26 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.model.nav;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/tools/internal/xjc/model/package-info.java	Tue Aug  4 09:34:29 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/model/package-info.java	Tue Aug  4 09:34:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /**
  * Implementation of the {@link com.sun.xml.internal.bind.v2.model.core} package for XJC.
  *
--- old/src/share/classes/com/sun/tools/internal/xjc/outline/Aspect.java	Tue Aug  4 09:34:31 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/outline/Aspect.java	Tue Aug  4 09:34:30 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.outline;
 
 import com.sun.tools.internal.xjc.generator.bean.ImplStructureStrategy;
--- old/src/share/classes/com/sun/tools/internal/xjc/outline/ClassOutline.java	Tue Aug  4 09:34:33 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/outline/ClassOutline.java	Tue Aug  4 09:34:33 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /*
  * Use is subject to the license terms.
  */
@@ -81,7 +82,7 @@
     /**
      * The implementation class that shall be used for reference.
      * <p>
-     * Usually this field holds the same value as the impl method,
+     * Usually this field holds the same value as the {@link #implClass} method,
      * but sometimes it holds the user-specified implementation class
      * when it is specified.
      * <p>
--- old/src/share/classes/com/sun/tools/internal/xjc/outline/ElementOutline.java	Tue Aug  4 09:34:35 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/outline/ElementOutline.java	Tue Aug  4 09:34:35 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.outline;
 
 import com.sun.codemodel.internal.JDefinedClass;
--- old/src/share/classes/com/sun/tools/internal/xjc/outline/EnumConstantOutline.java	Tue Aug  4 09:34:37 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/outline/EnumConstantOutline.java	Tue Aug  4 09:34:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.outline;
 
 import com.sun.codemodel.internal.JEnumConstant;
--- old/src/share/classes/com/sun/tools/internal/xjc/outline/EnumOutline.java	Tue Aug  4 09:34:40 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/outline/EnumOutline.java	Tue Aug  4 09:34:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.outline;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/tools/internal/xjc/package-info.java	Tue Aug  4 09:34:42 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/package-info.java	Tue Aug  4 09:34:41 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /**
  * <h1>Schema to Java compiler</h1>.
  *
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/AbstractExtensionBindingChecker.java	Tue Aug  4 09:34:44 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/AbstractExtensionBindingChecker.java	Tue Aug  4 09:34:44 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader;
 
 import java.util.Set;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/Const.java	Tue Aug  4 09:34:46 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/Const.java	Tue Aug  4 09:34:46 2009
@@ -24,9 +24,9 @@
  */
 package com.sun.tools.internal.xjc.reader;
 
+import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 
 
-
 /**
  * Useful constant values.
  *
@@ -53,4 +53,12 @@
 
     /** URI to represent DTD. */
     public static final String DTD = "DTD";
+
+    /**
+     * Attribute name of the expected media type.
+     *
+     * @see WellKnownNamespace#XML_MIME_URI
+     * @see http://www.w3.org/TR/xml-media-types/
+     */
+    public static final String EXPECTED_CONTENT_TYPES = "expectedContentTypes";
 }
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/MessageBundle.properties	Tue Aug  4 09:34:48 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/MessageBundle.properties	Tue Aug  4 09:34:48 2009
@@ -30,30 +30,30 @@
 
 
 ERR_UNDECLARED_PREFIX = \
-	Prefix "{0}" is undeclared
+        Prefix "{0}" is undeclared
 
 ERR_UNEXPECTED_EXTENSION_BINDING_PREFIXES = \
-	extensionBindingPrefixes attribute must be declared at the root element
+        extensionBindingPrefixes attribute must be declared at the root element
 
 ERR_VENDOR_EXTENSION_DISALLOWED_IN_STRICT_MODE = \
     vendor extension bindings (jaxb:extensionBindingPrefixes) are not allowed in the strict mode. Use -extension.
 
 ERR_UNSUPPORTED_EXTENSION = \
-	Unsupported binding namespace "{0}". Perhaps you meant "{1}"?
+        Unsupported binding namespace "{0}". Perhaps you meant "{1}"?
 
 ERR_SUPPORTED_EXTENSION_IGNORED = \
-	Binding declaration namespace "{0}" will be ignored because it is \
-	not designated by the jaxb:extensionBindingPrefixes attribute.
+        Binding declaration namespace "{0}" will be ignored because it is \
+        not designated by the jaxb:extensionBindingPrefixes attribute.
 
 ERR_RELEVANT_LOCATION = \
-	The following location is relevant to the above error
+        The following location is relevant to the above error
 
 
 ERR_CLASS_NOT_FOUND = \
-	Unable to find type "{0}". Without knowing the proper inheritance hierarchy of this type, \
-	XJC may fail to generate some signatures correctly. \
-	Make this class available via the -classpath option.
-	
+        Unable to find type "{0}". Without knowing the proper inheritance hierarchy of this type, \
+        XJC may fail to generate some signatures correctly. \
+        Make this class available via the -classpath option.
+
 DUPLICATE_PROPERTY = \
     Property "{0}" is already defined. Use &lt;jaxb:property> to resolve this conflict.
 
@@ -71,4 +71,3 @@
 
 ERR_PLUGIN_NOT_ENABLED = \
     Using "{1}" customizations requires the "-{0}" switch to enable this plug-in.
- 
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/ModelChecker.java	Tue Aug  4 09:34:51 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/ModelChecker.java	Tue Aug  4 09:34:50 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader;
 
 import java.util.List;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/RawTypeSet.java	Tue Aug  4 09:34:53 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/RawTypeSet.java	Tue Aug  4 09:34:52 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader;
 
 import java.util.HashSet;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/Ring.java	Tue Aug  4 09:34:55 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/Ring.java	Tue Aug  4 09:34:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader;
 
 import java.lang.reflect.Constructor;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/Block.java	Tue Aug  4 09:34:57 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/Block.java	Tue Aug  4 09:34:57 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.dtd;
 
 import java.util.LinkedHashSet;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/Element.java	Tue Aug  4 09:34:59 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/Element.java	Tue Aug  4 09:34:59 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.dtd;
 
 import java.util.ArrayList;
@@ -221,7 +222,7 @@
 
         switch(contentModelType) {
         case DTDEventListener.CONTENT_MODEL_ANY:
-            CReferencePropertyInfo rp = new CReferencePropertyInfo("Content",true,true,null,null/*TODO*/,locator);
+            CReferencePropertyInfo rp = new CReferencePropertyInfo("Content",true,false,true,null,null/*TODO*/,locator, false, false, false);
             rp.setWildcard(WildcardMode.SKIP);
             ci.addProperty(rp);
             return;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/MessageBundle.properties	Tue Aug  4 09:35:02 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/MessageBundle.properties	Tue Aug  4 09:35:01 2009
@@ -24,26 +24,25 @@
 #
 
 TDTDReader.NoRootElement = \
-	No root element was specified.
+        No root element was specified.
 
 TDTDReader.UndefinedElementInBindInfo = \
-	Binding information contains element "{0}", but it's not defined in DTD.
+        Binding information contains element "{0}", but it's not defined in DTD.
 
 TDTDReader.ConversionForNonValueElement = \
-	Conversion declaration is specified for the element "{0}", but \
-	the content model of this element is not #PCDATA.
+        Conversion declaration is specified for the element "{0}", but \
+        the content model of this element is not #PCDATA.
 
 TDTDReader.ContentProperty.ParticleMismatch = \
-	The content model of the element "{0}" does not match \
-	the content-property declaration of the specified binding information.
+        The content model of the element "{0}" does not match \
+        the content-property declaration of the specified binding information.
 
 TDTDReader.ContentProperty.DeclarationTooShort = \
-	The content-property declaration for the element "{0}" is too short.
+        The content-property declaration for the element "{0}" is too short.
 
 TDTDReader.BindInfo.NonExistentElementDeclaration = \
-	DTD does not contain the element "{0}"
+        DTD does not contain the element "{0}"
 
 TDTDReader.BindInfo.NonExistentInterfaceMember = \
-	"{0}" is specified as a member of an interface, \
-	but there is no such class nor interface.
- 
+        "{0}" is specified as a member of an interface, \
+        but there is no such class nor interface.
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/ModelGroup.java	Tue Aug  4 09:35:04 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/ModelGroup.java	Tue Aug  4 09:35:03 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.dtd;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/Occurence.java	Tue Aug  4 09:35:06 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/Occurence.java	Tue Aug  4 09:35:06 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.dtd;
 
 import java.util.List;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/Term.java	Tue Aug  4 09:35:08 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/Term.java	Tue Aug  4 09:35:08 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.dtd;
 
 import java.util.List;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/DOMBuilder.java	Tue Aug  4 09:35:10 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/DOMBuilder.java	Tue Aug  4 09:35:10 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.dtd.bindinfo;
 
 import javax.xml.parsers.ParserConfigurationException;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/DOMUtil.java	Tue Aug  4 09:35:13 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/DOMUtil.java	Tue Aug  4 09:35:12 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.dtd.bindinfo;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/DTDExtensionBindingChecker.java	Tue Aug  4 09:35:15 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/DTDExtensionBindingChecker.java	Tue Aug  4 09:35:14 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.dtd.bindinfo;
 
 import com.sun.tools.internal.xjc.Options;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/MessageBundle.properties	Tue Aug  4 09:35:17 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/MessageBundle.properties	Tue Aug  4 09:35:17 2009
@@ -24,6 +24,5 @@
 #
 
 BIConstructor.UndefinedField = \
-	Property "{0}" is declared in the <constructor> declaration \
-	but is not defined in DTD
- 
+        Property "{0}" is declared in the <constructor> declaration \
+        but is not defined in DTD
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/bindingfile.rng	Tue Aug  4 09:35:19 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/bindingfile.rng	Tue Aug  4 09:35:19 2009
@@ -25,7 +25,6 @@
 -->
 <!--
 DTD binding information file which is supported by this version of XJC.
-$Id: bindingfile.rng,v 1.1 2005/04/15 20:09:43 kohsuke Exp $
 
 - Changes from the EA1 is marked by "CHANGE:"
 - "ref:key" and "ref:keyref" are used to specify cross-reference
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/bindingfile.xsd	Tue Aug  4 09:35:21 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/bindingfile.xsd	Tue Aug  4 09:35:21 2009
@@ -23,9 +23,10 @@
  CA 95054 USA or visit www.sun.com if you need additional information or
  have any questions.
 -->
+
+
 <!--
   DTD binding information file which is supported by this version of XJC.
-  $Id: bindingfile.xsd,v 1.1 2005/04/29 18:11:05 kohsuke Exp $
   
   - Changes from the EA1 is marked by "CHANGE:"
   - "ref:key" and "ref:keyref" are used to specify cross-reference
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/xjc.xsd	Tue Aug  4 09:35:24 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/dtd/bindinfo/xjc.xsd	Tue Aug  4 09:35:23 2009
@@ -23,6 +23,8 @@
  CA 95054 USA or visit www.sun.com if you need additional information or
  have any questions.
 -->
+
+
 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://java.sun.com/xml/ns/jaxb/xjc" xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc">
   <xs:import schemaLocation="bindingfile.xsd"/>
   <xs:element name="serializable">
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/Choice.java	Tue Aug  4 09:35:26 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/Choice.java	Tue Aug  4 09:35:26 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.gbind;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/ConnectedComponent.java	Tue Aug  4 09:35:28 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/ConnectedComponent.java	Tue Aug  4 09:35:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.gbind;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/Element.java	Tue Aug  4 09:35:30 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/Element.java	Tue Aug  4 09:35:30 2009
@@ -22,8 +22,10 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.gbind;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
@@ -144,7 +146,19 @@
      * all into the given set.
      */
     public void buildStronglyConnectedComponents(List<ConnectedComponent> ccs) {
+
+        // store visited elements - loop detection
+        List<Element> visitedElements = new ArrayList<Element>();
+
         for(Element cur=this; cur!=cur.prevPostOrder; cur=cur.prevPostOrder) {
+
+            if(visitedElements.contains(cur)) {
+                // if I've already processed cur element, I'm in a loop
+                break;
+            } else {
+                visitedElements.add(cur);
+            }
+
             if(cur.belongsToSCC())
                 continue;
 
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/ElementSet.java	Tue Aug  4 09:35:33 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/ElementSet.java	Tue Aug  4 09:35:32 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.gbind;
 
 import java.util.Collections;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/ElementSets.java	Tue Aug  4 09:35:35 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/ElementSets.java	Tue Aug  4 09:35:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.gbind;
 
 import java.util.LinkedHashSet;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/Expression.java	Tue Aug  4 09:35:37 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/Expression.java	Tue Aug  4 09:35:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.gbind;
 
 import java.util.Set;
@@ -63,10 +64,6 @@
         void buildDAG(ElementSet incoming) {
             // noop
         }
-
-        void assignElementNumber(Set<Element> allElements) {
-            // noop
-        }
 
         public String toString() {
             return "-";
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/Graph.java	Tue Aug  4 09:35:39 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/Graph.java	Tue Aug  4 09:35:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.gbind;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/OneOrMore.java	Tue Aug  4 09:35:41 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/OneOrMore.java	Tue Aug  4 09:35:41 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.gbind;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/Sequence.java	Tue Aug  4 09:35:44 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/Sequence.java	Tue Aug  4 09:35:43 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.gbind;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/SinkNode.java	Tue Aug  4 09:35:46 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/SinkNode.java	Tue Aug  4 09:35:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.gbind;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/SourceNode.java	Tue Aug  4 09:35:48 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/gbind/SourceNode.java	Tue Aug  4 09:35:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.gbind;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/internalizer/ContentHandlerNamespacePrefixAdapter.java	Tue Aug  4 09:35:50 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/internalizer/ContentHandlerNamespacePrefixAdapter.java	Tue Aug  4 09:35:50 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.internalizer;
 
 import javax.xml.XMLConstants;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/internalizer/MessageBundle.properties	Tue Aug  4 09:35:52 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/internalizer/MessageBundle.properties	Tue Aug  4 09:35:52 2009
@@ -29,44 +29,44 @@
 
 
 AbstractReferenceFinderImpl.UnableToParse = \
-	Unable to parse "{0}" : {1}
+        Unable to parse "{0}" : {1}
 
-	
 
 
+
 Internalizer.IncorrectSchemaReference = \
-	"{0}" is not a part of this compilation. Is this a mistake for "{1}"?
+        "{0}" is not a part of this compilation. Is this a mistake for "{1}"?
 
 Internalizer.XPathEvaluationError = \
-	XPath error: {0}
+        XPath error: {0}
 
 Internalizer.XPathEvaluatesToNoTarget = \
-	XPath evaluation of "{0}" results in empty target node
+        XPath evaluation of "{0}" results in empty target node
 
 Internalizer.XPathEvaulatesToTooManyTargets = \
-	XPath evaluation of "{0}" results in too many ({1}) target nodes
+        XPath evaluation of "{0}" results in too many ({1}) target nodes
 
 Internalizer.XPathEvaluatesToNonElement = \
-	XPath evaluation of "{0}" needs to result in an element.
+        XPath evaluation of "{0}" needs to result in an element.
 
 Internalizer.XPathEvaluatesToNonSchemaElement = \
-	XPath evaluation of "{0}" needs to result in an element of the schema language, \
-	but it results in {1}
+        XPath evaluation of "{0}" needs to result in an element of the schema language, \
+        but it results in {1}
 
 Internalizer.ContextNodeIsNotElement = \
-	Context node is not an element.
+        Context node is not an element.
 
 Internalizer.OrphanedCustomization = \
-	The "{0}" customization is not associated with any schema element.
+        The "{0}" customization is not associated with any schema element.
 
 Internalizer.IncorrectVersion = \
-	JAXB version attribute must be "1.0"
+        JAXB version attribute must be "1.0"
 
 Internalizer.VersionNotPresent = \
-	JAXB version attribute must be present
+        JAXB version attribute must be present
 
 Internalizer.TwoVersionAttributes = \
-	Both jaxb:version and version are present
+        Both jaxb:version and version are present
 
 ERR_GENERAL_SCHEMA_CORRECTNESS_ERROR = \
     We were unable to ensure the correctness of the schema: {0}
@@ -91,4 +91,3 @@
 
 ERR_FILENAME_IS_NOT_URI = \
     File name is not an URI.
- 
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/internalizer/NamespaceContextImpl.java	Tue Aug  4 09:35:54 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/internalizer/NamespaceContextImpl.java	Tue Aug  4 09:35:54 2009
@@ -2,7 +2,7 @@
  * reserved comment block
  * DO NOT REMOVE OR ALTER!
  */
-/*
+ /*
  * Portions Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
@@ -28,6 +28,23 @@
  *
  * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
  */
+
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.sun.tools.internal.xjc.reader.internalizer;
 
 import java.util.Iterator;
@@ -53,21 +70,6 @@
         this.e = e;
     }
 
-    /*
-     * Copyright 1999-2004 The Apache Software Foundation.
-     *
-     * Licensed under the Apache License, Version 2.0 (the "License");
-     * you may not use this file except in compliance with the License.
-     * You may obtain a copy of the License at
-     *
-     *     http://www.apache.org/licenses/LICENSE-2.0
-     *
-     * Unless required by applicable law or agreed to in writing, software
-     * distributed under the License is distributed on an "AS IS" BASIS,
-     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     * See the License for the specific language governing permissions and
-     * limitations under the License.
-     */
     public String getNamespaceURI(String prefix) {
         Node parent = e;
         String namespace = null;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/internalizer/SCDBasedBindingSet.java	Tue Aug  4 09:35:57 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/internalizer/SCDBasedBindingSet.java	Tue Aug  4 09:35:56 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.internalizer;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/internalizer/WhitespaceStripper.java	Tue Aug  4 09:35:59 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/internalizer/WhitespaceStripper.java	Tue Aug  4 09:35:58 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * @(#)$Id: WhitespaceStripper.java,v 1.2 2005/04/29 19:56:57 kohsuke Exp $
- */
-
-
 package com.sun.tools.internal.xjc.reader.internalizer;
 
 import com.sun.xml.internal.bind.WhiteSpaceProcessor;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/BindStyle.java	Tue Aug  4 09:36:01 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/BindStyle.java	Tue Aug  4 09:36:01 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.relaxng;
 
 /**
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/ContentModelBinder.java	Tue Aug  4 09:36:03 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/ContentModelBinder.java	Tue Aug  4 09:36:03 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.relaxng;
 
 import javax.xml.namespace.QName;
@@ -101,7 +102,7 @@
             clazz.addProperty(prop);
         } else {
             CReferencePropertyInfo prop = new CReferencePropertyInfo(
-                    calcName(p),true,false/*TODO*/,null,null,p.getLocation());
+                    calcName(p),true,!optional,false/*TODO*/,null,null,p.getLocation(), false, false, false);
             rts.addTo(prop);
             clazz.addProperty(prop);
         }
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/DatatypeLib.java	Tue Aug  4 09:36:05 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/DatatypeLib.java	Tue Aug  4 09:36:05 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.relaxng;
 
 import java.util.HashMap;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/DefineFinder.java	Tue Aug  4 09:36:08 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/DefineFinder.java	Tue Aug  4 09:36:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.relaxng;
 
 import java.util.HashSet;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/NameCalculator.java	Tue Aug  4 09:36:10 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/NameCalculator.java	Tue Aug  4 09:36:09 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.relaxng;
 
 import com.sun.xml.internal.rngom.digested.DPatternWalker;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/RELAXNGCompiler.java	Tue Aug  4 09:36:12 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/RELAXNGCompiler.java	Tue Aug  4 09:36:12 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.relaxng;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/RawTypeSetBuilder.java	Tue Aug  4 09:36:14 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/RawTypeSetBuilder.java	Tue Aug  4 09:36:14 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.relaxng;
 
 import java.util.HashSet;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/TypePatternBinder.java	Tue Aug  4 09:36:17 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/TypePatternBinder.java	Tue Aug  4 09:36:17 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.relaxng;
 
 import java.util.HashSet;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/TypeUseBinder.java	Tue Aug  4 09:36:19 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/relaxng/TypeUseBinder.java	Tue Aug  4 09:36:19 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.relaxng;
 
 import com.sun.tools.internal.xjc.model.CBuiltinLeafInfo;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/Abstractifier.java	Tue Aug  4 09:36:22 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/Abstractifier.java	Tue Aug  4 09:36:21 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import com.sun.tools.internal.xjc.model.CElement;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BGMBuilder.java	Tue Aug  4 09:36:24 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BGMBuilder.java	Tue Aug  4 09:36:23 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import java.util.ArrayList;
@@ -435,6 +436,9 @@
      * Gets the {@link BIDom} object that applies to the given particle.
      */
     protected final BIDom getLocalDomCustomization( XSParticle p ) {
+        if (p == null) {
+            return null;
+        }
         BIDom dom = getBindInfo(p).get(BIDom.class);
         if(dom!=null)  return dom;
 
@@ -549,4 +553,12 @@
 
         return name;
     }
+
+    public boolean isGenerateMixedExtensions() {
+        if (globalBinding != null) {
+            return globalBinding.isGenerateMixedExtensions();
+        }
+        return false;
+    }
+
 }
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindBlue.java	Tue Aug  4 09:36:26 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindBlue.java	Tue Aug  4 09:36:26 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import com.sun.xml.internal.xsom.XSAttGroupDecl;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindGreen.java	Tue Aug  4 09:36:28 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindGreen.java	Tue Aug  4 09:36:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import java.util.Iterator;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindPurple.java	Tue Aug  4 09:36:30 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindPurple.java	Tue Aug  4 09:36:30 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import com.sun.tools.internal.xjc.model.CClassInfo;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindRed.java	Tue Aug  4 09:36:33 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindRed.java	Tue Aug  4 09:36:32 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import com.sun.tools.internal.xjc.reader.Ring;
@@ -48,21 +49,10 @@
 
     private final ComplexTypeFieldBuilder ctBuilder = Ring.get(ComplexTypeFieldBuilder.class);
 
-
-
-
-
-
-
-
-
-
     public void complexType(XSComplexType ct) {
         ctBuilder.build(ct);
     }
 
-
-
     public void wildcard(XSWildcard xsWildcard) {
         // TODO: implement this method later
         // I guess we might allow this to be mapped to a generic element property ---
@@ -85,8 +75,6 @@
         stb.refererStack.pop();
     }
 
-
-
 /*
     Components that can never be mapped to a class
 */
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindYellow.java	Tue Aug  4 09:36:35 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindYellow.java	Tue Aug  4 09:36:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import com.sun.xml.internal.xsom.XSAttGroupDecl;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindingComponent.java	Tue Aug  4 09:36:37 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/BindingComponent.java	Tue Aug  4 09:36:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import com.sun.tools.internal.xjc.reader.Ring;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ClassBinderFilter.java	Tue Aug  4 09:36:39 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ClassBinderFilter.java	Tue Aug  4 09:36:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import com.sun.tools.internal.xjc.model.CElement;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/CollisionInfo.java	Tue Aug  4 09:36:41 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/CollisionInfo.java	Tue Aug  4 09:36:41 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * @(#)$Id: CollisionInfo.java,v 1.1 2005/04/15 20:09:53 kohsuke Exp $
- */
-
-
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import org.xml.sax.Locator;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ColorBinder.java	Tue Aug  4 09:36:44 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ColorBinder.java	Tue Aug  4 09:36:43 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import com.sun.tools.internal.xjc.model.CClassInfo;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/DefaultParticleBinder.java	Tue Aug  4 09:36:46 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/DefaultParticleBinder.java	Tue Aug  4 09:36:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import java.util.ArrayList;
@@ -58,9 +59,9 @@
         if(checker.hasNameCollision()) {
             CReferencePropertyInfo prop = new CReferencePropertyInfo(
                 getCurrentBean().getBaseClass()==null?"Content":"Rest",
-                true, false, p,
+                true, false, false, p,
                 builder.getBindInfo(p).toCustomizationList(),
-                p.getLocator() );
+                p.getLocator(), false, false, false);
             RawTypeSetBuilder.build(p,false).addTo(prop);
             prop.javadoc = Messages.format( Messages.MSG_FALLBACK_JAVADOC,
                     checker.getCollisionInfo().toString() );
@@ -170,6 +171,12 @@
         }
 
         public void modelGroup(XSModelGroup mg) {
+            // choice gets mapped to a property
+            if(mg.getCompositor()== XSModelGroup.Compositor.CHOICE && builder.getGlobalBinding().isChoiceContentPropertyEnabled()) {
+                mark(outerParticle);
+                return;
+            }
+
             for( XSParticle child : mg.getChildren() )
                 particle(child);
         }
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ExpressionBuilder.java	Tue Aug  4 09:36:48 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ExpressionBuilder.java	Tue Aug  4 09:36:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import java.util.HashMap;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ExpressionParticleBinder.java	Tue Aug  4 09:36:50 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ExpressionParticleBinder.java	Tue Aug  4 09:36:50 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import java.util.Collection;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/GElement.java	Tue Aug  4 09:36:52 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/GElement.java	Tue Aug  4 09:36:52 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import java.util.HashSet;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/GElementImpl.java	Tue Aug  4 09:36:55 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/GElementImpl.java	Tue Aug  4 09:36:54 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/GWildcardElement.java	Tue Aug  4 09:36:57 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/GWildcardElement.java	Tue Aug  4 09:36:56 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import com.sun.tools.internal.xjc.reader.gbind.Element;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/MessageBundle.properties	Tue Aug  4 09:36:59 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/MessageBundle.properties	Tue Aug  4 09:36:59 2009
@@ -30,61 +30,66 @@
 
 
 BGMBuilder.NoGlobalElement = \
-	Schema contains no global element declaration.
+        Schema contains no global element declaration.
 
+UnusedCustomizationChecker.WarnUnusedExpectedContentTypes = \
+    An xmime:expectedContentTypes attribute is present on an incorrect element
+
 BGMBuilder.MultipleSchemaBindings = \
-	Multiple <schemaBindings> are defined for the target namespace "{0}"
+        Multiple <schemaBindings> are defined for the target namespace "{0}"
 
 BGMBuilder.MultipleSchemaBindings.Location = \
-	Another <schemaBindings> is defined here
+        Another <schemaBindings> is defined here
 
 
 
 ClassSelector.ClassNameIsRequired = \
-	Cannot derive a name from schema. A name attribute specified to the <class> customization.
+        Cannot derive a name from schema. A name attribute specified to the <class> customization.
 
 ClassSelector.IncorrectClassName = \
-	Specified name ''{0}'' is not a valid Java identifier.
+        Specified name ''{0}'' is not a valid Java identifier.
 
 ClassSelector.IncorrectPackageName = \
-	The package name ''{1}'' used for this schema is not a valid package name.
+        The package name ''{1}'' used for this schema is not a valid package name.
 
 ClassSelector.JavadocHeading = \
-	<p>Java class for {0}.\n\n<p>The following schema fragment specifies the expected \
-	content contained within this class.
+        <p>Java class for {0}.\n\n<p>The following schema fragment specifies the expected \
+        content contained within this class.
 
 ClassSelector.JavadocLineUnknown = \
-	unknown
+        unknown
 
 ClassSelector.ReservedClassName = \
-	Attempt to create a class having the same name as the reserved word "{0}".
+        Attempt to create a class having the same name as the reserved word "{0}".
 
 
 CollisionInfo.CollisionInfo = \
-	The field name "{0}" is used by two different parts of a schema. See: \n\
-	{1}\n\
-	{2}
+        The field name "{0}" is used by two different parts of a schema. See: \n\
+        {1}\n\
+        {2}
 
 CollisionInfo.UnknownFile = \
-	unknown file
+        unknown file
 
 CollisionInfo.LineXOfY = \
-	line {0} of {1}
+        line {0} of {1}
 
 
 ConversionFinder.CannotBeTypeSafeEnum = \
-	A type safe enum customization is specified to a simple type that cannot \
-	be mapped to a type safe enum.
+        A type safe enum customization is specified to a simple type that cannot \
+        be mapped to a type safe enum.
 ConversionFinder.CannotBeTypeSafeEnum.Location = \
-	Ths relevant simple type declaration is specified at this location
+        Ths relevant simple type declaration is specified at this location
 ConversionFinder.NoEnumNameAvailable = \
-	A name attribute is required to customize an anonymous simple type to type-safe enum.
+        A name attribute is required to customize an anonymous simple type to type-safe enum.
+ConversionFinder.NoEnumFacet= \
+    enum class customization is specified on a type that has no enumeration facet.
 ERR_ILLEGAL_EXPECTED_MIME_TYPE = \
-    Unable to parse the expected MIME type "{0}". {1}. 
+    Unable to parse the expected MIME type "{0}". {1}.
 
 
 DatatypeBuilder.DatatypeError = \
-	Simple type error: {0}
+        Simple type error: {0}
 
 
 
@@ -92,17 +97,17 @@
 
 
 DefaultParticleBinder.UnableToGenerateNameFromModelGroup = \
-	Unable to generate a property name from a model group. A customization is required.
+        Unable to generate a property name from a model group. A customization is required.
 
 DefaultParticleBinder.FallbackJavadoc = \
-	Gets the rest of the content model. \n\
-	\n\
-	<p>\n\
-	You are getting this "catch-all" property because of the following reason: \n\
-	{0}\n\
-	<p>\n\
-	To get rid of this property, apply a property customization to one \n\
-	of both of the following declarations to change their names: \n
+        Gets the rest of the content model. \n\
+        \n\
+        <p>\n\
+        You are getting this "catch-all" property because of the following reason: \n\
+        {0}\n\
+        <p>\n\
+        To get rid of this property, apply a property customization to one \n\
+        of both of the following declarations to change their names: \n
 
 
 
@@ -111,30 +116,30 @@
 
 
 FieldBuilder.IncorrectFixedValue = \
-	The value specified in the fixed attribute "{0}" is not a valid value for the datatype
+        The value specified in the fixed attribute "{0}" is not a valid value for the datatype
 
 FieldBuilder.IncorrectDefaultValue = \
-	The value specified in the default attribute "{0}" is not a valid value for the datatype
+        The value specified in the default attribute "{0}" is not a valid value for the datatype
 
 FieldBuilder.ConflictBetweenUserTypeAndActualType.AttUse = \
-	"{0}" is specified by a customization but this attribute has incompatible type "{1}"
+        "{0}" is specified by a customization but this attribute has incompatible type "{1}"
 
 FieldBuilder.ConflictBetweenUserTypeAndActualType.AttUse.Source = \
-	The relevant customization is specified	at this location
+        The relevant customization is specified at this location
 
 FieldBuilder.Javadoc.NilProperty = \
-	This property is used to control \
-	<a href="http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/#Nils">the xsi:nil feature</a> \
-	of W3C XML Schema. \nSetting this property to true will cause \
-	the output to be &lt;{0} xsi:nil="true" /> regardless of the \
-	values of the other properties.
+        This property is used to control \
+        <a href="http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/#Nils">the xsi:nil feature</a> \
+        of W3C XML Schema. \nSetting this property to true will cause \
+        the output to be &lt;{0} xsi:nil="true" /> regardless of the \
+        values of the other properties.
 
 FieldBuilder.Javadoc.ValueObject = \
-	get/set the complex type value associated with this element.\n \
-	when you unmarshal a document that contains xsi:type, the get{1} method \
-	would return an instance of derived classes of '{'@link {0}'}'. Similarly, if you set \
-	an instance of derived classes, then you would get the instance with xsi:type \
-	when you marshal out to XML.
+        get/set the complex type value associated with this element.\n \
+        when you unmarshal a document that contains xsi:type, the get{1} method \
+        would return an instance of derived classes of '{'@link {0}'}'. Similarly, if you set \
+        an instance of derived classes, then you would get the instance with xsi:type \
+        when you marshal out to XML.
 
 
 SimpleTypeBuilder.UnnestedJavaTypeCustomization = \
@@ -146,11 +151,11 @@
     \t</property>
 
 UnusedCustomizationChecker.UnacknolwedgedCustomization = \
-	compiler was unable to honor this {0} customization. It is attached to a wrong place, \
-	or it's inconsistent with other bindings.
+        compiler was unable to honor this {0} customization. It is attached to a wrong place, \
+        or it's inconsistent with other bindings.
 
 UnusedCustomizationChecker.UnacknolwedgedCustomization.Relevant = \
-	(the above customization is attached to the following location in the schema)
+        (the above customization is attached to the following location in the schema)
 
 ERR_ENUM_MEMBER_NAME_COLLISION = \
     Two enum members yield the same constant name {0}
@@ -160,7 +165,7 @@
 
 ERR_CANNOT_GENERATE_ENUM_NAME = \
     Cannot generate a constant name from the enumeration value "{0}". \
-    Use <jaxb:typesafeEnumMember name="..."/> to specify one. 
+    Use <jaxb:typesafeEnumMember name="..."/> to specify one.
 
 ERR_MULTIPLE_GLOBAL_BINDINGS = \
     only one globalBindings customization is allowed in a whole compilation
@@ -178,4 +183,3 @@
 
 ERR_REFERENCE_TO_NONEXPORTED_CLASS_REFERER = \
     (related to above) The problematic schema component is referenced from this component: {0}
- 
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/Messages.java	Tue Aug  4 09:37:01 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/Messages.java	Tue Aug  4 09:37:01 2009
@@ -43,6 +43,9 @@
     static final String WARN_NO_GLOBAL_ELEMENT =
         "BGMBuilder.NoGlobalElement";
 
+    public static final String WARN_UNUSED_EXPECTED_CONTENT_TYPES =
+        "UnusedCustomizationChecker.WarnUnusedExpectedContentTypes";
+
     static final String ERR_MULTIPLE_SCHEMA_BINDINGS =
         "BGMBuilder.MultipleSchemaBindings"; // arg:1
 
@@ -73,6 +76,9 @@
     static final String ERR_NO_ENUM_NAME_AVAILABLE =
         "ConversionFinder.NoEnumNameAvailable"; // arg:0
 
+    static final String ERR_NO_ENUM_FACET =
+        "ConversionFinder.NoEnumFacet"; // arg:0
+
     static final String ERR_ILLEGAL_EXPECTED_MIME_TYPE =
         "ERR_ILLEGAL_EXPECTED_MIME_TYPE"; // args:2
 
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/MultiplicityCounter.java	Tue Aug  4 09:37:03 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/MultiplicityCounter.java	Tue Aug  4 09:37:03 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import com.sun.tools.internal.xjc.model.Multiplicity;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/RawTypeSetBuilder.java	Tue Aug  4 09:37:06 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/RawTypeSetBuilder.java	Tue Aug  4 09:37:05 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import java.util.HashSet;
@@ -275,7 +276,12 @@
             if(parent.refs.size() > 1 && p.getAdapter() != null)
                 return RawTypeSet.Mode.MUST_BE_REFERENCE;
 
-            return RawTypeSet.Mode.SHOULD_BE_TYPEREF;
+            if(target.hasClass())
+                // if the CElementInfo was explicitly bound to a class (which happen if and only if
+                // the user requested so, then map that to reference property so that the user sees a class
+                return RawTypeSet.Mode.CAN_BE_TYPEREF;
+            else
+                return RawTypeSet.Mode.SHOULD_BE_TYPEREF;
         }
 
         protected boolean isListOfValues() {
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/RefererFinder.java	Tue Aug  4 09:37:08 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/RefererFinder.java	Tue Aug  4 09:37:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema;
 
 import java.util.HashMap;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/SimpleTypeBuilder.java	Tue Aug  4 09:37:10 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/SimpleTypeBuilder.java	Tue Aug  4 09:37:10 2009
@@ -51,6 +51,7 @@
 import com.sun.tools.internal.xjc.model.Model;
 import com.sun.tools.internal.xjc.model.TypeUse;
 import com.sun.tools.internal.xjc.model.TypeUseFactory;
+import com.sun.tools.internal.xjc.reader.Const;
 import com.sun.tools.internal.xjc.reader.Ring;
 import com.sun.tools.internal.xjc.reader.xmlschema.bindinfo.BIConversion;
 import com.sun.tools.internal.xjc.reader.xmlschema.bindinfo.BIEnum;
@@ -122,6 +123,13 @@
     public final Stack<XSComponent> refererStack = new Stack<XSComponent>();
 
     /**
+     * Records what xmime:expectedContentTypes annotations we honored and processed,
+     * so that we can later check if the user had these annotations in the places
+     * where we didn't anticipate them.
+     */
+    private final Set<XSComponent> acknowledgedXmimeContentTypes = new HashSet<XSComponent>();
+
+    /**
      * The type that was originally passed to this {@link SimpleTypeBuilder#build(XSSimpleType)}.
      * Never null.
      */
@@ -289,7 +297,7 @@
         public TypeUse unionSimpleType(XSUnionSimpleType type) {
             boolean isCollection = false;
             for( int i=0; i<type.getMemberSize(); i++ )
-                if(type.getMember(i).getVariety()==XSVariety.LIST) {
+                if(type.getMember(i).getVariety()==XSVariety.LIST || type.getMember(i).getVariety()==XSVariety.UNION) {
                     isCollection = true;
                     break;
                 }
@@ -369,6 +377,15 @@
         }
 
 
+//        // Issue 558 .. ugly fix; see https://wsit-docs.dev.java.net/releases/1-0-FCS/DataBinding5.html and https://jaxb.dev.java.net/issues/show_bug.cgi?id=558
+//        // need to check specification
+//        if (type.isSimpleType() && builder.getGlobalBinding().isSimpleTypeSubstitution() &&
+//                type.isGlobal() && type.getName() != null &&
+//                (type.getName().equals("unsignedInt") || type.getName().equals("unsignedShort") || type.getName().equals("unsignedByte"))) {
+//                // !type.getName().equals("anySimpleType") && !type.getName().equals("string")) {
+//            return (CNonElement) getClassSelector()._bindToClass(type, type.getSimpleBaseType(), false);
+//        }
+
         // if the type is built in, look for the default binding
         if(type.getTargetNamespace().equals(WellKnownNamespace.XML_SCHEMA)) {
             String name = type.getName();
@@ -584,6 +601,10 @@
                 break;
             }
         }
+        if(memberList.isEmpty()) {
+            getErrorReporter().error( loc, Messages.ERR_NO_ENUM_FACET );
+            return null;
+        }
 
         // use the name of the simple type as the name of the class.
         CClassInfoParent scope;
@@ -616,10 +637,15 @@
     private List<CEnumConstant> buildCEnumConstants(XSRestrictionSimpleType type, boolean needsToGenerateMemberName, Map<String, BIEnumMember> members, XSFacet[] errorRef) {
         List<CEnumConstant> memberList = new ArrayList<CEnumConstant>();
         int idx=1;
+        Set<String> enums = new HashSet<String>(); // to avoid duplicates. See issue #366
+
         for( XSFacet facet : type.getDeclaredFacets(XSFacet.FACET_ENUMERATION)) {
             String name=null;
-            String mdoc=null;
+            String mdoc=builder.getBindInfo(facet).getDocumentation();
 
+            if(!enums.add(facet.getValue().value))
+                continue;   // ignore the 2nd occasion
+
             if( needsToGenerateMemberName ) {
                 // generate names for all member names.
                 // this will even override names specified by the user. that's crazy.
@@ -739,8 +765,9 @@
      */
     private TypeUse lookupBinaryTypeBinding() {
         XSComponent referer = getReferer();
-        String emt = referer.getForeignAttribute(XML_MIME_URI,"expectedContentTypes");
+        String emt = referer.getForeignAttribute(XML_MIME_URI, Const.EXPECTED_CONTENT_TYPES);
         if(emt!=null) {
+            acknowledgedXmimeContentTypes.add(referer);
             try {
                 // see http://www.xml.com/lpt/a/2004/07/21/dive.html
                 List<MimeTypeRange> types = MimeTypeRange.parseRanges(emt);
@@ -772,6 +799,10 @@
         return CBuiltinLeafInfo.BASE64_BYTE_ARRAY;
     }
 
+    public boolean isAcknowledgedXmimeContentTypes(XSComponent c) {
+        return acknowledgedXmimeContentTypes.contains(c);
+    }
+
     /**
      * Returns true if the specified sub-type is an XML type.
      */
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/UnusedCustomizationChecker.java	Tue Aug  4 09:37:12 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/UnusedCustomizationChecker.java	Tue Aug  4 09:37:12 2009
@@ -29,8 +29,10 @@
 import java.util.Map;
 import java.util.Set;
 
+import com.sun.tools.internal.xjc.reader.Const;
 import com.sun.tools.internal.xjc.reader.Ring;
 import com.sun.tools.internal.xjc.reader.xmlschema.bindinfo.BIDeclaration;
+import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 import com.sun.xml.internal.xsom.XSAnnotation;
 import com.sun.xml.internal.xsom.XSAttContainer;
 import com.sun.xml.internal.xsom.XSAttGroupDecl;
@@ -60,11 +62,17 @@
 /**
  * Reports all unacknowledged customizations as errors.
  *
+ * <p>
+ * Since we scan the whole content tree, we use this to check for unused
+ * <tt>xmime:expectedContentTypes</tt> attributes. TODO: if we find this kind of error checks more
+ * common, use the visitors so that we don't have to mix everything in one class.
+ *
  * @author
  *     Kohsuke Kawaguchi (kohsuke.kawaguchi@sun.com)
  */
 class UnusedCustomizationChecker extends BindingComponent implements XSVisitor, XSSimpleTypeVisitor {
     private final BGMBuilder builder = Ring.get(BGMBuilder.class);
+    private final SimpleTypeBuilder stb = Ring.get(SimpleTypeBuilder.class);
 
     private final Set<XSComponent> visitedComponents = new HashSet<XSComponent>();
 
@@ -102,9 +110,24 @@
         for( BIDeclaration decl : builder.getBindInfo(c).getDecls() )
             check(decl, c);
 
+        checkExpectedContentTypes(c);
+
         return true;
     }
 
+    private void checkExpectedContentTypes(XSComponent c) {
+        if(c.getForeignAttribute(WellKnownNamespace.XML_MIME_URI, Const.EXPECTED_CONTENT_TYPES)==null)
+            return; // no such attribute
+        if(c instanceof XSParticle)
+            return; // particles get the same foreign attributes as local element decls,
+                    // so we need to skip them
+
+        if(!stb.isAcknowledgedXmimeContentTypes(c)) {
+            // this is not used
+            getErrorReporter().warning(c.getLocator(),Messages.WARN_UNUSED_EXPECTED_CONTENT_TYPES);
+        }
+    }
+
     private void check(BIDeclaration decl, XSComponent c) {
         if( !decl.isAcknowledged() ) {
             getErrorReporter().error(
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/AnnotationParserFactoryImpl.java	Tue Aug  4 09:37:14 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/AnnotationParserFactoryImpl.java	Tue Aug  4 09:37:14 2009
@@ -31,11 +31,11 @@
 import javax.xml.validation.ValidatorHandler;
 
 import com.sun.tools.internal.xjc.Options;
-import com.sun.tools.internal.xjc.SchemaCache;
 import com.sun.tools.internal.xjc.reader.Const;
 import com.sun.xml.internal.xsom.parser.AnnotationContext;
 import com.sun.xml.internal.xsom.parser.AnnotationParser;
 import com.sun.xml.internal.xsom.parser.AnnotationParserFactory;
+import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 
 import org.xml.sax.Attributes;
 import org.xml.sax.ContentHandler;
@@ -42,6 +42,7 @@
 import org.xml.sax.EntityResolver;
 import org.xml.sax.ErrorHandler;
 import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
 import org.xml.sax.helpers.XMLFilterImpl;
 
 /**
@@ -102,11 +103,22 @@
                             validator.setErrorHandler(errorHandler);
                             startForking(uri,localName,qName,atts,new ValidatorProtecter(validator));
                         }
+
+                        // check for xmime:expectedContentTypes attributes in annotations and report them
+                        for( int i=atts.getLength()-1; i>=0; i-- ) {
+                            if(atts.getURI(i).equals(WellKnownNamespace.XML_MIME_URI)
+                            && atts.getLocalName(i).equals(Const.EXPECTED_CONTENT_TYPES))
+                                errorHandler.warning(new SAXParseException(
+                                    com.sun.tools.internal.xjc.reader.xmlschema.Messages.format(
+                                        com.sun.tools.internal.xjc.reader.xmlschema.Messages.WARN_UNUSED_EXPECTED_CONTENT_TYPES),
+                                    getDocumentLocator()
+                                ));
+                        }
                     }
                 };
             }
 
-            public Object getResult( Object existing ) {
+            public BindInfo getResult( Object existing ) {
                 if(handler==null)
                     // interface contract violation.
                     // the getContentHandler method must have been called.
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIConversion.java	Tue Aug  4 09:37:17 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIConversion.java	Tue Aug  4 09:37:16 2009
@@ -254,9 +254,11 @@
         private String printMethodFor(XSSimpleType owner) {
             if(printMethod!=null)   return printMethod;
 
-            String method = getConversionMethod("print",owner);
-            if(method!=null)
-                return method;
+            if(inMemoryType.unboxify().isPrimitive()) {
+                String method = getConversionMethod("print",owner);
+                if(method!=null)
+                    return method;
+            }
 
             return "toString";
         }
@@ -264,10 +266,12 @@
         private String parseMethodFor(XSSimpleType owner) {
             if(parseMethod!=null)   return parseMethod;
 
-            String method = getConversionMethod("parse", owner);
-            if(method!=null) {
-                // this cast is necessary for conversion between primitive Java types
-                return '('+inMemoryType.unboxify().fullName()+')'+method;
+            if(inMemoryType.unboxify().isPrimitive()) {
+                String method = getConversionMethod("parse", owner);
+                if(method!=null) {
+                    // this cast is necessary for conversion between primitive Java types
+                    return '('+inMemoryType.unboxify().fullName()+')'+method;
+                }
             }
 
             return "new";
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIGlobalBinding.java	Tue Aug  4 09:37:19 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIGlobalBinding.java	Tue Aug  4 09:37:19 2009
@@ -120,6 +120,10 @@
         return generateElementClass;
     }
 
+    public boolean isGenerateMixedExtensions() {
+        return generateMixedExtensions;
+    }
+
     public boolean isChoiceContentPropertyEnabled() {
         return choiceContentProperty;
     }
@@ -285,6 +289,9 @@
     @XmlAttribute
     boolean generateElementClass = false;
 
+    @XmlAttribute
+    boolean generateMixedExtensions = false;
+
     @XmlElement(namespace=Const.XJC_EXTENSION_URI)
     Boolean generateElementProperty = null;
 
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIProperty.java	Tue Aug  4 09:37:21 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIProperty.java	Tue Aug  4 09:37:21 2009
@@ -291,7 +291,9 @@
                 name = JJavaName.getPluralForm(name);
         }
 
-        return wrapUp(new CValuePropertyInfo(name, source,getCustomizations(source),source.getLocator(), tu, typeName ),source);
+        CValuePropertyInfo prop = wrapUp(new CValuePropertyInfo(name, source, getCustomizations(source), source.getLocator(), tu, typeName), source);
+        BIInlineBinaryData.handle(source, prop);
+        return prop;
     }
 
     public CAttributePropertyInfo createAttributeProperty( XSAttributeUse use, TypeUse tu ) {
@@ -353,17 +355,48 @@
 
         types.addTo(prop);
 
+        BIInlineBinaryData.handle(source.getTerm(), prop);
         return prop;
     }
 
+    public CReferencePropertyInfo createDummyExtendedMixedReferenceProperty(
+            String defaultName, XSComponent source, RawTypeSet types) {
+            return createReferenceProperty(
+                    defaultName,
+                    false,
+                    source,
+                    types,
+                    true,
+                    true,
+                    false,
+                    true);
+    }
+
+    public CReferencePropertyInfo createContentExtendedMixedReferenceProperty(
+            String defaultName, XSComponent source, RawTypeSet types) {
+            return createReferenceProperty(
+                    defaultName,
+                    false,
+                    source,
+                    types,
+                    true,
+                    false,
+                    true,
+                    true);
+    }
+
     public CReferencePropertyInfo createReferenceProperty(
             String defaultName, boolean forConstant, XSComponent source,
-            RawTypeSet types, boolean isMixed) {
+            RawTypeSet types, boolean isMixed, boolean dummy, boolean content, boolean isMixedExtended) {
 
-        if(!types.refs.isEmpty())
-            // if this property is empty, don't acknowleedge the customization
-            // this allows pointless property customization to be reported as an error
-            markAsAcknowledged();
+        if (types == null) {    // this is a special case where we need to generate content because potential subtypes would need to be able to override what's store inside
+            content = true;
+        } else {
+            if(!types.refs.isEmpty())
+                // if this property is empty, don't acknowleedge the customization
+                // this allows pointless property customization to be reported as an error
+                markAsAcknowledged();
+        }
         constantPropertyErrorCheck();
 
         String name = getPropertyName(forConstant);
@@ -371,15 +404,19 @@
             name = defaultName;
 
         CReferencePropertyInfo prop = wrapUp(
-            new CReferencePropertyInfo(
-                name,
-                types.getCollectionMode().isRepeated()||isMixed,
-                isMixed, source,
-                getCustomizations(source), source.getLocator() ),
-            source);
+                                            new CReferencePropertyInfo(
+                                                name,
+                                                (types == null) ? true : types.getCollectionMode().isRepeated()||isMixed,
+                                                (types == null) ? false : types.isRequired(),
+                                                isMixed,
+                                                source,
+                                                getCustomizations(source), source.getLocator(), dummy, content, isMixedExtended),
+                                        source);
+        if (types != null) {
+            types.addTo(prop);
+        }
 
-        types.addTo(prop);
-
+        BIInlineBinaryData.handle(source, prop);
         return prop;
     }
 
@@ -407,7 +444,7 @@
         }
 
         if(generateRef) {
-            return createReferenceProperty(defaultName,forConstant,source,types, false);
+            return createReferenceProperty(defaultName,forConstant,source,types, false, false, false, false);
         } else {
             return createElementProperty(defaultName,forConstant,source,types);
         }
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIXDom.java	Tue Aug  4 09:37:24 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIXDom.java	Tue Aug  4 09:37:23 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
 
 import javax.xml.bind.annotation.XmlAttribute;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIXPluginCustomization.java	Tue Aug  4 09:37:26 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIXPluginCustomization.java	Tue Aug  4 09:37:25 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIXSubstitutable.java	Tue Aug  4 09:37:28 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIXSubstitutable.java	Tue Aug  4 09:37:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
 
 import javax.xml.bind.annotation.XmlRootElement;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BindInfo.java	Tue Aug  4 09:37:30 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BindInfo.java	Tue Aug  4 09:37:30 2009
@@ -29,7 +29,6 @@
 import java.io.StringWriter;
 import java.io.Writer;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 
@@ -53,7 +52,6 @@
 import com.sun.tools.internal.xjc.reader.Ring;
 import com.sun.tools.internal.xjc.reader.xmlschema.BGMBuilder;
 import com.sun.xml.internal.bind.annotation.XmlLocation;
-import com.sun.xml.internal.bind.api.TypeReference;
 import com.sun.xml.internal.bind.marshaller.MinimumEscapeHandler;
 import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 import com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl;
@@ -82,7 +80,7 @@
     /**
      * Documentation taken from &lt;xs:documentation>s.
      */
-    @XmlElement
+    @XmlElement(namespace=WellKnownNamespace.XML_SCHEMA)
     private Documentation documentation;
 
     /**
@@ -146,7 +144,7 @@
 
 
     // only used by JAXB
-    @XmlElement
+    @XmlElement(namespace=WellKnownNamespace.XML_SCHEMA)
     void setAppinfo(AppInfo aib) {
         aib.addTo(this);
     }
@@ -318,7 +316,7 @@
         synchronized(AnnotationParserFactoryImpl.class) {
             try {
                 if(customizationContext==null)
-                    customizationContext = new JAXBContextImpl(
+                    customizationContext = new JAXBContextImpl.JAXBContextBuilder().setClasses(
                         new Class[] {
                             BindInfo.class, // for xs:annotation
                             BIClass.class,
@@ -325,6 +323,8 @@
                             BIConversion.User.class,
                             BIConversion.UserAdapter.class,
                             BIDom.class,
+                            BIFactoryMethod.class,
+                            BIInlineBinaryData.class,
                             BIXDom.class,
                             BIXSubstitutable.class,
                             BIEnum.class,
@@ -332,8 +332,7 @@
                             BIGlobalBinding.class,
                             BIProperty.class,
                             BISchemaBinding.class
-                        }, Collections.<TypeReference>emptyList(),
-                            Collections.<Class,Class>emptyMap(), null, false, null, false, false);
+                        }).build();
                 return customizationContext;
             } catch (JAXBException e) {
                 throw new AssertionError(e);
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/CollectionTypeAttribute.java	Tue Aug  4 09:37:32 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/CollectionTypeAttribute.java	Tue Aug  4 09:37:32 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
 
 import javax.xml.bind.annotation.XmlTransient;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/DomHandlerEx.java	Tue Aug  4 09:37:35 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/DomHandlerEx.java	Tue Aug  4 09:37:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
 
 import javax.xml.bind.ValidationEventHandler;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/EnumMemberMode.java	Tue Aug  4 09:37:37 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/EnumMemberMode.java	Tue Aug  4 09:37:36 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
 
 import javax.xml.bind.annotation.XmlEnum;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/ForkingFilter.java	Tue Aug  4 09:37:39 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/ForkingFilter.java	Tue Aug  4 09:37:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
 
 import java.util.ArrayList;
@@ -80,6 +81,10 @@
         this.loc = locator;
     }
 
+    public Locator getDocumentLocator() {
+        return loc;
+    }
+
     public void startDocument() throws SAXException {
         reset();
         super.startDocument();
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/LocalScoping.java	Tue Aug  4 09:37:41 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/LocalScoping.java	Tue Aug  4 09:37:41 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
 
 import javax.xml.bind.annotation.XmlEnumValue;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/MessageBundle.properties	Tue Aug  4 09:37:44 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/MessageBundle.properties	Tue Aug  4 09:37:43 2009
@@ -29,25 +29,24 @@
 
 
 NGCCRuntimeEx.Unimplemented = \
-	The "{0}" feature is not implemented yet
+        The "{0}" feature is not implemented yet
 
 NGCCRuntimeEx.Unsupported = \
-	The "{0}" feature is an unsupported optional feature
+        The "{0}" feature is an unsupported optional feature
 
 NGCCRuntimeEx.UndefinedPrefix = \
-	Prefix "{0}" is undefined
+        Prefix "{0}" is undefined
 
 
 
 MagicTransducer.AttributeRequired = \
-	parseMethod/printMethod attributes are both required.
+        parseMethod/printMethod attributes are both required.
 
 ERR_ILLEGAL_FIXEDATTR = \
-	fixedAttributeAsConstantProperty is allowed only with attributes with a fixed value constraint.
+        fixedAttributeAsConstantProperty is allowed only with attributes with a fixed value constraint.
 
 ERR_UNDEFINED_SIMPLE_TYPE = \
-	undefined simple type "{0}".
+        undefined simple type "{0}".
 
 ERR_CANNOT_BE_BOUND_TO_SIMPLETYPE = \
     Simple type "{0}" is not allowed by the spec to be bound to a type-safe enum.
- 
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/OptionalPropertyMode.java	Tue Aug  4 09:37:46 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/OptionalPropertyMode.java	Tue Aug  4 09:37:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
 
 import javax.xml.bind.annotation.XmlEnumValue;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/binding.rng	Tue Aug  4 09:37:48 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/binding.rng	Tue Aug  4 09:37:48 2009
@@ -215,6 +215,7 @@
       private boolean xSimpleMode;
       private boolean generateValueClass = true;
       private boolean generateElementClass = false;
+      private boolean generateMixedExtensions = false;
 
       public BIGlobalBinding makeResult() {
         if( enumBaseTypes.size()==0 )
@@ -359,6 +360,12 @@
         </attribute>
       </optional>
 
+      <optional>
+        <attribute name="generateMixedExtensions">
+          value = <data type="boolean"/>
+          generateMixedExtensions = $runtime.parseBoolean(value);
+        </attribute>
+      </optional>
 
       <!-- unimplemented attributes -->
       <optional>
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/binding.xsd	Tue Aug  4 09:37:50 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/binding.xsd	Tue Aug  4 09:37:50 2009
@@ -23,8 +23,16 @@
  CA 95054 USA or visit www.sun.com if you need additional information or
  have any questions.
 -->
+
+
 <!-- THIS IS A GENERATED FILE. DO NOT MODIFY. -->
 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://java.sun.com/xml/ns/jaxb" xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc">
+  <xs:annotation>
+    <xs:documentation>
+      JAXB customization schema
+    </xs:documentation>
+  </xs:annotation>
+  
   <xs:import namespace="http://java.sun.com/xml/ns/jaxb/xjc" schemaLocation="xjc.xsd"/>
   <xs:import namespace="http://www.w3.org/2001/XMLSchema" schemaLocation="xs.xsd"/>
   <xs:element name="bindings">
@@ -38,6 +46,11 @@
   </xs:element>
   <xs:element name="declaration" abstract="true"/>
   <xs:element name="globalBindings" substitutionGroup="jaxb:declaration">
+    <xs:annotation>
+      <xs:documentation>
+        Defines global customization. Only one of this is allowed per compilation.
+      </xs:documentation>
+    </xs:annotation>
     <xs:complexType>
       <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="javaType">
@@ -122,6 +135,7 @@
       <xs:attribute name="choiceContentProperty" type="xs:boolean"/>
       <xs:attribute name="generateValueClass" type="xs:boolean"/>
       <xs:attribute name="generateElementClass" type="xs:boolean"/>
+      <xs:attribute name="generateMixedExtensions" type="xs:boolean"/>
       <xs:attribute name="generateElementProperty" type="xs:boolean"/>
       <xs:attribute name="enableValidation" type="xs:boolean"/>
       <xs:attribute name="enableFailFastCheck" type="xs:boolean"/>
@@ -277,6 +291,28 @@
       <xs:attribute name="type" default="w3c"/>
     </xs:complexType>
   </xs:element>
+
+  <xs:element name="inlineBinaryData">
+    <xs:annotation><xs:documentation><![CDATA[
+      Disable binary optimization.
+
+      Used on elements like <xs:element name="foo" type="xs:base64Binary"/> to indicate
+      that this base64 binary data is always inlined and never subjected to the binary
+      transfer optimization (such as XOP/MTOM)
+    ]]></xs:documentation></xs:annotation>
+    <xs:complexType />
+  </xs:element>
+
+  <xs:element name="factoryMethod">
+    <xs:annotation><xs:documentation><![CDATA[
+      Controls the name of the factory method on ObjectFactory. 
+    ]]></xs:documentation></xs:annotation>
+    <xs:complexType>
+      <xs:sequence />
+      <xs:attribute name="name" type="xs:string" use="required" />
+    </xs:complexType>
+  </xs:element>
+
   <xs:group name="anyContents">
     <xs:sequence>
       <xs:any minOccurs="0" maxOccurs="unbounded" processContents="skip"/>
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/package-info.java	Tue Aug  4 09:37:53 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/package-info.java	Tue Aug  4 09:37:52 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 @XmlSchema(elementFormDefault = QUALIFIED, namespace=Const.JAXB_NSURI)
 package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
 
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/package.html	Tue Aug  4 09:37:55 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/package.html	Tue Aug  4 09:37:54 2009
@@ -26,8 +26,8 @@
 Object Model that represents customization declarations.
 
 <p>
-	<a href="http://relaxngcc.sourceforge.net/">RelaxNGCC</a> is used to parse
-	XML syntax into this representation, and the other parts of XJC will use
-	this object model.
+        <a href="http://relaxngcc.sourceforge.net/">RelaxNGCC</a> is used to parse
+        XML syntax into this representation, and the other parts of XJC will use
+        this object model.
 </p>
 </body>
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/xjc.xsd	Tue Aug  4 09:37:57 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/xjc.xsd	Tue Aug  4 09:37:57 2009
@@ -23,6 +23,8 @@
  CA 95054 USA or visit www.sun.com if you need additional information or
  have any questions.
 -->
+
+
 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://java.sun.com/xml/ns/jaxb/xjc" xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc">
   <xs:import namespace="http://java.sun.com/xml/ns/jaxb" schemaLocation="binding.xsd"/>
   <xs:import namespace="http://www.w3.org/2001/XMLSchema" schemaLocation="xs.xsd"/>
@@ -80,6 +82,8 @@
     </xs:sequence>
   </xs:group>
 
+  <xs:element name="allowMixedTypeExtensions" type="xs:boolean" />
+  
   <xs:element name="generateElementProperty" type="xs:boolean" />
   <xs:element name="dom">
     <xs:complexType>
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/xs.xsd	Tue Aug  4 09:37:59 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/xs.xsd	Tue Aug  4 09:37:59 2009
@@ -23,6 +23,8 @@
  CA 95054 USA or visit www.sun.com if you need additional information or
  have any questions.
 -->
+
+
 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://www.w3.org/2001/XMLSchema" xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc">
   <xs:import namespace="http://java.sun.com/xml/ns/jaxb" schemaLocation="binding.xsd"/>
   <xs:import namespace="http://java.sun.com/xml/ns/jaxb/xjc" schemaLocation="xjc.xsd"/>
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/ChoiceContentComplexTypeBuilder.java	Tue Aug  4 09:38:01 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/ChoiceContentComplexTypeBuilder.java	Tue Aug  4 09:38:01 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.ct;
 
 import java.util.Collections;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/ComplexTypeBindingMode.java	Tue Aug  4 09:38:04 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/ComplexTypeBindingMode.java	Tue Aug  4 09:38:03 2009
@@ -47,7 +47,14 @@
      * If a complex type has falled back to the rest content and
      * it is not NOMOREEXTENSION.
      */
-    FALLBACK_REST
+    FALLBACK_REST,
+
+    /**
+     * If a complex type has fallen to the dummy property in order
+     * to override previously inherited content.
+     */
+    FALLBACK_EXTENSION
+
 //
 //    /**
 //     * If a complex type is derived by restriction from a complex type
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/ComplexTypeFieldBuilder.java	Tue Aug  4 09:38:06 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/ComplexTypeFieldBuilder.java	Tue Aug  4 09:38:05 2009
@@ -48,7 +48,8 @@
      * Builders are tried in this order, to put specific ones first.
      */
     private final CTBuilder[] complexTypeBuilders = new CTBuilder[]{
-        new ChoiceContentComplexTypeBuilder(),
+//        new ChoiceContentComplexTypeBuilder(),
+        new MixedExtendedComplexTypeBuilder(),
         new MixedComplexTypeBuilder(),
         new FreshComplexTypeBuilder(),
         new ExtendedComplexTypeBuilder(),
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/ExtendedComplexTypeBuilder.java	Tue Aug  4 09:38:08 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/ExtendedComplexTypeBuilder.java	Tue Aug  4 09:38:08 2009
@@ -24,28 +24,12 @@
  */
 package com.sun.tools.internal.xjc.reader.xmlschema.ct;
 
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
 
-import com.sun.tools.internal.xjc.model.CClassInfo;
 import com.sun.tools.internal.xjc.model.CClass;
-import com.sun.tools.internal.xjc.reader.xmlschema.WildcardNameClassBuilder;
-import com.sun.xml.internal.xsom.XSAttributeUse;
 import com.sun.xml.internal.xsom.XSComplexType;
 import com.sun.xml.internal.xsom.XSContentType;
-import com.sun.xml.internal.xsom.XSDeclaration;
-import com.sun.xml.internal.xsom.XSElementDecl;
-import com.sun.xml.internal.xsom.XSModelGroup;
-import com.sun.xml.internal.xsom.XSModelGroupDecl;
-import com.sun.xml.internal.xsom.XSParticle;
 import com.sun.xml.internal.xsom.XSType;
-import com.sun.xml.internal.xsom.XSWildcard;
-import com.sun.xml.internal.xsom.visitor.XSTermFunction;
 
-import com.sun.xml.internal.rngom.nc.ChoiceNameClass;
-import com.sun.xml.internal.rngom.nc.NameClass;
-import com.sun.xml.internal.rngom.nc.SimpleNameClass;
 
 /**
  * Binds a complex type derived from another complex type by extension.
@@ -53,15 +37,8 @@
  * @author
  *     Kohsuke Kawaguchi (kohsuke.kawaguchi@sun.com)
  */
-final class ExtendedComplexTypeBuilder extends CTBuilder {
+final class ExtendedComplexTypeBuilder extends AbstractExtendedComplexTypeBuilder {
 
-    /**
-     * Map from {@link XSComplexType} to {@link NameClass}[2] that
-     * represents the names used in its child elements [0] and
-     * attributes [1].
-     */
-    private final Map<XSComplexType,NameClass[]> characteristicNameClasses = new HashMap<XSComplexType,NameClass[]>();
-
     public boolean isApplicable(XSComplexType ct) {
         XSType baseType = ct.getBaseType();
         return baseType!=schemas.getAnyType()
@@ -73,8 +50,8 @@
         XSComplexType baseType = ct.getBaseType().asComplexType();
 
         // build the base class
-        CClass baseClass = selector.bindToType(baseType,ct,true);
-        assert baseClass!=null;   // global complex type must map to a class
+        CClass baseClass = selector.bindToType(baseType, ct, true);
+        assert baseClass != null;   // global complex type must map to a class
 
         selector.getCurrentBean().setBaseClass(baseClass);
 
@@ -83,26 +60,23 @@
 
         XSContentType explicitContent = ct.getExplicitContent();
 
-        if(!checkIfExtensionSafe(baseType,ct)) {
+        if (!checkIfExtensionSafe(baseType, ct)) {
             // error. We can't handle any further extension
-            errorReceiver.error( ct.getLocator(),
-                Messages.ERR_NO_FURTHER_EXTENSION.format(
+            errorReceiver.error(ct.getLocator(),
+                    Messages.ERR_NO_FURTHER_EXTENSION.format(
                     baseType.getName(), ct.getName() )
             );
             return;
         }
 
-
         // explicit content is always either empty or a particle.
-        if( explicitContent!=null && explicitContent.asParticle()!=null ) {
-
-            if( baseTypeFlag==ComplexTypeBindingMode.NORMAL) {
+        if (explicitContent != null && explicitContent.asParticle() != null) {
+            if (baseTypeFlag == ComplexTypeBindingMode.NORMAL) {
                 // if we have additional explicit content, process them.
-
                 builder.recordBindingMode(ct,
-                    bgmBuilder.getParticleBinder().checkFallback(explicitContent.asParticle())
-                    ?ComplexTypeBindingMode.FALLBACK_REST
-                    :ComplexTypeBindingMode.NORMAL);
+                        bgmBuilder.getParticleBinder().checkFallback(explicitContent.asParticle())
+                        ? ComplexTypeBindingMode.FALLBACK_REST
+                        : ComplexTypeBindingMode.NORMAL);
 
                 bgmBuilder.getParticleBinder().build(explicitContent.asParticle());
 
@@ -113,7 +87,7 @@
             }
         } else {
             // if it's empty, no additional processing is necessary
-            builder.recordBindingMode(ct, baseTypeFlag );
+            builder.recordBindingMode(ct, baseTypeFlag);
         }
 
         // adds attributes and we are through.
@@ -120,158 +94,4 @@
         green.attContainer(ct);
     }
 
-    /**
-     * Checks if this new extension is safe.
-     *
-     * UGLY.
-     * <p>
-     * If you have ctA extending ctB and ctB restricting ctC, our
-     * Java classes will look like CtAImpl extending CtBImpl
-     * extending CtCImpl.
-     *
-     * <p>
-     * Since a derived class unmarshaller uses the base class unmarshaller,
-     * this could potentially result in incorrect unmarshalling.
-     * We used to just reject such a case, but then we found that
-     * there are schemas that are using it.
-     *
-     * <p>
-     * One generalized observation that we reached is that if the extension
-     * is only adding new elements/attributes which has never been used
-     * in any of its base class (IOW, if none of the particle / attribute use /
-     * attribute wildcard can match the name of newly added elements/attributes)
-     * then it is safe to add them.
-     *
-     * <p>
-     * This function checks if the derivation chain to this type is
-     * not using restriction, and if it is, then checks if it is safe
-     * according to the above condition.
-     *
-     * @return false
-     *      If this complex type needs to be rejected.
-     */
-    private boolean checkIfExtensionSafe( XSComplexType baseType, XSComplexType thisType ) {
-        XSComplexType lastType = getLastRestrictedType(baseType);
-
-        if(lastType==null)
-            return true;    // no restriction in derivation chain
-
-        NameClass anc = NameClass.NULL;
-        // build name class for attributes in new complex type
-        Iterator itr = thisType.iterateDeclaredAttributeUses();
-        while( itr.hasNext() )
-            anc = new ChoiceNameClass( anc, getNameClass(((XSAttributeUse)itr.next()).getDecl()) );
-        // TODO: attribute wildcard
-
-        NameClass enc = getNameClass(thisType.getExplicitContent());
-
-        // check against every base type ... except the root anyType
-        while(lastType!=lastType.getBaseType()) {
-            if(checkCollision(anc,enc,lastType))
-                return false;
-
-            if(lastType.getBaseType().isSimpleType())
-                // if the base type is a simple type, there won't be
-                // any further name collision.
-                return true;
-
-            lastType = lastType.getBaseType().asComplexType();
-        }
-
-
-
-        return true;    // OK
-    }
-
-    /**
-     * Checks if the particles/attributes defined in the type parameter
-     * collides with the name classes of anc/enc.
-     *
-     * @return true if there's a collision.
-     */
-    private boolean checkCollision(NameClass anc, NameClass enc, XSComplexType type) {
-        NameClass[] chnc = characteristicNameClasses.get(type);
-        if(chnc==null) {
-            chnc = new NameClass[2];
-            chnc[0] = getNameClass(type.getContentType());
-
-            // build attribute name classes
-            NameClass nc = NameClass.NULL;
-            Iterator itr = type.iterateAttributeUses();
-            while( itr.hasNext() )
-                anc = new ChoiceNameClass( anc, getNameClass(((XSAttributeUse)itr.next()).getDecl()) );
-            XSWildcard wc = type.getAttributeWildcard();
-            if(wc!=null)
-                nc = new ChoiceNameClass( nc, WildcardNameClassBuilder.build(wc) );
-            chnc[1] = nc;
-
-            characteristicNameClasses.put(type,chnc);
-        }
-
-        return chnc[0].hasOverlapWith(enc) || chnc[1].hasOverlapWith(anc);
-    }
-
-    /**
-     * Gets a {@link NameClass} that represents all the terms in the given content type.
-     * If t is not a particle, just return an empty name class.
-     */
-    private NameClass getNameClass( XSContentType t ) {
-        if(t==null) return NameClass.NULL;
-        XSParticle p = t.asParticle();
-        if(p==null) return NameClass.NULL;
-        else        return p.getTerm().apply(contentModelNameClassBuilder);
-    }
-
-    /**
-     * Gets a {@link SimpleNameClass} from the name of a {@link XSDeclaration}.
-     */
-    private NameClass getNameClass( XSDeclaration decl ) {
-        return new SimpleNameClass(decl.getTargetNamespace(),decl.getName());
-    }
-
-    /**
-     * Computes a name class that represents everything in a given content model.
-     */
-    private final XSTermFunction<NameClass> contentModelNameClassBuilder = new XSTermFunction<NameClass>() {
-        public NameClass wildcard(XSWildcard wc) {
-            return WildcardNameClassBuilder.build(wc);
-        }
-
-        public NameClass modelGroupDecl(XSModelGroupDecl decl) {
-            return modelGroup(decl.getModelGroup());
-        }
-
-        public NameClass modelGroup(XSModelGroup group) {
-            NameClass nc = NameClass.NULL;
-            for( int i=0; i<group.getSize(); i++ )
-                nc = new ChoiceNameClass(nc,group.getChild(i).getTerm().apply(this));
-            return nc;
-        }
-
-        public NameClass elementDecl(XSElementDecl decl) {
-            return getNameClass(decl);
-        }
-    };
-
-
-    /**
-     * Looks for the derivation chain t_1 > t_2 > ... > t
-     * and find t_i such that t_i derives by restriction but
-     * for every j>i, t_j derives by extension.
-     *
-     * @return null
-     *      If there's no such t_i or if t_i is any type.
-     */
-    private XSComplexType getLastRestrictedType( XSComplexType t ) {
-        if( t.getBaseType()==schemas.getAnyType() )
-            return null;   // we don't count the restriction from anyType
-        if( t.getDerivationMethod()==XSType.RESTRICTION )
-            return t;
-
-        XSComplexType baseType = t.getBaseType().asComplexType();
-        if(baseType!=null)
-            return getLastRestrictedType(baseType);
-        else
-            return null;
-    }
 }
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/MessageBundle.properties	Tue Aug  4 09:38:10 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/MessageBundle.properties	Tue Aug  4 09:38:10 2009
@@ -27,4 +27,3 @@
     Base complex type "{0}" is derived by restriction, while this complex type "{1}" \
     is derived by extension. This is not currently handled by XJC, but we are \
     seeking input on this issue. Please report this to the JAXB team.
- 
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/Messages.java	Tue Aug  4 09:38:12 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/Messages.java	Tue Aug  4 09:38:12 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.ct;
 
 import java.text.MessageFormat;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/MixedComplexTypeBuilder.java	Tue Aug  4 09:38:15 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/MixedComplexTypeBuilder.java	Tue Aug  4 09:38:15 2009
@@ -22,9 +22,11 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.ct;
 
 import com.sun.tools.internal.xjc.model.CBuiltinLeafInfo;
+import com.sun.tools.internal.xjc.model.CClass;
 import com.sun.tools.internal.xjc.model.CPropertyInfo;
 import com.sun.tools.internal.xjc.reader.RawTypeSet;
 import com.sun.tools.internal.xjc.reader.xmlschema.RawTypeSetBuilder;
@@ -33,6 +35,7 @@
 import com.sun.xml.internal.xsom.XSComplexType;
 import com.sun.xml.internal.xsom.XSContentType;
 import com.sun.xml.internal.xsom.XSType;
+import java.util.List;
 
 /**
  * @author Kohsuke Kawaguchi
@@ -44,12 +47,16 @@
         if(bt ==schemas.getAnyType() && ct.isMixed())
             return true;    // fresh mixed complex type
 
-        // see issue 148. handle complex type extended from another and added mixed=true.
-        // the current implementation only works when the base type doesn't define
-        // any elements, and we should ideally warn it.
-        if(bt.isComplexType() && !bt.asComplexType().isMixed()
-        && ct.isMixed() && ct.getDerivationMethod()==XSType.EXTENSION)
-            return true;
+        // there's no complex type in the inheritance tree yet
+        if (bt.isComplexType() &&
+            !bt.asComplexType().isMixed() &&
+            ct.isMixed() &&
+            ct.getDerivationMethod() == XSType.EXTENSION) {
+                if (!bgmBuilder.isGenerateMixedExtensions() && (ct.getContentType().asParticle() == null)) {
+                    return false;
+                }
+                return true;
+        }
 
         return false;
     }
@@ -57,18 +64,45 @@
     public void build(XSComplexType ct) {
         XSContentType contentType = ct.getContentType();
 
-        // if mixed, we fallback immediately
-        builder.recordBindingMode(ct,FALLBACK_CONTENT);
+        boolean generateMixedExtensions = bgmBuilder.isGenerateMixedExtensions();
+        if (generateMixedExtensions) {
+            if (!(ct.getBaseType() == schemas.getAnyType() && ct.isMixed())) {
+                XSComplexType baseType = ct.getBaseType().asComplexType();
+                // build the base class
+                CClass baseClass = selector.bindToType(baseType, ct, true);
+                selector.getCurrentBean().setBaseClass(baseClass);
+            }
+        }
 
+        builder.recordBindingMode(ct, FALLBACK_CONTENT);
         BIProperty prop = BIProperty.getCustomization(ct);
 
         CPropertyInfo p;
 
-        if(contentType.asEmpty()!=null) {
-            p = prop.createValueProperty("Content",false,ct,CBuiltinLeafInfo.STRING,null);
+        if (generateMixedExtensions) {
+            List<XSComplexType> cType = ct.getSubtypes();
+            boolean isSubtyped = (cType != null) && (cType.size() > 0);
+
+            if (contentType.asEmpty() != null) {
+                if (isSubtyped) {
+                    p = prop.createContentExtendedMixedReferenceProperty("Content", ct, null);
+                } else {
+                    p = prop.createValueProperty("Content",false,ct,CBuiltinLeafInfo.STRING,null);
+                }
+            } else if (contentType.asParticle() == null) {
+                p = prop.createContentExtendedMixedReferenceProperty("Content", ct, null);
+            } else {
+                RawTypeSet ts = RawTypeSetBuilder.build(contentType.asParticle(), false);
+                p = prop.createContentExtendedMixedReferenceProperty("Content", ct, ts);
+            }
+
         } else {
-            RawTypeSet ts = RawTypeSetBuilder.build(contentType.asParticle(),false);
-            p = prop.createReferenceProperty("Content",false,ct,ts, true);
+            if(contentType.asEmpty()!=null) {
+                p = prop.createValueProperty("Content",false,ct,CBuiltinLeafInfo.STRING,null);
+            } else {
+                RawTypeSet ts = RawTypeSetBuilder.build(contentType.asParticle(),false);
+                p = prop.createReferenceProperty("Content", false, ct, ts, true, false, true, false);
+            }
         }
 
         selector.getCurrentBean().addProperty(p);
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/RestrictedComplexTypeBuilder.java	Tue Aug  4 09:38:18 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/RestrictedComplexTypeBuilder.java	Tue Aug  4 09:38:17 2009
@@ -25,7 +25,13 @@
 package com.sun.tools.internal.xjc.reader.xmlschema.ct;
 
 import com.sun.tools.internal.xjc.model.CClass;
+import com.sun.tools.internal.xjc.model.CPropertyInfo;
+import com.sun.tools.internal.xjc.reader.RawTypeSet;
+import com.sun.tools.internal.xjc.reader.xmlschema.RawTypeSetBuilder;
+import com.sun.tools.internal.xjc.reader.xmlschema.bindinfo.BIGlobalBinding;
+import com.sun.tools.internal.xjc.reader.xmlschema.bindinfo.BIProperty;
 import com.sun.xml.internal.xsom.XSComplexType;
+import com.sun.xml.internal.xsom.XSParticle;
 import com.sun.xml.internal.xsom.XSType;
 
 /**
@@ -45,13 +51,13 @@
     }
 
     public void build(XSComplexType ct) {
-        if(bgmBuilder.getGlobalBinding().isRestrictionFreshType()) {
+
+        if (bgmBuilder.getGlobalBinding().isRestrictionFreshType()) {
             // handle derivation-by-restriction like a whole new type
             new FreshComplexTypeBuilder().build(ct);
             return;
         }
 
-
         XSComplexType baseType = ct.getBaseType().asComplexType();
 
         // build the base class
@@ -60,7 +66,29 @@
 
         selector.getCurrentBean().setBaseClass(baseClass);
 
-        // determine the binding of this complex type.
-        builder.recordBindingMode(ct,builder.getBindingMode(baseType));
+        if (bgmBuilder.isGenerateMixedExtensions()) {
+            boolean forceFallbackInExtension = baseType.isMixed() &&
+                                               ct.isMixed() &&
+                                               (ct.getExplicitContent() != null) &&
+                                               bgmBuilder.inExtensionMode;
+            if (forceFallbackInExtension) {
+                builder.recordBindingMode(ct, ComplexTypeBindingMode.NORMAL);
+
+                BIProperty prop = BIProperty.getCustomization(ct);
+                CPropertyInfo p;
+
+                XSParticle particle = ct.getContentType().asParticle();
+                if (particle != null) {
+                    RawTypeSet ts = RawTypeSetBuilder.build(particle, false);
+                    p = prop.createDummyExtendedMixedReferenceProperty("Content", ct, ts);
+                    selector.getCurrentBean().addProperty(p);
+                }
+            } else {
+                // determine the binding of this complex type.
+                builder.recordBindingMode(ct,builder.getBindingMode(baseType));
+            }
+        } else {
+            builder.recordBindingMode(ct,builder.getBindingMode(baseType));
+        }
     }
 }
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/parser/LSInputSAXWrapper.java	Tue Aug  4 09:38:20 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/parser/LSInputSAXWrapper.java	Tue Aug  4 09:38:20 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.reader.xmlschema.parser;
 
 import java.io.InputStream;
--- old/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/parser/MessageBundle.properties	Tue Aug  4 09:38:22 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/parser/MessageBundle.properties	Tue Aug  4 09:38:22 2009
@@ -30,7 +30,7 @@
 
 
 CustomizationContextChecker.UnacknolwedgedCustomization = \
-	Specified {0} customization is not used.
+        Specified {0} customization is not used.
 
 
 SchemaConstraintChecker.UnableToCheckCorrectness = \
@@ -37,17 +37,11 @@
     Unable to check the correctness of the schema due to OutOfMemoryError. \
     This typically happens when your schema contains constructs like maxOccurs="999". \
     In the future compilation, add the '-nv' option to skip the correctness check \
-    for faster compilation. 
+    for faster compilation.
 
 
 
 
 IncorrectNamespaceURIChecker.WarnIncorrectURI = \
-	No JAXB customization was detected in the schema but the prefix "jaxb" is used for \
-	other namespace URIs. If you did intend to use JAXB customization, make sure the namespace URI is "{0}"
-
-	
-
-
-	
- 
+        No JAXB customization was detected in the schema but the prefix "jaxb" is used for \
+        other namespace URIs. If you did intend to use JAXB customization, make sure the namespace URI is "{0}"
--- old/src/share/classes/com/sun/tools/internal/xjc/runtime/JAXBContextFactory.java	Tue Aug  4 09:38:24 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/runtime/JAXBContextFactory.java	Tue Aug  4 09:38:24 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.runtime;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/tools/internal/xjc/runtime/ZeroOneBooleanAdapter.java	Tue Aug  4 09:38:27 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/runtime/ZeroOneBooleanAdapter.java	Tue Aug  4 09:38:26 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.runtime;
 
 import javax.xml.bind.DatatypeConverter;
--- old/src/share/classes/com/sun/tools/internal/xjc/util/ForkContentHandler.java	Tue Aug  4 09:38:29 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/util/ForkContentHandler.java	Tue Aug  4 09:38:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.util;
 
 import org.xml.sax.Attributes;
@@ -34,7 +35,6 @@
  * two ContentHandlers.
  *
  *
- * @version     $Id: ForkContentHandler.java,v 1.1 2005/05/23 17:04:58 kohsuke Exp $
  * @author  <a href="mailto:kohsuke.kawaguchi@sun.com">Kohsuke KAWAGUCHI</a>
  */
 public class ForkContentHandler implements ContentHandler {
--- old/src/share/classes/com/sun/tools/internal/xjc/util/ForkEntityResolver.java	Tue Aug  4 09:38:31 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/util/ForkEntityResolver.java	Tue Aug  4 09:38:31 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.util;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/tools/internal/xjc/util/MessageBundle.properties	Tue Aug  4 09:38:33 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/util/MessageBundle.properties	Tue Aug  4 09:38:33 2009
@@ -30,11 +30,11 @@
 
 
 CodeModelClassFactory.ClassNameCollision = \
-	A class/interface with the same name "{0}" is already in use. \
+        A class/interface with the same name "{0}" is already in use. \
     Use a class customization to resolve this conflict.
 
 CodeModelClassFactory.ClassNameCollision.Source = \
-	(Relevant to above error) another "{0}" is generated from here.
+        (Relevant to above error) another "{0}" is generated from here.
 
 ERR_INVALID_CLASSNAME = \
     Invalid class name "{0}". Either XJC has failed to derive a class name \
@@ -42,8 +42,8 @@
     to override a name.
 
 CodeModelClassFactory.CaseSensitivityCollision = \
-	This error is caused because on Windows you cannot have both "{0}.java" and "{1}.java" \
-	in the same directory.
+        This error is caused because on Windows you cannot have both "{0}.java" and "{1}.java" \
+        in the same directory.
 
 ERR_CHAMELEON_SCHEMA_GONE_WILD = \
     (Relevant to above error) This confusing error happened most likely because the schema uses a technique called \
@@ -50,4 +50,3 @@
     "chameleon schema", which causes a single definition to be loaded multiple times into \
     different namespaces. See http://forums.java.net/jive/thread.jspa?threadID=18631 for \
     more about this.
- 
--- old/src/share/classes/com/sun/tools/internal/xjc/util/MimeTypeRange.java	Tue Aug  4 09:38:35 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/util/MimeTypeRange.java	Tue Aug  4 09:38:35 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.util;
 
 import java.text.ParseException;
--- old/src/share/classes/com/sun/tools/internal/xjc/util/NamespaceContextAdapter.java	Tue Aug  4 09:38:38 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/util/NamespaceContextAdapter.java	Tue Aug  4 09:38:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.util;
 
 import java.util.Collections;
--- old/src/share/classes/com/sun/tools/internal/xjc/util/ReadOnlyAdapter.java	Tue Aug  4 09:38:40 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/util/ReadOnlyAdapter.java	Tue Aug  4 09:38:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.util;
 
 import javax.xml.bind.annotation.adapters.XmlAdapter;
--- old/src/share/classes/com/sun/tools/internal/xjc/util/StringCutter.java	Tue Aug  4 09:38:42 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/util/StringCutter.java	Tue Aug  4 09:38:42 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.util;
 
 import java.text.ParseException;
--- old/src/share/classes/com/sun/tools/internal/xjc/util/SubtreeCutter.java	Tue Aug  4 09:38:44 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/util/SubtreeCutter.java	Tue Aug  4 09:38:44 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.tools.internal.xjc.util;
 
 import org.xml.sax.helpers.XMLFilterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/AccessorFactoryImpl.java	Tue Aug  4 09:38:46 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/AccessorFactoryImpl.java	Tue Aug  4 09:38:46 2009
@@ -27,16 +27,17 @@
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+
+import javax.xml.bind.JAXBException;
+
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
-import com.sun.xml.internal.bind.api.AccessorException;
 
 public class AccessorFactoryImpl implements AccessorFactory {
 
-    private static AccessorFactoryImpl instance = null;
+    private static AccessorFactoryImpl instance = new AccessorFactoryImpl();
     private AccessorFactoryImpl(){}
-    public static synchronized AccessorFactoryImpl getInstance(){
-        if (instance == null)
-            instance = new AccessorFactoryImpl();
+
+    public static AccessorFactoryImpl getInstance(){
         return instance;
     }
 
@@ -44,7 +45,7 @@
      * Access a field of the class.
      *
      * @param bean the class to be processed.
-     * @param f the field within the class to be accessed.
+     * @param field the field within the class to be accessed.
      * @param readOnly  the isStatic value of the field's modifier.
      * @return Accessor the accessor for this field
      *
--- old/src/share/classes/com/sun/xml/internal/bind/AnyTypeAdapter.java	Tue Aug  4 09:38:48 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/AnyTypeAdapter.java	Tue Aug  4 09:38:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind;
 
 import javax.xml.bind.annotation.adapters.XmlAdapter;
--- old/src/share/classes/com/sun/xml/internal/bind/CycleRecoverable.java	Tue Aug  4 09:38:51 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/CycleRecoverable.java	Tue Aug  4 09:38:50 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind;
 
 import javax.xml.bind.Marshaller;
--- old/src/share/classes/com/sun/xml/internal/bind/DatatypeConverterImpl.java	Tue Aug  4 09:38:53 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/DatatypeConverterImpl.java	Tue Aug  4 09:38:52 2009
@@ -52,7 +52,6 @@
  * This class is responsible for whitespace normalization.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.9 $
  * @since JAXB1.0
  */
 public final class DatatypeConverterImpl implements DatatypeConverterInterface {
@@ -117,7 +116,7 @@
                 sign = -1;
             } else
             if(ch=='+') {
-                ; // noop
+                // noop
             } else
                 throw new NumberFormatException("Not a number: "+s);
         }
@@ -137,7 +136,7 @@
         return _parseShort(lexicalXSDShort);
     }
 
-    public static final short _parseShort(CharSequence s) {
+    public static short _parseShort(CharSequence s) {
         return (short)_parseInt(s);
     }
 
@@ -209,7 +208,7 @@
     }
 
     public static String _printFloat(float v) {
-        if( v==Float.NaN )                  return "NaN";
+        if( Float.isNaN(v) )                return "NaN";
         if( v==Float.POSITIVE_INFINITY )    return "INF";
         if( v==Float.NEGATIVE_INFINITY )    return "-INF";
         return String.valueOf(v);
@@ -242,16 +241,18 @@
         return _parseBoolean(lexicalXSDBoolean);
     }
 
-    public static boolean _parseBoolean(CharSequence literal) {
+    public static Boolean _parseBoolean(CharSequence literal) {
         int i=0;
         int len = literal.length();
         char ch;
+        if (literal.length() <= 0) {
+            return null;
+        }
         do {
             ch = literal.charAt(i++);
         } while(WhiteSpaceProcessor.isWhiteSpace(ch) && i<len);
 
         // if we are strict about errors, check i==len. and report an error
-
         if( ch=='t' || ch=='1' )        return true;
         if( ch=='f' || ch=='0' )        return false;
         TODO.checkSpec("issue #42");
@@ -358,7 +359,8 @@
         final int len = s.length();
 
         // "111" is not a valid hex encoding.
-        if( len%2 != 0 )    return null;
+        if( len%2 != 0 )
+            throw new IllegalArgumentException("hexBinary needs to be even-length: "+s);
 
         byte[] out = new byte[len/2];
 
@@ -366,7 +368,7 @@
             int h = hexToBin(s.charAt(i  ));
             int l = hexToBin(s.charAt(i+1));
             if( h==-1 || l==-1 )
-                return null;    // illegal character
+                throw new IllegalArgumentException("contains illegal character for hexBinary: "+s);
 
             out[i/2] = (byte)(h*16+l);
         }
@@ -454,7 +456,7 @@
     }
 
     public static String _printDecimal(BigDecimal val) {
-        return val.toString();
+        return val.toPlainString();
     }
 
     public String printDouble(double v) {
@@ -462,7 +464,7 @@
     }
 
     public static String _printDouble(double v) {
-        if( v==Double.NaN )                    return "NaN";
+        if(Double.isNaN(v))                  return "NaN";
         if( v==Double.POSITIVE_INFINITY )    return "INF";
         if( v==Double.NEGATIVE_INFINITY )    return "-INF";
         return String.valueOf(v);
@@ -884,11 +886,11 @@
             if (tz == null)      return;
 
             // otherwise print out normally.
-            int offset;
-            if (tz.inDaylightTime(cal.getTime())) {
-                offset = tz.getRawOffset() + (tz.useDaylightTime()?3600000:0);
-            } else {
-                offset = tz.getRawOffset();
+            int offset = tz.getOffset(cal.getTime().getTime());
+
+            if(offset==0) {
+                buf.append('Z');
+                return;
             }
 
             if (offset >= 0)
@@ -906,7 +908,7 @@
         }
 
         /** formats Integer into two-character-wide string. */
-        private static final void formatTwoDigits(int n,StringBuilder buf) {
+        private static void formatTwoDigits(int n,StringBuilder buf) {
             // n is always non-negative.
             if (n < 10) buf.append('0');
             buf.append(n);
--- old/src/share/classes/com/sun/xml/internal/bind/IDResolver.java	Tue Aug  4 09:38:55 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/IDResolver.java	Tue Aug  4 09:38:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind;
 
 import java.util.concurrent.Callable;
--- old/src/share/classes/com/sun/xml/internal/bind/Locatable.java	Tue Aug  4 09:38:57 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/Locatable.java	Tue Aug  4 09:38:57 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * @(#)$Id: Locatable.java,v 1.1 2005/04/15 20:03:41 kohsuke Exp $
- */
-
-
 package com.sun.xml.internal.bind;
 
 import com.sun.xml.internal.bind.annotation.XmlLocation;
--- old/src/share/classes/com/sun/xml/internal/bind/Util.java	Tue Aug  4 09:38:59 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/Util.java	Tue Aug  4 09:38:59 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind;
 
 import java.util.logging.Logger;
--- old/src/share/classes/com/sun/xml/internal/bind/ValidationEventLocatorEx.java	Tue Aug  4 09:39:02 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/ValidationEventLocatorEx.java	Tue Aug  4 09:39:01 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * @(#)$Id: ValidationEventLocatorEx.java,v 1.1 2005/04/15 20:03:42 kohsuke Exp $
- */
-
-
 package com.sun.xml.internal.bind;
 
 import javax.xml.bind.ValidationEventLocator;
--- old/src/share/classes/com/sun/xml/internal/bind/XmlAccessorFactory.java	Tue Aug  4 09:39:04 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/XmlAccessorFactory.java	Tue Aug  4 09:39:03 2009
@@ -22,7 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-
 package com.sun.xml.internal.bind;
 
 import static java.lang.annotation.ElementType.PACKAGE;
--- old/src/share/classes/com/sun/xml/internal/bind/annotation/XmlIsSet.java	Tue Aug  4 09:39:06 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/annotation/XmlIsSet.java	Tue Aug  4 09:39:06 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.annotation;
 
 import java.lang.annotation.Retention;
--- old/src/share/classes/com/sun/xml/internal/bind/annotation/XmlLocation.java	Tue Aug  4 09:39:08 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/annotation/XmlLocation.java	Tue Aug  4 09:39:08 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.annotation;
 
 import java.lang.annotation.Retention;
--- old/src/share/classes/com/sun/xml/internal/bind/api/AccessorException.java	Tue Aug  4 09:39:10 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/AccessorException.java	Tue Aug  4 09:39:10 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.api;
 
 
--- old/src/share/classes/com/sun/xml/internal/bind/api/Bridge.java	Tue Aug  4 09:39:12 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/Bridge.java	Tue Aug  4 09:39:12 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.api;
 
 import java.io.InputStream;
--- old/src/share/classes/com/sun/xml/internal/bind/api/BridgeContext.java	Tue Aug  4 09:39:15 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/BridgeContext.java	Tue Aug  4 09:39:14 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.api;
 
 import javax.xml.bind.ValidationEventHandler;
--- old/src/share/classes/com/sun/xml/internal/bind/api/ClassResolver.java	Tue Aug  4 09:39:17 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/ClassResolver.java	Tue Aug  4 09:39:17 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.api;
 
 import javax.xml.bind.JAXBContext;
--- old/src/share/classes/com/sun/xml/internal/bind/api/CompositeStructure.java	Tue Aug  4 09:39:19 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/CompositeStructure.java	Tue Aug  4 09:39:19 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.api;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/api/ErrorListener.java	Tue Aug  4 09:39:21 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/ErrorListener.java	Tue Aug  4 09:39:21 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.api;
 
 import org.xml.sax.ErrorHandler;
--- old/src/share/classes/com/sun/xml/internal/bind/api/JAXBRIContext.java	Tue Aug  4 09:39:23 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/JAXBRIContext.java	Tue Aug  4 09:39:23 2009
@@ -45,6 +45,7 @@
 import com.sun.xml.internal.bind.v2.ContextFactory;
 import com.sun.xml.internal.bind.v2.model.annotation.RuntimeAnnotationReader;
 import com.sun.xml.internal.bind.v2.model.nav.Navigator;
+import com.sun.xml.internal.bind.v2.model.runtime.RuntimeTypeInfoSet;
 
 /**
  * {@link JAXBContext} enhanced with JAXB RI specific functionalities.
@@ -92,7 +93,7 @@
        @Nullable String defaultNamespaceRemap, boolean c14nSupport,
        @Nullable RuntimeAnnotationReader ar) throws JAXBException {
         return ContextFactory.createContext(classes, typeRefs, subclassReplacements,
-                defaultNamespaceRemap, c14nSupport, ar, false, false);
+                defaultNamespaceRemap, c14nSupport, ar, false, false, false);
     }
 
     /**
@@ -128,6 +129,15 @@
     public abstract @Nullable QName getElementName(@NotNull Object o) throws JAXBException;
 
     /**
+     * Allows to retrieve the element name based on Class.
+     * @param o
+     * @return
+     * @throws javax.xml.bind.JAXBException
+     * @since 2.1.10
+     */
+    public abstract @Nullable QName getElementName(@NotNull Class o) throws JAXBException;
+
+    /**
      * Creates a mini-marshaller/unmarshaller that can process a {@link TypeReference}.
      *
      * @return
@@ -220,6 +230,7 @@
      * @throws IOException
      *      if {@link SchemaOutputResolver} throws an {@link IOException}.
      */
+    @Override
     public abstract void generateSchema(@NotNull SchemaOutputResolver outputResolver) throws IOException;
 
     /**
@@ -264,6 +275,17 @@
     public abstract void generateEpisode(Result output);
 
     /**
+     * Allows you to access the runtime model information of the JAXB XML/Java binding.
+     *
+     * <p>
+     * This is useful for doing a deeper integration with the JAXB RI.
+     * For more information about the model, see https://jaxb2-reflection.dev.java.net/
+     *
+     * @since 2.1.10
+     */
+    public abstract RuntimeTypeInfoSet getRuntimeTypeInfoSet();
+
+    /**
      * Computes a Java identifier from a local name.
      *
      * <p>
@@ -423,4 +445,11 @@
      */
     public static final String XMLACCESSORFACTORY_SUPPORT = "com.sun.xml.internal.bind.XmlAccessorFactory";
 
+    /**
+     * Retains references to PropertyInfos.
+     *
+     * @since 2.1.10
+     */
+    public static final String RETAIN_REFERENCE_TO_INFO = "retainReferenceToInfo";
+
 }
--- old/src/share/classes/com/sun/xml/internal/bind/api/RawAccessor.java	Tue Aug  4 09:39:26 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/RawAccessor.java	Tue Aug  4 09:39:25 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.api;
 
 
--- old/src/share/classes/com/sun/xml/internal/bind/api/TypeReference.java	Tue Aug  4 09:39:28 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/TypeReference.java	Tue Aug  4 09:39:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.api;
 
 import java.lang.annotation.Annotation;
@@ -65,9 +66,18 @@
     public final Annotation[] annotations;
 
     public TypeReference(QName tagName, Type type, Annotation... annotations) {
-        if(tagName==null || type==null || annotations==null)
-            throw new IllegalArgumentException();
+        if(tagName==null || type==null || annotations==null) {
+            String nullArgs = "";
 
+            if(tagName == null)     nullArgs = "tagName";
+            if(type == null)        nullArgs += (nullArgs.length() > 0 ? ", type" : "type");
+            if(annotations == null) nullArgs += (nullArgs.length() > 0 ? ", annotations" : "annotations");
+
+            Messages.ARGUMENT_CANT_BE_NULL.format(nullArgs);
+
+            throw new IllegalArgumentException(Messages.ARGUMENT_CANT_BE_NULL.format(nullArgs));
+        }
+
         this.tagName = new QName(tagName.getNamespaceURI().intern(), tagName.getLocalPart().intern(), tagName.getPrefix());
         this.type = type;
         this.annotations = annotations;
--- old/src/share/classes/com/sun/xml/internal/bind/api/impl/NameConverter.java	Tue Aug  4 09:39:30 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/impl/NameConverter.java	Tue Aug  4 09:39:30 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.api.impl;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/xml/internal/bind/api/impl/NameUtil.java	Tue Aug  4 09:39:32 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/impl/NameUtil.java	Tue Aug  4 09:39:32 2009
@@ -22,11 +22,13 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.api.impl;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Locale;
 
 /**
  * Methods that convert strings into various formats.
@@ -59,6 +61,18 @@
         return c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || Character.isLetter(c);
     }
 
+    private String toLowerCase(String s) {
+        return s.toLowerCase(Locale.ENGLISH);
+    }
+
+    private String toUpperCase(char c) {
+        return String.valueOf(c).toUpperCase(Locale.ENGLISH);
+    }
+
+    private String toUpperCase(String s) {
+        return s.toUpperCase(Locale.ENGLISH);
+    }
+
     /**
      * Capitalizes the first character of the specified string,
      * and de-capitalize the rest of characters.
@@ -67,8 +81,8 @@
         if (!isLower(s.charAt(0)))
             return s;
         StringBuilder sb = new StringBuilder(s.length());
-        sb.append(Character.toUpperCase(s.charAt(0)));
-        sb.append(s.substring(1).toLowerCase());
+        sb.append(toUpperCase(s.charAt(0)));
+        sb.append(toLowerCase(s.substring(1)));
         return sb.toString();
     }
 
@@ -209,7 +223,7 @@
     protected String toMixedCaseName(List<String> ss, boolean startUpper) {
         StringBuilder sb = new StringBuilder();
         if(!ss.isEmpty()) {
-            sb.append(startUpper ? ss.get(0) : ss.get(0).toLowerCase());
+            sb.append(startUpper ? ss.get(0) : toLowerCase(ss.get(0)));
             for (int i = 1; i < ss.size(); i++)
                 sb.append(ss.get(i));
         }
@@ -224,7 +238,7 @@
                 ss[i] = capitalize(ss[i]);
         StringBuilder sb = new StringBuilder();
         if( ss.length>0 ) {
-            sb.append(startUpper ? ss[0] : ss[0].toLowerCase());
+            sb.append(startUpper ? ss[0] : toLowerCase(ss[0]));
             for (int i = 1; i < ss.length; i++)
                 sb.append(ss[i]);
         }
@@ -253,10 +267,10 @@
     public String toConstantName(List<String> ss) {
         StringBuilder sb = new StringBuilder();
         if( !ss.isEmpty() ) {
-            sb.append(ss.get(0).toUpperCase());
+            sb.append(toUpperCase(ss.get(0)));
             for (int i = 1; i < ss.size(); i++) {
                 sb.append('_');
-                sb.append(ss.get(i).toUpperCase());
+                sb.append(toUpperCase(ss.get(i)));
             }
         }
         return sb.toString();
--- old/src/share/classes/com/sun/xml/internal/bind/api/package-info.java	Tue Aug  4 09:39:35 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/package-info.java	Tue Aug  4 09:39:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /**
  * <h1>Runtime API for the JAX-WS RI</h1>.
  *
--- old/src/share/classes/com/sun/xml/internal/bind/marshaller/DataWriter.java	Tue Aug  4 09:39:37 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/marshaller/DataWriter.java	Tue Aug  4 09:39:36 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 //@@3RD PARTY CODE@@
 
 // DataWriter.java - XML writer for data-oriented files.
--- old/src/share/classes/com/sun/xml/internal/bind/marshaller/Messages.properties	Tue Aug  4 09:39:39 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/marshaller/Messages.properties	Tue Aug  4 09:39:39 2009
@@ -28,32 +28,31 @@
 #
 
 MarshallerImpl.NotMarshallable = \
-	the object parameter to marshal() is not marshallable
-	
+        the object parameter to marshal() is not marshallable
+
 MarshallerImpl.UnsupportedResult = \
-	unsupported javax.xml.parser.transform.Result parameter
-	
+        unsupported javax.xml.parser.transform.Result parameter
+
 MarshallerImpl.UnsupportedEncoding = \
-	unsupported encoding: {0}
-	
+        unsupported encoding: {0}
+
 MarshallerImpl.NullWriterParam = \
-	StAX writer parameter must not be null
-	
+        StAX writer parameter must not be null
+
 SAXMarshaller.AssertFailed = \
-	assertion failed
-	 
+        assertion failed
+
 SAXMarshaller.MissingObject = \
-	a required object is missing
-	 
+        a required object is missing
+
 SAXMarshaller.MissingObject2 = \
-	a required field "{0}" is missing an object
+        a required field "{0}" is missing an object
 
 SAXMarshaller.DanglingIDREF = \
-	A tree contains a reference to ID "{0}" but it's not a part of the object graph
+        A tree contains a reference to ID "{0}" but it's not a part of the object graph
 
 SAXMarshaller.NotIdentifiable = \
-	An object is referenced as IDREF but its ID field is null
+        An object is referenced as IDREF but its ID field is null
 
 SAX2DOMEx.DomImplDoesntSupportCreateElementNs = \
-	DOM implementation ({0} from {1}) is broken. It does not support the createElementNS method.
- 
+        DOM implementation ({0} from {1}) is broken. It does not support the createElementNS method.
--- old/src/share/classes/com/sun/xml/internal/bind/marshaller/MinimumEscapeHandler.java	Tue Aug  4 09:39:41 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/marshaller/MinimumEscapeHandler.java	Tue Aug  4 09:39:41 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * @(#)$Id: MinimumEscapeHandler.java,v 1.1 2005/04/15 20:03:47 kohsuke Exp $
- */
-
-
 package com.sun.xml.internal.bind.marshaller;
 
 import java.io.IOException;
@@ -52,23 +47,23 @@
         int limit = start+length;
         for (int i = start; i < limit; i++) {
             char c = ch[i];
-            if( c=='&' || c=='<' || c=='>' || (c=='\"' && isAttVal) ) {
+                if(c == '&' || c == '<' || c == '>' || c == '\r' || (c == '\"' && isAttVal) ) {
                 if(i!=start)
                     out.write(ch,start,i-start);
                 start = i+1;
                 switch (ch[i]) {
-                case '&' :
-                    out.write("&amp;");
-                    break;
-                case '<' :
-                    out.write("&lt;");
-                    break;
-                case '>' :
-                    out.write("&gt;");
-                    break;
-                case '\"' :
-                    out.write("&quot;");
-                    break;
+                    case '&':
+                        out.write("&amp;");
+                        break;
+                    case '<':
+                        out.write("&lt;");
+                        break;
+                    case '>':
+                        out.write("&gt;");
+                        break;
+                    case '\"':
+                        out.write("&quot;");
+                        break;
                 }
             }
         }
--- old/src/share/classes/com/sun/xml/internal/bind/marshaller/NamespacePrefixMapper.java	Tue Aug  4 09:39:43 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/marshaller/NamespacePrefixMapper.java	Tue Aug  4 09:39:43 2009
@@ -26,6 +26,7 @@
 
 import java.io.OutputStream;
 
+import javax.xml.bind.JAXBContext;
 import javax.xml.stream.XMLEventWriter;
 import javax.xml.stream.XMLStreamWriter;
 import javax.xml.transform.dom.DOMResult;
@@ -61,6 +62,26 @@
      *
      * This method is intended to be overrided by a derived class.
      *
+     *
+     * <p>
+     * As noted in the return value portion of the javadoc, there
+     * are several cases where the preference cannot be honored.
+     * Specifically, as of JAXB RI 2.0 and onward:
+     *
+     * <ol>
+     * <li>
+     * If the prefix returned is already in use as one of the in-scope
+     * namespace bindings. This is partly necessary for correctness
+     * (so that we don't unexpectedly change the meaning of QNames
+     * bound to {@link String}), partly to simplify the marshaller.
+     * <li>
+     * If the prefix returned is "" yet the current {@link JAXBContext}
+     * includes classes that use the empty namespace URI. This allows
+     * the JAXB RI to reserve the "" prefix for the empty namespace URI,
+     * which is the only possible prefix for the URI.
+     * This restriction is also to simplify the marshaller.
+     * </ol>
+     *
      * @param namespaceUri
      *      The namespace URI for which the prefix needs to be found.
      *      Never be null. "" is used to denote the default namespace.
@@ -112,7 +133,7 @@
      *   <ns3:child xmlns:ns3="urn:foo"> ... </ns3:child>
      *   ...
      * </root>
-     * <xmp></pre>
+     * </xmp></pre>
      *
      * <p>
      * The JAXB RI 2.x mostly doesn't exhibit this behavior any more,
@@ -139,7 +160,7 @@
      *   <ns1:child> ... </ns1:child>
      *   ...
      * </root>
-     * <xmp></pre>
+     * </xmp></pre>
      * <p>
      * To control prefixes assigned to those namespace URIs, use the
      * {@link #getPreferredPrefix(String, String, boolean)} method.
--- old/src/share/classes/com/sun/xml/internal/bind/marshaller/XMLWriter.java	Tue Aug  4 09:39:46 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/marshaller/XMLWriter.java	Tue Aug  4 09:39:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 // @@3RD PARTY CODE@@
 
 // XMLWriter.java - serialize an XML document.
--- old/src/share/classes/com/sun/xml/internal/bind/unmarshaller/DOMScanner.java	Tue Aug  4 09:39:48 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/unmarshaller/DOMScanner.java	Tue Aug  4 09:39:47 2009
@@ -54,7 +54,6 @@
  * classes like this.
  *
  * @author <ul><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.6 $ $Date: 2006/04/24 15:27:52 $
  * @since JAXB1.0
  */
 public class DOMScanner implements LocatorEx,InfosetScanner/*<Node> --- but can't do this to protect 1.0 clients, or can I? */
--- old/src/share/classes/com/sun/xml/internal/bind/unmarshaller/Messages.properties	Tue Aug  4 09:39:50 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/unmarshaller/Messages.properties	Tue Aug  4 09:39:50 2009
@@ -28,36 +28,34 @@
 #
 
 ContentHandlerEx.UnexpectedEnterElement = \
-	Unexpected element '{'{0}'}':{1}
+        Unexpected element '{'{0}'}':{1}
 
 ContentHandlerEx.UnexpectedLeaveElement = \
-	Unexpected end of element '{'{0}'}':{1}
+        Unexpected end of element '{'{0}'}':{1}
 
 ContentHandlerEx.UnexpectedEnterAttribute = \
-	Unexpected attribute '{'{0}'}':{1}
+        Unexpected attribute '{'{0}'}':{1}
 
 ContentHandlerEx.UnexpectedLeaveAttribute = \
-	Unexpected end of attribute '{'{0}'}':{1}
+        Unexpected end of attribute '{'{0}'}':{1}
 
 ContentHandlerEx.UnexpectedText = \
-	Unexpected text "{0}"
+        Unexpected text "{0}"
 
 ContentHandlerEx.UnexpectedLeaveChild = \
-	compiler error(unexpectedLeaveChild)
-	
+        compiler error(unexpectedLeaveChild)
+
 SAXUnmarshallerHandlerImpl.UnexpectedRootElement = \
-	unexpected root element {0}
-	
+        unexpected root element {0}
+
 SAXUnmarshallerHandlerImpl.UnexpectedRootElement2 = \
-	unexpected root element (uri:"{0}", local:"{1}"). Expected elements are {2}
-	
+        unexpected root element (uri:"{0}", local:"{1}"). Expected elements are {2}
+
 Util.UndefinedPrefix = \
-	undefined prefix: {0}
-	
+        undefined prefix: {0}
+
 Unmarshaller.NullReader = \
-	reader can not be null	
-	
+        reader can not be null
+
 Unmarshaller.IllegalReaderState = \
-	reader must be on a START_ELEMENT event, not a {0} event
-	
- 
+        reader must be on a START_ELEMENT event, not a {0} event
--- old/src/share/classes/com/sun/xml/internal/bind/unmarshaller/Patcher.java	Tue Aug  4 09:39:52 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/unmarshaller/Patcher.java	Tue Aug  4 09:39:52 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.unmarshaller;
 
 import org.xml.sax.SAXException;
--- old/src/share/classes/com/sun/xml/internal/bind/util/AttributesImpl.java	Tue Aug  4 09:39:54 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/util/AttributesImpl.java	Tue Aug  4 09:39:54 2009
@@ -27,7 +27,6 @@
 // http://www.saxproject.org
 // Written by David Megginson
 // NO WARRANTY!  This class is in the public domain.
-// $Id: AttributesImpl.java,v 1.2 2005/05/11 19:44:28 kohsuke Exp $
 package com.sun.xml.internal.bind.util;
 
 import org.xml.sax.Attributes;
--- old/src/share/classes/com/sun/xml/internal/bind/util/ValidationEventLocatorExImpl.java	Tue Aug  4 09:39:57 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/util/ValidationEventLocatorExImpl.java	Tue Aug  4 09:39:56 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * @(#)$Id: ValidationEventLocatorExImpl.java,v 1.1 2005/04/15 20:03:50 kohsuke Exp $
- */
-
-
 package com.sun.xml.internal.bind.util;
 
 import javax.xml.bind.helpers.ValidationEventLocatorImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/util/Which.java	Tue Aug  4 09:39:59 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/util/Which.java	Tue Aug  4 09:39:58 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * @(#)$Id: Which.java,v 1.1 2005/04/15 20:03:51 kohsuke Exp $
- */
-
-
 package com.sun.xml.internal.bind.util;
 
 import java.net.URL;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/ClassFactory.java	Tue Aug  4 09:40:01 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/ClassFactory.java	Tue Aug  4 09:40:01 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2;
 
 import java.lang.reflect.Constructor;
@@ -28,6 +29,7 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.LinkedList;
@@ -61,9 +63,9 @@
      *
      * To avoid synchronization among threads, we use {@link ThreadLocal}.
      */
-    private static final ThreadLocal<Map<Class,Constructor>> tls = new ThreadLocal<Map<Class,Constructor>>() {
-        public Map<Class, Constructor> initialValue() {
-            return new WeakHashMap<Class,Constructor>();
+    private static final ThreadLocal<Map<Class, WeakReference<Constructor>>> tls = new ThreadLocal<Map<Class,WeakReference<Constructor>>>() {
+        public Map<Class,WeakReference<Constructor>> initialValue() {
+            return new WeakHashMap<Class,WeakReference<Constructor>>();
         }
     };
 
@@ -71,8 +73,11 @@
      * Creates a new instance of the class but throw exceptions without catching it.
      */
     public static <T> T create0( final Class<T> clazz ) throws IllegalAccessException, InvocationTargetException, InstantiationException {
-        Map<Class,Constructor> m = tls.get();
-        Constructor<T> cons = m.get(clazz);
+        Map<Class,WeakReference<Constructor>> m = tls.get();
+        Constructor<T> cons = null;
+        WeakReference<Constructor> consRef = m.get(clazz);
+        if(consRef!=null)
+            cons = consRef.get();
         if(cons==null) {
             try {
                 cons = clazz.getDeclaredConstructor(emptyClass);
@@ -101,7 +106,7 @@
                 }
             }
 
-            m.put(clazz,cons);
+            m.put(clazz,new WeakReference<Constructor>(cons));
         }
 
         return cons.newInstance(emptyObject);
@@ -142,11 +147,10 @@
     /**
      *  Call a method in the factory class to get the object.
      */
-    public static Object create(final Method method) {
-        Object cons = null;
-        Throwable errorMsg = null;
+    public static Object create(Method method) {
+        Throwable errorMsg;
         try {
-            cons = method.invoke(null, emptyObject);
+            return method.invoke(null, emptyObject);
         } catch (InvocationTargetException ive) {
             Throwable target = ive.getTargetException();
 
@@ -170,13 +174,11 @@
             logger.log(Level.INFO,"failed to create a new instance of "+method.getReturnType().getName(),eie);
             errorMsg = eie;
         }
-        if (errorMsg != null){
-            NoSuchMethodError exp;
-            exp = new NoSuchMethodError(errorMsg.getMessage());
-            exp.initCause(errorMsg);
-            throw exp;
-        }
-        return cons;
+
+        NoSuchMethodError exp;
+        exp = new NoSuchMethodError(errorMsg.getMessage());
+        exp.initCause(errorMsg);
+        throw exp;
     }
 
     /**
@@ -201,12 +203,4 @@
         // and returns null
         return null;
     }
-
-    public static final Class[] COLLECTION_IMPL_CLASSES = new Class[] {
-        ArrayList.class,
-        LinkedList.class,
-        HashSet.class,
-        TreeSet.class,
-        Stack.class,
-    };
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/ContextFactory.java	Tue Aug  4 09:40:03 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/ContextFactory.java	Tue Aug  4 09:40:03 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2;
 
 import java.io.BufferedReader;
@@ -79,6 +80,10 @@
         if(allNillable==null)
             allNillable = false;
 
+        Boolean retainPropertyInfo = getPropertyValue(properties, JAXBRIContext.RETAIN_REFERENCE_TO_INFO, Boolean.class);
+        if(retainPropertyInfo==null)
+            retainPropertyInfo = false;
+
         Boolean xmlAccessorFactorySupport = getPropertyValue(properties,
            JAXBRIContext.XMLACCESSORFACTORY_SUPPORT,Boolean.class);
         if(xmlAccessorFactorySupport==null){
@@ -103,7 +108,7 @@
         }
 
         return createContext(classes,Collections.<TypeReference>emptyList(),
-                subclassReplacements,defaultNsUri,c14nSupport,ar,xmlAccessorFactorySupport,allNillable);
+                subclassReplacements,defaultNsUri,c14nSupport,ar,xmlAccessorFactorySupport,allNillable, retainPropertyInfo);
     }
 
     /**
@@ -123,9 +128,19 @@
     public static JAXBRIContext createContext( Class[] classes,
             Collection<TypeReference> typeRefs, Map<Class,Class> subclassReplacements,
             String defaultNsUri, boolean c14nSupport, RuntimeAnnotationReader ar,
-            boolean xmlAccessorFactorySupport, boolean allNillable) throws JAXBException {
-        return new JAXBContextImpl(classes,typeRefs,subclassReplacements,defaultNsUri,
-                c14nSupport,ar, xmlAccessorFactorySupport,allNillable);
+            boolean xmlAccessorFactorySupport, boolean allNillable, boolean retainPropertyInfo) throws JAXBException {
+
+        JAXBContextImpl.JAXBContextBuilder builder = new JAXBContextImpl.JAXBContextBuilder();
+        builder.setClasses(classes);
+        builder.setTypeRefs(typeRefs);
+        builder.setSubclassReplacements(subclassReplacements);
+        builder.setDefaultNsUri(defaultNsUri);
+        builder.setC14NSupport(c14nSupport);
+        builder.setAnnotationReader(ar);
+        builder.setXmlAccessorFactorySupport(xmlAccessorFactorySupport);
+        builder.setAllNillable(allNillable);
+        builder.setRetainPropertyInfo(retainPropertyInfo);
+        return builder.build();
     }
 
     /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/Messages.properties	Tue Aug  4 09:40:05 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/Messages.properties	Tue Aug  4 09:40:05 2009
@@ -43,4 +43,3 @@
 
 INVALID_TYPE_IN_MAP = \
     Map contains a wrong type
- 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/TODO.java	Tue Aug  4 09:40:08 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/TODO.java	Tue Aug  4 09:40:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/bytecode/ClassTailor.java	Tue Aug  4 09:40:10 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/bytecode/ClassTailor.java	Tue Aug  4 09:40:09 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.bytecode;
 
 import java.io.ByteArrayOutputStream;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/AbstractInlineAnnotationReaderImpl.java	Tue Aug  4 09:40:12 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/AbstractInlineAnnotationReaderImpl.java	Tue Aug  4 09:40:12 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/AnnotationReader.java	Tue Aug  4 09:40:14 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/AnnotationReader.java	Tue Aug  4 09:40:14 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/AnnotationSource.java	Tue Aug  4 09:40:16 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/AnnotationSource.java	Tue Aug  4 09:40:16 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/ClassLocatable.java	Tue Aug  4 09:40:19 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/ClassLocatable.java	Tue Aug  4 09:40:18 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import com.sun.xml.internal.bind.v2.model.nav.Navigator;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/FieldLocatable.java	Tue Aug  4 09:40:21 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/FieldLocatable.java	Tue Aug  4 09:40:20 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import com.sun.xml.internal.bind.v2.model.nav.Navigator;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/Init.java	Tue Aug  4 09:40:23 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/Init.java	Tue Aug  4 09:40:23 2009
@@ -29,7 +29,7 @@
 
 
     static Quick[] getAll() {
-        return new Quick[] {new XmlTypeQuick(null, null), new XmlSchemaQuick(null, null), new XmlElementRefsQuick(null, null), new XmlValueQuick(null, null), new XmlElementDeclQuick(null, null), new XmlElementRefQuick(null, null), new XmlTransientQuick(null, null), new XmlElementQuick(null, null), new XmlAttributeQuick(null, null), new XmlRootElementQuick(null, null), new XmlEnumQuick(null, null)};
+        return new Quick[] {new XmlSchemaTypeQuick(null, null), new XmlElementDeclQuick(null, null), new XmlEnumQuick(null, null), new XmlTransientQuick(null, null), new XmlSchemaQuick(null, null), new XmlRootElementQuick(null, null), new XmlElementQuick(null, null), new XmlTypeQuick(null, null), new XmlElementRefQuick(null, null), new XmlElementRefsQuick(null, null), new XmlAttributeQuick(null, null), new XmlValueQuick(null, null)};
     }
 
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/Locatable.java	Tue Aug  4 09:40:25 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/Locatable.java	Tue Aug  4 09:40:25 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import com.sun.xml.internal.bind.v2.runtime.Location;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/LocatableAnnotation.java	Tue Aug  4 09:40:27 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/LocatableAnnotation.java	Tue Aug  4 09:40:27 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import java.lang.annotation.Annotation;
@@ -29,6 +30,7 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
+import java.lang.reflect.Modifier;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -96,8 +98,13 @@
         try {
             if(method.getDeclaringClass()==Locatable.class)
                 return method.invoke(this,args);
-            else
-                return method.invoke(core,args);
+            if(Modifier.isStatic(method.getModifiers()))
+                // malicious code can pass in a static Method object.
+                // doing method.invoke() would end up executing it,
+                // so we need to protect against it.
+                throw new IllegalArgumentException();
+
+            return method.invoke(core,args);
         } catch (InvocationTargetException e) {
             if(e.getTargetException()!=null)
                 throw e.getTargetException();
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/Messages.java	Tue Aug  4 09:40:30 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/Messages.java	Tue Aug  4 09:40:29 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import java.text.MessageFormat;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/Messages.properties	Tue Aug  4 09:40:32 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/Messages.properties	Tue Aug  4 09:40:31 2009
@@ -25,4 +25,3 @@
 
 DUPLICATE_ANNOTATIONS = \
     Annotation "{0}" is present on both "{1}" and "{2}"
- 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/MethodLocatable.java	Tue Aug  4 09:40:34 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/MethodLocatable.java	Tue Aug  4 09:40:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import com.sun.xml.internal.bind.v2.model.nav.Navigator;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/Quick.java	Tue Aug  4 09:40:36 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/Quick.java	Tue Aug  4 09:40:36 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/RuntimeAnnotationReader.java	Tue Aug  4 09:40:38 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/RuntimeAnnotationReader.java	Tue Aug  4 09:40:38 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/RuntimeInlineAnnotationReader.java	Tue Aug  4 09:40:41 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/RuntimeInlineAnnotationReader.java	Tue Aug  4 09:40:40 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.annotation;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/Adapter.java	Tue Aug  4 09:40:43 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/Adapter.java	Tue Aug  4 09:40:42 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import javax.xml.bind.annotation.adapters.XmlAdapter;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ArrayInfo.java	Tue Aug  4 09:40:45 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ArrayInfo.java	Tue Aug  4 09:40:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/AttributePropertyInfo.java	Tue Aug  4 09:40:47 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/AttributePropertyInfo.java	Tue Aug  4 09:40:47 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/BuiltinLeafInfo.java	Tue Aug  4 09:40:49 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/BuiltinLeafInfo.java	Tue Aug  4 09:40:49 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ClassInfo.java	Tue Aug  4 09:40:52 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ClassInfo.java	Tue Aug  4 09:40:51 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import java.util.List;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/Element.java	Tue Aug  4 09:40:54 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/Element.java	Tue Aug  4 09:40:53 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ElementInfo.java	Tue Aug  4 09:40:56 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ElementInfo.java	Tue Aug  4 09:40:56 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import java.util.Collection;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ElementPropertyInfo.java	Tue Aug  4 09:40:58 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ElementPropertyInfo.java	Tue Aug  4 09:40:58 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import java.util.List;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/EnumConstant.java	Tue Aug  4 09:41:00 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/EnumConstant.java	Tue Aug  4 09:41:00 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import javax.xml.bind.annotation.XmlEnumValue;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/EnumLeafInfo.java	Tue Aug  4 09:41:03 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/EnumLeafInfo.java	Tue Aug  4 09:41:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ErrorHandler.java	Tue Aug  4 09:41:05 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ErrorHandler.java	Tue Aug  4 09:41:04 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import com.sun.xml.internal.bind.v2.model.impl.ModelBuilder;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ID.java	Tue Aug  4 09:41:07 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ID.java	Tue Aug  4 09:41:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/LeafInfo.java	Tue Aug  4 09:41:09 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/LeafInfo.java	Tue Aug  4 09:41:09 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/MapPropertyInfo.java	Tue Aug  4 09:41:11 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/MapPropertyInfo.java	Tue Aug  4 09:41:11 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import java.util.Map;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/MaybeElement.java	Tue Aug  4 09:41:14 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/MaybeElement.java	Tue Aug  4 09:41:13 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/NonElement.java	Tue Aug  4 09:41:16 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/NonElement.java	Tue Aug  4 09:41:15 2009
@@ -22,8 +22,10 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
+import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 import javax.xml.namespace.QName;
 
 /**
@@ -31,13 +33,15 @@
  *
  * Either {@link LeafInfo} or {@link ClassInfo}.
  *
- * TODO: better name.
+ * TODO: better ANYTYPE_NAME.
  *
  * @author Kohsuke Kawaguchi
  */
 public interface NonElement<T,C> extends TypeInfo<T,C> {
+    public static final QName ANYTYPE_NAME = new QName(WellKnownNamespace.XML_SCHEMA, "anyType");
+
     /**
-     * Gets the primary XML type name of the class.
+     * Gets the primary XML type ANYTYPE_NAME of the class.
      *
      * <p>
      * A Java type can be mapped to multiple XML types, but one of them is
@@ -44,7 +48,7 @@
      * considered "primary" and used when we generate a schema.
      *
      * @return
-     *      null if the object doesn't have an explicit type name (AKA anonymous.)
+     *      null if the object doesn't have an explicit type ANYTYPE_NAME (AKA anonymous.)
      */
     QName getTypeName();
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/NonElementRef.java	Tue Aug  4 09:41:18 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/NonElementRef.java	Tue Aug  4 09:41:18 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/PropertyInfo.java	Tue Aug  4 09:41:20 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/PropertyInfo.java	Tue Aug  4 09:41:20 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import java.util.Collection;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/PropertyKind.java	Tue Aug  4 09:41:22 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/PropertyKind.java	Tue Aug  4 09:41:22 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import javax.xml.bind.annotation.XmlMimeType;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/Ref.java	Tue Aug  4 09:41:25 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/Ref.java	Tue Aug  4 09:41:24 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import javax.xml.bind.annotation.XmlList;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ReferencePropertyInfo.java	Tue Aug  4 09:41:27 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ReferencePropertyInfo.java	Tue Aug  4 09:41:26 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import java.util.Collection;
@@ -114,5 +115,10 @@
      */
     C getDOMHandler();
 
+    /**
+     * Returns true if this element is mandatory.
+     */
+    boolean isRequired();
+
     Adapter<T,C> getAdapter();
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/RegistryInfo.java	Tue Aug  4 09:41:29 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/RegistryInfo.java	Tue Aug  4 09:41:29 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import java.util.Set;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/TypeInfo.java	Tue Aug  4 09:41:31 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/TypeInfo.java	Tue Aug  4 09:41:31 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import javax.xml.bind.annotation.XmlIDREF;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/TypeInfoSet.java	Tue Aug  4 09:41:33 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/TypeInfoSet.java	Tue Aug  4 09:41:33 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import java.util.Map;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/TypeRef.java	Tue Aug  4 09:41:36 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/TypeRef.java	Tue Aug  4 09:41:35 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ValuePropertyInfo.java	Tue Aug  4 09:41:38 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/ValuePropertyInfo.java	Tue Aug  4 09:41:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/WildcardMode.java	Tue Aug  4 09:41:40 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/WildcardMode.java	Tue Aug  4 09:41:40 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/WildcardTypeInfo.java	Tue Aug  4 09:41:42 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/WildcardTypeInfo.java	Tue Aug  4 09:41:42 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.core;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/core/package-info.java	Tue Aug  4 09:41:44 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/core/package-info.java	Tue Aug  4 09:41:44 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /**
  * The in-memory model of the JAXB-bound beans.
  *
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/AnyTypeImpl.java	Tue Aug  4 09:41:47 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/AnyTypeImpl.java	Tue Aug  4 09:41:46 2009
@@ -22,12 +22,12 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import javax.xml.namespace.QName;
 import javax.xml.bind.annotation.XmlIDREF;
 
-import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 import com.sun.xml.internal.bind.v2.runtime.Location;
 import com.sun.xml.internal.bind.v2.model.core.NonElement;
 import com.sun.xml.internal.bind.v2.model.core.TypeInfo;
@@ -50,7 +50,7 @@
     }
 
     public QName getTypeName() {
-        return name;
+        return ANYTYPE_NAME;
     }
 
     public T getType() {
@@ -79,5 +79,4 @@
         return true;
     }
 
-    private static final QName name = new QName(WellKnownNamespace.XML_SCHEMA,"anyType");
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ArrayInfoImpl.java	Tue Aug  4 09:41:49 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ArrayInfoImpl.java	Tue Aug  4 09:41:49 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import javax.xml.namespace.QName;
@@ -32,6 +33,7 @@
 import com.sun.xml.internal.bind.v2.model.core.ArrayInfo;
 import com.sun.xml.internal.bind.v2.model.core.NonElement;
 import com.sun.xml.internal.bind.v2.runtime.Location;
+import com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationException;
 
 /**
  *
@@ -57,10 +59,15 @@
                          Locatable upstream, TypeT arrayType) {
         super(builder, upstream);
         this.arrayType = arrayType;
-        this.itemType = builder.getTypeInfo(nav().getComponentType(arrayType), this);
+        TypeT componentType = nav().getComponentType(arrayType);
+        this.itemType = builder.getTypeInfo(componentType, this);
 
-        // TODO: check itemType.getTypeName()!=null and report an error
         QName n = itemType.getTypeName();
+        if(n==null) {
+            builder.reportError(new IllegalAnnotationException(Messages.ANONYMOUS_ARRAY_ITEM.format(
+                nav().getTypeName(componentType)),this));
+            n = new QName("#dummy"); // for error recovery
+        }
         this.typeName = calcArrayTypeName(n);
     }
 
@@ -67,7 +74,7 @@
     /**
      * Computes the type name of the array from that of the item type.
      */
-    public static final QName calcArrayTypeName(QName n) {
+    public static QName calcArrayTypeName(QName n) {
         String uri;
         if(n.getNamespaceURI().equals(WellKnownNamespace.XML_SCHEMA)) {
             TODO.checkSpec("this URI");
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/AttributePropertyInfoImpl.java	Tue Aug  4 09:41:51 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/AttributePropertyInfoImpl.java	Tue Aug  4 09:41:51 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import javax.xml.bind.annotation.XmlAttribute;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/BuiltinLeafInfoImpl.java	Tue Aug  4 09:41:53 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/BuiltinLeafInfoImpl.java	Tue Aug  4 09:41:53 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.util.HashMap;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ClassInfoImpl.java	Tue Aug  4 09:41:56 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ClassInfoImpl.java	Tue Aug  4 09:41:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.annotation.Annotation;
@@ -37,6 +38,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.AbstractList;
 
 import javax.xml.bind.annotation.XmlAccessOrder;
 import javax.xml.bind.annotation.XmlAccessType;
@@ -66,7 +68,7 @@
 import javax.xml.namespace.QName;
 
 import com.sun.istack.internal.FinalArrayList;
-import com.sun.xml.internal.bind.annotation.XmlLocation;
+import com.sun.xml.internal.bind.annotation.OverrideAnnotationOf;
 import com.sun.xml.internal.bind.v2.model.annotation.Locatable;
 import com.sun.xml.internal.bind.v2.model.annotation.MethodLocatable;
 import com.sun.xml.internal.bind.v2.model.core.ClassInfo;
@@ -75,10 +77,10 @@
 import com.sun.xml.internal.bind.v2.model.core.NonElement;
 import com.sun.xml.internal.bind.v2.model.core.PropertyInfo;
 import com.sun.xml.internal.bind.v2.model.core.PropertyKind;
-import com.sun.xml.internal.bind.v2.model.core.TypeInfo;
 import com.sun.xml.internal.bind.v2.model.core.ValuePropertyInfo;
 import com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationException;
 import com.sun.xml.internal.bind.v2.runtime.Location;
+import com.sun.xml.internal.bind.v2.util.EditDistance;
 
 
 /**
@@ -116,7 +118,7 @@
      *
      * @see #isOrdered()
      */
-    private final String[] propOrder;
+    private /*final*/ String[] propOrder;
 
     /**
      * Lazily computed.
@@ -169,6 +171,12 @@
             propOrder = DEFAULT_ORDER;
         }
 
+        // obtain XmlAccessorOrder and  set proporder (<xs:all> vs <xs:sequence>)
+        XmlAccessorOrder xao = reader().getClassAnnotation(XmlAccessorOrder.class, clazz, this);
+        if((xao != null) && (xao.value() == XmlAccessOrder.UNDEFINED)) {
+            propOrder = null;
+        }
+
         if(nav().isInterface(clazz)) {
             builder.reportError(new IllegalAnnotationException(
                 Messages.CANT_HANDLE_INTERFACE.format(nav().getClassName(clazz)), this ));
@@ -187,16 +195,15 @@
                     msg.format(nav().getClassName(clazz)), this ));
             }
         }
-    }
+        }
 
     public ClassInfoImpl<T,C,F,M> getBaseClass() {
-        if(!baseClassComputed) {
-            baseClassComputed = true;
+        if (!baseClassComputed) {
             // compute the base class
             C s = nav().getSuperClass(clazz);
-            if(s==null || s==nav().asDecl(Object.class))
+            if(s==null || s==nav().asDecl(Object.class)) {
                 baseClass = null;
-            else {
+            } else {
                 NonElement<T,C> b = builder.getClassInfo(s, true, this);
                 if(b instanceof ClassInfoImpl) {
                     baseClass = (ClassInfoImpl<T,C,F,M>) b;
@@ -205,6 +212,7 @@
                     baseClass = null;
                 }
             }
+            baseClassComputed = true;
         }
         return baseClass;
     }
@@ -290,8 +298,9 @@
         } else {
             //sort them as specified
             PropertySorter sorter = new PropertySorter();
-            for (PropertyInfoImpl p : properties)
+            for (PropertyInfoImpl p : properties) {
                 sorter.checkedGet(p);   // have it check for errors
+            }
             Collections.sort(properties,sorter);
             sorter.checkUnusedProperties();
         }
@@ -340,13 +349,17 @@
     }
 
     private void findFieldProperties(C c, XmlAccessType at) {
+
         // always find properties from the super class first
         C sc = nav().getSuperClass(c);
-        if(shouldRecurseSuperClass(sc))
+        if (shouldRecurseSuperClass(sc)) {
             findFieldProperties(sc,at);
+        }
 
         for( F f : nav().getDeclaredFields(c) ) {
             Annotation[] annotations = reader().getAllFieldAnnotations(f,this);
+            boolean isDummy = reader().hasFieldAnnotation(OverrideAnnotationOf.class, f);
+
             if( nav().isTransient(f) ) {
                 // it's an error for transient field to have any binding annotation
                 if(hasJAXBAnnotation(annotations))
@@ -357,12 +370,23 @@
             if( nav().isStaticField(f) ) {
                 // static fields are bound only when there's explicit annotation.
                 if(hasJAXBAnnotation(annotations))
-                    addProperty(createFieldSeed(f),annotations);
+                    addProperty(createFieldSeed(f),annotations, false);
             } else {
                 if(at==XmlAccessType.FIELD
                 ||(at==XmlAccessType.PUBLIC_MEMBER && nav().isPublicField(f))
-                || hasJAXBAnnotation(annotations))
-                    addProperty(createFieldSeed(f),annotations);
+                || hasJAXBAnnotation(annotations)) {
+                    if (isDummy) {
+                        ClassInfo<T, C> top = getBaseClass();
+                        while ((top != null) && (top.getProperty("content") == null)) {
+                            top = top.getBaseClass();
+                        }
+                        DummyPropertyInfo prop = (DummyPropertyInfo) top.getProperty("content");
+                        PropertySeed seed = createFieldSeed(f);
+                        ((DummyPropertyInfo)prop).addType(createReferenceProperty(seed));
+                    } else {
+                        addProperty(createFieldSeed(f), annotations, false);
+                    }
+                }
                 checkFieldXmlLocation(f);
             }
         }
@@ -378,7 +402,7 @@
         }
 
         return false;
-    }
+        }
 
     public PropertyInfo<T,C> getProperty(String name) {
         for( PropertyInfo<T,C> p: getProperties() ) {
@@ -467,7 +491,7 @@
             Integer i = get(p.getName());
             if(i==null) {
                 // missing
-                if((p.kind().isOrdered))
+                if (p.kind().isOrdered)
                     builder.reportError(new IllegalAnnotationException(
                         Messages.PROPERTY_MISSING_FROM_ORDER.format(p.getName()),p));
 
@@ -500,8 +524,20 @@
             for( int i=0; i<used.length; i++ )
                 if(used[i]==null) {
                     String unusedName = propOrder[i];
-                    builder.reportError(new IllegalAnnotationException(
-                        Messages.PROPERTY_ORDER_CONTAINS_UNUSED_ENTRY.format(unusedName),ClassInfoImpl.this));
+                    String nearest = EditDistance.findNearest(unusedName, new AbstractList<String>() {
+                        public String get(int index) {
+                            return properties.get(index).getName();
+                        }
+
+                        public int size() {
+                            return properties.size();
+                        }
+                    });
+                    boolean isOverriding = (i > (properties.size()-1)) ? false : properties.get(i).hasAnnotation(OverrideAnnotationOf.class);
+                    if (!isOverriding) {
+                        builder.reportError(new IllegalAnnotationException(
+                        Messages.PROPERTY_ORDER_CONTAINS_UNUSED_ENTRY.format(unusedName,nearest),ClassInfoImpl.this));
+                    }
                 }
         }
     }
@@ -536,9 +572,9 @@
         }
     }
 
-    private static final class DupliateException extends Exception {
+    private static final class DuplicateException extends Exception {
         final Annotation a1,a2;
-        public DupliateException(Annotation a1, Annotation a2) {
+        public DuplicateException(Annotation a1, Annotation a2) {
             this.a1 = a1;
             this.a2 = a2;
         }
@@ -628,6 +664,7 @@
             XmlElementRefs.class,   // 7
             XmlAnyElement.class,    // 8
             XmlMixed.class,         // 9
+            OverrideAnnotationOf.class,// 10
         };
 
         HashMap<Class,Integer> m = ANNOTATION_NUMBER_MAP;
@@ -645,10 +682,10 @@
         }
     }
 
-    private void checkConflict(Annotation a, Annotation b) throws DupliateException {
+    private void checkConflict(Annotation a, Annotation b) throws DuplicateException {
         assert b!=null;
         if(a!=null)
-            throw new DupliateException(a,b);
+            throw new DuplicateException(a,b);
     }
 
     /**
@@ -663,7 +700,7 @@
      *      {@code seed.readAllAnnotation()}, but taken as a parameter
      *      because the caller should know it already.
      */
-    private void addProperty( PropertySeed<T,C,F,M> seed, Annotation[] annotations ) {
+    private void addProperty( PropertySeed<T,C,F,M> seed, Annotation[] annotations, boolean dummy ) {
         // since typically there's a very few annotations on a method,
         // this runs faster than checking for each annotation via readAnnotation(A)
 
@@ -681,6 +718,7 @@
         XmlElementRefs r2 = null;
         XmlAnyElement xae = null;
         XmlMixed mx = null;
+        OverrideAnnotationOf ov = null;
 
         // encountered secondary annotations are accumulated into a bit mask
         int secondaryAnnotations = 0;
@@ -700,6 +738,7 @@
                 case 7:     checkConflict(r2 ,ann); r2  = (XmlElementRefs) ann; break;
                 case 8:     checkConflict(xae,ann); xae = (XmlAnyElement) ann; break;
                 case 9:     checkConflict(mx, ann); mx  = (XmlMixed) ann; break;
+                case 10:    checkConflict(ov, ann); ov  = (OverrideAnnotationOf) ann; break;
                 default:
                     // secondary annotations
                     secondaryAnnotations |= (1<<(index-20));
@@ -732,7 +771,7 @@
                 group = PropertyGroup.ELEMENT;
                 groupCount++;
             }
-            if(r1!=null || r2!=null || xae!=null || mx!=null) {
+            if(r1!=null || r2!=null || xae!=null || mx!=null || ov != null) {
                 group = PropertyGroup.ELEMENT_REF;
                 groupCount++;
             }
@@ -837,7 +876,7 @@
                     err.get(0), err.get(1) ));
 
             // recover by ignoring this property
-        } catch( DupliateException e ) {
+        } catch( DuplicateException e ) {
             // both are present
             builder.reportError(new IllegalAnnotationException(
                 Messages.DUPLICATE_ANNOTATIONS.format(e.a1.annotationType().getName()),
@@ -940,7 +979,7 @@
                     System.arraycopy(sa,0,r,ga.length,sa.length);
                 }
 
-                addProperty(createAccessorSeed(getter, setter),r);
+                addProperty(createAccessorSeed(getter, setter), r, false);
             }
         }
         // done with complete pairs
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ERPropertyInfoImpl.java	Tue Aug  4 09:41:58 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ERPropertyInfoImpl.java	Tue Aug  4 09:41:58 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import javax.xml.bind.annotation.XmlElementWrapper;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ElementInfoImpl.java	Tue Aug  4 09:42:00 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ElementInfoImpl.java	Tue Aug  4 09:42:00 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ElementPropertyInfoImpl.java	Tue Aug  4 09:42:02 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ElementPropertyInfoImpl.java	Tue Aug  4 09:42:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.util.AbstractList;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/EnumConstantImpl.java	Tue Aug  4 09:42:05 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/EnumConstantImpl.java	Tue Aug  4 09:42:04 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import com.sun.xml.internal.bind.v2.model.core.EnumConstant;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/EnumLeafInfoImpl.java	Tue Aug  4 09:42:07 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/EnumLeafInfoImpl.java	Tue Aug  4 09:42:06 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.util.Iterator;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/FieldPropertySeed.java	Tue Aug  4 09:42:09 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/FieldPropertySeed.java	Tue Aug  4 09:42:09 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/GetterSetterPropertySeed.java	Tue Aug  4 09:42:11 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/GetterSetterPropertySeed.java	Tue Aug  4 09:42:11 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/LeafInfoImpl.java	Tue Aug  4 09:42:13 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/LeafInfoImpl.java	Tue Aug  4 09:42:13 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/MapPropertyInfoImpl.java	Tue Aug  4 09:42:16 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/MapPropertyInfoImpl.java	Tue Aug  4 09:42:15 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.util.Arrays;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/Messages.java	Tue Aug  4 09:42:18 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/Messages.java	Tue Aug  4 09:42:17 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.text.MessageFormat;
@@ -56,7 +57,7 @@
     SUPER_CLASS_HAS_WILDCARD, // 0 args
     INVALID_ATTRIBUTE_WILDCARD_TYPE, // 1 arg
     PROPERTY_MISSING_FROM_ORDER, // 1 arg
-    PROPERTY_ORDER_CONTAINS_UNUSED_ENTRY, // 1 arg
+    PROPERTY_ORDER_CONTAINS_UNUSED_ENTRY, // 2 args
 
     INVALID_XML_ENUM_VALUE, // 2 arg
     FAILED_TO_INITIALE_DATATYPE_FACTORY, // 0 args
@@ -72,7 +73,7 @@
     SIMPLE_TYPE_IS_REQUIRED, // 1 arg
     PROPERTY_COLLISION, // 1 arg
     INVALID_IDREF, // 1 arg
-    INVALID_XML_ELEMENT_REF, // 0 arg
+    INVALID_XML_ELEMENT_REF, // 1 arg
     NO_XML_ELEMENT_DECL, // 2 args
     XML_ELEMENT_WRAPPER_ON_NON_COLLECTION, // 1 arg
 
@@ -84,20 +85,31 @@
 
     INCOMPATIBLE_API_VERSION, // 2 args
     INCOMPATIBLE_API_VERSION_MUSTANG, // 2 args
+    RUNNING_WITH_1_0_RUNTIME, // 2 args
 
     MISSING_JAXB_PROPERTIES, // 1arg
     TRANSIENT_FIELD_NOT_BINDABLE, // 1 arg
     THERE_MUST_BE_VALUE_IN_XMLVALUE, // 1 arg
     UNMATCHABLE_ADAPTER, // 2 args
+    ANONYMOUS_ARRAY_ITEM, // 1 arg
 
     ACCESSORFACTORY_INSTANTIATION_EXCEPTION, // 2 arg
     ACCESSORFACTORY_ACCESS_EXCEPTION, // 2 arg
     CUSTOM_ACCESSORFACTORY_PROPERTY_ERROR, // 2 arg
     CUSTOM_ACCESSORFACTORY_FIELD_ERROR, // 2 arg
+        XMLGREGORIANCALENDAR_INVALID, // 1 arg
+        XMLGREGORIANCALENDAR_SEC, // 0 arg
+        XMLGREGORIANCALENDAR_MIN, // 0 arg
+        XMLGREGORIANCALENDAR_HR, // 0 arg
+        XMLGREGORIANCALENDAR_DAY, // 0 arg
+        XMLGREGORIANCALENDAR_MONTH, // 0 arg
+        XMLGREGORIANCALENDAR_YEAR, // 0 arg
+        XMLGREGORIANCALENDAR_TIMEZONE, // 0 arg
     ;
 
     private static final ResourceBundle rb = ResourceBundle.getBundle(Messages.class.getName());
 
+    @Override
     public String toString() {
         return format();
     }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/Messages.properties	Tue Aug  4 09:42:20 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/Messages.properties	Tue Aug  4 09:42:20 2009
@@ -51,7 +51,7 @@
     Property "{0}" appears more than once in the @XmlType.propOrder
 
 DUPLICATE_PROPERTIES = \
-    There are two properties named "{0}" 
+    There are two properties named "{0}"
 
 XML_ELEMENT_MAPPING_ON_NON_IXMLELEMENT_METHOD = \
     The {0} method has @XmlElementMapping on it, but it doesn''t return a sub-type of JAXBElement.
@@ -61,7 +61,7 @@
 
 CONFLICTING_XML_ELEMENT_MAPPING = \
     The element name '{'{0}'}'{1} has more than one mapping.
-    
+
 REFERENCE_TO_NON_ELEMENT = \
     Property {0} is annotated with @XmlReference but doesn''t refer to an element.
 
@@ -81,8 +81,8 @@
     Property {0} is present but not specified in @XmlType.propOrder
 
 PROPERTY_ORDER_CONTAINS_UNUSED_ENTRY = \
-    Property {0} appears in @XmlType.propOrder, but no such property exists
-    
+    Property {0} appears in @XmlType.propOrder, but no such property exists. Maybe you meant {1}?
+
 INVALID_XML_ENUM_VALUE = \
     "{0}" is not a valid value for {1}.
 
@@ -121,7 +121,7 @@
     XmlIDREF property is referencing a type "{0}" that doesn''t have an XmlID property.
 
 INVALID_XML_ELEMENT_REF = \
-    XmlElementRef points to a non-existent class.
+    Invalid @XmlElementRef : Type "{0}" or any of it's subclasses are not known to this context.
 
 NO_XML_ELEMENT_DECL = \
     There''s no ObjectFactory with an @XmlElementDecl for the element '{'{0}'}'{1}.
@@ -161,8 +161,12 @@
     Use the endorsed directory mechanism to place jaxb-api.jar in the bootstrap classloader. \
     (See http://java.sun.com/j2se/1.5.0/docs/guide/standards/)
 
+RUNNING_WITH_1_0_RUNTIME = \
+    You are trying to run JAXB 2.0 runtime (from {1}) but you have old JAXB 1.0 runtime earlier \
+    in the classpath (at {0}) Please remove the JAXB 1.0 runtime for 2.0 runtime to work correctly.
+
 UNMATCHABLE_ADAPTER = \
-    Adapter {0} is not applicable to the field type {1}. 
+    Adapter {0} is not applicable to the field type {1}.
 
 ACCESSORFACTORY_INSTANTIATION_EXCEPTION = \
     Unable to create instance of AccessorFactory, {0} for class {1}.
@@ -175,4 +179,30 @@
 
 CUSTOM_ACCESSORFACTORY_FIELD_ERROR = \
     Custom AccessorFactory, {0}, is reporting an error accessing a field. {1}
- 
+
+ANONYMOUS_ARRAY_ITEM = \
+    {0} is used as an array component type, so it cannot be anonymous.
+
+XMLGREGORIANCALENDAR_INVALID = \
+    Invalid set of fields set for XMLGregorianCalendar type {0}.
+
+XMLGREGORIANCALENDAR_SEC = \
+    Seconds not set.
+
+XMLGREGORIANCALENDAR_MIN = \
+    Minutes not set.
+
+XMLGREGORIANCALENDAR_HR = \
+    Hour not set.
+
+XMLGREGORIANCALENDAR_DAY = \
+    Day not set.
+
+XMLGREGORIANCALENDAR_MONTH = \
+    Month not set.
+
+XMLGREGORIANCALENDAR_YEAR = \
+    Year not set.
+
+XMLGREGORIANCALENDAR_TIMEZONE = \
+    Timezone not set.
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ModelBuilder.java	Tue Aug  4 09:42:22 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ModelBuilder.java	Tue Aug  4 09:42:22 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.util.HashMap;
@@ -50,6 +51,7 @@
 import com.sun.xml.internal.bind.v2.model.core.TypeInfoSet;
 import com.sun.xml.internal.bind.v2.model.nav.Navigator;
 import com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationException;
+import com.sun.xml.internal.bind.WhiteSpaceProcessor;
 
 
 /**
@@ -161,6 +163,22 @@
                 Which.which(XmlSchema.class),
                 Which.which(ModelBuilder.class)
             ));
+        }
+    }
+
+    /**
+     * Makes sure that we don't have conflicting 1.0 runtime,
+     * and report an error if we do.
+     */
+    static {
+        try {
+            WhiteSpaceProcessor.isWhiteSpace("xyz");
+        } catch (NoSuchMethodError e) {
+            // we seem to be getting 1.0 runtime
+            throw new LinkageError( Messages.RUNNING_WITH_1_0_RUNTIME.format(
+                Which.which(WhiteSpaceProcessor.class),
+                Which.which(ModelBuilder.class)
+            ));
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/PropertyInfoImpl.java	Tue Aug  4 09:42:25 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/PropertyInfoImpl.java	Tue Aug  4 09:42:24 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.util.Collection;
@@ -103,8 +104,6 @@
         }
         this.expectedMimeType = mt;
         this.inlineBinary = seed.hasAnnotation(XmlInlineBinaryData.class);
-        this.schemaType = Util.calcSchemaType(reader(),seed,parent.clazz,
-                getIndividualType(),this);
 
         T t = seed.getRawType();
 
@@ -147,6 +146,8 @@
         }
 
         this.id = calcId();
+        this.schemaType = Util.calcSchemaType(reader(),seed,parent.clazz,
+                getIndividualType(),this);
     }
 
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/PropertySeed.java	Tue Aug  4 09:42:27 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/PropertySeed.java	Tue Aug  4 09:42:26 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import com.sun.xml.internal.bind.v2.model.annotation.Locatable;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ReferencePropertyInfoImpl.java	Tue Aug  4 09:42:29 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ReferencePropertyInfoImpl.java	Tue Aug  4 09:42:29 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.util.Collections;
@@ -47,6 +48,7 @@
 import com.sun.xml.internal.bind.v2.model.core.WildcardMode;
 import com.sun.xml.internal.bind.v2.model.nav.Navigator;
 import com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationException;
+import java.util.Iterator;
 
 /**
  * Implementation of {@link ReferencePropertyInfo}.
@@ -55,7 +57,7 @@
  */
 class ReferencePropertyInfoImpl<T,C,F,M>
     extends ERPropertyInfoImpl<T,C,F,M>
-    implements ReferencePropertyInfo<T,C>
+    implements ReferencePropertyInfo<T,C>, DummyPropertyInfo<T, C, F, M>
 {
     /**
      * Lazily computed.
@@ -62,13 +64,18 @@
      * @see #getElements()
      */
     private Set<Element<T,C>> types;
+    private Set<PropertyInfoImpl<T,C,F,M>> subTypes = new LinkedHashSet<PropertyInfoImpl<T,C,F,M>>();
 
     private final boolean isMixed;
 
     private final WildcardMode wildcard;
     private final C domHandler;
+    /**
+     * Lazily computed.
+     * @see #isRequired()
+     */
+    private Boolean isRequired;
 
-
     public ReferencePropertyInfoImpl(
         ClassInfoImpl<T,C,F,M> classInfo,
         PropertySeed<T,C,F,M> seed) {
@@ -75,7 +82,7 @@
 
         super(classInfo, seed);
 
-        isMixed = seed.readAnnotation(XmlMixed.class)!=null;
+        isMixed = seed.readAnnotation(XmlMixed.class) != null;
 
         XmlAnyElement xae = seed.readAnnotation(XmlAnyElement.class);
         if(xae==null) {
@@ -131,6 +138,8 @@
                 ann = null;
         }
 
+        isRequired = !isCollection();  // this is by default, to remain compatible with 2.1
+
         if(ann!=null) {
             Navigator<T,C,F,M> nav = nav();
             AnnotationReader<T,C,F,M> reader = reader();
@@ -147,6 +156,11 @@
                 else
                     yield = addAllSubtypes(type);
 
+                // essentially "isRequired &= isRequired(r)" except that we'd like to skip evaluating isRequird(r)
+                // if the value is already false.
+                if(isRequired && !isRequired(r))
+                    isRequired = false;
+
                 if(last && !yield) {
                     // a reference didn't produce any type.
                     // diagnose the problem
@@ -159,7 +173,7 @@
                         ));
                     } else {
                         parent.builder.reportError(new IllegalAnnotationException(
-                            Messages.INVALID_XML_ELEMENT_REF.format(),this));
+                            Messages.INVALID_XML_ELEMENT_REF.format(type),this));
                     }
 
                     // reporting one error would do.
@@ -171,10 +185,102 @@
             }
         }
 
+        Iterator<PropertyInfoImpl<T,C,F,M>> i = subTypes.iterator();
+        while (i.hasNext()) {
+
+            ReferencePropertyInfoImpl<T,C,F,M> info = (ReferencePropertyInfoImpl<T, C, F, M>) i.next();
+            PropertySeed sd = info.seed;
+            refs = sd.readAnnotation(XmlElementRefs.class);
+            ref = sd.readAnnotation(XmlElementRef.class);
+
+            if (refs != null && ref != null) {
+                parent.builder.reportError(new IllegalAnnotationException(
+                        Messages.MUTUALLY_EXCLUSIVE_ANNOTATIONS.format(
+                        nav().getClassName(parent.getClazz())+'#'+seed.getName(),
+                        ref.annotationType().getName(), refs.annotationType().getName()),
+                        ref, refs ));
+            }
+
+            if (refs != null) {
+                ann = refs.value();
+            } else {
+                if (ref != null) {
+                    ann = new XmlElementRef[]{ref};
+                } else {
+                    ann = null;
+                }
+            }
+
+            if (ann != null) {
+                Navigator<T,C,F,M> nav = nav();
+                AnnotationReader<T,C,F,M> reader = reader();
+
+                final T defaultType = nav.ref(XmlElementRef.DEFAULT.class);
+                final C je = nav.asDecl(JAXBElement.class);
+
+                for( XmlElementRef r : ann ) {
+                    boolean yield;
+                    T type = reader.getClassValue(r,"type");
+                    if (type.equals(defaultType)) {
+                        type = nav.erasure(getIndividualType());
+                    }
+                    if (nav.getBaseClass(type,je) != null) {
+                        yield = addGenericElement(r, info);
+
+                    } else {
+                        yield = addAllSubtypes(type);
+                    }
+
+                    if(last && !yield) {
+                        // a reference didn't produce any type.
+                        // diagnose the problem
+                        if(type.equals(nav.ref(JAXBElement.class))) {
+                            // no XmlElementDecl
+                            parent.builder.reportError(new IllegalAnnotationException(
+                                Messages.NO_XML_ELEMENT_DECL.format(
+                                    getEffectiveNamespaceFor(r), r.name()),
+                                this
+                            ));
+                        } else {
+                            parent.builder.reportError(new IllegalAnnotationException(
+                                Messages.INVALID_XML_ELEMENT_REF.format(),this));
+                        }
+
+                        // reporting one error would do.
+                        // often the element ref field is using @XmlElementRefs
+                        // to point to multiple JAXBElements.
+                        // reporting one error for each @XmlElemetnRef is thus often redundant.
+                        return;
+                    }
+                }
+            }
+        }
+
         types = Collections.unmodifiableSet(types);
     }
 
+    public boolean isRequired() {
+        if(isRequired==null)
+            calcTypes(false);
+        return isRequired;
+    }
+
     /**
+     * If we find out that we are working with 2.1 API, remember the fact so that
+     * we don't waste time generating exceptions every time we call {@link #isRequired(XmlElementRef)}.
+     */
+    private static boolean is2_2 = true;
+
+    /**
+     * Reads the value of {@code XmlElementRef.required()}.
+     *
+     * If we are working as 2.1 RI, this defaults to true.
+     */
+    private boolean isRequired(XmlElementRef ref) {
+        return true;
+    }
+
+    /**
      * @return
      *      true if the reference yields at least one type
      */
@@ -184,6 +290,13 @@
         return addGenericElement(parent.owner.getElementInfo(parent.getClazz(),new QName(nsUri,r.name())));
     }
 
+    private boolean addGenericElement(XmlElementRef r, ReferencePropertyInfoImpl<T,C,F,M> info) {
+        String nsUri = info.getEffectiveNamespaceFor(r);
+        ElementInfo ei = parent.owner.getElementInfo(info.parent.getClazz(), new QName(nsUri, r.name()));
+        types.add(ei);
+        return true;
+    }
+
     private String getEffectiveNamespaceFor(XmlElementRef r) {
         String nsUri = r.namespace();
 
@@ -244,6 +357,7 @@
     }
 
 
+    @Override
     protected void link() {
         super.link();
 
@@ -254,6 +368,9 @@
 
     }
 
+    public final void addType(PropertyInfoImpl<T,C,F,M> info) {
+        subTypes.add(info);
+    }
 
     public final boolean isMixed() {
         return isMixed;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RegistryInfoImpl.java	Tue Aug  4 09:42:31 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RegistryInfoImpl.java	Tue Aug  4 09:42:31 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.util.LinkedHashSet;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeAnyTypeImpl.java	Tue Aug  4 09:42:33 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeAnyTypeImpl.java	Tue Aug  4 09:42:33 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeArrayInfoImpl.java	Tue Aug  4 09:42:36 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeArrayInfoImpl.java	Tue Aug  4 09:42:35 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeAttributePropertyInfoImpl.java	Tue Aug  4 09:42:38 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeAttributePropertyInfoImpl.java	Tue Aug  4 09:42:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeBuiltinLeafInfoImpl.java	Tue Aug  4 09:42:40 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeBuiltinLeafInfoImpl.java	Tue Aug  4 09:42:40 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.awt.*;
@@ -56,6 +57,7 @@
 import javax.activation.MimeTypeParseException;
 import javax.imageio.ImageIO;
 import javax.imageio.ImageWriter;
+import javax.imageio.stream.ImageOutputStream;
 import javax.xml.bind.ValidationEvent;
 import javax.xml.bind.helpers.ValidationEventImpl;
 import javax.xml.datatype.DatatypeConfigurationException;
@@ -174,6 +176,7 @@
     public static final RuntimeBuiltinLeafInfoImpl<String> STRING = new StringImpl<String>(String.class,
         createXS("string"),
         createXS("normalizedString"),
+        createXS("anyURI"),
         createXS("token"),
         createXS("language"),
         createXS("Name"),
@@ -282,12 +285,29 @@
                     return v.toExternalForm();
                 }
             },
+            new StringImpl<URI>(URI.class, createXS("string")) {
+                public URI parse(CharSequence text) throws SAXException {
+                    try {
+                        return new URI(text.toString());
+                    } catch (URISyntaxException e) {
+                        UnmarshallingContext.getInstance().handleError(e);
+                        return null;
+                    }
+                }
+
+                public String print(URI v) {
+                    return v.toString();
+                }
+            },
             new StringImpl<Class>(Class.class, createXS("string")) {
                 public Class parse(CharSequence text) throws SAXException {
                     TODO.checkSpec("JSR222 Issue #42");
                     try {
                         String name = WhiteSpaceProcessor.trim(text).toString();
-                        ClassLoader cl = Thread.currentThread().getContextClassLoader();
+                        ClassLoader cl = UnmarshallingContext.getInstance().classLoader;
+                        if(cl==null)
+                            cl = Thread.currentThread().getContextClassLoader();
+
                         if(cl!=null)
                             return cl.loadClass(name);
                         else
@@ -319,7 +339,11 @@
                         // normally images can be content-sniffed.
                         // so the MIME type check will only make us slower and draconian, both of which
                         // JAXB 2.0 isn't interested.
-                        return ImageIO.read(is);
+                        try {
+                            return ImageIO.read(is);
+                        } finally {
+                            is.close();
+                        }
                     } catch (IOException e) {
                         UnmarshallingContext.getInstance().handleError(e);
                         return null;
@@ -366,8 +390,10 @@
                         Iterator<ImageWriter> itr = ImageIO.getImageWritersByMIMEType(mimeType);
                         if(itr.hasNext()) {
                             ImageWriter w = itr.next();
-                            w.setOutput(ImageIO.createImageOutputStream(imageData));
+                            ImageOutputStream os = ImageIO.createImageOutputStream(imageData);
+                            w.setOutput(os);
                             w.write(convertToBufferedImage(v));
+                            os.close();
                             w.dispose();
                         } else {
                             // no encoder
@@ -383,7 +409,7 @@
                         // TODO: proper error reporting
                         throw new RuntimeException(e);
                     }
-                    Base64Data bd = xs.getCachedBase64DataInstance();
+                    Base64Data bd = new Base64Data();
                     imageData.set(bd,mimeType);
                     return bd;
                 }
@@ -398,7 +424,7 @@
                 }
 
                 public Base64Data print(DataHandler v) {
-                    Base64Data bd = XMLSerializer.getInstance().getCachedBase64DataInstance();
+                    Base64Data bd = new Base64Data();
                     bd.set(v);
                     return bd;
                 }
@@ -419,7 +445,7 @@
 
                 public Base64Data print(Source v) {
                     XMLSerializer xs = XMLSerializer.getInstance();
-                    Base64Data bd = xs.getCachedBase64DataInstance();
+                    Base64Data bd = new Base64Data();
 
                     String contentType = xs.getXMIMEContentType();
                     MimeType mt = null;
@@ -486,21 +512,27 @@
 
                     QName type = xs.getSchemaType();
                     if(type!=null) {
-                        String format = xmlGregorianCalendarFormatString.get(type);
-                        if(format!=null)
-                            return format(format,cal);
-                        // TODO:
-                        // we need to think about how to report an error where @XmlSchemaType
-                        // didn't take effect. a general case is when a transducer isn't even
-                        // written to look at that value.
-                    }
-
+                                                try {
+                                                        checkXmlGregorianCalendarFieldRef(type, cal);
+                                                        String format = xmlGregorianCalendarFormatString.get(type);
+                                                        if(format!=null)
+                                                                return format(format,cal);
+                                                        // TODO:
+                                                        // we need to think about how to report an error where @XmlSchemaType
+                                                        // didn't take effect. a general case is when a transducer isn't even
+                                                        // written to look at that value.
+                                                } catch (javax.xml.bind.MarshalException e){
+                                                        //-xs.handleError(e);
+                                                        System.out.println(e.toString());
+                                                        return "";
+                                                }
+                                        }
                     return cal.toXMLFormat();
                 }
 
                 public XMLGregorianCalendar parse(CharSequence lexical) throws SAXException {
                     try {
-                        return datatypeFactory.newXMLGregorianCalendar(lexical.toString());
+                        return datatypeFactory.newXMLGregorianCalendar(lexical.toString().trim()); // (.trim() - issue 396)
                     } catch (Exception e) {
                         UnmarshallingContext.getInstance().handleError(e);
                         return null;
@@ -611,7 +643,7 @@
 
                 public Base64Data print(byte[] v) {
                     XMLSerializer w = XMLSerializer.getInstance();
-                    Base64Data bd = w.getCachedBase64DataInstance();
+                    Base64Data bd = new Base64Data();
                     String mimeType = w.getXMIMEContentType();
                     bd.set(v,mimeType);
                     return bd;
@@ -737,21 +769,6 @@
                     w.getNamespaceContext().declareNamespace(v.getNamespaceURI(),v.getPrefix(),false);
                 }
             },
-            new StringImpl<URI>(URI.class, createXS("anyURI")) {
-                public URI parse(CharSequence text) throws SAXException {
-                    TODO.checkSpec("JSR222 Issue #42");
-                    try {
-                        return new URI(text.toString());
-                    } catch (URISyntaxException e) {
-                        UnmarshallingContext.getInstance().handleError(e);
-                        return null;
-                    }
-                }
-
-                public String print(URI v) {
-                    return v.toString();
-                }
-            },
             new StringImpl<Duration>(Duration.class,  createXS("duration")) {
                 public String print(Duration duration) {
                     return duration.toString();
@@ -821,6 +838,61 @@
         }
     }
 
+        private static void checkXmlGregorianCalendarFieldRef(QName type,
+                XMLGregorianCalendar cal)throws javax.xml.bind.MarshalException{
+                StringBuffer buf = new StringBuffer();
+                int bitField = xmlGregorianCalendarFieldRef.get(type);
+                final int l = 0x1;
+                int pos = 0;
+                while (bitField != 0x0){
+                        int bit = bitField & l;
+                        bitField >>>= 4;
+                        pos++;
+
+                        if (bit == 1) {
+                                switch(pos){
+                                        case 1:
+                                                if (cal.getSecond() == DatatypeConstants.FIELD_UNDEFINED){
+                                                        buf.append("  " + Messages.XMLGREGORIANCALENDAR_SEC);
+                                                }
+                                                break;
+                                        case 2:
+                                                if (cal.getMinute() == DatatypeConstants.FIELD_UNDEFINED){
+                                                        buf.append("  " + Messages.XMLGREGORIANCALENDAR_MIN);
+                                                }
+                                                break;
+                                        case 3:
+                                                if (cal.getHour() == DatatypeConstants.FIELD_UNDEFINED){
+                                                        buf.append("  " + Messages.XMLGREGORIANCALENDAR_HR);
+                                                }
+                                                break;
+                                        case 4:
+                                                if (cal.getDay() == DatatypeConstants.FIELD_UNDEFINED){
+                                                        buf.append("  " + Messages.XMLGREGORIANCALENDAR_DAY);
+                                                }
+                                                break;
+                                        case 5:
+                                                if (cal.getMonth() == DatatypeConstants.FIELD_UNDEFINED){
+                                                        buf.append("  " + Messages.XMLGREGORIANCALENDAR_MONTH);
+                                                }
+                                                break;
+                                        case 6:
+                                                if (cal.getYear() == DatatypeConstants.FIELD_UNDEFINED){
+                                                        buf.append("  " + Messages.XMLGREGORIANCALENDAR_YEAR);
+                                                }
+                                                break;
+                                        case 7:  // ignore timezone setting
+                                                break;
+                                }
+                        }
+                }
+                if (buf.length() > 0){
+                        throw new javax.xml.bind.MarshalException(
+                         Messages.XMLGREGORIANCALENDAR_INVALID.format(type.getLocalPart())
+                         + buf.toString());
+                }
+        }
+
     /**
      * Format string for the {@link XMLGregorianCalendar}.
      */
@@ -839,6 +911,30 @@
         m.put(DatatypeConstants.GMONTHDAY,  "--%M-%D" +"%z");
     }
 
+        /**
+         * Field designations for XMLGregorianCalendar format string.
+         * sec          0x0000001
+         * min          0x0000010
+         * hrs          0x0000100
+         * day          0x0001000
+         * month        0x0010000
+         * year         0x0100000
+         * timezone 0x1000000
+         */
+        private static final Map<QName, Integer> xmlGregorianCalendarFieldRef =
+                new HashMap<QName, Integer>();
+        static {
+                Map<QName, Integer> f = xmlGregorianCalendarFieldRef;
+                f.put(DatatypeConstants.DATETIME,   0x1111111);
+                f.put(DatatypeConstants.DATE,       0x1111000);
+                f.put(DatatypeConstants.TIME,       0x1000111);
+                f.put(DatatypeConstants.GDAY,       0x1001000);
+                f.put(DatatypeConstants.GMONTH,     0x1010000);
+                f.put(DatatypeConstants.GYEAR,      0x1100000);
+                f.put(DatatypeConstants.GYEARMONTH, 0x1110000);
+                f.put(DatatypeConstants.GMONTHDAY,  0x1011000);
+        }
+
     /**
      * {@link RuntimeBuiltinLeafInfoImpl} for {@link UUID}.
      *
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeClassInfoImpl.java	Tue Aug  4 09:42:42 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeClassInfoImpl.java	Tue Aug  4 09:42:42 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.io.IOException;
@@ -33,12 +34,14 @@
 import java.util.List;
 import java.util.Map;
 
-import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.JAXBException;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLStreamException;
-import javax.xml.bind.JAXBException;
 
 import com.sun.istack.internal.NotNull;
+import com.sun.xml.internal.bind.AccessorFactory;
+import com.sun.xml.internal.bind.AccessorFactoryImpl;
+import com.sun.xml.internal.bind.XmlAccessorFactory;
 import com.sun.xml.internal.bind.annotation.XmlLocation;
 import com.sun.xml.internal.bind.api.AccessorException;
 import com.sun.xml.internal.bind.v2.ClassFactory;
@@ -48,6 +51,7 @@
 import com.sun.xml.internal.bind.v2.model.runtime.RuntimeElement;
 import com.sun.xml.internal.bind.v2.model.runtime.RuntimePropertyInfo;
 import com.sun.xml.internal.bind.v2.model.runtime.RuntimeValuePropertyInfo;
+import com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationException;
 import com.sun.xml.internal.bind.v2.runtime.Location;
 import com.sun.xml.internal.bind.v2.runtime.Name;
 import com.sun.xml.internal.bind.v2.runtime.Transducer;
@@ -54,12 +58,8 @@
 import com.sun.xml.internal.bind.v2.runtime.XMLSerializer;
 import com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl;
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
-import com.sun.xml.internal.bind.AccessorFactory;
-import com.sun.xml.internal.bind.AccessorFactoryImpl;
 import com.sun.xml.internal.bind.v2.runtime.reflect.TransducedAccessor;
 import com.sun.xml.internal.bind.v2.runtime.unmarshaller.UnmarshallingContext;
-import com.sun.xml.internal.bind.XmlAccessorFactory;
-import com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationException;
 
 import org.xml.sax.Locator;
 import org.xml.sax.SAXException;
@@ -90,7 +90,8 @@
         AccessorFactory accFactory = null;
 
         // user providing class to be used.
-        if (((RuntimeModelBuilder)builder).context.xmlAccessorFactorySupport){
+        JAXBContextImpl context = ((RuntimeModelBuilder) builder).context;
+        if (context!=null && context.xmlAccessorFactorySupport){
             factoryAnn = findXmlAccessorFactoryAnnotation(clazz);
 
             if (factoryAnn != null) {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeElementInfoImpl.java	Tue Aug  4 09:42:45 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeElementInfoImpl.java	Tue Aug  4 09:42:44 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeElementPropertyInfoImpl.java	Tue Aug  4 09:42:47 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeElementPropertyInfoImpl.java	Tue Aug  4 09:42:46 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeEnumConstantImpl.java	Tue Aug  4 09:42:49 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeEnumConstantImpl.java	Tue Aug  4 09:42:49 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeEnumLeafInfoImpl.java	Tue Aug  4 09:42:51 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeEnumLeafInfoImpl.java	Tue Aug  4 09:42:51 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeMapPropertyInfoImpl.java	Tue Aug  4 09:42:53 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeMapPropertyInfoImpl.java	Tue Aug  4 09:42:53 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeModelBuilder.java	Tue Aug  4 09:42:56 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeModelBuilder.java	Tue Aug  4 09:42:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Field;
@@ -50,7 +51,10 @@
 import com.sun.xml.internal.bind.v2.runtime.Transducer;
 import com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl;
 import com.sun.xml.internal.bind.v2.runtime.unmarshaller.UnmarshallingContext;
+import com.sun.istack.internal.Nullable;
 
+import com.sun.xml.internal.bind.v2.WellKnownNamespace;
+import javax.xml.namespace.QName;
 import org.xml.sax.SAXException;
 
 /**
@@ -66,8 +70,9 @@
 public class RuntimeModelBuilder extends ModelBuilder<Type,Class,Field,Method> {
     /**
      * The {@link JAXBContextImpl} for which the model is built.
+     * Null when created for reflection.
      */
-    public final JAXBContextImpl context;
+    public final @Nullable JAXBContextImpl context;
 
     public RuntimeModelBuilder(JAXBContextImpl context, RuntimeAnnotationReader annotationReader, Map<Class, Class> subclassReplacements, String defaultNamespaceRemap) {
         super(annotationReader, Navigator.REFLECTION, subclassReplacements, defaultNamespaceRemap);
@@ -144,14 +149,20 @@
         if(src.inlineBinaryData())
             t = new InlineBinaryTransducer(t);
 
-        if(src.getSchemaType()!=null)
+        if(src.getSchemaType()!=null) {
+            if (src.getSchemaType().equals(createXSSimpleType())) {
+                return RuntimeBuiltinLeafInfoImpl.STRING;
+            }
             t = new SchemaTypeTransducer(t,src.getSchemaType());
+        }
 
         return t;
     }
 
+    private static QName createXSSimpleType() {
+        return new QName(WellKnownNamespace.XML_SCHEMA,"anySimpleType");
+    }
 
-
     /**
      * Transducer implementation for ID.
      *
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeReferencePropertyInfoImpl.java	Tue Aug  4 09:42:58 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeReferencePropertyInfoImpl.java	Tue Aug  4 09:42:57 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeTypeInfoSetImpl.java	Tue Aug  4 09:43:00 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeTypeInfoSetImpl.java	Tue Aug  4 09:43:00 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeTypeRefImpl.java	Tue Aug  4 09:43:02 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeTypeRefImpl.java	Tue Aug  4 09:43:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeValuePropertyInfoImpl.java	Tue Aug  4 09:43:04 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeValuePropertyInfoImpl.java	Tue Aug  4 09:43:04 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/SingleTypePropertyInfoImpl.java	Tue Aug  4 09:43:07 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/SingleTypePropertyInfoImpl.java	Tue Aug  4 09:43:06 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.util.Collections;
@@ -87,8 +88,8 @@
     public void link() {
         super.link();
 
-        if(!type.isSimpleType() && id()!=ID.IDREF) {
-            parent.builder.reportError(new IllegalAnnotationException(
+        if (!(NonElement.ANYTYPE_NAME.equals(type.getTypeName()) || type.isSimpleType() || id()==ID.IDREF)) {
+                parent.builder.reportError(new IllegalAnnotationException(
                 Messages.SIMPLE_TYPE_IS_REQUIRED.format(),
                 seed
             ));
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/TypeInfoImpl.java	Tue Aug  4 09:43:09 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/TypeInfoImpl.java	Tue Aug  4 09:43:08 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import javax.xml.bind.annotation.XmlRootElement;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/TypeInfoSetImpl.java	Tue Aug  4 09:43:11 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/TypeInfoSetImpl.java	Tue Aug  4 09:43:11 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import java.util.Collections;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/TypeRefImpl.java	Tue Aug  4 09:43:13 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/TypeRefImpl.java	Tue Aug  4 09:43:13 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/Util.java	Tue Aug  4 09:43:15 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/Util.java	Tue Aug  4 09:43:15 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import javax.activation.MimeType;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ValuePropertyInfoImpl.java	Tue Aug  4 09:43:18 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/ValuePropertyInfoImpl.java	Tue Aug  4 09:43:17 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.impl;
 
 import com.sun.xml.internal.bind.v2.model.core.PropertyKind;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/GenericArrayTypeImpl.java	Tue Aug  4 09:43:20 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/GenericArrayTypeImpl.java	Tue Aug  4 09:43:19 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.nav;
 
 import java.lang.reflect.GenericArrayType;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/Navigator.java	Tue Aug  4 09:43:22 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/Navigator.java	Tue Aug  4 09:43:22 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.nav;
 
 import java.util.Collection;
@@ -386,6 +387,9 @@
      *
      * This is only used to improve the error diagnostics, so
      * it's OK to fail to detect some inner classes as such.
+     *
+     * Note that this method should return false for nested classes
+     * (static classes.)
      */
     boolean isInnerClass(C clazz);
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/ParameterizedTypeImpl.java	Tue Aug  4 09:43:24 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/ParameterizedTypeImpl.java	Tue Aug  4 09:43:24 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.nav;
 
 import java.lang.reflect.MalformedParameterizedTypeException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/ReflectionNavigator.java	Tue Aug  4 09:43:27 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/ReflectionNavigator.java	Tue Aug  4 09:43:26 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.nav;
 
 import java.lang.reflect.Array;
@@ -143,7 +144,7 @@
 
         Type replace( TypeVariable v ) {
             for(int i=0; i<params.length; i++)
-                if(params[i]==v)
+                if(params[i].equals(v))
                     return args[i];
             return v;   // this is a free variable
         }
@@ -548,7 +549,7 @@
     }
 
     public boolean isInnerClass(Class clazz) {
-        return clazz.getEnclosingClass()!=null;
+        return clazz.getEnclosingClass()!=null && !Modifier.isStatic(clazz.getModifiers());
     }
 
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/TypeVisitor.java	Tue Aug  4 09:43:29 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/TypeVisitor.java	Tue Aug  4 09:43:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.nav;
 
 import java.lang.reflect.GenericArrayType;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/WildcardTypeImpl.java	Tue Aug  4 09:43:31 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/nav/WildcardTypeImpl.java	Tue Aug  4 09:43:31 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.nav;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeArrayInfo.java	Tue Aug  4 09:43:33 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeArrayInfo.java	Tue Aug  4 09:43:33 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeAttributePropertyInfo.java	Tue Aug  4 09:43:35 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeAttributePropertyInfo.java	Tue Aug  4 09:43:35 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeBuiltinLeafInfo.java	Tue Aug  4 09:43:38 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeBuiltinLeafInfo.java	Tue Aug  4 09:43:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeClassInfo.java	Tue Aug  4 09:43:40 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeClassInfo.java	Tue Aug  4 09:43:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeElement.java	Tue Aug  4 09:43:42 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeElement.java	Tue Aug  4 09:43:42 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeElementInfo.java	Tue Aug  4 09:43:44 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeElementInfo.java	Tue Aug  4 09:43:44 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeElementPropertyInfo.java	Tue Aug  4 09:43:46 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeElementPropertyInfo.java	Tue Aug  4 09:43:46 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeEnumLeafInfo.java	Tue Aug  4 09:43:49 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeEnumLeafInfo.java	Tue Aug  4 09:43:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeLeafInfo.java	Tue Aug  4 09:43:51 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeLeafInfo.java	Tue Aug  4 09:43:50 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeMapPropertyInfo.java	Tue Aug  4 09:43:53 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeMapPropertyInfo.java	Tue Aug  4 09:43:53 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeNonElement.java	Tue Aug  4 09:43:55 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeNonElement.java	Tue Aug  4 09:43:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeNonElementRef.java	Tue Aug  4 09:43:58 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeNonElementRef.java	Tue Aug  4 09:43:57 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimePropertyInfo.java	Tue Aug  4 09:44:00 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimePropertyInfo.java	Tue Aug  4 09:44:00 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeReferencePropertyInfo.java	Tue Aug  4 09:44:02 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeReferencePropertyInfo.java	Tue Aug  4 09:44:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeTypeInfo.java	Tue Aug  4 09:44:05 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeTypeInfo.java	Tue Aug  4 09:44:04 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeTypeInfoSet.java	Tue Aug  4 09:44:07 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeTypeInfoSet.java	Tue Aug  4 09:44:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeTypeRef.java	Tue Aug  4 09:44:09 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeTypeRef.java	Tue Aug  4 09:44:09 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeValuePropertyInfo.java	Tue Aug  4 09:44:12 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/RuntimeValuePropertyInfo.java	Tue Aug  4 09:44:11 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.model.runtime;
 
 import java.lang.reflect.Type;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/package-info.java	Tue Aug  4 09:44:14 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/runtime/package-info.java	Tue Aug  4 09:44:14 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /**
  * The specialization of {@link com.sun.xml.internal.bind.v2.model.core} for the runtime.
  *
--- old/src/share/classes/com/sun/xml/internal/bind/v2/package-info.java	Tue Aug  4 09:44:17 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/package-info.java	Tue Aug  4 09:44:16 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /**
  * <h1>The JAXB 2.0 runtime</h1>.
  *
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/AnyTypeBeanInfo.java	Tue Aug  4 09:44:19 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/AnyTypeBeanInfo.java	Tue Aug  4 09:44:19 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
@@ -51,8 +52,10 @@
  *
  * @author Kohsuke Kawaguchi
  */
-final class AnyTypeBeanInfo extends JaxBeanInfo<Object> {
+final class AnyTypeBeanInfo extends JaxBeanInfo<Object> implements AttributeAccessor {
 
+    private boolean nilIncluded = false;
+
     public AnyTypeBeanInfo(JAXBContextImpl grammar,RuntimeTypeInfo anyTypeInfo) {
         super(grammar, anyTypeInfo, Object.class, new QName(WellKnownNamespace.XML_SCHEMA,"anyType"), false, true, false);
     }
@@ -113,7 +116,9 @@
             String local = a.getLocalName();
             String name = a.getName();
             if(local==null) local = name;
-
+            if (uri.equals(WellKnownNamespace.XML_SCHEMA_INSTANCE) && ("nil".equals(local))) {
+                nilIncluded = true;
+            }
             if(name.startsWith("xmlns")) continue;// DOM reports ns decls as attributes
 
             target.attribute(uri,local,a.getValue());
@@ -163,4 +168,8 @@
     private static final W3CDomHandler domHandler = new W3CDomHandler();
     private static final DomLoader domLoader = new DomLoader(domHandler);
     private final XsiTypeLoader substLoader = new XsiTypeLoader(this);
+
+    public boolean isNilIncluded() {
+        return nilIncluded;
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/ArrayBeanInfoImpl.java	Tue Aug  4 09:44:22 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/ArrayBeanInfoImpl.java	Tue Aug  4 09:44:21 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
@@ -54,14 +55,18 @@
 
     private final Class itemType;
     private final JaxBeanInfo itemBeanInfo;
-    private final Loader loader;
+    private Loader loader;
 
     public ArrayBeanInfoImpl(JAXBContextImpl owner, RuntimeArrayInfo rai) {
         super(owner,rai,rai.getType(), rai.getTypeName(), false, true, false);
         this.itemType = jaxbType.getComponentType();
         this.itemBeanInfo = owner.getOrCreate(rai.getItemType());
+    }
 
-        loader = new ArrayLoader(owner);
+    @Override
+    protected void link(JAXBContextImpl grammar) {
+        getLoader(grammar,false);
+        super.link(grammar);
     }
 
     private final class ArrayLoader extends Loader implements Receiver {
@@ -119,7 +124,7 @@
             if(item==null) {
                 target.writeXsiNilTrue();
             } else {
-                target.childAsXsiType(item,"arrayItem",itemBeanInfo);
+                target.childAsXsiType(item,"arrayItem",itemBeanInfo, false);
             }
             target.endElement();
         }
@@ -168,6 +173,9 @@
     }
 
     public final Loader getLoader(JAXBContextImpl context, boolean typeSubstitutionCapable) {
+        if(loader==null)
+            loader = new ArrayLoader(context);
+
         // type substitution not possible
         return loader;
     }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/BinderImpl.java	Tue Aug  4 09:44:24 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/BinderImpl.java	Tue Aug  4 09:44:24 2009
@@ -151,6 +151,8 @@
     }
 
     public XmlNode getXMLNode(Object jaxbObject) {
+        if(jaxbObject==null)
+            throw new IllegalArgumentException();
         AssociationMap.Entry<XmlNode> e = assoc.byPeer(jaxbObject);
         if(e==null)     return null;
         return e.element();
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/BridgeAdapter.java	Tue Aug  4 09:44:27 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/BridgeAdapter.java	Tue Aug  4 09:44:26 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/BridgeContextImpl.java	Tue Aug  4 09:44:29 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/BridgeContextImpl.java	Tue Aug  4 09:44:29 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import javax.xml.bind.JAXBException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/BridgeImpl.java	Tue Aug  4 09:44:32 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/BridgeImpl.java	Tue Aug  4 09:44:31 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
@@ -132,7 +133,7 @@
         if(value==null) {
             out.writeXsiNilTrue();
         } else {
-            out.childAsXsiType(value,null,bi);
+            out.childAsXsiType(value,null,bi,false);
         }
         out.endElement();
     }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/ClassBeanInfoImpl.java	Tue Aug  4 09:44:34 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/ClassBeanInfoImpl.java	Tue Aug  4 09:44:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
@@ -36,6 +37,7 @@
 import java.util.logging.Logger;
 
 import javax.xml.bind.ValidationEvent;
+import javax.xml.bind.annotation.XmlRootElement;
 import javax.xml.bind.helpers.ValidationEventImpl;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLStreamException;
@@ -44,6 +46,7 @@
 import com.sun.xml.internal.bind.Util;
 import com.sun.xml.internal.bind.api.AccessorException;
 import com.sun.xml.internal.bind.v2.ClassFactory;
+import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 import com.sun.xml.internal.bind.v2.model.core.ID;
 import com.sun.xml.internal.bind.v2.model.runtime.RuntimeClassInfo;
 import com.sun.xml.internal.bind.v2.model.runtime.RuntimePropertyInfo;
@@ -65,8 +68,10 @@
  *
  * @author Kohsuke Kawaguchi (kohsuke.kawaguchi@sun.com)
  */
-public final class ClassBeanInfoImpl<BeanT> extends JaxBeanInfo<BeanT> {
+public final class ClassBeanInfoImpl<BeanT> extends JaxBeanInfo<BeanT> implements AttributeAccessor<BeanT> {
 
+    private boolean isNilIncluded = false;
+
     /**
      * Properties of this bean class but not its ancestor classes.
      */
@@ -288,17 +293,22 @@
 
     public void serializeRoot(BeanT bean, XMLSerializer target) throws SAXException, IOException, XMLStreamException {
         if(tagName==null) {
-            target.reportError(
-                    new ValidationEventImpl(
-                            ValidationEvent.ERROR,
-                            Messages.UNABLE_TO_MARSHAL_NON_ELEMENT.format(bean.getClass().getName()),
-                            null,
-                            null));
+            Class beanClass = bean.getClass();
+            String message;
+
+            if (beanClass.isAnnotationPresent(XmlRootElement.class)) {
+                message = Messages.UNABLE_TO_MARSHAL_UNBOUND_CLASS.format(beanClass.getName());
+            } else {
+                message = Messages.UNABLE_TO_MARSHAL_NON_ELEMENT.format(beanClass.getName());
+            }
+
+            target.reportError(new ValidationEventImpl(ValidationEvent.ERROR,message,null, null));
         }
         else {
             target.startElement(tagName,bean);
             target.childAsSoleContent(bean,null);
             target.endElement();
+            target.currentProperty.remove();
         }
     }
 
@@ -306,8 +316,10 @@
         if(superClazz!=null)
             superClazz.serializeBody(bean,target);
         try {
-            for( Property<BeanT> p : properties )
+            for( Property<BeanT> p : properties ) {
+                target.currentProperty.set(p);
                 p.serializeBody(bean,target, null);
+            }
         } catch (AccessorException e) {
             target.reportError(null,e);
         }
@@ -314,10 +326,20 @@
     }
 
     public void serializeAttributes(BeanT bean, XMLSerializer target) throws SAXException, IOException, XMLStreamException {
-        try {
-            for( AttributeProperty<BeanT> p : attributeProperties )
+        for( AttributeProperty<BeanT> p : attributeProperties )
+            try {
+                final Property parentProperty = target.getCurrentProperty();
+                target.currentProperty.set(p);
                 p.serializeAttributes(bean,target);
+                target.currentProperty.set(parentProperty);
+                if (p.attName.equals(WellKnownNamespace.XML_SCHEMA_INSTANCE, "nil")) {
+                    isNilIncluded = true;
+                }
+            } catch (AccessorException e) {
+                target.reportError(null,e);
+            }
 
+        try {
             if(inheritedAttWildcard!=null) {
                 Map<QName,String> map = inheritedAttWildcard.get(bean);
                 target.attWildcardAsAttributes(map,null);
@@ -329,8 +351,12 @@
 
     public void serializeURIs(BeanT bean, XMLSerializer target) throws SAXException {
         try {
-            for( Property<BeanT> p : uriProperties )
+            final Property parentProperty = target.getCurrentProperty();
+            for( Property<BeanT> p : uriProperties ) {
+                target.currentProperty.set(p);
                 p.serializeURIs(bean,target);
+            }
+            target.currentProperty.set(parentProperty);
 
             if(inheritedAttWildcard!=null) {
                 Map<QName,String> map = inheritedAttWildcard.get(bean);
@@ -369,4 +395,8 @@
     private static final AttributeProperty[] EMPTY_PROPERTIES = new AttributeProperty[0];
 
     private static final Logger logger = Util.getClassLogger();
+
+    public boolean isNilIncluded() {
+        return isNilIncluded;
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/CompositeStructureBeanInfo.java	Tue Aug  4 09:44:37 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/CompositeStructureBeanInfo.java	Tue Aug  4 09:44:36 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Coordinator.java	Tue Aug  4 09:44:39 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Coordinator.java	Tue Aug  4 09:44:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.util.HashMap;
@@ -96,13 +97,13 @@
     /**
      * The {@link Coordinator} in charge before this {@link Coordinator}.
      */
-    private Coordinator old;
+    private Object old;
 
     /**
      * A 'pointer' to a {@link Coordinator} that keeps track of the currently active {@link Coordinator}.
      * Having this improves the runtime performance.
      */
-    private Coordinator[] table;
+    private Object[] table;
 
     /**
      * When we set {@link #table} to null, record who did it.
@@ -148,13 +149,13 @@
     }
 
     public static Coordinator _getInstance() {
-        return activeTable.get()[0];
+        return (Coordinator) activeTable.get()[0];
     }
 
     // this much is necessary to avoid calling get and set twice when we push.
-    private static final ThreadLocal<Coordinator[]> activeTable = new ThreadLocal<Coordinator[]>() {
-        public Coordinator[] initialValue() {
-            return new Coordinator[1];
+    private static final ThreadLocal<Object[]> activeTable = new ThreadLocal<Object[]>() {
+        public Object[] initialValue() {
+            return new Object[1];
         }
     };
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/DomPostInitAction.java	Tue Aug  4 09:44:41 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/DomPostInitAction.java	Tue Aug  4 09:44:41 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.util.HashSet;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/ElementBeanInfoImpl.java	Tue Aug  4 09:44:43 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/ElementBeanInfoImpl.java	Tue Aug  4 09:44:43 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
@@ -37,6 +38,7 @@
 import com.sun.xml.internal.bind.v2.model.core.PropertyKind;
 import com.sun.xml.internal.bind.v2.model.nav.Navigator;
 import com.sun.xml.internal.bind.v2.model.runtime.RuntimeElementInfo;
+import com.sun.xml.internal.bind.v2.model.runtime.RuntimePropertyInfo;
 import com.sun.xml.internal.bind.v2.runtime.property.Property;
 import com.sun.xml.internal.bind.v2.runtime.property.PropertyFactory;
 import com.sun.xml.internal.bind.v2.runtime.property.UnmarshallerChain;
@@ -136,7 +138,7 @@
                     if(value==null) {
                         target.writeXsiNilTrue();
                     } else {
-                        target.childAsXsiType(value,"value",tbi);
+                        target.childAsXsiType(value,"value",tbi, false);
                     }
                     target.endElement();
                 } else {
@@ -172,6 +174,11 @@
 
             public void wrapUp() {
             }
+
+            public RuntimePropertyInfo getInfo() {
+                return property.getInfo();
+            }
+
         };
     }
 
@@ -224,6 +231,10 @@
             state.target = state.backup;
             state.backup = null;
 
+            if (state.nil) {
+                e.setNil(true);
+            }
+
             if(o!=null)
                 // if the value is a leaf type, it's often already set to the element
                 // through Accessor.
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/FilterTransducer.java	Tue Aug  4 09:44:46 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/FilterTransducer.java	Tue Aug  4 09:44:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/IllegalAnnotationException.java	Tue Aug  4 09:44:48 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/IllegalAnnotationException.java	Tue Aug  4 09:44:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.lang.annotation.Annotation;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/IllegalAnnotationsException.java	Tue Aug  4 09:44:50 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/IllegalAnnotationsException.java	Tue Aug  4 09:44:50 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/InlineBinaryTransducer.java	Tue Aug  4 09:44:53 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/InlineBinaryTransducer.java	Tue Aug  4 09:44:52 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/InternalBridge.java	Tue Aug  4 09:44:55 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/InternalBridge.java	Tue Aug  4 09:44:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/JAXBContextImpl.java	Tue Aug  4 09:44:57 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/JAXBContextImpl.java	Tue Aug  4 09:44:57 2009
@@ -40,6 +40,8 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 import javax.xml.bind.Binder;
 import javax.xml.bind.DatatypeConverter;
@@ -68,7 +70,6 @@
 import javax.xml.transform.sax.TransformerHandler;
 
 import com.sun.istack.internal.NotNull;
-import com.sun.istack.internal.Nullable;
 import com.sun.istack.internal.Pool;
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
 import com.sun.xml.internal.bind.api.AccessorException;
@@ -122,7 +123,6 @@
 /**
  * This class provides the implementation of JAXBContext.
  *
- * @version $Revision$
  */
 public final class JAXBContextImpl extends JAXBRIContext {
 
@@ -215,6 +215,10 @@
      */
     public final boolean allNillable;
 
+    /**
+     * Store properties, so that they can be recovered in the run (is here because of JSON encoding of Jersey).
+     */
+    public final boolean retainPropertyInfo;
 
     private WeakReference<RuntimeTypeInfoSet> typeInfoSetCache;
 
@@ -240,41 +244,38 @@
      * @param xmlAccessorFactorySupport
      *      Use custom com.sun.xml.internal.bind.v2.runtime.reflect.Accessor implementation.
      */
-    public JAXBContextImpl(Class[] classes, Collection<TypeReference> typeRefs,
-        Map<Class,Class> subclassReplacements, String defaultNsUri, boolean c14nSupport,
-        @Nullable RuntimeAnnotationReader ar, boolean xmlAccessorFactorySupport, boolean allNillable) throws JAXBException {
-        // initialize datatype converter with ours
-        DatatypeConverter.setDatatypeConverter(DatatypeConverterImpl.theInstance);
+    public JAXBContextImpl(JAXBContextBuilder builder) throws JAXBException {
 
-        if(defaultNsUri==null)      defaultNsUri="";    // fool-proof
+        this.defaultNsUri = builder.defaultNsUri;
+        this.retainPropertyInfo = builder.retainPropertyInfo;
+        this.annotaitonReader = builder.annotationReader;
+        this.subclassReplacements = builder.subclassReplacements;
+        this.c14nSupport = builder.c14nSupport;
+        this.classes = builder.classes;
+        this.xmlAccessorFactorySupport = builder.xmlAccessorFactorySupport;
+        this.allNillable = builder.allNillable;
 
-        if(ar==null)
-            ar = new RuntimeInlineAnnotationReader();
+        Collection<TypeReference> typeRefs = builder.typeRefs;
 
-        if(subclassReplacements==null)  subclassReplacements=Collections.emptyMap();
-        if(typeRefs==null)              typeRefs=Collections.emptyList();
+        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+            public Void run() {
+                DatatypeConverter.setDatatypeConverter(DatatypeConverterImpl.theInstance);
+                return null;
+            }
+        });
 
-        this.annotaitonReader = ar;
-        this.subclassReplacements = subclassReplacements;
-
-        boolean fastBoot;
+        boolean fastB;
         try {
-            fastBoot = Boolean.getBoolean(JAXBContextImpl.class.getName()+".fastBoot");
+            fastB = Boolean.getBoolean(JAXBContextImpl.class.getName()+".fastBoot");
         } catch (SecurityException e) {
-            fastBoot = false;
+            fastB = false;
         }
-        this.fastBoot = fastBoot;
+        this.fastBoot = fastB;
 
-        this.defaultNsUri = defaultNsUri;
-        this.c14nSupport = c14nSupport;
-        this.xmlAccessorFactorySupport = xmlAccessorFactorySupport;
-        this.allNillable = allNillable;
-        this.classes = new Class[classes.length];
         System.arraycopy(classes,0,this.classes,0,classes.length);
 
         RuntimeTypeInfoSet typeSet = getTypeInfoSet();
 
-
         // at least prepare the empty table so that we don't have to check for null later
         elements.put(null,new LinkedHashMap<QName, ElementBeanInfoImpl>());
 
@@ -378,7 +379,6 @@
             bridges.put(tr,bridge);
         }
 
-
         this.nameList = nameBuilder.conclude();
 
         for (JaxBeanInfo bi : beanInfos.values())
@@ -396,10 +396,19 @@
         return hasSwaRef;
     }
 
+    public RuntimeTypeInfoSet getRuntimeTypeInfoSet() {
+        try {
+            return getTypeInfoSet();
+        } catch (IllegalAnnotationsException e) {
+            // impossible, once the model is constructred
+            throw new AssertionError(e);
+        }
+    }
+
     /**
      * Creates a {@link RuntimeTypeInfoSet}.
      */
-    private RuntimeTypeInfoSet getTypeInfoSet() throws IllegalAnnotationsException {
+    public RuntimeTypeInfoSet getTypeInfoSet() throws IllegalAnnotationsException {
 
         // check cache
         if(typeInfoSetCache!=null) {
@@ -473,7 +482,7 @@
     }
 
     protected JaxBeanInfo getOrCreate( RuntimeArrayInfo ai ) {
-        JaxBeanInfo abi = beanInfos.get(ai.getType());
+        JaxBeanInfo abi = beanInfos.get(ai);
         if(abi!=null)   return abi;
 
         abi = new ArrayBeanInfoImpl(this,ai);
@@ -879,6 +888,13 @@
         return new QName(bi.getElementNamespaceURI(o),bi.getElementLocalName(o));
     }
 
+    public QName getElementName(Class o) throws JAXBException {
+        JaxBeanInfo bi = getBeanInfo(o,true);
+        if(!bi.isElement())
+            return null;
+        return new QName(bi.getElementNamespaceURI(o),bi.getElementLocalName(o));
+    }
+
     public Bridge createBridge(TypeReference ref) {
         return bridges.get(ref);
     }
@@ -925,6 +941,7 @@
         return pkg.getImplementationVersion();
     }
 
+    @Override
     public String toString() {
         StringBuilder buf = new StringBuilder(Which.which(getClass()) + " Build-Id: " + getBuildId());
         buf.append("\nClasses known to this context:\n");
@@ -976,8 +993,9 @@
         System.arraycopy(classes,0,newList,0,classes.length);
         newList[classes.length] = clazz;
 
-        return new JAXBContextImpl(newList,bridges.keySet(),subclassReplacements,
-        defaultNsUri,c14nSupport,annotaitonReader, xmlAccessorFactorySupport, allNillable);
+        JAXBContextBuilder builder = new JAXBContextBuilder(this);
+        builder.setClasses(newList);
+        return builder.build();
     }
 
     private static final Comparator<QName> QNAME_COMPARATOR = new Comparator<QName>() {
@@ -988,4 +1006,100 @@
             return lhs.getNamespaceURI().compareTo(rhs.getNamespaceURI());
         }
     };
+
+    public static class JAXBContextBuilder {
+
+        private boolean retainPropertyInfo = false;
+        private String defaultNsUri = "";
+        private @NotNull RuntimeAnnotationReader annotationReader = new RuntimeInlineAnnotationReader();
+        private @NotNull Map<Class,Class> subclassReplacements = Collections.emptyMap();
+        private boolean c14nSupport = false;
+        private Class[] classes;
+        private Collection<TypeReference> typeRefs;
+        private boolean xmlAccessorFactorySupport = false;
+        private boolean allNillable;
+
+        public JAXBContextBuilder() {};
+
+        public JAXBContextBuilder(JAXBContextImpl baseImpl) {
+            this.retainPropertyInfo = baseImpl.retainPropertyInfo;
+            this.defaultNsUri = baseImpl.defaultNsUri;
+            this.annotationReader = baseImpl.annotaitonReader;
+            this.subclassReplacements = baseImpl.subclassReplacements;
+            this.c14nSupport = baseImpl.c14nSupport;
+            this.classes = baseImpl.classes;
+            this.typeRefs = baseImpl.bridges.keySet();
+            this.xmlAccessorFactorySupport = baseImpl.xmlAccessorFactorySupport;
+            this.allNillable = baseImpl.allNillable;
+        }
+
+        public JAXBContextBuilder setRetainPropertyInfo(boolean val) {
+            this.retainPropertyInfo = val;
+            return this;
+        }
+
+        public JAXBContextBuilder setC14NSupport(boolean val) {
+            this.c14nSupport = val;
+            return this;
+        }
+
+        public JAXBContextBuilder setXmlAccessorFactorySupport(boolean val) {
+            this.xmlAccessorFactorySupport = val;
+            return this;
+        }
+
+        public JAXBContextBuilder setDefaultNsUri(String val) {
+            this.defaultNsUri = val;
+            return this;
+        }
+
+        public JAXBContextBuilder setAllNillable(boolean val) {
+            this.allNillable = val;
+            return this;
+        }
+
+        public JAXBContextBuilder setClasses(Class[] val) {
+            this.classes = val;
+            return this;
+        }
+
+        public JAXBContextBuilder setAnnotationReader(RuntimeAnnotationReader val) {
+            this.annotationReader = val;
+            return this;
+        }
+
+        public JAXBContextBuilder setSubclassReplacements(Map<Class,Class> val) {
+            this.subclassReplacements = val;
+            return this;
+        }
+
+        public JAXBContextBuilder setTypeRefs(Collection<TypeReference> val) {
+            this.typeRefs = val;
+            return this;
+        }
+
+        public JAXBContextImpl build() throws JAXBException {
+
+            // fool-proof
+            if (this.defaultNsUri == null) {
+                this.defaultNsUri = "";
+            }
+
+            if (this.subclassReplacements == null) {
+                this.subclassReplacements = Collections.emptyMap();
+            }
+
+            if (this.annotationReader == null) {
+                this.annotationReader = new RuntimeInlineAnnotationReader();
+            }
+
+            if (this.typeRefs == null) {
+                this.typeRefs = Collections.<TypeReference>emptyList();
+            }
+
+            return new JAXBContextImpl(this);
+        }
+
+    }
+
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/JaxBeanInfo.java	Tue Aug  4 09:45:00 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/JaxBeanInfo.java	Tue Aug  4 09:44:59 2009
@@ -414,33 +414,54 @@
      */
     protected final void setLifecycleFlags() {
         try {
-            for( Method m : jaxbType.getDeclaredMethods() ) {
-                String name = m.getName();
-                if(name.equals("beforeUnmarshal")) {
-                    if(match(m,unmarshalEventParams)) {
-                        cacheLifecycleMethod(m, FLAG_HAS_BEFORE_UNMARSHAL_METHOD);
+            Class<BeanT> jt = jaxbType;
+
+            if (lcm == null) {
+                lcm = new LifecycleMethods();
+            }
+
+            while (jt != null) {
+                for (Method m : jt.getDeclaredMethods()) {
+                    String name = m.getName();
+
+                    if (lcm.beforeUnmarshal == null) {
+                        if (name.equals("beforeUnmarshal")) {
+                            if (match(m, unmarshalEventParams)) {
+                                cacheLifecycleMethod(m, FLAG_HAS_BEFORE_UNMARSHAL_METHOD);
+                            }
+                        }
                     }
-                } else
-                if(name.equals("afterUnmarshal")) {
-                    if(match(m,unmarshalEventParams)) {
-                        cacheLifecycleMethod(m, FLAG_HAS_AFTER_UNMARSHAL_METHOD);
+
+                    if (lcm.afterUnmarshal == null) {
+                        if (name.equals("afterUnmarshal")) {
+                            if (match(m, unmarshalEventParams)) {
+                                cacheLifecycleMethod(m, FLAG_HAS_AFTER_UNMARSHAL_METHOD);
+                            }
+                        }
                     }
-                } else
-                if(name.equals("beforeMarshal")) {
-                    if(match(m,marshalEventParams)) {
-                        cacheLifecycleMethod(m, FLAG_HAS_BEFORE_MARSHAL_METHOD);
+
+                    if (lcm.beforeMarshal == null) {
+                        if (name.equals("beforeMarshal")) {
+                            if (match(m, marshalEventParams)) {
+                                cacheLifecycleMethod(m, FLAG_HAS_BEFORE_MARSHAL_METHOD);
+                            }
+                        }
                     }
-                } else
-                if(name.equals("afterMarshal")) {
-                    if(match(m,marshalEventParams)) {
-                        cacheLifecycleMethod(m, FLAG_HAS_AFTER_MARSHAL_METHOD);
+
+                    if (lcm.afterMarshal == null) {
+                        if (name.equals("afterMarshal")) {
+                            if (match(m, marshalEventParams)) {
+                                cacheLifecycleMethod(m, FLAG_HAS_AFTER_MARSHAL_METHOD);
+                            }
+                        }
                     }
                 }
+                jt = (Class<BeanT>) jt.getSuperclass();
             }
-        } catch(SecurityException e) {
+        } catch (SecurityException e) {
             // this happens when we don't have enough permission.
-            logger.log( Level.WARNING, Messages.UNABLE_TO_DISCOVER_EVENTHANDLER.format(
-                jaxbType.getName(), e ));
+            logger.log(Level.WARNING, Messages.UNABLE_TO_DISCOVER_EVENTHANDLER.format(
+                    jaxbType.getName(), e));
         }
     }
 
@@ -512,9 +533,9 @@
         try {
             m.invoke(child,unm,parent);
         } catch (IllegalAccessException e) {
-            UnmarshallingContext.getInstance().handleError(e);
+            UnmarshallingContext.getInstance().handleError(e, false);
         } catch (InvocationTargetException e) {
-            UnmarshallingContext.getInstance().handleError(e);
+            UnmarshallingContext.getInstance().handleError(e, false);
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/LeafBeanInfoImpl.java	Tue Aug  4 09:45:02 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/LeafBeanInfoImpl.java	Tue Aug  4 09:45:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/LifecycleMethods.java	Tue Aug  4 09:45:04 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/LifecycleMethods.java	Tue Aug  4 09:45:04 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.lang.reflect.Method;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Location.java	Tue Aug  4 09:45:07 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Location.java	Tue Aug  4 09:45:06 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/MarshallerImpl.java	Tue Aug  4 09:45:09 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/MarshallerImpl.java	Tue Aug  4 09:45:09 2009
@@ -53,6 +53,7 @@
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.validation.Schema;
 import javax.xml.validation.ValidatorHandler;
+import javax.xml.namespace.NamespaceContext;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
 import com.sun.xml.internal.bind.api.JAXBRIContext;
@@ -131,9 +132,6 @@
      *      non-null if the marshaller is working inside {@link BinderImpl}.
      */
     public MarshallerImpl( JAXBContextImpl c, AssociationMap assoc ) {
-        // initialize datatype converter with ours
-        DatatypeConverter.setDatatypeConverter(DatatypeConverterImpl.theInstance);
-
         context = c;
         serializer = new XMLSerializer(this);
         c14nSupport = context.c14nSupport;
@@ -149,6 +147,16 @@
         return context;
     }
 
+    /**
+     * Marshals to {@link OutputStream} with the given in-scope namespaces
+     * taken into account.
+     *
+     * @since 2.1.5
+     */
+    public void marshal(Object obj, OutputStream out, NamespaceContext inscopeNamespace) throws JAXBException {
+        write(obj, createWriter(out), new StAXPostInitAction(inscopeNamespace,serializer));
+    }
+
     public void marshal(Object obj, XMLStreamWriter writer) throws JAXBException {
         write(obj, XMLStreamWriterOutput.create(writer,context), new StAXPostInitAction(writer,serializer));
     }
@@ -252,7 +260,7 @@
                     if(obj==null)
                         serializer.writeXsiNilTrue();
                     else
-                        serializer.childAsXsiType(obj,"root",bi);
+                        serializer.childAsXsiType(obj,"root",bi, false);
                 }
                 serializer.endElement();
                 postwrite();
@@ -426,14 +434,18 @@
 
         if(encoding.equals("UTF-8")) {
             Encoded[] table = context.getUTF8NameTable();
+            final UTF8XmlOutput out;
             if(isFormattedOutput())
-                return new IndentingUTF8XmlOutput(os,indent,table);
+                out = new IndentingUTF8XmlOutput(os,indent,table);
             else {
                 if(c14nSupport)
-                    return new C14nXmlOutput(os,table,context.c14nSupport);
+                    out = new C14nXmlOutput(os,table,context.c14nSupport);
                 else
-                    return new UTF8XmlOutput(os,table);
+                    out = new UTF8XmlOutput(os,table);
             }
+            if(header!=null)
+                out.setHeader(header);
+            return out;
         }
 
         try {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Messages.java	Tue Aug  4 09:45:12 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Messages.java	Tue Aug  4 09:45:11 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.text.MessageFormat;
@@ -42,6 +43,7 @@
     DANGLING_IDREF, // 1 arg
     NULL_OUTPUT_RESOLVER, // 0 args
     UNABLE_TO_MARSHAL_NON_ELEMENT, // 1 arg
+    UNABLE_TO_MARSHAL_UNBOUND_CLASS, // 1 arg
     UNSUPPORTED_PROPERTY, // 1 arg
     NULL_PROPERTY_NAME, // 0 args
     MUST_BE_X, // 3 args
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Messages.properties	Tue Aug  4 09:45:15 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Messages.properties	Tue Aug  4 09:45:14 2009
@@ -24,13 +24,13 @@
 #
 
 NOT_MARSHALLABLE = \
-	the object parameter to marshal() is not marshallable
+        the object parameter to marshal() is not marshallable
 
 UNSUPPORTED_RESULT = \
-	unsupported javax.xml.parser.transform.Result parameter
+        unsupported javax.xml.parser.transform.Result parameter
 
 UNSUPPORTED_ENCODING = \
-	unsupported encoding: {0}
+        unsupported encoding: {0}
 
 ILLEGAL_PARAMETER = \
     Illegal "{0}" parameter: {1}
@@ -48,17 +48,17 @@
     The tag name "{0}" is not known to this JAXBContext.
 
 TYPE_MISMATCH = \
-	"{1}" property of a "{0}" object contains an object of type "{2}" but this is not allowed. \
-	See javadoc of this property for what this property can accept.
+        "{1}" property of a "{0}" object contains an object of type "{2}" but this is not allowed. \
+        See javadoc of this property for what this property can accept.
 
 MISSING_OBJECT = \
-	a required field "{0}" is missing an object
+        a required field "{0}" is missing an object
 
 NOT_IDENTIFIABLE = \
-	An object is referenced as IDREF but its ID field is null
+        An object is referenced as IDREF but its ID field is null
 
 DANGLING_IDREF = \
-	A tree contains a reference to ID "{0}" but it's not a part of the object graph
+        A tree contains a reference to ID "{0}" but it's not a part of the object graph
 
 NULL_OUTPUT_RESOLVER = \
     schema output resolver must not be null
@@ -66,6 +66,9 @@
 UNABLE_TO_MARSHAL_NON_ELEMENT = \
     unable to marshal type "{0}" as an element because it is missing an @XmlRootElement annotation
 
+UNABLE_TO_MARSHAL_UNBOUND_CLASS = \
+    unable to marshal type "{0}" as an element because it is not known to this context.
+
 UNSUPPORTED_PROPERTY = \
     "{0}" is not a supported property
 
@@ -74,7 +77,7 @@
 
 MUST_BE_X = \
     property "{0}" must be an instance of type {1}, not {2}
-    
+
 SUBSTITUTED_BY_ANONYMOUS_TYPE = \
     Instance of "{1}" is substituting "{0}", but "{2}" is bound to an anonymous type.
 
@@ -92,4 +95,3 @@
 
 FAILED_TO_GENERATE_SCHEMA = \
     Failed to generate schema.
- 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/MimeTypedTransducer.java	Tue Aug  4 09:45:17 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/MimeTypedTransducer.java	Tue Aug  4 09:45:17 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.awt.*;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Name.java	Tue Aug  4 09:45:20 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Name.java	Tue Aug  4 09:45:19 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/NameBuilder.java	Tue Aug  4 09:45:22 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/NameBuilder.java	Tue Aug  4 09:45:22 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.util.HashMap;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/NameList.java	Tue Aug  4 09:45:25 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/NameList.java	Tue Aug  4 09:45:24 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/RuntimeUtil.java	Tue Aug  4 09:45:27 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/RuntimeUtil.java	Tue Aug  4 09:45:27 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.util.Collections;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/SchemaTypeTransducer.java	Tue Aug  4 09:45:30 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/SchemaTypeTransducer.java	Tue Aug  4 09:45:30 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/StAXPostInitAction.java	Tue Aug  4 09:45:33 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/StAXPostInitAction.java	Tue Aug  4 09:45:32 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import javax.xml.namespace.NamespaceContext;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/SwaRefAdapter.java	Tue Aug  4 09:45:36 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/SwaRefAdapter.java	Tue Aug  4 09:45:35 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Transducer.java	Tue Aug  4 09:45:38 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/Transducer.java	Tue Aug  4 09:45:38 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/ValueListBeanInfoImpl.java	Tue Aug  4 09:45:41 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/ValueListBeanInfoImpl.java	Tue Aug  4 09:45:40 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/XMLSerializer.java	Tue Aug  4 09:45:44 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/XMLSerializer.java	Tue Aug  4 09:45:43 2009
@@ -52,6 +52,7 @@
 import javax.xml.transform.sax.SAXResult;
 
 import com.sun.istack.internal.SAXException2;
+import com.sun.xml.internal.bind.CycleRecoverable;
 import com.sun.xml.internal.bind.api.AccessorException;
 import com.sun.xml.internal.bind.marshaller.NamespacePrefixMapper;
 import com.sun.xml.internal.bind.util.ValidationEventLocatorExImpl;
@@ -61,10 +62,10 @@
 import com.sun.xml.internal.bind.v2.runtime.output.NamespaceContextImpl;
 import com.sun.xml.internal.bind.v2.runtime.output.Pcdata;
 import com.sun.xml.internal.bind.v2.runtime.output.XmlOutput;
+import com.sun.xml.internal.bind.v2.runtime.property.Property;
 import com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data;
 import com.sun.xml.internal.bind.v2.runtime.unmarshaller.IntData;
 import com.sun.xml.internal.bind.v2.util.CollisionCheckStack;
-import com.sun.xml.internal.bind.CycleRecoverable;
 
 import org.xml.sax.SAXException;
 
@@ -131,6 +132,9 @@
 
     private NamespaceContextImpl.Element nse;
 
+    // Introduced based on Jersey requirements - to be able to retrieve marshalled name
+    ThreadLocal<Property> currentProperty = new ThreadLocal<Property>();
+
     /**
      * Set to true if a text is already written,
      * and we need to print ' ' for additional text methods.
@@ -181,7 +185,6 @@
 
     public AttachmentMarshaller attachmentMarshaller;
 
-
     /*package*/ XMLSerializer( MarshallerImpl _owner ) {
         this.marshaller = _owner;
         this.grammar = marshaller.context;
@@ -192,11 +195,13 @@
 
     /**
      * Gets the cached instance of {@link Base64Data}.
+     *
+     * @deprecated
+     *      {@link Base64Data} is no longer cached, so that
+     *      XMLStreamWriterEx impl can retain the data, like JAX-WS does.
      */
     public Base64Data getCachedBase64DataInstance() {
-        if(base64Data==null)
-            base64Data = new Base64Data();
-        return base64Data;
+        return new Base64Data();
     }
 
     /**
@@ -607,7 +612,7 @@
      *      Used as a part of the error message in case anything goes wrong
      *      with 'o'.
      */
-    public final void childAsXsiType( Object child, String fieldName, JaxBeanInfo expected ) throws SAXException, IOException, XMLStreamException {
+    public final void childAsXsiType( Object child, String fieldName, JaxBeanInfo expected, boolean nillable) throws SAXException, IOException, XMLStreamException {
         if(child==null) {
             handleMissingObjectError(fieldName);
         } else {
@@ -658,12 +663,26 @@
                 }
             }
             actual.serializeURIs(child,this);
+
+            if (nillable) {
+                getNamespaceContext().declareNamespace(WellKnownNamespace.XML_SCHEMA_INSTANCE,"xsi",true);
+            }
+
             endNamespaceDecls(child);
             if(!asExpected) {
                 attribute(WellKnownNamespace.XML_SCHEMA_INSTANCE,"type",
                     DatatypeConverter.printQName(actualTypeName,getNamespaceContext()));
             }
+
             actual.serializeAttributes(child,this);
+            boolean nilDefined = false;
+            if (actual instanceof AttributeAccessor) {
+                nilDefined = ((AttributeAccessor)actual).isNilIncluded();
+            }
+            if ((nillable) && (!nilDefined)) {
+                attribute(WellKnownNamespace.XML_SCHEMA_INSTANCE,"nil","true");
+            }
+
             endAttributes();
             actual.serializeBody(child,this);
 
@@ -1028,6 +1047,14 @@
         return getCurrentLocation(null);
     }
 
+    /**
+     * May return null when the property hasn't been set.
+     * Introduced based on Jersey requirements.
+     */
+    public Property getCurrentProperty() {
+        return currentProperty.get();
+    }
+
     /**
      * When called from within the realm of the marshaller, this method
      * returns the current {@link XMLSerializer} in charge.
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/C14nXmlOutput.java	Tue Aug  4 09:45:46 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/C14nXmlOutput.java	Tue Aug  4 09:45:46 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/DOMOutput.java	Tue Aug  4 09:45:49 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/DOMOutput.java	Tue Aug  4 09:45:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import com.sun.xml.internal.bind.v2.runtime.AssociationMap;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/Encoded.java	Tue Aug  4 09:45:52 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/Encoded.java	Tue Aug  4 09:45:52 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/FastInfosetStreamWriterOutput.java	Tue Aug  4 09:45:54 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/FastInfosetStreamWriterOutput.java	Tue Aug  4 09:45:54 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl;
@@ -75,6 +76,8 @@
      */
     final static class TablesPerJAXBContext {
         final int[] elementIndexes;
+        final int[] elementIndexPrefixes;
+
         final int[] attributeIndexes;
         final int[] localNameIndexes;
 
@@ -103,6 +106,7 @@
          */
         TablesPerJAXBContext(JAXBContextImpl context, int initialIndexOffset) {
             elementIndexes = new int[context.getNumberOfElementNames()];
+            elementIndexPrefixes = new int[context.getNumberOfElementNames()];
             attributeIndexes = new int[context.getNumberOfAttributeNames()];
             localNameIndexes = new int[context.getNumberOfLocalNames()];
 
@@ -244,6 +248,7 @@
         }
     }
 
+    @Override
     public void startDocument(XMLSerializer serializer, boolean fragment,
             int[] nsUriIndex2prefixIndex, NamespaceContextImpl nsContext)
             throws IOException, SAXException, XMLStreamException {
@@ -253,25 +258,29 @@
             fiout.initiateLowLevelWriting();
     }
 
+    @Override
     public void endDocument(boolean fragment) throws IOException, SAXException, XMLStreamException {
         super.endDocument(fragment);
     }
 
+    @Override
     public void beginStartTag(Name name) throws IOException {
         fiout.writeLowLevelTerminationAndMark();
 
         if (nsContext.getCurrent().count() == 0) {
             final int qNameIndex = tables.elementIndexes[name.qNameIndex] - tables.indexOffset;
-            if (qNameIndex >= 0) {
+            final int prefixIndex = nsUriIndex2prefixIndex[name.nsUriIndex];
+
+            if (qNameIndex >= 0 &&
+                    tables.elementIndexPrefixes[name.qNameIndex] == prefixIndex) {
                 fiout.writeLowLevelStartElementIndexed(EncodingConstants.ELEMENT, qNameIndex);
             } else {
                 tables.elementIndexes[name.qNameIndex] = fiout.getNextElementIndex() + tables.indexOffset;
-
-                final int prefix = nsUriIndex2prefixIndex[name.nsUriIndex];
+                tables.elementIndexPrefixes[name.qNameIndex] = prefixIndex;
                 writeLiteral(EncodingConstants.ELEMENT | EncodingConstants.ELEMENT_LITERAL_QNAME_FLAG,
                         name,
-                        nsContext.getPrefix(prefix),
-                        nsContext.getNamespaceURI(prefix));
+                        nsContext.getPrefix(prefixIndex),
+                        nsContext.getNamespaceURI(prefixIndex));
             }
         } else {
             beginStartTagWithNamespaces(name);
@@ -291,19 +300,22 @@
         fiout.writeLowLevelEndNamespaces();
 
         final int qNameIndex = tables.elementIndexes[name.qNameIndex] - tables.indexOffset;
-        if (qNameIndex >= 0) {
+        final int prefixIndex = nsUriIndex2prefixIndex[name.nsUriIndex];
+
+        if (qNameIndex >= 0 &&
+                tables.elementIndexPrefixes[name.qNameIndex] == prefixIndex) {
             fiout.writeLowLevelStartElementIndexed(0, qNameIndex);
         } else {
             tables.elementIndexes[name.qNameIndex] = fiout.getNextElementIndex() + tables.indexOffset;
-
-            final int prefix = nsUriIndex2prefixIndex[name.nsUriIndex];
+            tables.elementIndexPrefixes[name.qNameIndex] = prefixIndex;
             writeLiteral(EncodingConstants.ELEMENT_LITERAL_QNAME_FLAG,
                     name,
-                    nsContext.getPrefix(prefix),
-                    nsContext.getNamespaceURI(prefix));
+                    nsContext.getPrefix(prefixIndex),
+                    nsContext.getNamespaceURI(prefixIndex));
         }
     }
 
+    @Override
     public void attribute(Name name, String value) throws IOException {
         fiout.writeLowLevelStartAttributes();
 
@@ -351,19 +363,23 @@
         }
     }
 
+    @Override
     public void endStartTag() throws IOException {
         fiout.writeLowLevelEndStartElement();
     }
 
+    @Override
     public void endTag(Name name) throws IOException {
         fiout.writeLowLevelEndElement();
     }
 
+    @Override
     public void endTag(int prefix, String localName) throws IOException {
         fiout.writeLowLevelEndElement();
     }
 
 
+    @Override
     public void text(Pcdata value, boolean needsSeparatingWhitespace) throws IOException {
         if (needsSeparatingWhitespace)
             fiout.writeLowLevelText(" ");
@@ -387,6 +403,7 @@
     }
 
 
+    @Override
     public void text(String value, boolean needsSeparatingWhitespace) throws IOException {
         if (needsSeparatingWhitespace)
             fiout.writeLowLevelText(" ");
@@ -395,6 +412,7 @@
     }
 
 
+    @Override
     public void beginStartTag(int prefix, String localName) throws IOException {
         fiout.writeLowLevelTerminationAndMark();
 
@@ -424,6 +442,7 @@
             tables.incrementMaxIndexValue();
     }
 
+    @Override
     public void attribute(int prefix, String localName, String value) throws IOException {
         fiout.writeLowLevelStartAttributes();
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/ForkXmlOutput.java	Tue Aug  4 09:45:57 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/ForkXmlOutput.java	Tue Aug  4 09:45:57 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/InPlaceDOMOutput.java	Tue Aug  4 09:46:00 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/InPlaceDOMOutput.java	Tue Aug  4 09:45:59 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import com.sun.xml.internal.bind.v2.runtime.AssociationMap;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/IndentingUTF8XmlOutput.java	Tue Aug  4 09:46:03 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/IndentingUTF8XmlOutput.java	Tue Aug  4 09:46:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/MTOMXmlOutput.java	Tue Aug  4 09:46:05 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/MTOMXmlOutput.java	Tue Aug  4 09:46:05 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/NamespaceContextImpl.java	Tue Aug  4 09:46:07 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/NamespaceContextImpl.java	Tue Aug  4 09:46:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
@@ -164,7 +165,7 @@
                                 break;
                             }
                         }
-
+                        current.setTagName(subst, current.elementLocalName, current.getOuterPeer());
                         return i;
                     } else {
                         // first, if the previous URI assigned to "" is
@@ -217,6 +218,7 @@
 
     public int force(@NotNull String uri, @NotNull String prefix) {
         // check for the existing binding
+
         for( int i=size-1; i>=0; i-- ) {
             if(prefixes[i].equals(prefix)) {
                 if(nsUris[i].equals(uri))
@@ -442,6 +444,8 @@
             }
             context.size = baseIndex;
             context.current = prev;
+            // release references to user objects
+            outerPeer = innerPeer = null;
             return prev;
         }
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/Pcdata.java	Tue Aug  4 09:46:10 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/Pcdata.java	Tue Aug  4 09:46:09 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/SAXOutput.java	Tue Aug  4 09:46:12 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/SAXOutput.java	Tue Aug  4 09:46:12 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
@@ -84,7 +85,15 @@
             qname = localName;
         } else {
             nsUri = nsContext.getNamespaceURI(prefix);
-            qname = nsContext.getPrefix(prefix)+':'+localName;
+            String p = nsContext.getPrefix(prefix);
+            if(p.length()==0)
+                // this is more likely a bug in the application code (NamespacePrefixMapper implementation)
+                // this only happens when it tries to assign "" prefix to a non-"" URI,
+                // which is by itself violation of namespace rec. But let's just be safe.
+                // See http://forums.java.net/jive/thread.jspa?messageID=212598#212598
+                qname = localName;
+            else
+                qname = p +':'+localName;
         }
         atts.addAttribute( nsUri, localName, qname, "CDATA", value );
     }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/UTF8XmlOutput.java	Tue Aug  4 09:46:15 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/UTF8XmlOutput.java	Tue Aug  4 09:46:15 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/XMLEventWriterOutput.java	Tue Aug  4 09:46:18 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/XMLEventWriterOutput.java	Tue Aug  4 09:46:17 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/XMLStreamWriterOutput.java	Tue Aug  4 09:46:20 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/XMLStreamWriterOutput.java	Tue Aug  4 09:46:20 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
@@ -160,8 +161,8 @@
 
     private static Class initFIStAXWriterClass() {
         try {
-            Class llfisw = MarshallerImpl.class.getClassLoader().
-                    loadClass("com.sun.xml.internal.org.jvnet.fastinfoset.stax.LowLevelFastInfosetStreamWriter");
+            Class llfisw = Class.forName(
+                    "com.sun.xml.internal.org.jvnet.fastinfoset.stax.LowLevelFastInfosetStreamWriter", true, MarshallerImpl.class.getClassLoader());
             Class sds = MarshallerImpl.class.getClassLoader().
                     loadClass("com.sun.xml.internal.fastinfoset.stax.StAXDocumentSerializer");
             // Check if StAXDocumentSerializer implements LowLevelFastInfosetStreamWriter
@@ -179,7 +180,9 @@
             if (FI_STAX_WRITER_CLASS == null)
                 return null;
 
-            Class c = UnmarshallerImpl.class.getClassLoader().loadClass("com.sun.xml.internal.bind.v2.runtime.output.FastInfosetStreamWriterOutput");
+            Class c = Class.forName(
+                    "com.sun.xml.internal.bind.v2.runtime.output.FastInfosetStreamWriterOutput", true,
+                    UnmarshallerImpl.class.getClassLoader());
             return c.getConstructor(FI_STAX_WRITER_CLASS, JAXBContextImpl.class);
         } catch (Throwable e) {
             return null;
@@ -194,7 +197,7 @@
 
     private static Class initStAXExWriterClass() {
         try {
-            return MarshallerImpl.class.getClassLoader().loadClass("com.sun.xml.internal.org.jvnet.staxex.XMLStreamWriterEx");
+            return Class.forName("com.sun.xml.internal.org.jvnet.staxex.XMLStreamWriterEx",true,MarshallerImpl.class.getClassLoader());
         } catch (Throwable e) {
             return null;
         }
@@ -202,7 +205,7 @@
 
     private static Constructor<? extends XmlOutput> initStAXExOutputClass() {
         try {
-            Class c = UnmarshallerImpl.class.getClassLoader().loadClass("com.sun.xml.internal.bind.v2.runtime.output.StAXExStreamWriterOutput");
+            Class c = Class.forName("com.sun.xml.internal.bind.v2.runtime.output.StAXExStreamWriterOutput",true, UnmarshallerImpl.class.getClassLoader());
             return c.getConstructor(STAXEX_WRITER_CLASS);
         } catch (Throwable e) {
             return null;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/XmlOutput.java	Tue Aug  4 09:46:23 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/XmlOutput.java	Tue Aug  4 09:46:22 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/XmlOutputAbstractImpl.java	Tue Aug  4 09:46:25 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/XmlOutputAbstractImpl.java	Tue Aug  4 09:46:25 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.output;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/package-info.java	Tue Aug  4 09:46:28 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/package-info.java	Tue Aug  4 09:46:27 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /**
  * Code that writes well-formed XML ({@link XmlOutput} and its implementations}.
  */
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayERProperty.java	Tue Aug  4 09:46:30 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayERProperty.java	Tue Aug  4 09:46:30 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayElementLeafProperty.java	Tue Aug  4 09:46:32 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayElementLeafProperty.java	Tue Aug  4 09:46:32 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayElementNodeProperty.java	Tue Aug  4 09:46:35 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayElementNodeProperty.java	Tue Aug  4 09:46:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
@@ -50,7 +51,7 @@
         if(item==null) {
             w.writeXsiNilTrue();
         } else {
-            w.childAsXsiType(item,fieldName,expected);
+            w.childAsXsiType(item,fieldName,expected, false);
         }
     }
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayElementProperty.java	Tue Aug  4 09:46:37 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayElementProperty.java	Tue Aug  4 09:46:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
@@ -150,7 +151,7 @@
                         // for the purpose of simple type substitution, make it a non-error
 
                         w.startElement(typeMap.values().iterator().next().tagName,null);
-                        w.childAsXsiType(item,fieldName,w.grammar.getBeanInfo(Object.class));
+                        w.childAsXsiType(item,fieldName,w.grammar.getBeanInfo(Object.class), false);
                     } else {
                         w.startElement(tt.tagName,null);
                         serializeItem(tt.beanInfo,item,w);
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayProperty.java	Tue Aug  4 09:46:40 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayProperty.java	Tue Aug  4 09:46:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayReferenceNodeProperty.java	Tue Aug  4 09:46:42 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ArrayReferenceNodeProperty.java	Tue Aug  4 09:46:42 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
@@ -122,7 +123,7 @@
         if(isMixed) {
             // handler for processing mixed contents.
             loaders.put(TEXT_HANDLER,
-                new ChildLoader(new MixedTextoader(recv),null));
+                new ChildLoader(new MixedTextLoader(recv),null));
         }
 
         if(domHandler!=null) {
@@ -131,17 +132,18 @@
         }
     }
 
-    private static final class MixedTextoader extends Loader {
+    private static final class MixedTextLoader extends Loader {
 
         private final Receiver recv;
 
-        public MixedTextoader(Receiver recv) {
+        public MixedTextLoader(Receiver recv) {
             super(true);
             this.recv = recv;
         }
 
         public void text(UnmarshallingContext.State state, CharSequence text) throws SAXException {
-            recv.receive(state,text.toString());
+            if(text.length()!=0) // length 0 text is pointless
+                recv.receive(state,text.toString());
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/AttributeProperty.java	Tue Aug  4 09:46:44 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/AttributeProperty.java	Tue Aug  4 09:46:44 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
@@ -63,6 +64,11 @@
     public final Name attName;
 
     /**
+     * Required
+     */
+    public final boolean required;
+
+    /**
      * Heart of the conversion logic.
      */
     public final TransducedAccessor<BeanT> xacc;
@@ -72,6 +78,7 @@
     public AttributeProperty(JAXBContextImpl context, RuntimeAttributePropertyInfo prop) {
         super(context,prop);
         this.attName = context.nameBuilder.createAttributeName(prop.getXmlName());
+        this.required = prop.isRequired();
         this.xacc = TransducedAccessor.get(context,prop);
         this.acc = prop.getAccessor();   // we only use this for binder, so don't waste memory by optimizing
     }
@@ -83,8 +90,10 @@
      */
     public void serializeAttributes(BeanT o, XMLSerializer w) throws SAXException, AccessorException, IOException, XMLStreamException {
         CharSequence value = xacc.print(o);
-        if(value!=null)
-            w.attribute(attName,value.toString());
+        if(value != null)
+            w.attribute(attName, value.toString());
+        else if(required)
+           w.attribute(attName, "");
     }
 
     public void serializeURIs(BeanT o, XMLSerializer w) throws AccessorException, SAXException {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ListElementProperty.java	Tue Aug  4 09:46:46 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ListElementProperty.java	Tue Aug  4 09:46:46 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/Messages.java	Tue Aug  4 09:46:49 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/Messages.java	Tue Aug  4 09:46:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.text.MessageFormat;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/Messages.properties	Tue Aug  4 09:46:51 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/Messages.properties	Tue Aug  4 09:46:50 2009
@@ -28,4 +28,3 @@
 
 UNEXPECTED_JAVA_TYPE = \
     Java class {0} is not allowed in this property. Expected types are: {1}
- 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/Property.java	Tue Aug  4 09:46:53 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/Property.java	Tue Aug  4 09:46:53 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
@@ -34,6 +35,7 @@
 import com.sun.xml.internal.bind.v2.model.core.ID;
 import com.sun.xml.internal.bind.v2.model.core.PropertyInfo;
 import com.sun.xml.internal.bind.v2.model.core.PropertyKind;
+import com.sun.xml.internal.bind.v2.model.runtime.RuntimePropertyInfo;
 import com.sun.xml.internal.bind.v2.runtime.JaxBeanInfo;
 import com.sun.xml.internal.bind.v2.runtime.XMLSerializer;
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
@@ -125,4 +127,14 @@
      * to clean up any unnecessary references.
      */
     void wrapUp();
+
+
+
+    /**
+     * Provides more {@link RuntimePropertyInfo} information on the property.
+     *
+     * @return
+     *      null if RETAIN_REFERENCE_TO_INFO property is not set on the {@link JAXBContext}
+     */
+    public RuntimePropertyInfo getInfo();
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/PropertyFactory.java	Tue Aug  4 09:46:55 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/PropertyFactory.java	Tue Aug  4 09:46:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.lang.reflect.Constructor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/PropertyImpl.java	Tue Aug  4 09:46:57 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/PropertyImpl.java	Tue Aug  4 09:46:57 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
@@ -44,11 +45,19 @@
      * Name of this field.
      */
     protected final String fieldName;
+    private RuntimePropertyInfo propertyInfo = null;
 
     public PropertyImpl(JAXBContextImpl context, RuntimePropertyInfo prop) {
         fieldName = prop.getName();
+        if (context.retainPropertyInfo) {
+            propertyInfo = prop;
+        }
     }
 
+    public RuntimePropertyInfo getInfo() {
+        return propertyInfo;
+    }
+
     public void serializeBody(BeanT o, XMLSerializer w, Object outerPeer) throws SAXException, AccessorException, IOException, XMLStreamException {
     }
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/SingleElementLeafProperty.java	Tue Aug  4 09:47:00 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/SingleElementLeafProperty.java	Tue Aug  4 09:46:59 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/SingleElementNodeProperty.java	Tue Aug  4 09:47:02 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/SingleElementNodeProperty.java	Tue Aug  4 09:47:01 2009
@@ -22,9 +22,11 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
+import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
 import java.util.HashMap;
 import java.util.Map;
@@ -33,7 +35,6 @@
 import javax.xml.stream.XMLStreamException;
 
 import com.sun.xml.internal.bind.api.AccessorException;
-import com.sun.xml.internal.bind.v2.util.QNameMap;
 import com.sun.xml.internal.bind.v2.model.core.PropertyKind;
 import com.sun.xml.internal.bind.v2.model.core.TypeRef;
 import com.sun.xml.internal.bind.v2.model.runtime.RuntimeElementPropertyInfo;
@@ -43,12 +44,14 @@
 import com.sun.xml.internal.bind.v2.runtime.JaxBeanInfo;
 import com.sun.xml.internal.bind.v2.runtime.Name;
 import com.sun.xml.internal.bind.v2.runtime.XMLSerializer;
-import com.sun.xml.internal.bind.v2.runtime.unmarshaller.Loader;
+import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
 import com.sun.xml.internal.bind.v2.runtime.unmarshaller.ChildLoader;
-import com.sun.xml.internal.bind.v2.runtime.unmarshaller.XsiNilLoader;
 import com.sun.xml.internal.bind.v2.runtime.unmarshaller.DefaultValueLoaderDecorator;
-import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
+import com.sun.xml.internal.bind.v2.runtime.unmarshaller.Loader;
+import com.sun.xml.internal.bind.v2.runtime.unmarshaller.XsiNilLoader;
+import com.sun.xml.internal.bind.v2.util.QNameMap;
 
+import javax.xml.bind.JAXBElement;
 import org.xml.sax.SAXException;
 
 /**
@@ -111,7 +114,7 @@
 
     public void serializeBody(BeanT o, XMLSerializer w, Object outerPeer) throws SAXException, AccessorException, IOException, XMLStreamException {
         ValueT v = acc.get(o);
-        if(v!=null) {
+        if (v!=null) {
             Class vtype = v.getClass();
             TagAndType tt=typeNames.get(vtype); // quick way that usually works
 
@@ -124,6 +127,7 @@
                 }
             }
 
+            boolean addNilDecl = (o instanceof JAXBElement) && ((JAXBElement)o).isNil();
             if(tt==null) {
                 // actually this is an error, because the actual type was not a sub-type
                 // of any of the types specified in the annotations,
@@ -131,14 +135,13 @@
                 // it's convenient to marshal this anyway (for example so that classes
                 // generated from simple types like String can be marshalled as expected.)
                 w.startElement(typeNames.values().iterator().next().tagName,null);
-                w.childAsXsiType(v,fieldName,w.grammar.getBeanInfo(Object.class));
+                w.childAsXsiType(v,fieldName,w.grammar.getBeanInfo(Object.class), addNilDecl && nillable);
             } else {
                 w.startElement(tt.tagName,null);
-                w.childAsXsiType(v,fieldName,tt.beanInfo);
+                w.childAsXsiType(v,fieldName,tt.beanInfo, addNilDecl && nillable);
             }
             w.endElement();
-        } else
-        if(nillable) {
+        } else if (nillable) {
             w.startElement(nullTagName,null);
             w.writeXsiNilTrue();
             w.endElement();
@@ -150,7 +153,9 @@
 
         for (TypeRef<Type,Class> e : prop.getTypes()) {
             JaxBeanInfo bi = context.getOrCreate((RuntimeTypeInfo) e.getTarget());
-            Loader l = bi.getLoader(context,true);
+            // if the expected Java type is already final, type substitution won't really work anyway.
+            // this also traps cases like trying to substitute xsd:long element with xsi:type='xsd:int'
+            Loader l = bi.getLoader(context,!Modifier.isFinal(bi.jaxbType.getModifiers()));
             if(e.getDefaultValue()!=null)
                 l = new DefaultValueLoaderDecorator(l,e.getDefaultValue());
             if(nillable || chain.context.allNillable)
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/SingleMapNodeProperty.java	Tue Aug  4 09:47:04 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/SingleMapNodeProperty.java	Tue Aug  4 09:47:04 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
@@ -236,7 +237,7 @@
                 Object key = e.getKey();
                 if(key!=null) {
                     w.startElement(keyTag,key);
-                    w.childAsXsiType(key,fieldName,keyBeanInfo);
+                    w.childAsXsiType(key,fieldName,keyBeanInfo, false);
                     w.endElement();
                 }
 
@@ -243,7 +244,7 @@
                 Object value = e.getValue();
                 if(value!=null) {
                     w.startElement(valueTag,value);
-                    w.childAsXsiType(value,fieldName,valueBeanInfo);
+                    w.childAsXsiType(value,fieldName,valueBeanInfo, false);
                     w.endElement();
                 }
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/SingleReferenceNodeProperty.java	Tue Aug  4 09:47:06 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/SingleReferenceNodeProperty.java	Tue Aug  4 09:47:06 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/StructureLoaderBuilder.java	Tue Aug  4 09:47:09 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/StructureLoaderBuilder.java	Tue Aug  4 09:47:08 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/TagAndType.java	Tue Aug  4 09:47:11 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/TagAndType.java	Tue Aug  4 09:47:10 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/UnmarshallerChain.java	Tue Aug  4 09:47:13 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/UnmarshallerChain.java	Tue Aug  4 09:47:13 2009
@@ -23,9 +23,6 @@
  * have any questions.
  */
 
-/*
- * @(#)$Id:
- */
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 import com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ValueProperty.java	Tue Aug  4 09:47:16 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/property/ValueProperty.java	Tue Aug  4 09:47:16 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.property;
 
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/Accessor.java	Tue Aug  4 09:47:18 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/Accessor.java	Tue Aug  4 09:47:18 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import java.lang.reflect.Field;
@@ -42,11 +43,13 @@
 import com.sun.xml.internal.bind.api.JAXBRIContext;
 import com.sun.xml.internal.bind.v2.model.core.Adapter;
 import com.sun.xml.internal.bind.v2.model.nav.Navigator;
+import com.sun.xml.internal.bind.v2.model.impl.RuntimeModelBuilder;
 import com.sun.xml.internal.bind.v2.runtime.reflect.opt.OptimizedAccessorFactory;
 import com.sun.xml.internal.bind.v2.runtime.unmarshaller.Loader;
 import com.sun.xml.internal.bind.v2.runtime.unmarshaller.Receiver;
 import com.sun.xml.internal.bind.v2.runtime.unmarshaller.UnmarshallingContext;
 import com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl;
+import com.sun.istack.internal.Nullable;
 
 import org.xml.sax.SAXException;
 
@@ -84,10 +87,11 @@
      *
      * @param context
      *      The {@link JAXBContextImpl} that owns the whole thing.
+     *      (See {@link RuntimeModelBuilder#context}.)
      * @return
      *      At least the implementation can return <tt>this</tt>.
      */
-    public Accessor<BeanT,ValueT> optimize(JAXBContextImpl context) {
+    public Accessor<BeanT,ValueT> optimize(@Nullable JAXBContextImpl context) {
         return this;
     }
 
@@ -156,6 +160,9 @@
             set((BeanT)state.target,(ValueT)o);
         } catch (AccessorException e) {
             Loader.handleGenericException(e,true);
+        } catch (IllegalAccessError iae) {
+            // throw UnmarshalException instead IllegalAccesssError | Issue 475
+            Loader.handleGenericError(iae);
         }
     }
 
@@ -189,8 +196,6 @@
 
         private static final Logger logger = Util.getClassLogger();
 
-        // TODO: revisit. this is a security hole because this method can be used by anyone
-        // to enable access to a field.
         public FieldReflection(Field f) {
             super((Class<ValueT>)f.getType());
             this.f = f;
@@ -198,6 +203,9 @@
             int mod = f.getModifiers();
             if(!Modifier.isPublic(mod) || Modifier.isFinal(mod) || !Modifier.isPublic(f.getDeclaringClass().getModifiers())) {
                 try {
+                    // attempt to make it accessible, but do so in the security context of the calling application.
+                    // don't do this in the doPrivilege block, as that would create a security hole for anyone
+                    // to make any field accessible.
                     f.setAccessible(true);
                 } catch( SecurityException e ) {
                     if(!accessWarned)
@@ -231,7 +239,7 @@
 
         @Override
         public Accessor<BeanT,ValueT> optimize(JAXBContextImpl context) {
-            if(context.fastBoot)
+            if(context!=null && context.fastBoot)
                 // let's not waste time on doing this for the sake of faster boot.
                 return this;
             Accessor<BeanT,ValueT> acc = OptimizedAccessorFactory.get(f);
@@ -343,7 +351,7 @@
             if(getter==null || setter==null)
                 // if we aren't complete, OptimizedAccessor won't always work
                 return this;
-            if(context.fastBoot)
+            if(context!=null && context.fastBoot)
                 // let's not waste time on doing this for the sake of faster boot.
                 return this;
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/AdaptedAccessor.java	Tue Aug  4 09:47:21 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/AdaptedAccessor.java	Tue Aug  4 09:47:20 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import javax.xml.bind.annotation.adapters.XmlAdapter;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/AdaptedLister.java	Tue Aug  4 09:47:23 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/AdaptedLister.java	Tue Aug  4 09:47:22 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import javax.xml.bind.annotation.adapters.XmlAdapter;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/DefaultTransducedAccessor.java	Tue Aug  4 09:47:25 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/DefaultTransducedAccessor.java	Tue Aug  4 09:47:25 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/ListIterator.java	Tue Aug  4 09:47:28 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/ListIterator.java	Tue Aug  4 09:47:27 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import java.util.Iterator;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/ListTransducedAccessorImpl.java	Tue Aug  4 09:47:30 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/ListTransducedAccessorImpl.java	Tue Aug  4 09:47:30 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import javax.xml.bind.JAXBException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/Lister.java	Tue Aug  4 09:47:33 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/Lister.java	Tue Aug  4 09:47:32 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import java.lang.ref.WeakReference;
@@ -36,6 +37,10 @@
 import java.util.List;
 import java.util.Map;
 import java.util.WeakHashMap;
+import java.util.LinkedList;
+import java.util.HashSet;
+import java.util.TreeSet;
+import java.util.Stack;
 import java.util.concurrent.Callable;
 
 import javax.xml.bind.JAXBException;
@@ -139,7 +144,7 @@
     }
 
     private static Class getImplClass(Class<?> fieldType) {
-        return ClassFactory.inferImplClass(fieldType,ClassFactory.COLLECTION_IMPL_CLASSES);
+        return ClassFactory.inferImplClass(fieldType,COLLECTION_IMPL_CLASSES);
     }
 
     /**
@@ -474,4 +479,11 @@
         }
     };
 
+    private static final Class[] COLLECTION_IMPL_CLASSES = new Class[] {
+        ArrayList.class,
+        LinkedList.class,
+        HashSet.class,
+        TreeSet.class,
+        Stack.class
+    };
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/Messages.java	Tue Aug  4 09:47:35 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/Messages.java	Tue Aug  4 09:47:35 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import java.text.MessageFormat;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/Messages.properties	Tue Aug  4 09:47:38 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/Messages.properties	Tue Aug  4 09:47:38 2009
@@ -38,4 +38,3 @@
 NO_GETTER = \
     The property has a setter "{0}" but no getter. \
     For marshaller, please define getters.
- 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/NullSafeAccessor.java	Tue Aug  4 09:47:41 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/NullSafeAccessor.java	Tue Aug  4 09:47:41 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import com.sun.xml.internal.bind.api.AccessorException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerBoolean.java	Tue Aug  4 09:47:44 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerBoolean.java	Tue Aug  4 09:47:43 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import com.sun.xml.internal.bind.api.AccessorException;
@@ -83,7 +84,8 @@
                 System.arraycopy(buf,0,nb,0,buf.length);
                 buf = nb;
             }
-            buf[size++] = b;
+            if(b!=null)
+                buf[size++] = b;
         }
 
         boolean[] build() {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerByte.java	Tue Aug  4 09:47:46 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerByte.java	Tue Aug  4 09:47:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import com.sun.xml.internal.bind.api.AccessorException;
@@ -83,7 +84,8 @@
                 System.arraycopy(buf,0,nb,0,buf.length);
                 buf = nb;
             }
-            buf[size++] = b;
+            if(b!=null)
+                buf[size++] = b;
         }
 
         byte[] build() {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerCharacter.java	Tue Aug  4 09:47:48 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerCharacter.java	Tue Aug  4 09:47:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import com.sun.xml.internal.bind.api.AccessorException;
@@ -83,7 +84,8 @@
                 System.arraycopy(buf,0,nb,0,buf.length);
                 buf = nb;
             }
-            buf[size++] = b;
+            if(b!=null)
+                buf[size++] = b;
         }
 
         char[] build() {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerDouble.java	Tue Aug  4 09:47:51 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerDouble.java	Tue Aug  4 09:47:50 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import com.sun.xml.internal.bind.api.AccessorException;
@@ -83,7 +84,8 @@
                 System.arraycopy(buf,0,nb,0,buf.length);
                 buf = nb;
             }
-            buf[size++] = b;
+            if(b!=null)
+                buf[size++] = b;
         }
 
         double[] build() {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerFloat.java	Tue Aug  4 09:47:53 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerFloat.java	Tue Aug  4 09:47:53 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import com.sun.xml.internal.bind.api.AccessorException;
@@ -83,7 +84,8 @@
                 System.arraycopy(buf,0,nb,0,buf.length);
                 buf = nb;
             }
-            buf[size++] = b;
+            if(b!=null)
+                buf[size++] = b;
         }
 
         float[] build() {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerInteger.java	Tue Aug  4 09:47:55 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerInteger.java	Tue Aug  4 09:47:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import com.sun.xml.internal.bind.api.AccessorException;
@@ -83,7 +84,8 @@
                 System.arraycopy(buf,0,nb,0,buf.length);
                 buf = nb;
             }
-            buf[size++] = b;
+            if(b!=null)
+                buf[size++] = b;
         }
 
         int[] build() {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerLong.java	Tue Aug  4 09:47:58 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerLong.java	Tue Aug  4 09:47:57 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import com.sun.xml.internal.bind.api.AccessorException;
@@ -83,7 +84,8 @@
                 System.arraycopy(buf,0,nb,0,buf.length);
                 buf = nb;
             }
-            buf[size++] = b;
+            if(b!=null)
+                buf[size++] = b;
         }
 
         long[] build() {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerShort.java	Tue Aug  4 09:48:00 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/PrimitiveArrayListerShort.java	Tue Aug  4 09:48:00 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import com.sun.xml.internal.bind.api.AccessorException;
@@ -83,7 +84,8 @@
                 System.arraycopy(buf,0,nb,0,buf.length);
                 buf = nb;
             }
-            buf[size++] = b;
+            if(b!=null)
+                buf[size++] = b;
         }
 
         short[] build() {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/TransducedAccessor.java	Tue Aug  4 09:48:02 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/TransducedAccessor.java	Tue Aug  4 09:48:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/AccessorInjector.java	Tue Aug  4 09:48:05 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/AccessorInjector.java	Tue Aug  4 09:48:04 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import java.io.InputStream;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/Bean.java	Tue Aug  4 09:48:07 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/Bean.java	Tue Aug  4 09:48:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.TransducedAccessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/Const.java	Tue Aug  4 09:48:10 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/Const.java	Tue Aug  4 09:48:09 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Boolean.java	Tue Aug  4 09:48:12 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Boolean.java	Tue Aug  4 09:48:12 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Byte.java	Tue Aug  4 09:48:15 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Byte.java	Tue Aug  4 09:48:15 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Character.java	Tue Aug  4 09:48:18 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Character.java	Tue Aug  4 09:48:17 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Double.java	Tue Aug  4 09:48:20 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Double.java	Tue Aug  4 09:48:20 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Float.java	Tue Aug  4 09:48:23 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Float.java	Tue Aug  4 09:48:22 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Integer.java	Tue Aug  4 09:48:26 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Integer.java	Tue Aug  4 09:48:25 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Long.java	Tue Aug  4 09:48:28 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Long.java	Tue Aug  4 09:48:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Ref.java	Tue Aug  4 09:48:31 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Ref.java	Tue Aug  4 09:48:31 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Short.java	Tue Aug  4 09:48:34 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/FieldAccessor_Short.java	Tue Aug  4 09:48:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/Injector.java	Tue Aug  4 09:48:37 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/Injector.java	Tue Aug  4 09:48:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import java.lang.reflect.InvocationTargetException;
@@ -37,6 +38,7 @@
 import java.util.logging.Logger;
 
 import com.sun.xml.internal.bind.Util;
+import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
 
 /**
  * A {@link ClassLoader} used to "inject" optimized accessor classes
@@ -113,6 +115,12 @@
 
     private final ClassLoader parent;
 
+    /**
+     * True if this injector is capable of injecting accessors.
+     * False otherwise, which happens if this classloader can't see {@link Accessor}.
+     */
+    private final boolean loadable;
+
     private static final Method defineClass;
     private static final Method resolveClass;
 
@@ -138,10 +146,23 @@
     private Injector(ClassLoader parent) {
         this.parent = parent;
         assert parent!=null;
+
+        boolean loadable = false;
+
+        try {
+            loadable = parent.loadClass(Accessor.class.getName())==Accessor.class;
+        } catch (ClassNotFoundException e) {
+            ; // not loadable
+        }
+
+        this.loadable = loadable;
     }
 
 
     private synchronized Class inject(String className, byte[] image) {
+        if(!loadable)   // this injector cannot inject anything
+            return null;
+
         Class c = classes.get(className);
         if(c==null) {
             // we need to inject a class into the
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Boolean.java	Tue Aug  4 09:48:40 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Boolean.java	Tue Aug  4 09:48:40 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Byte.java	Tue Aug  4 09:48:43 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Byte.java	Tue Aug  4 09:48:42 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Character.java	Tue Aug  4 09:48:46 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Character.java	Tue Aug  4 09:48:46 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Double.java	Tue Aug  4 09:48:49 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Double.java	Tue Aug  4 09:48:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Float.java	Tue Aug  4 09:48:52 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Float.java	Tue Aug  4 09:48:52 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Integer.java	Tue Aug  4 09:48:56 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Integer.java	Tue Aug  4 09:48:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Long.java	Tue Aug  4 09:48:59 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Long.java	Tue Aug  4 09:48:58 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Ref.java	Tue Aug  4 09:49:01 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Ref.java	Tue Aug  4 09:49:01 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Short.java	Tue Aug  4 09:49:04 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/MethodAccessor_Short.java	Tue Aug  4 09:49:03 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/OptimizedAccessorFactory.java	Tue Aug  4 09:49:06 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/OptimizedAccessorFactory.java	Tue Aug  4 09:49:06 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import java.lang.reflect.Field;
@@ -32,6 +33,7 @@
 
 import com.sun.xml.internal.bind.Util;
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
+import com.sun.xml.internal.bind.v2.runtime.RuntimeUtil;
 
 import static com.sun.xml.internal.bind.v2.bytecode.ClassTailor.toVMClassName;
 import static com.sun.xml.internal.bind.v2.bytecode.ClassTailor.toVMTypeName;
@@ -89,7 +91,7 @@
 
         if(t.isPrimitive())
             opt = AccessorInjector.prepare( getter.getDeclaringClass(),
-                methodTemplateName+t.getName(),
+                methodTemplateName+RuntimeUtil.primitiveToBox.get(t).getSimpleName(),
                 newClassName,
                 toVMClassName(Bean.class),
                 toVMClassName(getter.getDeclaringClass()),
@@ -142,7 +144,7 @@
 
         if(field.getType().isPrimitive())
             opt = AccessorInjector.prepare( field.getDeclaringClass(),
-                fieldTemplateName+field.getType().getName(),
+                fieldTemplateName+RuntimeUtil.primitiveToBox.get(field.getType()).getSimpleName(),
                 newClassName,
                 toVMClassName(Bean.class),
                 toVMClassName(field.getDeclaringClass()),
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/OptimizedTransducedAccessorFactory.java	Tue Aug  4 09:49:09 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/OptimizedTransducedAccessorFactory.java	Tue Aug  4 09:49:08 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import java.lang.reflect.Field;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/Ref.java	Tue Aug  4 09:49:11 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/Ref.java	Tue Aug  4 09:49:11 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.TransducedAccessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Boolean.java	Tue Aug  4 09:49:13 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Boolean.java	Tue Aug  4 09:49:13 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Byte.java	Tue Aug  4 09:49:16 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Byte.java	Tue Aug  4 09:49:15 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Double.java	Tue Aug  4 09:49:18 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Double.java	Tue Aug  4 09:49:18 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Float.java	Tue Aug  4 09:49:20 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Float.java	Tue Aug  4 09:49:20 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Integer.java	Tue Aug  4 09:49:23 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Integer.java	Tue Aug  4 09:49:22 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Long.java	Tue Aug  4 09:49:25 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Long.java	Tue Aug  4 09:49:25 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Short.java	Tue Aug  4 09:49:28 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_field_Short.java	Tue Aug  4 09:49:27 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Boolean.java	Tue Aug  4 09:49:30 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Boolean.java	Tue Aug  4 09:49:30 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Byte.java	Tue Aug  4 09:49:33 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Byte.java	Tue Aug  4 09:49:32 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Double.java	Tue Aug  4 09:49:35 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Double.java	Tue Aug  4 09:49:35 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Float.java	Tue Aug  4 09:49:37 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Float.java	Tue Aug  4 09:49:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Integer.java	Tue Aug  4 09:49:40 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Integer.java	Tue Aug  4 09:49:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Long.java	Tue Aug  4 09:49:43 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Long.java	Tue Aug  4 09:49:43 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Short.java	Tue Aug  4 09:49:46 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/reflect/opt/TransducedAccessor_method_Short.java	Tue Aug  4 09:49:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.reflect.opt;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/AttributesEx.java	Tue Aug  4 09:49:49 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/AttributesEx.java	Tue Aug  4 09:49:48 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import org.xml.sax.Attributes;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/AttributesExImpl.java	Tue Aug  4 09:49:51 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/AttributesExImpl.java	Tue Aug  4 09:49:51 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import com.sun.xml.internal.bind.util.AttributesImpl;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Base64Data.java	Tue Aug  4 09:49:54 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Base64Data.java	Tue Aug  4 09:49:53 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import java.io.ByteArrayInputStream;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/ChildLoader.java	Tue Aug  4 09:49:57 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/ChildLoader.java	Tue Aug  4 09:49:56 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/DefaultIDResolver.java	Tue Aug  4 09:50:00 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/DefaultIDResolver.java	Tue Aug  4 09:50:00 2009
@@ -22,13 +22,18 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import java.util.HashMap;
 import java.util.concurrent.Callable;
 
+import javax.xml.bind.ValidationEventHandler;
+
 import com.sun.xml.internal.bind.IDResolver;
 
+import org.xml.sax.SAXException;
+
 /**
  * Default implementation of {@link IDResolver}.
  *
@@ -38,16 +43,19 @@
     /** Records ID->Object map. */
     private HashMap<String,Object> idmap = null;
 
-    public void startDocument() {
+    @Override
+    public void startDocument(ValidationEventHandler eventHandler) throws SAXException {
         if(idmap!=null)
             idmap.clear();
     }
 
+    @Override
     public void bind(String id, Object obj) {
         if(idmap==null)     idmap = new HashMap<String,Object>();
         idmap.put(id,obj);
     }
 
+    @Override
     public Callable resolve(final String id, Class targetType) {
         return new Callable() {
             public Object call() throws Exception {
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/DefaultValueLoaderDecorator.java	Tue Aug  4 09:50:03 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/DefaultValueLoaderDecorator.java	Tue Aug  4 09:50:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import org.xml.sax.SAXException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Discarder.java	Tue Aug  4 09:50:05 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Discarder.java	Tue Aug  4 09:50:05 2009
@@ -23,9 +23,6 @@
  * have any questions.
  */
 
-/*
- * @(#)$Id: Discarder.java,v 1.4 2005/09/10 19:07:43 kohsuke Exp $
- */
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/DomLoader.java	Tue Aug  4 09:50:08 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/DomLoader.java	Tue Aug  4 09:50:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import javax.xml.bind.annotation.DomHandler;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/FastInfosetConnector.java	Tue Aug  4 09:50:11 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/FastInfosetConnector.java	Tue Aug  4 09:50:11 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import javax.xml.stream.Location;
@@ -30,6 +31,7 @@
 
 import com.sun.xml.internal.bind.WhiteSpaceProcessor;
 import com.sun.xml.internal.fastinfoset.stax.StAXDocumentParser;
+import com.sun.xml.internal.org.jvnet.fastinfoset.EncodingAlgorithmIndexes;
 import org.xml.sax.SAXException;
 
 /**
@@ -237,26 +239,42 @@
 
     private void processNonIgnorableText() throws SAXException {
         textReported = true;
-        if (fastInfosetStreamReader.getTextAlgorithmBytes() == null) {
-            charArray.set();
-            visitor.text(charArray);
-        } else {
+        boolean isTextAlgorithmAplied =
+                (fastInfosetStreamReader.getTextAlgorithmBytes() != null);
+
+        if (isTextAlgorithmAplied &&
+                fastInfosetStreamReader.getTextAlgorithmIndex() == EncodingAlgorithmIndexes.BASE64) {
             base64Data.set(fastInfosetStreamReader.getTextAlgorithmBytesClone(),null);
             visitor.text(base64Data);
+        } else {
+            if (isTextAlgorithmAplied) {
+                fastInfosetStreamReader.getText();
+            }
+
+            charArray.set();
+            visitor.text(charArray);
         }
     }
 
     private void processIgnorableText() throws SAXException {
-        if (fastInfosetStreamReader.getTextAlgorithmBytes() == null) {
+        boolean isTextAlgorithmAplied =
+                (fastInfosetStreamReader.getTextAlgorithmBytes() != null);
+
+        if (isTextAlgorithmAplied &&
+                fastInfosetStreamReader.getTextAlgorithmIndex() == EncodingAlgorithmIndexes.BASE64) {
+            base64Data.set(fastInfosetStreamReader.getTextAlgorithmBytesClone(),null);
+            visitor.text(base64Data);
+            textReported = true;
+        } else {
+            if (isTextAlgorithmAplied) {
+                fastInfosetStreamReader.getText();
+            }
+
             charArray.set();
             if (!WhiteSpaceProcessor.isWhiteSpace(charArray)) {
                 visitor.text(charArray);
                 textReported = true;
             }
-        } else {
-            base64Data.set(fastInfosetStreamReader.getTextAlgorithmBytesClone(),null);
-            visitor.text(base64Data);
-            textReported = true;
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/IntArrayData.java	Tue Aug  4 09:50:17 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/IntArrayData.java	Tue Aug  4 09:50:16 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/IntData.java	Tue Aug  4 09:50:19 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/IntData.java	Tue Aug  4 09:50:19 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Intercepter.java	Tue Aug  4 09:50:23 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Intercepter.java	Tue Aug  4 09:50:22 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import org.xml.sax.SAXException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/InterningXmlVisitor.java	Tue Aug  4 09:50:25 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/InterningXmlVisitor.java	Tue Aug  4 09:50:25 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import javax.xml.namespace.NamespaceContext;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/LeafPropertyLoader.java	Tue Aug  4 09:50:28 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/LeafPropertyLoader.java	Tue Aug  4 09:50:27 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import com.sun.xml.internal.bind.api.AccessorException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Loader.java	Tue Aug  4 09:50:31 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Loader.java	Tue Aug  4 09:50:31 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import java.util.Collection;
@@ -91,8 +92,17 @@
         state.receiver = null;
     }
 
+    @SuppressWarnings({"StringEquality"})
     protected final void reportUnexpectedChildElement(TagName ea, boolean canRecover) throws SAXException {
-        reportError(Messages.UNEXPECTED_ELEMENT.format(ea.uri,ea.local,computeExpectedElements()), canRecover );
+        if(canRecover && !UnmarshallingContext.getInstance().parent.hasEventHandler())
+            // this error happens particurly often (when input documents contain a lot of unexpected elements to be ignored),
+            // so don't bother computing all the messages and etc if we know that
+            // there's no event handler to receive the error in the end. See #286
+            return;
+        if(ea.uri!=ea.uri.intern() || ea.local!=ea.local.intern())
+            reportError(Messages.UNINTERNED_STRINGS.format(), canRecover );
+        else
+            reportError(Messages.UNEXPECTED_ELEMENT.format(ea.uri,ea.local,computeExpectedElements()), canRecover );
     }
 
     /**
@@ -213,6 +223,9 @@
         reportError(e.getMessage(), e, canRecover );
     }
 
+    public static void handleGenericError(Error e) throws SAXException {
+        reportError(e.getMessage(), false);
+    }
 
     protected static void reportError(String msg, boolean canRecover) throws SAXException {
         reportError(msg, null, canRecover );
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/LocatorEx.java	Tue Aug  4 09:50:34 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/LocatorEx.java	Tue Aug  4 09:50:33 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import java.net.URL;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/LocatorExWrapper.java	Tue Aug  4 09:50:36 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/LocatorExWrapper.java	Tue Aug  4 09:50:36 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import javax.xml.bind.ValidationEventLocator;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/MTOMDecorator.java	Tue Aug  4 09:50:39 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/MTOMDecorator.java	Tue Aug  4 09:50:38 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import javax.activation.DataHandler;
@@ -78,7 +79,7 @@
     }
 
     public void startElement(TagName tagName) throws SAXException {
-        if(tagName.local=="Include" && tagName.uri==WellKnownNamespace.XOP) {
+        if(tagName.local.equals("Include") && tagName.uri.equals(WellKnownNamespace.XOP)) {
             // found xop:Include
             String href = tagName.atts.getValue("href");
             DataHandler attachment = au.getAttachmentAsDataHandler(href);
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Messages.java	Tue Aug  4 09:50:41 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Messages.java	Tue Aug  4 09:50:41 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import java.text.MessageFormat;
@@ -38,6 +39,7 @@
     UNRECOGNIZED_TYPE_NAME, // 1 arg
     UNRECOGNIZED_TYPE_NAME_MAYBE, // 2 args
     UNABLE_TO_CREATE_MAP, // 1 arg
+    UNINTERNED_STRINGS, // no args
     ;
 
     private static final ResourceBundle rb = ResourceBundle.getBundle(Messages.class.getName());
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Messages.properties	Tue Aug  4 09:50:44 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Messages.properties	Tue Aug  4 09:50:43 2009
@@ -36,7 +36,7 @@
     Undefined ID "{0}".
 
 UNEXPECTED_ELEMENT = \
-	unexpected element (uri:"{0}", local:"{1}"). Expected elements are {2}
+        unexpected element (uri:"{0}", local:"{1}"). Expected elements are {2}
 
 UNEXPECTED_TEXT = \
     unexpected text "{0}"
@@ -45,4 +45,6 @@
     The type of the field is {0}, but JAXB doesn't know how to create an instance \
     assignable to it. Create an instance in the constructor, or use a type that can \
     be assignable from HashMap.
- 
+
+UNINTERNED_STRINGS = \
+    Namespace URIs and local names to the unmarshaller needs to be interned.
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Patcher.java	Tue Aug  4 09:50:47 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Patcher.java	Tue Aug  4 09:50:46 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import org.xml.sax.SAXException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/ProxyLoader.java	Tue Aug  4 09:50:50 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/ProxyLoader.java	Tue Aug  4 09:50:49 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import org.xml.sax.SAXException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Receiver.java	Tue Aug  4 09:50:53 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Receiver.java	Tue Aug  4 09:50:52 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import org.xml.sax.SAXException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/SAXConnector.java	Tue Aug  4 09:50:55 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/SAXConnector.java	Tue Aug  4 09:50:55 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import javax.xml.bind.JAXBException;
@@ -28,6 +29,7 @@
 import javax.xml.bind.UnmarshallerHandler;
 
 import com.sun.xml.internal.bind.WhiteSpaceProcessor;
+import com.sun.xml.internal.bind.v2.runtime.ClassBeanInfoImpl;
 
 import org.xml.sax.Attributes;
 import org.xml.sax.Locator;
@@ -116,8 +118,18 @@
         if( qname==null || qname.length()==0 )
             qname=local;
 
-        processText(true);
 
+        boolean ignorable = true;
+        StructureLoader sl;
+
+        // not null only if element content is processed (StructureLoader is used)
+        // ugly
+        if((sl = this.context.getStructureLoader()) != null) {
+            ignorable = ((ClassBeanInfoImpl)sl.getBeanInfo()).hasElementOnlyContentModel();
+        }
+
+        processText(ignorable);
+
         tagName.uri = uri;
         tagName.local = local;
         tagName.qname = qname;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Scope.java	Tue Aug  4 09:50:57 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/Scope.java	Tue Aug  4 09:50:57 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import com.sun.xml.internal.bind.api.AccessorException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StAXConnector.java	Tue Aug  4 09:51:00 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StAXConnector.java	Tue Aug  4 09:50:59 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import javax.xml.bind.ValidationEventLocator;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StAXEventConnector.java	Tue Aug  4 09:51:02 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StAXEventConnector.java	Tue Aug  4 09:51:02 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import java.util.Iterator;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StAXStreamConnector.java	Tue Aug  4 09:51:05 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StAXStreamConnector.java	Tue Aug  4 09:51:04 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import java.lang.reflect.Constructor;
@@ -68,13 +69,14 @@
 
         // Quick hack until SJSXP fixes 6270116
         boolean isZephyr = readerClass.getName().equals("com.sun.xml.internal.stream.XMLReaderImpl");
-        if(isZephyr)
+        if (getBoolProp(reader,"org.codehaus.stax2.internNames") &&
+            getBoolProp(reader,"org.codehaus.stax2.internNsUris"))
             ; // no need for interning
         else
-        if(checkImplementaionNameOfSjsxp(reader))
+        if (isZephyr)
             ; // no need for interning
-        if(getBoolProp(reader,"org.codehaus.stax2.internNames")
-        && getBoolProp(reader,"org.codehaus.stax2.internNsUris"))
+        else
+        if (checkImplementaionNameOfSjsxp(reader))
             ; // no need for interning.
         else
             visitor = new InterningXmlVisitor(visitor);
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StructureLoader.java	Tue Aug  4 09:51:07 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StructureLoader.java	Tue Aug  4 09:51:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import java.util.Collection;
@@ -256,4 +257,8 @@
     }
 
     private static final QNameMap<TransducedAccessor> EMPTY = new QNameMap<TransducedAccessor>();
+
+    public JaxBeanInfo getBeanInfo() {
+        return beanInfo;
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/TagName.java	Tue Aug  4 09:51:10 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/TagName.java	Tue Aug  4 09:51:09 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/TextLoader.java	Tue Aug  4 09:51:12 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/TextLoader.java	Tue Aug  4 09:51:12 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import com.sun.xml.internal.bind.api.AccessorException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/UnmarshallerImpl.java	Tue Aug  4 09:51:16 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/UnmarshallerImpl.java	Tue Aug  4 09:51:15 2009
@@ -266,6 +266,15 @@
         }
     }
 
+    /**
+     * Returns true if an event handler is installed.
+     * <p>
+     * The default handler ignores any errors, and for that this method returns false.
+     */
+    public final boolean hasEventHandler() {
+        return getEventHandler()!=this;
+    }
+
     @Override
     public <T> JAXBElement<T> unmarshal(Node node, Class<T> expectedType) throws JAXBException {
         if(expectedType==null)
@@ -297,9 +306,11 @@
                 scanner.scan((Document)node);
             else
                 // no other type of input is supported
-                throw new IllegalArgumentException();
+                throw new IllegalArgumentException("Unexpected node type: "+node);
 
-            return handler.getContext().getResult();
+            Object retVal = handler.getContext().getResult();
+            handler.getContext().clearResult();
+            return retVal;
         } catch( SAXException e ) {
             throw createUnmarshalException(e);
         }
@@ -340,7 +351,9 @@
             throw handleStreamException(e);
         }
 
-        return h.getContext().getResult();
+        Object retVal = h.getContext().getResult();
+        h.getContext().clearResult();
+        return retVal;
     }
 
     @Override
@@ -422,6 +435,10 @@
             coordinator.classResolver = (ClassResolver)value;
             return;
         }
+        if(name.equals(ClassLoader.class.getName())) {
+            coordinator.classLoader = (ClassLoader)value;
+            return;
+        }
         super.setProperty(name, value);
     }
 
@@ -516,4 +533,8 @@
     public void setListener(Listener listener) {
         externalListener = listener;
     }
+
+    public UnmarshallingContext getContext() {
+        return coordinator;
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/UnmarshallingContext.java	Tue Aug  4 09:51:18 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/UnmarshallingContext.java	Tue Aug  4 09:51:18 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import java.lang.reflect.InvocationTargetException;
@@ -58,9 +59,9 @@
 import com.sun.xml.internal.bind.v2.runtime.Coordinator;
 import com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl;
 import com.sun.xml.internal.bind.v2.runtime.JaxBeanInfo;
+import com.sun.xml.internal.bind.v2.runtime.ElementBeanInfoImpl;
 
 import org.xml.sax.ErrorHandler;
-import org.xml.sax.Locator;
 import org.xml.sax.SAXException;
 import org.xml.sax.helpers.LocatorImpl;
 
@@ -86,6 +87,17 @@
      */
     private State current;
 
+    private static final LocatorEx DUMMY_INSTANCE;
+
+    static {
+        LocatorImpl loc = new LocatorImpl();
+        loc.setPublicId(null);
+        loc.setSystemId(null);
+        loc.setLineNumber(-1);
+        loc.setColumnNumber(-1);
+        DUMMY_INSTANCE = new LocatorExWrapper(loc);
+    }
+
     private @NotNull LocatorEx locator = DUMMY_INSTANCE;
 
     /** Root object that is being unmarshalled. */
@@ -160,6 +172,12 @@
     public @Nullable ClassResolver classResolver;
 
     /**
+     * User-supplied {@link ClassLoader} for converting name to {@link Class}.
+     * For backward compatibility, when null, use thread context classloader.
+     */
+    public @Nullable ClassLoader classLoader;
+
+    /**
      * State information for each element.
      */
     public final class State {
@@ -183,6 +201,30 @@
 
         /**
          * Hack for making JAXBElement unmarshalling work.
+         *
+         * <p>
+         * While the unmarshalling is in progress, the {@link #target} field stores the object being unmarshalled.
+         * This makes it convenient to keep track of the unmarshalling activity in context of XML infoset, but
+         * since there's only one {@link State} per element, this mechanism only works when there's one object
+         * per element, which breaks down when we have {@link JAXBElement}, since the presence of JAXBElement
+         * requires that we have two objects unmarshalled (a JAXBElement X and a value object Y bound to an XML type.)
+         *
+         * <p>
+         * So to make room for storing both, this {@link #backup} field is used. When we create X instance
+         * in the above example, we set that to {@code state.prev.target} and displace its old value to
+         * {@code state.prev.backup} (where Y goes to {@code state.target}.) Upon the completion of the unmarshalling
+         * of Y, we revert this.
+         *
+         * <p>
+         * While this attributes X incorrectly to its parent element, this preserves the parent/child
+         * relationship between unmarshalled objects and {@link State} parent/child relationship, and
+         * it thereby makes {@link Receiver} mechanism simpler.
+         *
+         * <p>
+         * Yes, I know this is a hack, and no, I'm not proud of it.
+         *
+         * @see ElementBeanInfoImpl.IntercepterLoader#startElement(State, TagName)
+         * @see ElementBeanInfoImpl.IntercepterLoader#intercept(State, Object)
          */
         public Object backup;
 
@@ -210,6 +252,8 @@
         public final State prev;
         private State next;
 
+        public boolean nil = false;
+
         /**
          * Gets the context.
          */
@@ -514,6 +558,13 @@
         throw new UnmarshalException((String)null);
     }
 
+    void clearResult() {
+        if (isUnmarshalInProgress) {
+            throw new IllegalStateException();
+        }
+        result = null;
+    }
+
     /**
      * Creates a new instance of the specified class.
      * In the unmarshaller, we need to check the user-specified factory class.
@@ -970,6 +1021,7 @@
          * Receives the root element and determines how to start
          * unmarshalling.
          */
+        @Override
         public void childElement(UnmarshallingContext.State state, TagName ea) throws SAXException {
             Loader loader = state.getContext().selectRootLoader(state,ea);
             if(loader!=null) {
@@ -1002,6 +1054,9 @@
                 ((JAXBElement<Object>)state.backup).setValue(o);
                 o = state.backup;
             }
+            if (state.nil) {
+                ((JAXBElement<Object>)o).setNil(true);
+            }
             state.getContext().result = o;
         }
     }
@@ -1126,14 +1181,32 @@
         return (UnmarshallingContext) Coordinator._getInstance();
     }
 
-    private static final LocatorEx DUMMY_INSTANCE;
+    /**
+     * Allows to access elements which are expected in current state.
+     * Useful for getting elements/attributes for current parent.
+     *
+     * @return
+     */
+    public Collection<QName> getCurrentExpectedElements() {
+        pushCoordinator();
+        try {
+            State s = getCurrentState();
+            Loader l = s.loader;
+            return l.getExpectedChildElements();
+        } finally {
+            popCoordinator();
+        }
+    }
 
-    static {
-        LocatorImpl loc = new LocatorImpl();
-        loc.setPublicId(null);
-        loc.setSystemId(null);
-        loc.setLineNumber(-1);
-        loc.setColumnNumber(-1);
-        DUMMY_INSTANCE = new LocatorExWrapper(loc);
+    /**
+     * Gets StructureLoader if used as loader.
+     * Useful when determining if element is mixed or not.
+     *
+     */
+    public StructureLoader getStructureLoader() {
+        if(current.loader instanceof StructureLoader)
+            return (StructureLoader)current.loader;
+
+        return null;
     }
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/ValuePropertyLoader.java	Tue Aug  4 09:51:21 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/ValuePropertyLoader.java	Tue Aug  4 09:51:20 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import com.sun.xml.internal.bind.v2.runtime.reflect.TransducedAccessor;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/WildcardLoader.java	Tue Aug  4 09:51:23 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/WildcardLoader.java	Tue Aug  4 09:51:23 2009
@@ -23,9 +23,6 @@
  * have any questions.
  */
 
-/*
- * @(#)$Id: WildcardLoader.java,v 1.3.6.1 2006/08/23 17:24:39 kohsuke Exp $
- */
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import javax.xml.bind.annotation.DomHandler;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/XmlVisitor.java	Tue Aug  4 09:51:26 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/XmlVisitor.java	Tue Aug  4 09:51:26 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import javax.xml.namespace.NamespaceContext;
@@ -143,9 +144,9 @@
          *
          * <p>
          * If this method returns true, all the whitespaces are considered significant
-         * and thus need to be reported as a {@link #text} event. Furthermore,
+         * and thus need to be reported as a {@link XmlVisitor#text} event. Furthermore,
          * if the element has no children (like &lt;foo/>), then it has to be reported
-         * an empty {@link #text} event.
+         * an empty {@link XmlVisitor#text} event.
          */
         boolean expectText();
     }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/XsiNilLoader.java	Tue Aug  4 09:51:29 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/XsiNilLoader.java	Tue Aug  4 09:51:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
@@ -29,6 +30,9 @@
 import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
 
+import java.util.Collection;
+import javax.xml.bind.JAXBElement;
+import javax.xml.namespace.QName;
 import org.xml.sax.SAXException;
 
 /**
@@ -49,17 +53,24 @@
     protected Loader selectLoader(UnmarshallingContext.State state, TagName ea) throws SAXException {
         int idx = ea.atts.getIndex(WellKnownNamespace.XML_SCHEMA_INSTANCE,"nil");
 
-        if(idx!=-1) {
-            String value = ea.atts.getValue(idx);
-            if(DatatypeConverterImpl._parseBoolean(value)) {
+        if (idx!=-1) {
+            if (DatatypeConverterImpl._parseBoolean(ea.atts.getValue(idx))) {
                 onNil(state);
-                return Discarder.INSTANCE;
+                boolean hasOtherAttributes = (ea.atts.getLength() - 1) > 0;
+                // see issues 6759703 and 565 - need to preserve attributes even if the element is nil; only when the type is stored in JAXBElement
+                if (!(hasOtherAttributes && (state.prev.target instanceof JAXBElement))) {
+                    return Discarder.INSTANCE;
+                }
             }
         }
-
         return defaultLoader;
     }
 
+        @Override
+        public Collection<QName> getExpectedChildElements() {
+            return defaultLoader.getExpectedChildElements();
+        }
+
     /**
      * Called when xsi:nil='true' was found.
      */
@@ -75,13 +86,16 @@
             this.acc = acc;
         }
 
+        @Override
         protected void onNil(UnmarshallingContext.State state) throws SAXException {
             try {
                 acc.set(state.prev.target,null);
+                state.prev.nil = true;
             } catch (AccessorException e) {
                 handleGenericException(e,true);
             }
         }
+
     }
 
     public static final class Array extends XsiNilLoader {
@@ -89,6 +103,7 @@
             super(core);
         }
 
+        @Override
         protected void onNil(UnmarshallingContext.State state) {
             // let the receiver add this to the lister
             state.target = null;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/XsiTypeLoader.java	Tue Aug  4 09:51:33 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/XsiTypeLoader.java	Tue Aug  4 09:51:33 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
 
 import javax.xml.namespace.QName;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/FoolProofResolver.java	Tue Aug  4 09:51:36 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/FoolProofResolver.java	Tue Aug  4 09:51:35 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/Form.java	Tue Aug  4 09:51:38 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/Form.java	Tue Aug  4 09:51:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen;
 
 import javax.xml.bind.annotation.XmlNsForm;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/GroupKind.java	Tue Aug  4 09:51:40 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/GroupKind.java	Tue Aug  4 09:51:40 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen;
 
 import com.sun.xml.internal.bind.v2.schemagen.xmlschema.Particle;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/Messages.java	Tue Aug  4 09:51:42 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/Messages.java	Tue Aug  4 09:51:42 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen;
 
 import java.util.ResourceBundle;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/Messages.properties	Tue Aug  4 09:51:45 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/Messages.properties	Tue Aug  4 09:51:44 2009
@@ -24,4 +24,3 @@
 #
 
 ANONYMOUS_TYPE_CYCLE=Anonymous types form an infinite cycle: {0}
- 
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/MultiMap.java	Tue Aug  4 09:51:47 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/MultiMap.java	Tue Aug  4 09:51:47 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen;
 
 import java.util.TreeMap;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/Tree.java	Tue Aug  4 09:51:50 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/Tree.java	Tue Aug  4 09:51:49 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/XmlSchemaGenerator.java	Tue Aug  4 09:51:54 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/XmlSchemaGenerator.java	Tue Aug  4 09:51:54 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen;
 
 import java.io.IOException;
@@ -42,6 +43,7 @@
 
 import javax.activation.MimeType;
 import javax.xml.bind.SchemaOutputResolver;
+import javax.xml.bind.annotation.XmlElement;
 import javax.xml.namespace.QName;
 import javax.xml.transform.Result;
 import javax.xml.transform.stream.StreamResult;
@@ -54,6 +56,7 @@
 import com.sun.xml.internal.bind.v2.TODO;
 import com.sun.xml.internal.bind.v2.WellKnownNamespace;
 import com.sun.xml.internal.bind.v2.util.CollisionCheckStack;
+import com.sun.xml.internal.bind.v2.util.StackRecorder;
 import static com.sun.xml.internal.bind.v2.WellKnownNamespace.XML_SCHEMA;
 import com.sun.xml.internal.bind.v2.model.core.Adapter;
 import com.sun.xml.internal.bind.v2.model.core.ArrayInfo;
@@ -267,10 +270,28 @@
     public void add( ElementInfo<T,C> elem ) {
         assert elem!=null;
 
+        boolean nillable = false; // default value
+
         QName name = elem.getElementName();
         Namespace n = getNamespace(name.getNamespaceURI());
-        n.elementDecls.put(name.getLocalPart(),n.new ElementWithType(true,elem.getContentType()));
+        ElementInfo ei;
 
+        if (elem.getScope() != null) { // (probably) never happens
+            ei = this.types.getElementInfo(elem.getScope().getClazz(), name);
+        } else {
+            ei = this.types.getElementInfo(null, name);
+        }
+
+        XmlElement xmlElem = ei.getProperty().readAnnotation(XmlElement.class);
+
+        if (xmlElem == null) {
+            nillable = false;
+        } else {
+            nillable = xmlElem.nillable();
+        }
+
+        n.elementDecls.put(name.getLocalPart(),n.new ElementWithType(nillable, elem.getContentType()));
+
         // search for foreign namespace references
         n.processForeignNamespaces(elem.getProperty());
     }
@@ -404,6 +425,11 @@
         if(resolver==null)
             throw new IllegalArgumentException();
 
+        if(logger.isLoggable(Level.FINE)) {
+            // debug logging to see what's going on.
+            logger.log(Level.FINE,"Wrigin XML Schema for "+toString(),new StackRecorder());
+        }
+
         // make it fool-proof
         resolver = new FoolProofResolver(resolver);
         this.errorListener = errorListener;
@@ -1026,7 +1052,7 @@
                         if(ep.isCollectionNillable()) {
                             e.nillable(true);
                         }
-                        writeOccurs(e,true,repeated);
+                        writeOccurs(e,!ep.isCollectionRequired(),repeated);
 
                         ComplexType p = e.complexType();
                         choice.write(p);
@@ -1180,11 +1206,8 @@
             }
 
 
-            final Tree choice = Tree.makeGroup(GroupKind.CHOICE, children).makeRepeated(rp.isCollection()).makeOptional(rp.isCollection());
-            // it's a curious omission that XmlElementRef doesn't have required().
-            // instead right now a collection will make it [0,unbounded]
+            final Tree choice = Tree.makeGroup(GroupKind.CHOICE, children).makeRepeated(rp.isCollection()).makeOptional(!rp.isRequired());
 
-
             final QName ename = rp.getXmlName();
 
             if (ename != null) { // wrapped
@@ -1253,6 +1276,16 @@
             addDependencyTo(tref.getTarget().getTypeName());
         }
 
+        @Override
+        public String toString() {
+            StringBuilder buf = new StringBuilder();
+            buf.append("[classes=").append(classes);
+            buf.append(",elementDecls=").append(elementDecls);
+            buf.append(",enums=").append(enums);
+            buf.append("]");
+            return super.toString();
+        }
+
         /**
          * Represents a global element declaration to be written.
          *
@@ -1338,6 +1371,18 @@
         return (o.equals(adapter.adapterType));
     }
 
+    /**
+     * Debug information of what's in this {@link XmlSchemaGenerator}.
+     */
+    public String toString() {
+        StringBuilder buf = new StringBuilder();
+        for (Namespace ns : namespaces.values()) {
+            if(buf.length()>0)  buf.append(',');
+            buf.append(ns.uri).append('=').append(ns);
+        }
+        return super.toString()+'['+buf+']';
+    }
+
     /**
      * return the string representation of the processContents mode of the
      * give wildcard, or null if it is the schema default "strict"
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/episode/Bindings.java	Tue Aug  4 09:51:56 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/episode/Bindings.java	Tue Aug  4 09:51:56 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen.episode;
 
 import com.sun.xml.internal.txw2.TypedXmlWriter;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/episode/Klass.java	Tue Aug  4 09:51:59 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/episode/Klass.java	Tue Aug  4 09:51:58 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen.episode;
 
 import com.sun.xml.internal.txw2.TypedXmlWriter;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/episode/SchemaBindings.java	Tue Aug  4 09:52:01 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/episode/SchemaBindings.java	Tue Aug  4 09:52:01 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen.episode;
 
 import com.sun.xml.internal.txw2.TypedXmlWriter;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/episode/package-info.java	Tue Aug  4 09:52:03 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/episode/package-info.java	Tue Aug  4 09:52:03 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /**
  * TXW interfaces for writing episode file, which is what XJC needs to
  * handle separate compilation.
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/package-info.java	Tue Aug  4 09:52:06 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/package-info.java	Tue Aug  4 09:52:05 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 /**
  * Schema generator.
  *
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/ContentModelContainer.java	Tue Aug  4 09:52:09 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/ContentModelContainer.java	Tue Aug  4 09:52:09 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen.xmlschema;
 
 import com.sun.xml.internal.txw2.TypedXmlWriter;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/Element.java	Tue Aug  4 09:52:12 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/Element.java	Tue Aug  4 09:52:12 2009
@@ -37,10 +37,10 @@
     public Element type(QName value);
 
     @XmlAttribute
-    public Element block(String value);
+    public Element block(String[] value);
 
     @XmlAttribute
-    public Element block(String[] value);
+    public Element block(String value);
 
     @XmlAttribute
     public Element nillable(boolean value);
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/Occurs.java	Tue Aug  4 09:52:15 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/Occurs.java	Tue Aug  4 09:52:15 2009
@@ -36,9 +36,9 @@
     public Occurs minOccurs(int value);
 
     @XmlAttribute
-    public Occurs maxOccurs(int value);
+    public Occurs maxOccurs(String value);
 
     @XmlAttribute
-    public Occurs maxOccurs(String value);
+    public Occurs maxOccurs(int value);
 
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/Particle.java	Tue Aug  4 09:52:17 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/Particle.java	Tue Aug  4 09:52:17 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.schemagen.xmlschema;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/Schema.java	Tue Aug  4 09:52:20 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/Schema.java	Tue Aug  4 09:52:20 2009
@@ -56,10 +56,10 @@
     public Schema attributeFormDefault(String value);
 
     @XmlAttribute
-    public Schema blockDefault(String value);
+    public Schema blockDefault(String[] value);
 
     @XmlAttribute
-    public Schema blockDefault(String[] value);
+    public Schema blockDefault(String value);
 
     @XmlAttribute
     public Schema finalDefault(String value);
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/SimpleType.java	Tue Aug  4 09:52:23 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/SimpleType.java	Tue Aug  4 09:52:22 2009
@@ -35,10 +35,10 @@
 
 
     @XmlAttribute("final")
-    public SimpleType _final(String[] value);
+    public SimpleType _final(String value);
 
     @XmlAttribute("final")
-    public SimpleType _final(String value);
+    public SimpleType _final(String[] value);
 
     @XmlAttribute
     public SimpleType name(String value);
--- old/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/Wildcard.java	Tue Aug  4 09:52:25 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/schemagen/xmlschema/Wildcard.java	Tue Aug  4 09:52:25 2009
@@ -36,9 +36,9 @@
     public Wildcard processContents(String value);
 
     @XmlAttribute
-    public Wildcard namespace(String[] value);
+    public Wildcard namespace(String value);
 
     @XmlAttribute
-    public Wildcard namespace(String value);
+    public Wildcard namespace(String[] value);
 
 }
--- old/src/share/classes/com/sun/xml/internal/bind/v2/util/ByteArrayOutputStreamEx.java	Tue Aug  4 09:52:28 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/util/ByteArrayOutputStreamEx.java	Tue Aug  4 09:52:27 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.util;
 
 import java.io.ByteArrayOutputStream;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/util/CollisionCheckStack.java	Tue Aug  4 09:52:31 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/util/CollisionCheckStack.java	Tue Aug  4 09:52:30 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.util;
 
 import java.util.AbstractList;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/util/DataSourceSource.java	Tue Aug  4 09:52:34 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/util/DataSourceSource.java	Tue Aug  4 09:52:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.util;
 
 import java.io.IOException;
@@ -58,6 +59,12 @@
      */
     private final String charset;
 
+    // remember the value we returned so that the 2nd invocation
+    // will return the same object, which is what's expeted out of
+    // StreamSource
+    private Reader r;
+    private InputStream is;
+
     public DataSourceSource(DataHandler dh) throws MimeTypeParseException {
         this(dh.getDataSource());
     }
@@ -88,7 +95,9 @@
     public Reader getReader() {
         try {
             if(charset==null)   return null;
-            else                return new InputStreamReader(source.getInputStream(),charset);
+            if(r==null)
+                r = new InputStreamReader(source.getInputStream(),charset);
+            return r;
         } catch (IOException e) {
             // argh
             throw new RuntimeException(e);
@@ -98,8 +107,10 @@
     @Override
     public InputStream getInputStream() {
         try {
-            if(charset==null)   return source.getInputStream();
-            else                return null;
+            if(charset!=null)   return null;
+            if(is==null)
+                is = source.getInputStream();
+            return is;
         } catch (IOException e) {
             // argh
             throw new RuntimeException(e);
--- old/src/share/classes/com/sun/xml/internal/bind/v2/util/EditDistance.java	Tue Aug  4 09:52:37 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/util/EditDistance.java	Tue Aug  4 09:52:36 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * @(#)$Id$
- */
-
-
 package com.sun.xml.internal.bind.v2.util;
 
 import java.util.Collection;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/util/FatalAdapter.java	Tue Aug  4 09:52:39 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/util/FatalAdapter.java	Tue Aug  4 09:52:38 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.util;
 
 import org.xml.sax.ErrorHandler;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/util/FlattenIterator.java	Tue Aug  4 09:52:41 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/util/FlattenIterator.java	Tue Aug  4 09:52:41 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.util;
 
 import java.util.Iterator;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/util/QNameMap.java	Tue Aug  4 09:52:43 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/util/QNameMap.java	Tue Aug  4 09:52:43 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.util;
 import java.util.AbstractSet;
 import java.util.Iterator;
--- old/src/share/classes/com/sun/xml/internal/bind/v2/util/TypeCast.java	Tue Aug  4 09:52:46 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/util/TypeCast.java	Tue Aug  4 09:52:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.bind.v2.util;
 
 import java.util.Map;
--- old/src/share/classes/com/sun/xml/internal/dtdparser/DTDParser.java	Tue Aug  4 09:52:48 2009
+++ new/src/share/classes/com/sun/xml/internal/dtdparser/DTDParser.java	Tue Aug  4 09:52:47 2009
@@ -58,7 +58,7 @@
  * @author David Brownell
  * @author Janet Koenig
  * @author Kohsuke KAWAGUCHI
- * @version $Id: DTDParser.java,v 1.1 2005/05/15 04:24:19 kohsuke Exp $
+ * @version $Id: DTDParser.java,v 1.1 2005/05/31 22:28:54 kohsuke Exp $
  */
 public class DTDParser {
     public final static String TYPE_CDATA = "CDATA";
--- old/src/share/classes/com/sun/xml/internal/dtdparser/resources/Messages.properties	Tue Aug  4 09:52:50 2009
+++ new/src/share/classes/com/sun/xml/internal/dtdparser/resources/Messages.properties	Tue Aug  4 09:52:50 2009
@@ -28,7 +28,7 @@
 #
 # P-NNN ... parser messages
 # F-NNN ... message fragments (sometimes associated with more
-#		than one message, but usually just with one)
+#               than one message, but usually just with one)
 # V-NNN ... validation related messages
 #
 # Most messages can be produced in only one way.
@@ -45,51 +45,51 @@
 P-004 = Missing whitespace {0}
 P-005 = Only whitespace allowed {0}
 
-	#
-	# unadorned "missing whitespace", with P-004 only
-	#
-	F-000 = after element name declaration
-	F-001 = between attribute name and type
-	F-002 = after NOTATION type name
-	F-003 = between attribute type and default value
-	F-004 = after #FIXED
-	F-005 = after <!ENTITY declaration
-	F-006 = after % in parameter entity declaration
-	F-007 = after entity name
-	F-008 = before SYSTEM literal URI
-	F-009 = after PUBLIC keyword
-	# F-010 ... identifier can be reused
-	F-011 = after notation name
-	# F-012 ... identifier can be reused
-	# F-013 ... identifier can be reused
+        #
+        # unadorned "missing whitespace", with P-004 only
+        #
+        F-000 = after element name declaration
+        F-001 = between attribute name and type
+        F-002 = after NOTATION type name
+        F-003 = between attribute type and default value
+        F-004 = after #FIXED
+        F-005 = after <!ENTITY declaration
+        F-006 = after % in parameter entity declaration
+        F-007 = after entity name
+        F-008 = before SYSTEM literal URI
+        F-009 = after PUBLIC keyword
+        # F-010 ... identifier can be reused
+        F-011 = after notation name
+        # F-012 ... identifier can be reused
+        # F-013 ... identifier can be reused
 
-	#
-	# in declaration, in "S Name", with P-004 and P-005
-	#
-	F-014 = before name in <!DOCTYPE declaration
-	F-015 = before name in <!ELEMENT declaration
-	F-016 = before name in <!ATTLIST declaration
-	F-017 = before name in <!ENTITY declaration
-	F-018 = before NDATA notation name in <!ENTITY declaration
-	F-019 = before name in <!NOTATION declaration
+        #
+        # in declaration, in "S Name", with P-004 and P-005
+        #
+        F-014 = before name in <!DOCTYPE declaration
+        F-015 = before name in <!ELEMENT declaration
+        F-016 = before name in <!ATTLIST declaration
+        F-017 = before name in <!ENTITY declaration
+        F-018 = before NDATA notation name in <!ENTITY declaration
+        F-019 = before name in <!NOTATION declaration
 
 P-006 = Name tokens must not start with "{0}" characters
 P-007 = Value must be quoted
 P-008 = Next character must be "{0}" {1} {2}
 
-	F-020 = terminating reference to entity
-	F-021 = terminating reference to parameter entity
-	F-022 = terminating comment
-	F-023 = in XML Declaration
-	F-024 = terminating internal DTD subset
-	F-025 = terminating <!DOCTYPE ...> declaration
-	F-026 = after attribute name
-	F-027 = terminating element
-	F-028 = starting content model for element
-	F-029 = starting list of attribute NOTATIONS
-	F-030 = beginning condition DTD subset
-	F-031 = terminating <!ENTITY ...> declaration
-	F-032 = terminating <!NOTATION ...> declaration
+        F-020 = terminating reference to entity
+        F-021 = terminating reference to parameter entity
+        F-022 = terminating comment
+        F-023 = in XML Declaration
+        F-024 = terminating internal DTD subset
+        F-025 = terminating <!DOCTYPE ...> declaration
+        F-026 = after attribute name
+        F-027 = terminating element
+        F-028 = starting content model for element
+        F-029 = starting list of attribute NOTATIONS
+        F-030 = beginning condition DTD subset
+        F-031 = terminating <!ENTITY ...> declaration
+        F-032 = terminating <!NOTATION ...> declaration
 
 P-009 = Illegal character or entity reference syntax
 
@@ -99,11 +99,11 @@
 P-013 = Illegal reference to external entity "&{0};" in attribute
 P-014 = Reference to undefined entity "&{0};"
 P-015 = Expecting quoted value for {0}
-	
-	F-033 = PUBLIC identifier
-	F-034 = SYSTEM identifier
-	F-035 = attribute value {0}
 
+        F-033 = PUBLIC identifier
+        F-034 = SYSTEM identifier
+        F-035 = attribute value {0}
+
 P-016 = Illegal character in PUBLIC identifier:  "{0}"
 P-017 = End of entity while processing comment
 P-018 = Processing instruction target is missing
@@ -155,7 +155,7 @@
 
 P-060 = Illegal character "{0}" in encoding name
 P-061 = Declared encoding "{0}" does not match actual one "{1}"; \
-	this might not be an error
+        this might not be an error
 P-062 = Notation must be PUBLIC or SYSTEM
 P-063 = Using first definition of notation "{0}"
 P-064 = Premature end of parameter entity "%{0};"
@@ -175,10 +175,10 @@
 P-077 = Maximum symbol length ({0} characters) exceeded
 P-078 = No messages for locale "{0}" are available
 P-079 = The content beginning "<{1}" is not legal markup \
-	Perhaps the "{1}" (&#{0};) character should be a letter
+        Perhaps the "{1}" (&#{0};) character should be a letter
 
 P-080 = Parameter entity references must not appear within \
-	markup declarations in the internal DTD subset
+        markup declarations in the internal DTD subset
 P-081 = Incomplete Unicode surrogate pair:  &#x{0}
 
 #
@@ -188,7 +188,7 @@
 # there's no need for the VC, ever; and "standalone" would then affect
 # WF-ness.  For the moment this assumes it's to be a VC not a WFC
 #
-V-000 =	Validation is disabled
+V-000 = Validation is disabled
 V-001 = Valid documents must have a <!DOCTYPE declaration
 V-002 = This document is standalone, so it must not refer to "&{0};"
 V-003 = Undeclared notation "{0}" is used by an <!ENTITY...> declaration
@@ -200,9 +200,9 @@
 V-009 = Attribute value for "{0}" is #REQUIRED
 
 V-010 = This document is standalone, \
-	so attribute "{0}" must not be defaulted
+        so attribute "{0}" must not be defaulted
 V-011 = This document is standalone, \
-	so element "{0}" must not have ignorable whitespace
+        so element "{0}" must not have ignorable whitespace
 V-012 = Element "{0}" was already declared
 V-013 = Parameter entities must not contain partial declarations
 V-014 = Parameter entity nesting error in content model for "{0}"
@@ -235,4 +235,3 @@
 V-039 = IDREFS attributes must have at least one value
 
 V-040 = ENTITIES attributes must have at least one value
- 
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/AbstractResourceBundle.java	Tue Aug  4 09:52:52 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/AbstractResourceBundle.java	Tue Aug  4 09:52:52 2009
@@ -24,6 +24,14 @@
  *
  * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
  */
+/*
+ *
+ * This code is subject to the freebxml License, Version 1.1
+ *
+ * Copyright (c) 2001 - 2005 freebxml.org.  All rights reserved.
+ *
+ * $Header: /cvs/fi/FastInfoset/src/com/sun/xml/internal/fastinfoset/AbstractResourceBundle.java,v 1.3.2.4 2009/05/13 08:53:01 oleksiys Exp $
+ */
 package com.sun.xml.internal.fastinfoset;
 
 import java.text.MessageFormat;
@@ -35,19 +43,12 @@
 /**
  * This class contains methods common to all *ResourceBundle classes
  *
- * @author  Paul Sterk / Sun Microsystems
+ * @author FastInfoset team
  */
 public abstract class AbstractResourceBundle extends ResourceBundle {
 
     public static final String LOCALE = "com.sun.xml.internal.fastinfoset.locale";
-    static String _bundleName = null;
 
-    public static String getBundleName() {
-        return _bundleName;
-    }
-    public static void setBundleName(String name) {
-        _bundleName = name;
-    }
     /**
      * Gets 'key' from ResourceBundle and format mesage using 'args'.
      *
@@ -59,24 +60,6 @@
         String pattern = getBundle().getString(key);
         return MessageFormat.format(pattern, args);
     }
-
-    /**
-     * Gets 'key' from ResourceBundle and format mesage using 'args'.
-     *
-     * @param key String key for message.
-     * @param args Array of arguments for message.
-     * @param locale Locale in which to perform key lookup.
-     * @return String formatted message.
-     */
-    public String getString(String key, Object args[], Locale locale) {
-        String pattern = null;
-        if (locale == null) {
-            pattern = getBundle().getString(key);
-        } else {
-            pattern = getBundle(_bundleName, locale).getString(key);
-        }
-        return MessageFormat.format(pattern, args);
-    }
 
     /**
      * Parse a locale string, return corresponding Locale instance.
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/Decoder.java	Tue Aug  4 09:52:55 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/Decoder.java	Tue Aug  4 09:52:54 2009
@@ -72,11 +72,14 @@
  */
 public abstract class Decoder implements FastInfosetParser {
 
-    protected static final char[] XML_NAMESPACE_NAME_CHARS = EncodingConstants.XML_NAMESPACE_NAME.toCharArray();
+    private static final char[] XML_NAMESPACE_NAME_CHARS =
+            EncodingConstants.XML_NAMESPACE_NAME.toCharArray();
 
-    protected static final char[] XMLNS_NAMESPACE_PREFIX_CHARS = EncodingConstants.XMLNS_NAMESPACE_PREFIX.toCharArray();
+    private static final char[] XMLNS_NAMESPACE_PREFIX_CHARS =
+            EncodingConstants.XMLNS_NAMESPACE_PREFIX.toCharArray();
 
-    protected static final char[] XMLNS_NAMESPACE_NAME_CHARS = EncodingConstants.XMLNS_NAMESPACE_NAME.toCharArray();
+    private static final char[] XMLNS_NAMESPACE_NAME_CHARS =
+            EncodingConstants.XMLNS_NAMESPACE_NAME.toCharArray();
 
     /**
      * String interning system property.
@@ -592,7 +595,7 @@
                     prefixIndex, namespaceNameIndex, localNameIndex,
                     _charBuffer);
             if (isAttribute) {
-                qualifiedName.createAttributeValues(_duplicateAttributeVerifier.MAP_SIZE);
+                qualifiedName.createAttributeValues(DuplicateAttributeVerifier.MAP_SIZE);
             }
             array.add(qualifiedName);
         }
@@ -755,7 +758,7 @@
      */
     protected final int decodeNonIdentifyingStringOnFirstBit() throws FastInfosetException, IOException {
         final int b = read();
-        switch(DecoderStateTables.NISTRING[b]) {
+        switch(DecoderStateTables.NISTRING(b)) {
             case DecoderStateTables.NISTRING_UTF8_SMALL_LENGTH:
                 _addToTable = (b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0;
                 _octetBufferLength = (b & EncodingConstants.OCTET_STRING_LENGTH_5TH_BIT_SMALL_MASK) + 1;
@@ -844,7 +847,7 @@
         // Remove top 4 bits of restricted alphabet or encoding algorithm integer
         b &= 0x0F;
         // Reuse UTF8 length states
-        switch(DecoderStateTables.NISTRING[b]) {
+        switch(DecoderStateTables.NISTRING(b)) {
             case DecoderStateTables.NISTRING_UTF8_SMALL_LENGTH:
                 _octetBufferLength = b + 1;
                 break;
@@ -901,7 +904,7 @@
      */
     protected final String decodeIdentifyingNonEmptyStringOnFirstBit(StringArray table) throws FastInfosetException, IOException {
         final int b = read();
-        switch(DecoderStateTables.ISTRING[b]) {
+        switch(DecoderStateTables.ISTRING(b)) {
             case DecoderStateTables.ISTRING_SMALL_LENGTH:
             {
                 _octetBufferLength = b + 1;
@@ -950,7 +953,7 @@
      */
     protected final String decodeIdentifyingNonEmptyStringOnFirstBitAsPrefix(boolean namespaceNamePresent) throws FastInfosetException, IOException {
         final int b = read();
-        switch(DecoderStateTables.ISTRING_PREFIX_NAMESPACE[b]) {
+        switch(DecoderStateTables.ISTRING_PREFIX_NAMESPACE(b)) {
             case DecoderStateTables.ISTRING_PREFIX_NAMESPACE_LENGTH_3:
             {
                 _octetBufferLength = EncodingConstants.XML_NAMESPACE_PREFIX_LENGTH;
@@ -1016,7 +1019,7 @@
                 if (namespaceNamePresent) {
                     _prefixIndex = 0;
                     // Peak at next byte and check the index of the XML namespace name
-                    if (DecoderStateTables.ISTRING_PREFIX_NAMESPACE[peek()]
+                    if (DecoderStateTables.ISTRING_PREFIX_NAMESPACE(peek())
                             != DecoderStateTables.ISTRING_PREFIX_NAMESPACE_INDEX_ZERO) {
                         throw new FastInfosetException(CommonResourceBundle.getInstance().getString("message.wrongNamespaceName"));
                     }
@@ -1045,12 +1048,12 @@
      */
     protected final String decodeIdentifyingNonEmptyStringIndexOnFirstBitAsPrefix(boolean namespaceNamePresent) throws FastInfosetException, IOException {
         final int b = read();
-        switch(DecoderStateTables.ISTRING_PREFIX_NAMESPACE[b]) {
+        switch(DecoderStateTables.ISTRING_PREFIX_NAMESPACE(b)) {
             case DecoderStateTables.ISTRING_PREFIX_NAMESPACE_INDEX_ZERO:
                 if (namespaceNamePresent) {
                     _prefixIndex = 0;
                     // Peak at next byte and check the index of the XML namespace name
-                    if (DecoderStateTables.ISTRING_PREFIX_NAMESPACE[peek()]
+                    if (DecoderStateTables.ISTRING_PREFIX_NAMESPACE(peek())
                             != DecoderStateTables.ISTRING_PREFIX_NAMESPACE_INDEX_ZERO) {
                         throw new FastInfosetException(CommonResourceBundle.getInstance().getString("message.wrongNamespaceName"));
                     }
@@ -1081,7 +1084,7 @@
      */
     protected final String decodeIdentifyingNonEmptyStringOnFirstBitAsNamespaceName(boolean prefixPresent) throws FastInfosetException, IOException {
         final int b = read();
-        switch(DecoderStateTables.ISTRING_PREFIX_NAMESPACE[b]) {
+        switch(DecoderStateTables.ISTRING_PREFIX_NAMESPACE(b)) {
             case DecoderStateTables.ISTRING_PREFIX_NAMESPACE_LENGTH_3:
             case DecoderStateTables.ISTRING_PREFIX_NAMESPACE_LENGTH_5:
             case DecoderStateTables.ISTRING_SMALL_LENGTH:
@@ -1165,7 +1168,7 @@
      */
     protected final String decodeIdentifyingNonEmptyStringIndexOnFirstBitAsNamespaceName(boolean prefixPresent) throws FastInfosetException, IOException {
         final int b = read();
-        switch(DecoderStateTables.ISTRING_PREFIX_NAMESPACE[b]) {
+        switch(DecoderStateTables.ISTRING_PREFIX_NAMESPACE(b)) {
             case DecoderStateTables.ISTRING_PREFIX_NAMESPACE_INDEX_ZERO:
                 if (prefixPresent) {
                     _namespaceNameIndex = 0;
@@ -1220,7 +1223,7 @@
      */
     protected final void decodeNonEmptyOctetStringLengthOnSecondBit() throws FastInfosetException, IOException {
         final int b = read();
-        switch(DecoderStateTables.ISTRING[b]) {
+        switch(DecoderStateTables.ISTRING(b)) {
             case DecoderStateTables.ISTRING_SMALL_LENGTH:
                 _octetBufferLength = b + 1;
                 break;
@@ -1249,7 +1252,7 @@
      */
     protected final int decodeIntegerIndexOnSecondBit() throws FastInfosetException, IOException {
         final int b = read();
-        switch(DecoderStateTables.ISTRING[b]) {
+        switch(DecoderStateTables.ISTRING(b)) {
             case DecoderStateTables.ISTRING_INDEX_SMALL:
                 return b & EncodingConstants.INTEGER_2ND_BIT_SMALL_MASK;
             case DecoderStateTables.ISTRING_INDEX_MEDIUM:
@@ -1454,7 +1457,7 @@
         int b1;
         while (end != _octetBufferOffset) {
             b1 = _octetBuffer[_octetBufferOffset++] & 0xFF;
-            if (DecoderStateTables.UTF8[b1] == DecoderStateTables.UTF8_ONE_BYTE) {
+            if (DecoderStateTables.UTF8(b1) == DecoderStateTables.UTF8_ONE_BYTE) {
                 _charBuffer[_charBufferLength++] = (char) b1;
             } else {
                 decodeTwoToFourByteUtf8Character(b1, end);
@@ -1468,7 +1471,7 @@
         int b1;
         while (end != _octetBufferOffset) {
             b1 = _octetBuffer[_octetBufferOffset++] & 0xFF;
-            if (DecoderStateTables.UTF8[b1] == DecoderStateTables.UTF8_ONE_BYTE) {
+            if (DecoderStateTables.UTF8(b1) == DecoderStateTables.UTF8_ONE_BYTE) {
                 ch[_charBufferLength++] = (char) b1;
             } else {
                 decodeTwoToFourByteUtf8Character(ch, b1, end);
@@ -1478,7 +1481,7 @@
     }
 
     private void decodeTwoToFourByteUtf8Character(int b1, int end) throws IOException {
-        switch(DecoderStateTables.UTF8[b1]) {
+        switch(DecoderStateTables.UTF8(b1)) {
             case DecoderStateTables.UTF8_TWO_BYTES:
             {
                 // Decode byte 2
@@ -1523,7 +1526,7 @@
     }
 
     private void decodeTwoToFourByteUtf8Character(char ch[], int b1, int end) throws IOException {
-        switch(DecoderStateTables.UTF8[b1]) {
+        switch(DecoderStateTables.UTF8(b1)) {
             case DecoderStateTables.UTF8_TWO_BYTES:
             {
                 // Decode byte 2
@@ -1576,7 +1579,7 @@
         final int end = _octetBufferLength + _octetBufferOffset;
 
         int b1 = _octetBuffer[_octetBufferOffset++] & 0xFF;
-        if (DecoderStateTables.UTF8_NCNAME[b1] == DecoderStateTables.UTF8_NCNAME_NCNAME) {
+        if (DecoderStateTables.UTF8_NCNAME(b1) == DecoderStateTables.UTF8_NCNAME_NCNAME) {
             _charBuffer[_charBufferLength++] = (char) b1;
         } else {
             decodeUtf8NCNameStartTwoToFourByteCharacters(b1, end);
@@ -1584,7 +1587,7 @@
 
         while (end != _octetBufferOffset) {
             b1 = _octetBuffer[_octetBufferOffset++] & 0xFF;
-            if (DecoderStateTables.UTF8_NCNAME[b1] < DecoderStateTables.UTF8_TWO_BYTES) {
+            if (DecoderStateTables.UTF8_NCNAME(b1) < DecoderStateTables.UTF8_TWO_BYTES) {
                 _charBuffer[_charBufferLength++] = (char) b1;
             } else {
                 decodeUtf8NCNameTwoToFourByteCharacters(b1, end);
@@ -1593,7 +1596,7 @@
     }
 
     private void decodeUtf8NCNameStartTwoToFourByteCharacters(int b1, int end) throws IOException {
-        switch(DecoderStateTables.UTF8_NCNAME[b1]) {
+        switch(DecoderStateTables.UTF8_NCNAME(b1)) {
             case DecoderStateTables.UTF8_TWO_BYTES:
             {
                 // Decode byte 2
@@ -1642,7 +1645,7 @@
     }
 
     private void decodeUtf8NCNameTwoToFourByteCharacters(int b1, int end) throws IOException {
-        switch(DecoderStateTables.UTF8_NCNAME[b1]) {
+        switch(DecoderStateTables.UTF8_NCNAME(b1)) {
             case DecoderStateTables.UTF8_TWO_BYTES:
             {
                 // Decode byte 2
@@ -1787,6 +1790,10 @@
 
     }
 
+    protected String createQualifiedNameString(String second) {
+        return createQualifiedNameString(XMLNS_NAMESPACE_PREFIX_CHARS, second);
+    }
+
     protected String createQualifiedNameString(char[] first, String second) {
         final int l1 = first.length;
         final int l2 = second.length();
@@ -1880,10 +1887,12 @@
             }
         }
 
+        @Override
         public int read(byte b[]) throws IOException {
             return read(b, 0, b.length);
         }
 
+        @Override
         public int read(byte b[], int off, int len) throws IOException {
             if (b == null) {
                 throw new NullPointerException();
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/DecoderStateTables.java	Tue Aug  4 09:52:57 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/DecoderStateTables.java	Tue Aug  4 09:52:57 2009
@@ -62,9 +62,9 @@
     public final static int TERMINATOR_SINGLE               = 22;
     public final static int TERMINATOR_DOUBLE               = 23;
 
-    public static final int[] DII = new int[256];
+    private static final int[] DII = new int[256];
 
-    private static int[][] DII_RANGES = {
+    private static final int[][] DII_RANGES = {
         // EII
 
         // %00000000 to %00011111  EII no attributes small index
@@ -161,9 +161,9 @@
         { 0xFF, TERMINATOR_DOUBLE }
     };
 
-    public static final int[] EII = new int[256];
+    private static final int[] EII = new int[256];
 
-    private static int[][] EII_RANGES = {
+    private static final int[][] EII_RANGES = {
         // EII
 
         // %00000000 to %00011111  EII no attributes small index
@@ -349,9 +349,9 @@
     public final static int AII_TERMINATOR_SINGLE           = 4;
     public final static int AII_TERMINATOR_DOUBLE           = 5;
 
-    public static final int[] AII = new int[256];
+    private static final int[] AII = new int[256];
 
-    private static int[][] AII_RANGES = {
+    private static final int[][] AII_RANGES = {
         // %00000000 to %00111111  AII small index
         { 0x3F, AII_INDEX_SMALL },
 
@@ -404,9 +404,9 @@
     public final static int NISTRING_INDEX_LARGE           = 10;
     public final static int NISTRING_EMPTY                 = 11;
 
-    public static final int[] NISTRING = new int[256];
+    private static final int[] NISTRING = new int[256];
 
-    private static int[][] NISTRING_RANGES = {
+    private static final int[][] NISTRING_RANGES = {
         // UTF-8 string
 
         // %00000000 to %00000111  UTF-8 no add to table small length
@@ -521,9 +521,9 @@
     /* package */ final static int ISTRING_INDEX_MEDIUM        = 4;
     /* package */ final static int ISTRING_INDEX_LARGE         = 5;
 
-    /* package */ static final int[] ISTRING = new int[256];
+    private static final int[] ISTRING = new int[256];
 
-    private static int[][] ISTRING_RANGES = {
+    private static final int[][] ISTRING_RANGES = {
         // %00000000 to %00111111 small length
         { 0x3F, ISTRING_SMALL_LENGTH },
 
@@ -559,9 +559,9 @@
     /* package */ final static int ISTRING_PREFIX_NAMESPACE_LENGTH_36  = 9;
     /* package */ final static int ISTRING_PREFIX_NAMESPACE_INDEX_ZERO = 10;
 
-    /* package */ static final int[] ISTRING_PREFIX_NAMESPACE = new int[256];
+    private static final int[] ISTRING_PREFIX_NAMESPACE = new int[256];
 
-    private static int[][] ISTRING_PREFIX_NAMESPACE_RANGES = {
+    private static final int[][] ISTRING_PREFIX_NAMESPACE_RANGES = {
         // %00000000 to %00000001 small length
         { 0x01, ISTRING_SMALL_LENGTH },
 
@@ -627,9 +627,9 @@
     /* package */ final static int UTF8_THREE_BYTES           = 3;
     /* package */ final static int UTF8_FOUR_BYTES            = 4;
 
-    /* package */ static final int[] UTF8_NCNAME = new int[256];
+    private static final int[] UTF8_NCNAME = new int[256];
 
-    private static int[][] UTF8_NCNAME_RANGES = {
+    private static final int[][] UTF8_NCNAME_RANGES = {
 
         // Basic Latin
 
@@ -699,9 +699,9 @@
 
     /* package */ final static int UTF8_ONE_BYTE = 1;
 
-    /* package */ static final int[] UTF8 = new int[256];
+    private static final int[] UTF8 = new int[256];
 
-    private static int[][] UTF8_RANGES = {
+    private static final int[][] UTF8_RANGES = {
 
         // Basic Latin
 
@@ -763,8 +763,40 @@
         }
     }
 
+    public static final int DII(final int index) {
+        return DII[index];
+    }
+
+    public static final int EII(final int index) {
+        return EII[index];
+    }
+
+    public static final int AII(final int index) {
+        return AII[index];
+    }
+
+    public static final int NISTRING(final int index) {
+        return NISTRING[index];
+    }
+
+    public static final int ISTRING(final int index) {
+        return ISTRING[index];
+    }
+
+    public static final int ISTRING_PREFIX_NAMESPACE(final int index) {
+        return ISTRING_PREFIX_NAMESPACE[index];
+    }
+
+    public static final int UTF8(final int index) {
+        return UTF8[index];
+    }
+
+    public static final int UTF8_NCNAME(final int index) {
+        return UTF8_NCNAME[index];
+    }
+
     static {
-        // EII
+        // DII
         constructTable(DII, DII_RANGES);
 
         // EII
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/Encoder.java	Tue Aug  4 09:53:00 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/Encoder.java	Tue Aug  4 09:52:59 2009
@@ -95,9 +95,9 @@
         }
     }
 
-    protected static int[] NUMERIC_CHARACTERS_TABLE;
+    private static int[] NUMERIC_CHARACTERS_TABLE;
 
-    protected static int[] DATE_TIME_CHARACTERS_TABLE;
+    private static int[] DATE_TIME_CHARACTERS_TABLE;
 
     static {
         NUMERIC_CHARACTERS_TABLE = new int[maxCharacter(RestrictedAlphabet.NUMERIC_CHARACTERS) + 1];
@@ -235,12 +235,18 @@
     protected int _markIndex = -1;
 
     /**
-     * The limit on the size of [normalized value] of Attribute Information
+     * The minimum size of [normalized value] of Attribute Information
      * Items that will be indexed.
      */
-    protected int attributeValueSizeConstraint = FastInfosetSerializer.ATTRIBUTE_VALUE_SIZE_CONSTRAINT;
+    protected int minAttributeValueSize = FastInfosetSerializer.MIN_ATTRIBUTE_VALUE_SIZE;
 
     /**
+     * The maximum size of [normalized value] of Attribute Information
+     * Items that will be indexed.
+     */
+    protected int maxAttributeValueSize = FastInfosetSerializer.MAX_ATTRIBUTE_VALUE_SIZE;
+
+    /**
      * The limit on the size of indexed Map for attribute values
      * Limit is measured in characters number
      */
@@ -247,13 +253,20 @@
     protected int attributeValueMapTotalCharactersConstraint = FastInfosetSerializer.ATTRIBUTE_VALUE_MAP_MEMORY_CONSTRAINT / 2;
 
     /**
-     * The limit on the size of character content chunks
+     * The minimum size of character content chunks
      * of Character Information Items or Comment Information Items that
      * will be indexed.
      */
-    protected int characterContentChunkSizeContraint = FastInfosetSerializer.CHARACTER_CONTENT_CHUNK_SIZE_CONSTRAINT;
+    protected int minCharacterContentChunkSize = FastInfosetSerializer.MIN_CHARACTER_CONTENT_CHUNK_SIZE;
 
     /**
+     * The maximum size of character content chunks
+     * of Character Information Items or Comment Information Items that
+     * will be indexed.
+     */
+    protected int maxCharacterContentChunkSize = FastInfosetSerializer.MAX_CHARACTER_CONTENT_CHUNK_SIZE;
+
+    /**
      * The limit on the size of indexed Map for character content chunks
      * Limit is measured in characters number
      */
@@ -373,30 +386,37 @@
     /**
      * {@inheritDoc}
      */
-    public void setCharacterContentChunkSizeLimit(int size) {
+    public int getMinCharacterContentChunkSize() {
+        return minCharacterContentChunkSize;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void setMinCharacterContentChunkSize(int size) {
         if (size < 0 ) {
             size = 0;
         }
 
-        characterContentChunkSizeContraint = size;
+        minCharacterContentChunkSize = size;
     }
 
     /**
      * {@inheritDoc}
      */
-    public int getCharacterContentChunkSizeLimit() {
-        return characterContentChunkSizeContraint;
+    public int getMaxCharacterContentChunkSize() {
+        return maxCharacterContentChunkSize;
     }
 
     /**
      * {@inheritDoc}
      */
-    public void setCharacterContentChunkMapMemoryLimit(int size) {
+    public void setMaxCharacterContentChunkSize(int size) {
         if (size < 0 ) {
             size = 0;
         }
 
-        characterContentChunkMapTotalCharactersConstraint = size / 2;
+        maxCharacterContentChunkSize = size;
     }
 
     /**
@@ -407,40 +427,79 @@
     }
 
     /**
-     * Checks whether character content chunk (its length) matches limits:
-     * length limit itself and limit for total capacity of specified CharArrayIntMap
+     * {@inheritDoc}
+     */
+    public void setCharacterContentChunkMapMemoryLimit(int size) {
+        if (size < 0 ) {
+            size = 0;
+        }
+
+        characterContentChunkMapTotalCharactersConstraint = size / 2;
+    }
+
+    /**
+     * Checks whether character content chunk (its length) matches length limit
      *
      * @param length the length of character content chunk is checking to be added to Map.
+     * @return whether character content chunk length matches limit
+     */
+    public boolean isCharacterContentChunkLengthMatchesLimit(int length) {
+        return length >= minCharacterContentChunkSize &&
+                length <= maxCharacterContentChunkSize;
+    }
+
+    /**
+     * Checks whether character content table has enough memory to
+     * store character content chunk with the given length
+     *
+     * @param length the length of character content chunk is checking to be added to Map.
      * @param map the custom CharArrayIntMap, which memory limits will be checked.
-     * @return whether character content chunk length matches limits
+     * @return whether character content map has enough memory
      */
-    public boolean isCharacterContentChunkLengthMatchesLimit(int length, CharArrayIntMap map) {
-        return (length < characterContentChunkSizeContraint) &&
-                (map.getTotalCharacterCount() + length <
-                        characterContentChunkMapTotalCharactersConstraint);
+    public boolean canAddCharacterContentToTable(int length, CharArrayIntMap map) {
+        return map.getTotalCharacterCount() + length <
+                        characterContentChunkMapTotalCharactersConstraint;
     }
 
     /**
      * {@inheritDoc}
      */
-    public void setAttributeValueSizeLimit(int size) {
+    public int getMinAttributeValueSize() {
+        return minAttributeValueSize;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void setMinAttributeValueSize(int size) {
         if (size < 0 ) {
             size = 0;
         }
 
-        attributeValueSizeConstraint = size;
+        minAttributeValueSize = size;
     }
 
     /**
      * {@inheritDoc}
      */
-    public int getAttributeValueSizeLimit() {
-        return attributeValueSizeConstraint;
+    public int getMaxAttributeValueSize() {
+        return maxAttributeValueSize;
     }
 
     /**
      * {@inheritDoc}
      */
+    public void setMaxAttributeValueSize(int size) {
+        if (size < 0 ) {
+            size = 0;
+        }
+
+        maxAttributeValueSize = size;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
     public void setAttributeValueMapMemoryLimit(int size) {
         if (size < 0 ) {
             size = 0;
@@ -458,18 +517,29 @@
     }
 
     /**
-     * Checks whether attribute value (its length) matches limits:
-     * length limit itself and limit for index Map total capacity
+     * Checks whether attribute value (its length) matches length limit
      *
-     * @return whether attribute value matches limits
+     * @param length the length of attribute
+     * @return whether attribute value matches limit
      */
     public boolean isAttributeValueLengthMatchesLimit(int length) {
-        return (length < attributeValueSizeConstraint) &&
-                (_v.attributeValue.getTotalCharacterCount() + length <
-                        attributeValueMapTotalCharactersConstraint);
+        return length >= minAttributeValueSize &&
+                length <= maxAttributeValueSize;
     }
 
     /**
+     * Checks whether attribute table has enough memory to
+     * store attribute value with the given length
+     *
+     * @param length the length of attribute value is checking to be added to Map.
+     * @return whether attribute map has enough memory
+     */
+    public boolean canAddAttributeToTable(int length) {
+        return _v.attributeValue.getTotalCharacterCount() + length <
+                        attributeValueMapTotalCharactersConstraint;
+    }
+
+    /**
      * {@inheritDoc}
      */
     public void setExternalVocabulary(ExternalVocabulary v) {
@@ -668,7 +738,7 @@
      * @throws ArrayIndexOutOfBoundsException.
      */
     protected final void encodeCharacters(char[] ch, int offset, int length) throws IOException {
-        final boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length, _v.characterContentChunk);
+        final boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length);
         encodeNonIdentifyingStringOnThirdBit(ch, offset, length, _v.characterContentChunk, addToTable, true);
     }
 
@@ -685,11 +755,49 @@
      * @throws ArrayIndexOutOfBoundsException.
      */
     protected final void encodeCharactersNoClone(char[] ch, int offset, int length) throws IOException {
-        final boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length, _v.characterContentChunk);
+        final boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length);
         encodeNonIdentifyingStringOnThirdBit(ch, offset, length, _v.characterContentChunk, addToTable, false);
     }
 
     /**
+     * Encode a chunk of Character Information Items using a numeric
+     * alphabet that results in the encoding of a character in 4 bits
+     * (or two characters per octet).
+     *
+     * @param id the restricted alphabet identifier.
+     * @param table the table mapping characters to 4 bit values.
+     * @param ch the array of characters.
+     * @param offset the offset into the array of characters.
+     * @param length the length of characters.
+     * @param addToTable if characters should be added to table.
+     * @throws ArrayIndexOutOfBoundsException.
+     */
+    protected final void encodeNumericFourBitCharacters(char[] ch, int offset, int length,
+            boolean addToTable) throws FastInfosetException, IOException {
+        encodeFourBitCharacters(RestrictedAlphabet.NUMERIC_CHARACTERS_INDEX,
+                NUMERIC_CHARACTERS_TABLE, ch, offset, length, addToTable);
+    }
+
+    /**
+     * Encode a chunk of Character Information Items using a date-time
+     * alphabet that results in the encoding of a character in 4 bits
+     * (or two characters per octet).
+     *
+     * @param id the restricted alphabet identifier.
+     * @param table the table mapping characters to 4 bit values.
+     * @param ch the array of characters.
+     * @param offset the offset into the array of characters.
+     * @param length the length of characters.
+     * @param addToTable if characters should be added to table.
+     * @throws ArrayIndexOutOfBoundsException.
+     */
+    protected final void encodeDateTimeFourBitCharacters(char[] ch, int offset, int length,
+            boolean addToTable) throws FastInfosetException, IOException {
+        encodeFourBitCharacters(RestrictedAlphabet.DATE_TIME_CHARACTERS_INDEX,
+                DATE_TIME_CHARACTERS_TABLE, ch, offset, length, addToTable);
+    }
+
+    /**
      * Encode a chunk of Character Information Items using a restricted
      * alphabet that results in the encoding of a character in 4 bits
      * (or two characters per octet).
@@ -705,18 +813,31 @@
     protected final void encodeFourBitCharacters(int id, int[] table, char[] ch, int offset, int length,
             boolean addToTable) throws FastInfosetException, IOException {
         if (addToTable) {
-            final int index = _v.characterContentChunk.obtainIndex(ch, offset, length, true);
+            // if char array could be added to table
+            boolean canAddCharacterContentToTable =
+                    canAddCharacterContentToTable(length, _v.characterContentChunk);
+
+            // obtain/get index
+            int index = canAddCharacterContentToTable ?
+                _v.characterContentChunk.obtainIndex(ch, offset, length, true) :
+                _v.characterContentChunk.get(ch, offset, length);
+
             if (index != KeyIntMap.NOT_PRESENT) {
+                // if char array is in table
                 _b = EncodingConstants.CHARACTER_CHUNK | 0x20;
                 encodeNonZeroIntegerOnFourthBit(index);
                 return;
+            } else if (canAddCharacterContentToTable) {
+                // if char array is not in table, but could be added
+                _b = EncodingConstants.CHARACTER_CHUNK | EncodingConstants.CHARACTER_CHUNK_RESTRICTED_ALPHABET_FLAG | EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG;
+            } else {
+                // if char array is not in table and could not be added
+                _b = EncodingConstants.CHARACTER_CHUNK | EncodingConstants.CHARACTER_CHUNK_RESTRICTED_ALPHABET_FLAG;
             }
+        } else {
+            _b = EncodingConstants.CHARACTER_CHUNK | EncodingConstants.CHARACTER_CHUNK_RESTRICTED_ALPHABET_FLAG;
         }
 
-        // This procedure assumes that id <= 64
-        _b = (addToTable) ?
-            EncodingConstants.CHARACTER_CHUNK | EncodingConstants.CHARACTER_CHUNK_RESTRICTED_ALPHABET_FLAG | EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG :
-            EncodingConstants.CHARACTER_CHUNK | EncodingConstants.CHARACTER_CHUNK_RESTRICTED_ALPHABET_FLAG;
         write (_b);
 
         // Encode bottom 6 bits of enoding algorithm id
@@ -742,12 +863,29 @@
     protected final void encodeAlphabetCharacters(String alphabet, char[] ch, int offset, int length,
             boolean addToTable) throws FastInfosetException, IOException {
         if (addToTable) {
-            final int index = _v.characterContentChunk.obtainIndex(ch, offset, length, true);
+            // if char array could be added to table
+            boolean canAddCharacterContentToTable =
+                    canAddCharacterContentToTable(length, _v.characterContentChunk);
+
+            // obtain/get index
+            int index = canAddCharacterContentToTable ?
+                _v.characterContentChunk.obtainIndex(ch, offset, length, true) :
+                _v.characterContentChunk.get(ch, offset, length);
+
             if (index != KeyIntMap.NOT_PRESENT) {
+                // if char array is in table
                 _b = EncodingConstants.CHARACTER_CHUNK | 0x20;
                 encodeNonZeroIntegerOnFourthBit(index);
                 return;
+            } else if (canAddCharacterContentToTable) {
+                // if char array is not in table, but could be added
+                _b = EncodingConstants.CHARACTER_CHUNK | EncodingConstants.CHARACTER_CHUNK_RESTRICTED_ALPHABET_FLAG | EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG;
+            } else {
+                // if char array is not in table and could not be added
+                _b = EncodingConstants.CHARACTER_CHUNK | EncodingConstants.CHARACTER_CHUNK_RESTRICTED_ALPHABET_FLAG;
             }
+        } else {
+            _b = EncodingConstants.CHARACTER_CHUNK | EncodingConstants.CHARACTER_CHUNK_RESTRICTED_ALPHABET_FLAG;
         }
 
         int id = _v.restrictedAlphabet.get(alphabet);
@@ -756,9 +894,6 @@
         }
         id += EncodingConstants.RESTRICTED_ALPHABET_APPLICATION_START;
 
-        _b = (addToTable) ?
-            EncodingConstants.CHARACTER_CHUNK | EncodingConstants.CHARACTER_CHUNK_RESTRICTED_ALPHABET_FLAG | EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG :
-            EncodingConstants.CHARACTER_CHUNK | EncodingConstants.CHARACTER_CHUNK_RESTRICTED_ALPHABET_FLAG;
         _b |= (id & 0xC0) >> 6;
         write(_b);
 
@@ -781,7 +916,7 @@
         encodeIdentifyingNonEmptyStringOnFirstBit(target, _v.otherNCName);
 
         // Data
-        boolean addToTable = isCharacterContentChunkLengthMatchesLimit(data.length(), _v.characterContentChunk);
+        boolean addToTable = isCharacterContentChunkLengthMatchesLimit(data.length());
         encodeNonIdentifyingStringOnFirstBit(data, _v.otherString, addToTable);
     }
 
@@ -820,7 +955,7 @@
     protected final void encodeComment(char[] ch, int offset, int length) throws IOException {
         write(EncodingConstants.COMMENT);
 
-        boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length, _v.otherString);
+        boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length);
         encodeNonIdentifyingStringOnFirstBit(ch, offset, length, _v.otherString, addToTable, true);
     }
 
@@ -839,7 +974,7 @@
     protected final void encodeCommentNoClone(char[] ch, int offset, int length) throws IOException {
         write(EncodingConstants.COMMENT);
 
-        boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length, _v.otherString);
+        boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length);
         encodeNonIdentifyingStringOnFirstBit(ch, offset, length, _v.otherString, addToTable, false);
     }
 
@@ -1033,21 +1168,39 @@
      *
      * @param s the string to encode
      * @param map the vocabulary table of strings to indexes.
-     * @param addToTable true if the string should be added to the vocabulary
+     * @param addToTable true if the string could be added to the vocabulary
+     *                   table (if table has enough memory)
+     * @param mustBeAddedToTable true if the string must be added to the vocabulary
      *                   table (if not already present in the table).
      */
-    protected final void encodeNonIdentifyingStringOnFirstBit(String s, StringIntMap map, boolean addToTable) throws IOException {
+    protected final void encodeNonIdentifyingStringOnFirstBit(String s, StringIntMap map,
+            boolean addToTable, boolean mustBeAddedToTable) throws IOException {
         if (s == null || s.length() == 0) {
             // C.26 an index (first bit '1') with seven '1' bits for an empty string
             write(0xFF);
         } else {
-            if (addToTable) {
-                int index = map.obtainIndex(s);
-                if (index == KeyIntMap.NOT_PRESENT) {
-                    _b = EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG | _nonIdentifyingStringOnFirstBitCES;
+            if (addToTable || mustBeAddedToTable) {
+                // if attribute value could be added to table
+                boolean canAddAttributeToTable = mustBeAddedToTable ||
+                        canAddAttributeToTable(s.length());
+
+                // obtain/get index
+                int index = canAddAttributeToTable ?
+                    map.obtainIndex(s) :
+                    map.get(s);
+
+                if (index != KeyIntMap.NOT_PRESENT) {
+                    // if attribute value is in table
+                    encodeNonZeroIntegerOnSecondBitFirstBitOne(index);
+                } else if (canAddAttributeToTable) {
+                    // if attribute value is not in table, but could be added
+                    _b = EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG |
+                            _nonIdentifyingStringOnFirstBitCES;
                     encodeNonEmptyCharacterStringOnFifthBit(s);
                 } else {
-                    encodeNonZeroIntegerOnSecondBitFirstBitOne(index);
+                    // if attribute value is not in table and could not be added
+                    _b = _nonIdentifyingStringOnFirstBitCES;
+                    encodeNonEmptyCharacterStringOnFifthBit(s);
                 }
             } else {
                 _b = _nonIdentifyingStringOnFirstBitCES;
@@ -1073,12 +1226,28 @@
             if (addToTable) {
                 final char[] ch = s.toCharArray();
                 final int length = s.length();
-                int index = map.obtainIndex(ch, 0, length, false);
-                if (index == KeyIntMap.NOT_PRESENT) {
-                    _b = EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG | _nonIdentifyingStringOnFirstBitCES;
+
+                // if char array could be added to table
+                boolean canAddCharacterContentToTable =
+                        canAddCharacterContentToTable(length, map);
+
+                // obtain/get index
+                int index = canAddCharacterContentToTable ?
+                    map.obtainIndex(ch, 0, length, false) :
+                    map.get(ch, 0, length);
+
+                if (index != KeyIntMap.NOT_PRESENT) {
+                    // if char array is in table
+                    encodeNonZeroIntegerOnSecondBitFirstBitOne(index);
+                } else if (canAddCharacterContentToTable) {
+                    // if char array is not in table, but could be added
+                    _b = EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG |
+                            _nonIdentifyingStringOnFirstBitCES;
                     encodeNonEmptyCharacterStringOnFifthBit(ch, 0, length);
                 } else {
-                    encodeNonZeroIntegerOnSecondBitFirstBitOne(index);
+                    // if char array is not in table and could not be added
+                    _b = _nonIdentifyingStringOnFirstBitCES;
+                    encodeNonEmptyCharacterStringOnFifthBit(s);
                 }
             } else {
                 _b = _nonIdentifyingStringOnFirstBitCES;
@@ -1107,12 +1276,27 @@
             write(0xFF);
         } else {
             if (addToTable) {
-                int index = map.obtainIndex(ch, offset, length, clone);
-                if (index == KeyIntMap.NOT_PRESENT) {
-                    _b = EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG | _nonIdentifyingStringOnFirstBitCES;
+                // if char array could be added to table
+                boolean canAddCharacterContentToTable =
+                        canAddCharacterContentToTable(length, map);
+
+                // obtain/get index
+                int index = canAddCharacterContentToTable ?
+                    map.obtainIndex(ch, offset, length, clone) :
+                    map.get(ch, offset, length);
+
+                if (index != KeyIntMap.NOT_PRESENT) {
+                    // if char array is in table
+                    encodeNonZeroIntegerOnSecondBitFirstBitOne(index);
+                } else if (canAddCharacterContentToTable) {
+                    // if char array is not in table, but could be added
+                    _b = EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG |
+                            _nonIdentifyingStringOnFirstBitCES;
                     encodeNonEmptyCharacterStringOnFifthBit(ch, offset, length);
                 } else {
-                    encodeNonZeroIntegerOnSecondBitFirstBitOne(index);
+                    // if char array is not in table and could not be added
+                    _b = _nonIdentifyingStringOnFirstBitCES;
+                    encodeNonEmptyCharacterStringOnFifthBit(ch, offset, length);
                 }
             } else {
                 _b = _nonIdentifyingStringOnFirstBitCES;
@@ -1121,23 +1305,59 @@
         }
     }
 
-    protected final void encodeNonIdentifyingStringOnFirstBit(int id, int[] table, String s, boolean addToTable)
+    protected final void encodeNumericNonIdentifyingStringOnFirstBit(
+            String s, boolean addToTable, boolean mustBeAddedToTable)
             throws IOException, FastInfosetException {
+        encodeNonIdentifyingStringOnFirstBit(
+                                    RestrictedAlphabet.NUMERIC_CHARACTERS_INDEX,
+                                    NUMERIC_CHARACTERS_TABLE, s, addToTable,
+                                    mustBeAddedToTable);
+    }
+
+    protected final void encodeDateTimeNonIdentifyingStringOnFirstBit(
+            String s, boolean addToTable, boolean mustBeAddedToTable)
+            throws IOException, FastInfosetException {
+        encodeNonIdentifyingStringOnFirstBit(
+                                    RestrictedAlphabet.DATE_TIME_CHARACTERS_INDEX,
+                                    DATE_TIME_CHARACTERS_TABLE, s, addToTable,
+                                    mustBeAddedToTable);
+    }
+
+    protected final void encodeNonIdentifyingStringOnFirstBit(int id, int[] table,
+            String s, boolean addToTable, boolean mustBeAddedToTable)
+            throws IOException, FastInfosetException {
         if (s == null || s.length() == 0) {
             // C.26 an index (first bit '1') with seven '1' bits for an empty string
             write(0xFF);
             return;
-        } else if (addToTable) {
-            final int index = _v.attributeValue.obtainIndex(s);
+        }
+
+        if (addToTable || mustBeAddedToTable) {
+            // if attribute value could be added to table
+            boolean canAddAttributeToTable = mustBeAddedToTable ||
+                    canAddAttributeToTable(s.length());
+
+            // obtain/get index
+            int index = canAddAttributeToTable ?
+                _v.attributeValue.obtainIndex(s) :
+                _v.attributeValue.get(s);
+
             if (index != KeyIntMap.NOT_PRESENT) {
+                // if attribute value is in table
                 encodeNonZeroIntegerOnSecondBitFirstBitOne(index);
                 return;
+            } else if (canAddAttributeToTable) {
+                // if attribute value is not in table, but could be added
+                _b = EncodingConstants.NISTRING_RESTRICTED_ALPHABET_FLAG |
+                        EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG;
+            } else {
+                // if attribute value is not in table and could not be added
+                _b = EncodingConstants.NISTRING_RESTRICTED_ALPHABET_FLAG;
             }
+        } else {
+            _b = EncodingConstants.NISTRING_RESTRICTED_ALPHABET_FLAG;
         }
 
-        _b = (addToTable)
-                ? EncodingConstants.NISTRING_RESTRICTED_ALPHABET_FLAG | EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG
-                : EncodingConstants.NISTRING_RESTRICTED_ALPHABET_FLAG;
         // Encode identification and top four bits of alphabet id
         write (_b | ((id & 0xF0) >> 4));
         // Encode bottom 4 bits of alphabet id
@@ -1294,13 +1514,13 @@
         // Encode bottom 4 bits of enoding algorithm id
         _b = (id & 0x0F) << 4;
 
-        final int octetLength = BuiltInEncodingAlgorithmFactory.table[id].
+        final int octetLength = BuiltInEncodingAlgorithmFactory.getAlgorithm(id).
                     getOctetLengthFromPrimitiveLength(length);
 
         encodeNonZeroOctetStringLengthOnFifthBit(octetLength);
 
         ensureSize(octetLength);
-        BuiltInEncodingAlgorithmFactory.table[id].
+        BuiltInEncodingAlgorithmFactory.getAlgorithm(id).
                 encodeToBytes(data, offset, length, _octetBuffer, _octetBufferIndex);
         _octetBufferIndex += octetLength;
     }
@@ -1323,16 +1543,31 @@
         // length cannot be zero since sequence of CIIs has to be > 0
 
         if (addToTable) {
-            int index = map.obtainIndex(ch, offset, length, clone);
-            if (index == KeyIntMap.NOT_PRESENT) {
+            // if char array could be added to table
+            boolean canAddCharacterContentToTable =
+                    canAddCharacterContentToTable(length, map);
+
+            // obtain/get index
+            int index = canAddCharacterContentToTable ?
+                map.obtainIndex(ch, offset, length, clone) :
+                map.get(ch, offset, length);
+
+            if (index != KeyIntMap.NOT_PRESENT) {
+                // if char array is in table
+                _b = EncodingConstants.CHARACTER_CHUNK | 0x20;
+                encodeNonZeroIntegerOnFourthBit(index);
+            } else if (canAddCharacterContentToTable) {
+                // if char array is not in table, but could be added
                 _b = EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG |
                         _nonIdentifyingStringOnThirdBitCES;
                 encodeNonEmptyCharacterStringOnSeventhBit(ch, offset, length);
             } else {
-                _b = EncodingConstants.CHARACTER_CHUNK | 0x20;
-                encodeNonZeroIntegerOnFourthBit(index);
+                // if char array is not in table and could not be added
+                    _b = _nonIdentifyingStringOnThirdBitCES;
+                    encodeNonEmptyCharacterStringOnSeventhBit(ch, offset, length);
             }
         } else {
+            // char array will not be added to map
             _b = _nonIdentifyingStringOnThirdBitCES;
             encodeNonEmptyCharacterStringOnSeventhBit(ch, offset, length);
         }
@@ -1508,13 +1743,13 @@
         // Encode bottom 6 bits of enoding algorithm id
         _b = (id & 0x3F) << 2;
 
-        final int octetLength = BuiltInEncodingAlgorithmFactory.table[id].
+        final int octetLength = BuiltInEncodingAlgorithmFactory.getAlgorithm(id).
                     getOctetLengthFromPrimitiveLength(length);
 
         encodeNonZeroOctetStringLengthOnSenventhBit(octetLength);
 
         ensureSize(octetLength);
-        BuiltInEncodingAlgorithmFactory.table[id].
+        BuiltInEncodingAlgorithmFactory.getAlgorithm(id).
                 encodeToBytes(data, offset, length, _octetBuffer, _octetBufferIndex);
         _octetBufferIndex += octetLength;
     }
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/algorithm/BuiltInEncodingAlgorithmFactory.java	Tue Aug  4 09:53:02 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/algorithm/BuiltInEncodingAlgorithmFactory.java	Tue Aug  4 09:53:02 2009
@@ -33,7 +33,7 @@
 
 public final class BuiltInEncodingAlgorithmFactory {
 
-    public final static BuiltInEncodingAlgorithm[] table =
+    private final static BuiltInEncodingAlgorithm[] table =
             new BuiltInEncodingAlgorithm[EncodingConstants.ENCODING_ALGORITHM_BUILTIN_END + 1];
 
     public final static HexadecimalEncodingAlgorithm hexadecimalEncodingAlgorithm = new HexadecimalEncodingAlgorithm();
@@ -65,4 +65,8 @@
         table[EncodingAlgorithmIndexes.DOUBLE] = doubleEncodingAlgorithm;
         table[EncodingAlgorithmIndexes.UUID] = uuidEncodingAlgorithm;
     }
+
+    public static BuiltInEncodingAlgorithm getAlgorithm(int index) {
+        return table[index];
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/algorithm/HexadecimalEncodingAlgorithm.java	Tue Aug  4 09:53:05 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/algorithm/HexadecimalEncodingAlgorithm.java	Tue Aug  4 09:53:04 2009
@@ -37,7 +37,7 @@
 public class HexadecimalEncodingAlgorithm extends BuiltInEncodingAlgorithm {
     private static final char NIBBLE_TO_HEXADECIMAL_TABLE[] =
         {   '0','1','2','3','4','5','6','7',
-            '8','9','A','B','B','D','E','F' };
+            '8','9','A','B','C','D','E','F' };
 
     private static final int HEXADECIMAL_TO_NIBBLE_TABLE[] = {
         /*'0'*/ 0,
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/algorithm/LongEncodingAlgorithm.java	Tue Aug  4 09:53:07 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/algorithm/LongEncodingAlgorithm.java	Tue Aug  4 09:53:06 2009
@@ -140,14 +140,15 @@
             }
 
             final long l =
-                    ((long)(b[0] & 0xFF) << 56) |
-                    ((long)(b[1] & 0xFF) << 48) |
-                    ((long)(b[2] & 0xFF) << 40) |
-                    ((long)(b[3] & 0xFF) << 32) |
-                    ((b[4] & 0xFF) << 24) |
-                    ((b[5] & 0xFF) << 16) |
-                    ((b[6] & 0xFF) << 8) |
-                    (b[7] & 0xFF);
+                    (((long) b[0] << 56) +
+                    ((long) (b[1] & 0xFF) << 48) +
+                    ((long) (b[2] & 0xFF) << 40) +
+                    ((long) (b[3] & 0xFF) << 32) +
+                    ((long) (b[4] & 0xFF) << 24) +
+                    ((b[5] & 0xFF) << 16) +
+                    ((b[6] & 0xFF) << 8) +
+                    ((b[7] & 0xFF) << 0));
+
             longList.add(Long.valueOf(l));
         }
 
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/algorithm/UUIDEncodingAlgorithm.java	Tue Aug  4 09:53:09 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/algorithm/UUIDEncodingAlgorithm.java	Tue Aug  4 09:53:09 2009
@@ -69,7 +69,7 @@
 
         final long[] ldata = (long[])data;
 
-        final int end = ldata.length - 1;
+        final int end = ldata.length - 2;
         for (int i = 0; i <= end; i += 2) {
             s.append(toUUIDString(ldata[i], ldata[i + 1]));
             if (i != end) {
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/dom/DOMDocumentParser.java	Tue Aug  4 09:53:12 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/dom/DOMDocumentParser.java	Tue Aug  4 09:53:11 2009
@@ -45,6 +45,8 @@
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 import com.sun.xml.internal.fastinfoset.CommonResourceBundle;
+import com.sun.xml.internal.fastinfoset.util.DuplicateAttributeVerifier;
+import org.w3c.dom.Text;
 
 /**
  * The Fast Infoset DOM parser.
@@ -127,7 +129,7 @@
         boolean documentTypeDeclarationOccured = false;
         while(!_terminate || !firstElementHasOccured) {
             _b = read();
-            switch(DecoderStateTables.DII[_b]) {
+            switch(DecoderStateTables.DII(_b)) {
                 case DecoderStateTables.EII_NO_AIIS_INDEX_SMALL:
                     processEII(_elementNameTable._array[_b], false);
                     firstElementHasOccured = true;
@@ -147,8 +149,8 @@
                 case DecoderStateTables.EII_LITERAL:
                 {
                     final QualifiedName qn = processLiteralQualifiedName(
-                                _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
-                                _elementNameTable.getNext());
+                            _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
+                            _elementNameTable.getNext());
                     _elementNameTable.add(qn);
                     processEII(qn, (_b & EncodingConstants.ELEMENT_ATTRIBUTE_FLAG) > 0);
                     firstElementHasOccured = true;
@@ -166,9 +168,9 @@
                     documentTypeDeclarationOccured = true;
 
                     String system_identifier = ((_b & EncodingConstants.DOCUMENT_TYPE_SYSTEM_IDENTIFIER_FLAG) > 0)
-                        ? decodeIdentifyingNonEmptyStringOnFirstBit(_v.otherURI) : null;
+                    ? decodeIdentifyingNonEmptyStringOnFirstBit(_v.otherURI) : null;
                     String public_identifier = ((_b & EncodingConstants.DOCUMENT_TYPE_PUBLIC_IDENTIFIER_FLAG) > 0)
-                        ? decodeIdentifyingNonEmptyStringOnFirstBit(_v.otherURI) : null;
+                    ? decodeIdentifyingNonEmptyStringOnFirstBit(_v.otherURI) : null;
 
                     _b = read();
                     while (_b == EncodingConstants.PROCESSING_INSTRUCTION) {
@@ -221,7 +223,7 @@
         // Decode any remaining Comment IIs, PI IIs
         while(!_terminate) {
             _b = read();
-            switch(DecoderStateTables.DII[_b]) {
+            switch(DecoderStateTables.DII(_b)) {
                 case DecoderStateTables.COMMENT_II:
                     processCommentII();
                     break;
@@ -319,7 +321,7 @@
 
         while(!_terminate) {
             _b = read();
-            switch(DecoderStateTables.EII[_b]) {
+            switch(DecoderStateTables.EII(_b)) {
                 case DecoderStateTables.EII_NO_AIIS_INDEX_SMALL:
                     processEII(_elementNameTable._array[_b], false);
                     break;
@@ -335,8 +337,8 @@
                 case DecoderStateTables.EII_LITERAL:
                 {
                     final QualifiedName qn = processLiteralQualifiedName(
-                                _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
-                                _elementNameTable.getNext());
+                            _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
+                            _elementNameTable.getNext());
                     _elementNameTable.add(qn);
                     processEII(qn, (_b & EncodingConstants.ELEMENT_ATTRIBUTE_FLAG) > 0);
                     break;
@@ -347,36 +349,36 @@
                 case DecoderStateTables.CII_UTF8_SMALL_LENGTH:
                 {
                     _octetBufferLength = (_b & EncodingConstants.OCTET_STRING_LENGTH_7TH_BIT_SMALL_MASK)
-                        + 1;
-                    processUtf8CharacterString();
+                    + 1;
+                    appendOrCreateTextData(processUtf8CharacterString());
                     break;
                 }
                 case DecoderStateTables.CII_UTF8_MEDIUM_LENGTH:
                 {
                     _octetBufferLength = read() + EncodingConstants.OCTET_STRING_LENGTH_7TH_BIT_SMALL_LIMIT;
-                    processUtf8CharacterString();
+                    appendOrCreateTextData(processUtf8CharacterString());
                     break;
                 }
-                case DecoderStateTables.CII_UTF8_LARGE_LENGTH:
+                    case DecoderStateTables.CII_UTF8_LARGE_LENGTH:
                 {
                     _octetBufferLength = (read() << 24) |
-                        (read() << 16) |
-                        (read() << 8) |
-                        read();
+                            (read() << 16) |
+                            (read() << 8) |
+                            read();
                     _octetBufferLength += EncodingConstants.OCTET_STRING_LENGTH_7TH_BIT_MEDIUM_LIMIT;
-                    processUtf8CharacterString();
+                    appendOrCreateTextData(processUtf8CharacterString());
                     break;
                 }
                 case DecoderStateTables.CII_UTF16_SMALL_LENGTH:
                 {
                     _octetBufferLength = (_b & EncodingConstants.OCTET_STRING_LENGTH_7TH_BIT_SMALL_MASK)
-                        + 1;
+                    + 1;
                     String v = decodeUtf16StringAsString();
                     if ((_b & EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG) > 0) {
                         _characterContentChunkTable.add(_charBuffer, _charBufferLength);
                     }
 
-                    _currentNode.appendChild(_document.createTextNode(v));
+                    appendOrCreateTextData(v);
                     break;
                 }
                 case DecoderStateTables.CII_UTF16_MEDIUM_LENGTH:
@@ -387,15 +389,15 @@
                         _characterContentChunkTable.add(_charBuffer, _charBufferLength);
                     }
 
-                    _currentNode.appendChild(_document.createTextNode(v));
+                    appendOrCreateTextData(v);
                     break;
                 }
                 case DecoderStateTables.CII_UTF16_LARGE_LENGTH:
                 {
                     _octetBufferLength = (read() << 24) |
-                        (read() << 16) |
-                        (read() << 8) |
-                        read();
+                            (read() << 16) |
+                            (read() << 8) |
+                            read();
                     _octetBufferLength += EncodingConstants.OCTET_STRING_LENGTH_7TH_BIT_MEDIUM_LIMIT;
                     String v = decodeUtf16StringAsString();
                     if ((_b & EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG) > 0) {
@@ -402,7 +404,7 @@
                         _characterContentChunkTable.add(_charBuffer, _charBufferLength);
                     }
 
-                    _currentNode.appendChild(_document.createTextNode(v));
+                    appendOrCreateTextData(v);
                     break;
                 }
                 case DecoderStateTables.CII_RA:
@@ -421,15 +423,12 @@
                         _characterContentChunkTable.add(_charBuffer, _charBufferLength);
                     }
 
-                    _currentNode.appendChild(_document.createTextNode(v));
+                    appendOrCreateTextData(v);
                     break;
                 }
                 case DecoderStateTables.CII_EA:
                 {
-                    if ((_b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0) {
-                        throw new EncodingAlgorithmException(CommonResourceBundle.getInstance().getString("message.addToTableNotSupported"));
-                    }
-
+                    final boolean addToTable = (_b & EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG) > 0;
                     // Decode encoding algorithm integer
                     _identifier = (_b & 0x02) << 6;
                     _b = read();
@@ -437,7 +436,10 @@
 
                     decodeOctetsOnSeventhBitOfNonIdentifyingStringOnThirdBit(_b);
                     final String s = convertEncodingAlgorithmDataToCharacters(false);
-                    _currentNode.appendChild(_document.createTextNode(s));
+                    if (addToTable) {
+                        _characterContentChunkTable.add(s.toCharArray(), s.length());
+                    }
+                    appendOrCreateTextData(s);
                     break;
                 }
                 case DecoderStateTables.CII_INDEX_SMALL:
@@ -444,38 +446,38 @@
                 {
                     final String s = _characterContentChunkTable.getString(_b & EncodingConstants.INTEGER_4TH_BIT_SMALL_MASK);
 
-                    _currentNode.appendChild(_document.createTextNode(s));
+                    appendOrCreateTextData(s);
                     break;
                 }
                 case DecoderStateTables.CII_INDEX_MEDIUM:
                 {
                     final int index = (((_b & EncodingConstants.INTEGER_4TH_BIT_MEDIUM_MASK) << 8) | read())
-                        + EncodingConstants.INTEGER_4TH_BIT_SMALL_LIMIT;
+                    + EncodingConstants.INTEGER_4TH_BIT_SMALL_LIMIT;
                     final String s = _characterContentChunkTable.getString(index);
 
-                    _currentNode.appendChild(_document.createTextNode(s));
+                    appendOrCreateTextData(s);
                     break;
                 }
                 case DecoderStateTables.CII_INDEX_LARGE:
                 {
                     int index = ((_b & EncodingConstants.INTEGER_4TH_BIT_LARGE_MASK) << 16) |
-                        (read() << 8) |
-                        read();
+                            (read() << 8) |
+                            read();
                     index += EncodingConstants.INTEGER_4TH_BIT_MEDIUM_LIMIT;
                     final String s = _characterContentChunkTable.getString(index);
 
-                    _currentNode.appendChild(_document.createTextNode(s));
+                    appendOrCreateTextData(s);
                     break;
                 }
                 case DecoderStateTables.CII_INDEX_LARGE_LARGE:
                 {
                     int index = (read() << 16) |
-                        (read() << 8) |
-                        read();
+                            (read() << 8) |
+                            read();
                     index += EncodingConstants.INTEGER_4TH_BIT_LARGE_LIMIT;
                     final String s = _characterContentChunkTable.getString(index);
 
-                    _currentNode.appendChild(_document.createTextNode(s));
+                    appendOrCreateTextData(s);
                     break;
                 }
                 case DecoderStateTables.COMMENT_II:
@@ -489,9 +491,9 @@
                     String entity_reference_name = decodeIdentifyingNonEmptyStringOnFirstBit(_v.otherNCName);
 
                     String system_identifier = ((_b & EncodingConstants.UNEXPANDED_ENTITY_SYSTEM_IDENTIFIER_FLAG) > 0)
-                        ? decodeIdentifyingNonEmptyStringOnFirstBit(_v.otherURI) : null;
+                    ? decodeIdentifyingNonEmptyStringOnFirstBit(_v.otherURI) : null;
                     String public_identifier = ((_b & EncodingConstants.UNEXPANDED_ENTITY_PUBLIC_IDENTIFIER_FLAG) > 0)
-                        ? decodeIdentifyingNonEmptyStringOnFirstBit(_v.otherURI) : null;
+                    ? decodeIdentifyingNonEmptyStringOnFirstBit(_v.otherURI) : null;
 
                     // TODO create Node
                     break;
@@ -512,18 +514,26 @@
         _currentNode = parentCurrentNode;
     }
 
-    private final void processUtf8CharacterString() throws FastInfosetException, IOException {
+    private void appendOrCreateTextData(String textData) {
+        Node lastChild = _currentNode.getLastChild();
+        if (lastChild instanceof Text) {
+            ((Text) lastChild).appendData(textData);
+        } else {
+            _currentNode.appendChild(
+                    _document.createTextNode(textData));
+        }
+    }
+
+    private final String processUtf8CharacterString() throws FastInfosetException, IOException {
         if ((_b & EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG) > 0) {
             _characterContentChunkTable.ensureSize(_octetBufferLength);
             final int charactersOffset = _characterContentChunkTable._arrayIndex;
             decodeUtf8StringAsCharBuffer(_characterContentChunkTable._array, charactersOffset);
             _characterContentChunkTable.add(_charBufferLength);
-            _currentNode.appendChild(_document.createTextNode(
-                    _characterContentChunkTable.getString(_characterContentChunkTable._cachedIndex)));
+            return _characterContentChunkTable.getString(_characterContentChunkTable._cachedIndex);
         } else {
             decodeUtf8StringAsCharBuffer();
-            _currentNode.appendChild(_document.createTextNode(
-                    new String(_charBuffer, 0, _charBufferLength)));
+            return new String(_charBuffer, 0, _charBufferLength);
         }
     }
 
@@ -560,43 +570,43 @@
                             EncodingConstants.XMLNS_NAMESPACE_NAME,
                             EncodingConstants.XMLNS_NAMESPACE_PREFIX,
                             EncodingConstants.XMLNS_NAMESPACE_PREFIX);
-                    a.setValue ("");
+                    a.setValue("");
 
                     _prefixIndex = _namespaceNameIndex = _namespacePrefixes[_namespacePrefixesIndex++] = -1;
                     break;
-                // no prefix, namespace
-                // Declaration of default namespace
+                    // no prefix, namespace
+                    // Declaration of default namespace
                 case 1:
                     a = createAttribute(
                             EncodingConstants.XMLNS_NAMESPACE_NAME,
                             EncodingConstants.XMLNS_NAMESPACE_PREFIX,
                             EncodingConstants.XMLNS_NAMESPACE_PREFIX);
-                    a.setValue (decodeIdentifyingNonEmptyStringOnFirstBitAsNamespaceName(false));
+                    a.setValue(decodeIdentifyingNonEmptyStringOnFirstBitAsNamespaceName(false));
 
                     _prefixIndex = _namespacePrefixes[_namespacePrefixesIndex++] = -1;
                     break;
-                // prefix, no namespace
-                // Undeclaration of namespace
+                    // prefix, no namespace
+                    // Undeclaration of namespace
                 case 2:
                     prefix = decodeIdentifyingNonEmptyStringOnFirstBitAsPrefix(false);
                     a = createAttribute(
                             EncodingConstants.XMLNS_NAMESPACE_NAME,
-                            createQualifiedNameString(XMLNS_NAMESPACE_PREFIX_CHARS, prefix),
+                            createQualifiedNameString(prefix),
                             prefix);
-                    a.setValue ("");
+                    a.setValue("");
 
                     _namespaceNameIndex = -1;
                     _namespacePrefixes[_namespacePrefixesIndex++] = _prefixIndex;
                     break;
-                // prefix, namespace
-                // Declaration of prefixed namespace
+                    // prefix, namespace
+                    // Declaration of prefixed namespace
                 case 3:
                     prefix = decodeIdentifyingNonEmptyStringOnFirstBitAsPrefix(true);
                     a = createAttribute(
                             EncodingConstants.XMLNS_NAMESPACE_NAME,
-                            createQualifiedNameString(XMLNS_NAMESPACE_PREFIX_CHARS, prefix),
+                            createQualifiedNameString(prefix),
                             prefix);
-                    a.setValue (decodeIdentifyingNonEmptyStringOnFirstBitAsNamespaceName(true));
+                    a.setValue(decodeIdentifyingNonEmptyStringOnFirstBitAsNamespaceName(true));
 
                     _namespacePrefixes[_namespacePrefixesIndex++] = _prefixIndex;
                     break;
@@ -614,7 +624,7 @@
         final int end = _namespacePrefixesIndex;
 
         _b = read();
-        switch(DecoderStateTables.EII[_b]) {
+        switch(DecoderStateTables.EII(_b)) {
             case DecoderStateTables.EII_NO_AIIS_INDEX_SMALL:
                 processEII(_elementNameTable._array[_b], hasAttributes);
                 break;
@@ -627,8 +637,8 @@
             case DecoderStateTables.EII_LITERAL:
             {
                 final QualifiedName qn = processLiteralQualifiedName(
-                            _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
-                            _elementNameTable.getNext());
+                        _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
+                        _elementNameTable.getNext());
                 _elementNameTable.add(qn);
                 processEII(qn, hasAttributes);
                 break;
@@ -659,7 +669,7 @@
                         -1,
                         _identifier,
                         null);
-            // no prefix, namespace
+                // no prefix, namespace
             case 1:
                 return q.set(
                         null,
@@ -669,10 +679,10 @@
                         _namespaceNameIndex,
                         _identifier,
                         null);
-            // prefix, no namespace
+                // prefix, no namespace
             case 2:
                 throw new FastInfosetException(CommonResourceBundle.getInstance().getString("message.qNameMissingNamespaceName"));
-            // prefix, namespace
+                // prefix, namespace
             case 3:
                 return q.set(
                         decodeIdentifyingNonEmptyStringIndexOnFirstBitAsPrefix(true),
@@ -700,7 +710,7 @@
                         -1,
                         _identifier,
                         null);
-            // no prefix, namespace
+                // no prefix, namespace
             case 1:
                 return new QualifiedName(
                         null,
@@ -710,10 +720,10 @@
                         _namespaceNameIndex,
                         _identifier,
                         null);
-            // prefix, no namespace
+                // prefix, no namespace
             case 2:
                 throw new FastInfosetException(CommonResourceBundle.getInstance().getString("message.qNameMissingNamespaceName"));
-            // prefix, namespace
+                // prefix, namespace
             case 3:
                 return new QualifiedName(
                         decodeIdentifyingNonEmptyStringIndexOnFirstBitAsPrefix(true),
@@ -740,7 +750,7 @@
         do {
             // AII qualified name
             b = read();
-            switch (DecoderStateTables.AII[b]) {
+            switch (DecoderStateTables.AII(b)) {
                 case DecoderStateTables.AII_INDEX_SMALL:
                     name = _attributeNameTable._array[b];
                     break;
@@ -747,7 +757,7 @@
                 case DecoderStateTables.AII_INDEX_MEDIUM:
                 {
                     final int i = (((b & EncodingConstants.INTEGER_2ND_BIT_MEDIUM_MASK) << 8) | read())
-                        + EncodingConstants.INTEGER_2ND_BIT_SMALL_LIMIT;
+                    + EncodingConstants.INTEGER_2ND_BIT_SMALL_LIMIT;
                     name = _attributeNameTable._array[i];
                     break;
                 }
@@ -754,7 +764,7 @@
                 case DecoderStateTables.AII_INDEX_LARGE:
                 {
                     final int i = (((b & EncodingConstants.INTEGER_2ND_BIT_LARGE_MASK) << 16) | (read() << 8) | read())
-                        + EncodingConstants.INTEGER_2ND_BIT_MEDIUM_LIMIT;
+                    + EncodingConstants.INTEGER_2ND_BIT_MEDIUM_LIMIT;
                     name = _attributeNameTable._array[i];
                     break;
                 }
@@ -762,7 +772,7 @@
                     name = processLiteralQualifiedName(
                             b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
                             _attributeNameTable.getNext());
-                    name.createAttributeValues(_duplicateAttributeVerifier.MAP_SIZE);
+                    name.createAttributeValues(DuplicateAttributeVerifier.MAP_SIZE);
                     _attributeNameTable.add(name);
                     break;
                 case DecoderStateTables.AII_TERMINATOR_DOUBLE:
@@ -782,14 +792,14 @@
             _duplicateAttributeVerifier.checkForDuplicateAttribute(name.attributeHash, name.attributeId);
 
             Attr a = createAttribute(
-                        name.namespaceName,
-                        name.qName,
-                        name.localName);
+                    name.namespaceName,
+                    name.qName,
+                    name.localName);
 
             // [normalized value] of AII
 
             b = read();
-            switch(DecoderStateTables.NISTRING[b]) {
+            switch(DecoderStateTables.NISTRING(b)) {
                 case DecoderStateTables.NISTRING_UTF8_SMALL_LENGTH:
                 {
                     final boolean addToTable = (b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0;
@@ -820,9 +830,9 @@
                 {
                     final boolean addToTable = (b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0;
                     final int length = (read() << 24) |
-                        (read() << 16) |
-                        (read() << 8) |
-                        read();
+                            (read() << 16) |
+                            (read() << 8) |
+                            read();
                     _octetBufferLength = length + EncodingConstants.OCTET_STRING_LENGTH_5TH_BIT_MEDIUM_LIMIT;
                     value = decodeUtf8StringAsString();
                     if (addToTable) {
@@ -863,9 +873,9 @@
                 {
                     final boolean addToTable = (b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0;
                     final int length = (read() << 24) |
-                        (read() << 16) |
-                        (read() << 8) |
-                        read();
+                            (read() << 16) |
+                            (read() << 8) |
+                            read();
                     _octetBufferLength = length + EncodingConstants.OCTET_STRING_LENGTH_5TH_BIT_MEDIUM_LIMIT;
                     value = decodeUtf16StringAsString();
                     if (addToTable) {
@@ -897,10 +907,7 @@
                 }
                 case DecoderStateTables.NISTRING_EA:
                 {
-                    if ((b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0) {
-                        throw new EncodingAlgorithmException(CommonResourceBundle.getInstance().getString("message.addToTableNotSupported"));
-                    }
-
+                    final boolean addToTable = (b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0;
                     _identifier = (b & 0x0F) << 4;
                     b = read();
                     _identifier |= (b & 0xF0) >> 4;
@@ -907,6 +914,9 @@
 
                     decodeOctetsOnFifthBitOfNonIdentifyingStringOnFirstBit(b);
                     value = convertEncodingAlgorithmDataToCharacters(true);
+                    if (addToTable) {
+                        _attributeValueTable.add(value);
+                    }
                     a.setValue(value);
                     _currentElement.setAttributeNode(a);
                     break;
@@ -920,7 +930,7 @@
                 case DecoderStateTables.NISTRING_INDEX_MEDIUM:
                 {
                     final int index = (((b & EncodingConstants.INTEGER_2ND_BIT_MEDIUM_MASK) << 8) | read())
-                        + EncodingConstants.INTEGER_2ND_BIT_SMALL_LIMIT;
+                    + EncodingConstants.INTEGER_2ND_BIT_SMALL_LIMIT;
                     value = _attributeValueTable._array[index];
 
                     a.setValue(value);
@@ -930,7 +940,7 @@
                 case DecoderStateTables.NISTRING_INDEX_LARGE:
                 {
                     final int index = (((b & EncodingConstants.INTEGER_2ND_BIT_LARGE_MASK) << 16) | (read() << 8) | read())
-                        + EncodingConstants.INTEGER_2ND_BIT_MEDIUM_LIMIT;
+                    + EncodingConstants.INTEGER_2ND_BIT_MEDIUM_LIMIT;
                     value = _attributeValueTable._array[index];
 
                     a.setValue(value);
@@ -992,7 +1002,7 @@
                     _v.otherString.add(new CharArrayString(data, false));
                 }
 
-                _currentNode.appendChild (_document.createProcessingInstruction (target, data));
+                _currentNode.appendChild(_document.createProcessingInstruction(target, data));
                 break;
             }
             case NISTRING_ENCODING_ALGORITHM:
@@ -1001,11 +1011,11 @@
             {
                 final String data = _v.otherString.get(_integer).toString();
 
-                _currentNode.appendChild (_document.createProcessingInstruction (target, data));
+                _currentNode.appendChild(_document.createProcessingInstruction(target, data));
                 break;
             }
             case NISTRING_EMPTY_STRING:
-                _currentNode.appendChild (_document.createProcessingInstruction (target, ""));
+                _currentNode.appendChild(_document.createProcessingInstruction(target, ""));
                 break;
         }
     }
@@ -1021,9 +1031,9 @@
     protected String convertEncodingAlgorithmDataToCharacters(boolean isAttributeValue) throws FastInfosetException, IOException {
         StringBuffer buffer = new StringBuffer();
         if (_identifier < EncodingConstants.ENCODING_ALGORITHM_BUILTIN_END) {
-            Object array = BuiltInEncodingAlgorithmFactory.table[_identifier].
-                decodeFromBytes(_octetBuffer, _octetBufferStart, _octetBufferLength);
-            BuiltInEncodingAlgorithmFactory.table[_identifier].convertToCharacters(array,  buffer);
+            Object array = BuiltInEncodingAlgorithmFactory.getAlgorithm(_identifier).
+                    decodeFromBytes(_octetBuffer, _octetBufferStart, _octetBufferLength);
+            BuiltInEncodingAlgorithmFactory.getAlgorithm(_identifier).convertToCharacters(array,  buffer);
         } else if (_identifier == EncodingAlgorithmIndexes.CDATA) {
             if (!isAttributeValue) {
                 // Set back buffer position to start of encoded string
@@ -1044,5 +1054,4 @@
         }
         return buffer.toString();
     }
-
 }
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/dom/DOMDocumentSerializer.java	Tue Aug  4 09:53:15 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/dom/DOMDocumentSerializer.java	Tue Aug  4 09:53:14 2009
@@ -202,7 +202,7 @@
 
                 final String value = a.getNodeValue();
                 final boolean addToTable = isAttributeValueLengthMatchesLimit(value.length());
-                encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable);
+                encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable, false);
             }
 
             _b = EncodingConstants.TERMINATOR;
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/org/apache/xerces/util/XMLChar.java	Tue Aug  4 09:53:17 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/org/apache/xerces/util/XMLChar.java	Tue Aug  4 09:53:17 2009
@@ -2,7 +2,7 @@
  * reserved comment block
  * DO NOT REMOVE OR ALTER!
  */
-/*
+ /*
  * Portions Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
@@ -112,7 +112,7 @@
  * @author Michael Glavassevich, IBM
  * @author Rahul Srivastava, Sun Microsystems Inc.
  *
- * @version $Id: XMLChar.java,v 1.1 2005/04/18 12:54:47 sandoz Exp $
+ * @version $Id: XMLChar.java,v 1.2 2006/03/16 16:22:16 sandoz Exp $
  */
 public class XMLChar {
 
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/resources/ResourceBundle.properties	Tue Aug  4 09:53:20 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/resources/ResourceBundle.properties	Tue Aug  4 09:53:19 2009
@@ -22,6 +22,8 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
+#
 
 # Sample ResourceBundle properties file
 message.optinalValues = Optional values (other than initial vocabulary) of DII not supported
@@ -132,7 +134,7 @@
 message.URINotPresent=URI not present for encoding algorithm identifier {0}
 message.algorithmNotRegistered=Encoding algorithm not registered for URI {0}
 message.featureNotSupported=Feature not supported\: {0}
-message.propertyNotRecognized=Property not recognized\: 
+message.propertyNotRecognized=Property not recognized\:
 message.inputSource=InputSource must include a byte stream or a system ID
 message.qNameOfEIINotInScope=Qualified name of EII not in scope
 message.unsupportedAlgorithm=Unsupported built-in encoding algorithm\: {0}
@@ -172,7 +174,7 @@
 message.nullPropertyName=Property name can not be null.
 
 message.validationNotSupported=This implementation does not support validation
-message.externalEntities=This implementation does not resolve external entities 
+message.externalEntities=This implementation does not resolve external entities
 message.propertyNotSupported=Property {0} is not supported
 message.noElement=No element.
 message.nullXMLEventAllocator=XMLEvent Allocator may not be null
@@ -203,4 +205,3 @@
 message.illegalLoadFactor=Illegal load factor\: {0}
 message.duplicateNamespaceAttribute=Duplicate namespace attribute entry
 message.readonlyList=The list is read-only. Content can not be changed.
- 
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/sax/AttributesHolder.java	Tue Aug  4 09:53:23 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/sax/AttributesHolder.java	Tue Aug  4 09:53:22 2009
@@ -268,7 +268,7 @@
     private final StringBuffer convertEncodingAlgorithmDataToString(int identifier, String URI, Object data) throws FastInfosetException, IOException {
         EncodingAlgorithm ea = null;
         if (identifier < EncodingConstants.ENCODING_ALGORITHM_BUILTIN_END) {
-            ea = BuiltInEncodingAlgorithmFactory.table[identifier];
+            ea = BuiltInEncodingAlgorithmFactory.getAlgorithm(identifier);
         } else if (identifier == EncodingAlgorithmIndexes.CDATA) {
             throw new EncodingAlgorithmException(CommonResourceBundle.getInstance().getString("message.CDATAAlgorithmNotSupported"));
         } else if (identifier >= EncodingConstants.ENCODING_ALGORITHM_APPLICATION_START) {
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/sax/SAXDocumentParser.java	Tue Aug  4 09:53:26 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/sax/SAXDocumentParser.java	Tue Aug  4 09:53:26 2009
@@ -446,7 +446,7 @@
         boolean documentTypeDeclarationOccured = false;
         while(!_terminate || !firstElementHasOccured) {
             _b = read();
-            switch(DecoderStateTables.DII[_b]) {
+            switch(DecoderStateTables.DII(_b)) {
                 case DecoderStateTables.EII_NO_AIIS_INDEX_SMALL:
                     processEII(_elementNameTable._array[_b], false);
                     firstElementHasOccured = true;
@@ -466,8 +466,8 @@
                 case DecoderStateTables.EII_LITERAL:
                 {
                     final QualifiedName qn = decodeLiteralQualifiedName(
-                                _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
-                                _elementNameTable.getNext());
+                            _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
+                            _elementNameTable.getNext());
                     _elementNameTable.add(qn);
                     processEII(qn, (_b & EncodingConstants.ELEMENT_ATTRIBUTE_FLAG) > 0);
                     firstElementHasOccured = true;
@@ -540,7 +540,7 @@
         // Decode any remaining Comment IIs, PI IIs
         while(!_terminate) {
             _b = read();
-            switch(DecoderStateTables.DII[_b]) {
+            switch(DecoderStateTables.DII(_b)) {
                 case DecoderStateTables.COMMENT_II:
                     processCommentII();
                     break;
@@ -578,7 +578,7 @@
 
         while(!_terminate) {
             _b = read();
-            switch(DecoderStateTables.EII[_b]) {
+            switch(DecoderStateTables.EII(_b)) {
                 case DecoderStateTables.EII_NO_AIIS_INDEX_SMALL:
                     processEII(_elementNameTable._array[_b], false);
                     break;
@@ -594,8 +594,8 @@
                 case DecoderStateTables.EII_LITERAL:
                 {
                     final QualifiedName qn = decodeLiteralQualifiedName(
-                                _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
-                                _elementNameTable.getNext());
+                            _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
+                            _elementNameTable.getNext());
                     _elementNameTable.add(qn);
                     processEII(qn, (_b & EncodingConstants.ELEMENT_ATTRIBUTE_FLAG) > 0);
                     break;
@@ -690,9 +690,7 @@
                 }
                 case DecoderStateTables.CII_EA:
                 {
-                    if ((_b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0) {
-                        throw new EncodingAlgorithmException(CommonResourceBundle.getInstance().getString("message.addToTableNotSupported"));
-                    }
+                    final boolean addToTable = (_b & EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG) > 0;
 
                     // Decode encoding algorithm integer
                     _identifier = (_b & 0x02) << 6;
@@ -701,7 +699,7 @@
 
                     decodeOctetsOnSeventhBitOfNonIdentifyingStringOnThirdBit(_b);
 
-                    processCIIEncodingAlgorithm();
+                    processCIIEncodingAlgorithm(addToTable);
                     break;
                 }
                 case DecoderStateTables.CII_INDEX_SMALL:
@@ -719,7 +717,7 @@
                 case DecoderStateTables.CII_INDEX_MEDIUM:
                 {
                     final int index = (((_b & EncodingConstants.INTEGER_4TH_BIT_MEDIUM_MASK) << 8) | read())
-                            + EncodingConstants.INTEGER_4TH_BIT_SMALL_LIMIT;
+                    + EncodingConstants.INTEGER_4TH_BIT_SMALL_LIMIT;
                     try {
                         _contentHandler.characters(_characterContentChunkTable._array,
                                 _characterContentChunkTable._offset[index],
@@ -896,7 +894,7 @@
 
         while(!_terminate) {
             _b = read();
-            switch(DecoderStateTables.EII[_b]) {
+            switch(DecoderStateTables.EII(_b)) {
                 case DecoderStateTables.EII_NO_AIIS_INDEX_SMALL:
                     processEII(_elementNameTable._array[_b], false);
                     break;
@@ -912,8 +910,8 @@
                 case DecoderStateTables.EII_LITERAL:
                 {
                     final QualifiedName qn = decodeLiteralQualifiedName(
-                                _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
-                                _elementNameTable.getNext());
+                            _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
+                            _elementNameTable.getNext());
                     _elementNameTable.add(qn);
                     processEII(qn, (_b & EncodingConstants.ELEMENT_ATTRIBUTE_FLAG) > 0);
                     break;
@@ -1008,10 +1006,7 @@
                 }
                 case DecoderStateTables.CII_EA:
                 {
-                    if ((_b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0) {
-                        throw new EncodingAlgorithmException(CommonResourceBundle.getInstance().getString("message.addToTableNotSupported"));
-                    }
-
+                    final boolean addToTable = (_b & EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG) > 0;
                     // Decode encoding algorithm integer
                     _identifier = (_b & 0x02) << 6;
                     _b = read();
@@ -1019,7 +1014,7 @@
 
                     decodeOctetsOnSeventhBitOfNonIdentifyingStringOnThirdBit(_b);
 
-                    processCIIEncodingAlgorithm();
+                    processCIIEncodingAlgorithm(addToTable);
                     break;
                 }
                 case DecoderStateTables.CII_INDEX_SMALL:
@@ -1037,7 +1032,7 @@
                 case DecoderStateTables.CII_INDEX_MEDIUM:
                 {
                     final int index = (((_b & EncodingConstants.INTEGER_4TH_BIT_MEDIUM_MASK) << 8) | read())
-                            + EncodingConstants.INTEGER_4TH_BIT_SMALL_LIMIT;
+                    + EncodingConstants.INTEGER_4TH_BIT_SMALL_LIMIT;
                     try {
                         _contentHandler.characters(_characterContentChunkTable._array,
                                 _characterContentChunkTable._offset[index],
@@ -1175,8 +1170,8 @@
                     prefix = namespaceName = "";
                     _namespaceNameIndex = _prefixIndex = _namespacePrefixes[_namespacePrefixesIndex++] = -1;
                     break;
-                // no prefix, namespace
-                // Declaration of default namespace
+                    // no prefix, namespace
+                    // Declaration of default namespace
                 case 1:
                     prefix = "";
                     namespaceName = decodeIdentifyingNonEmptyStringOnFirstBitAsNamespaceName(false);
@@ -1183,8 +1178,8 @@
 
                     _prefixIndex = _namespacePrefixes[_namespacePrefixesIndex++] = -1;
                     break;
-                // prefix, no namespace
-                // Undeclaration of namespace
+                    // prefix, no namespace
+                    // Undeclaration of namespace
                 case 2:
                     prefix = decodeIdentifyingNonEmptyStringOnFirstBitAsPrefix(false);
                     namespaceName = "";
@@ -1192,8 +1187,8 @@
                     _namespaceNameIndex = -1;
                     _namespacePrefixes[_namespacePrefixesIndex++] = _prefixIndex;
                     break;
-                // prefix, namespace
-                // Declaration of prefixed namespace
+                    // prefix, namespace
+                    // Declaration of prefixed namespace
                 case 3:
                     prefix = decodeIdentifyingNonEmptyStringOnFirstBitAsPrefix(true);
                     namespaceName = decodeIdentifyingNonEmptyStringOnFirstBitAsNamespaceName(true);
@@ -1232,7 +1227,7 @@
         final int end = _namespacePrefixesIndex;
 
         _b = read();
-        switch(DecoderStateTables.EII[_b]) {
+        switch(DecoderStateTables.EII(_b)) {
             case DecoderStateTables.EII_NO_AIIS_INDEX_SMALL:
                 processEII(_elementNameTable._array[_b], hasAttributes);
                 break;
@@ -1245,8 +1240,8 @@
             case DecoderStateTables.EII_LITERAL:
             {
                 final QualifiedName qn = decodeLiteralQualifiedName(
-                            _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
-                            _elementNameTable.getNext());
+                        _b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
+                        _elementNameTable.getNext());
                 _elementNameTable.add(qn);
                 processEII(qn, hasAttributes);
                 break;
@@ -1260,7 +1255,7 @@
                 final int prefixIndex = _namespacePrefixes[i];
                 _prefixTable.popScope(prefixIndex);
                 prefix = (prefixIndex > 0) ? _prefixTable.get(prefixIndex - 1) :
-                        (prefixIndex == -1) ? "" : EncodingConstants.XML_NAMESPACE_PREFIX;
+                    (prefixIndex == -1) ? "" : EncodingConstants.XML_NAMESPACE_PREFIX;
                 _contentHandler.endPrefixMapping(prefix);
             }
             _namespacePrefixesIndex = start;
@@ -1283,7 +1278,7 @@
         do {
             // AII qualified name
             b = read();
-            switch (DecoderStateTables.AII[b]) {
+            switch (DecoderStateTables.AII(b)) {
                 case DecoderStateTables.AII_INDEX_SMALL:
                     name = _attributeNameTable._array[b];
                     break;
@@ -1290,7 +1285,7 @@
                 case DecoderStateTables.AII_INDEX_MEDIUM:
                 {
                     final int i = (((b & EncodingConstants.INTEGER_2ND_BIT_MEDIUM_MASK) << 8) | read())
-                            + EncodingConstants.INTEGER_2ND_BIT_SMALL_LIMIT;
+                    + EncodingConstants.INTEGER_2ND_BIT_SMALL_LIMIT;
                     name = _attributeNameTable._array[i];
                     break;
                 }
@@ -1297,7 +1292,7 @@
                 case DecoderStateTables.AII_INDEX_LARGE:
                 {
                     final int i = (((b & EncodingConstants.INTEGER_2ND_BIT_LARGE_MASK) << 16) | (read() << 8) | read())
-                            + EncodingConstants.INTEGER_2ND_BIT_MEDIUM_LIMIT;
+                    + EncodingConstants.INTEGER_2ND_BIT_MEDIUM_LIMIT;
                     name = _attributeNameTable._array[i];
                     break;
                 }
@@ -1327,7 +1322,7 @@
             // [normalized value] of AII
 
             b = read();
-            switch(DecoderStateTables.NISTRING[b]) {
+            switch(DecoderStateTables.NISTRING(b)) {
                 case DecoderStateTables.NISTRING_UTF8_SMALL_LENGTH:
                     _octetBufferLength = (b & EncodingConstants.OCTET_STRING_LENGTH_5TH_BIT_SMALL_MASK) + 1;
                     value = decodeUtf8StringAsString();
@@ -1410,9 +1405,7 @@
                 }
                 case DecoderStateTables.NISTRING_EA:
                 {
-                    if ((b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0) {
-                        throw new EncodingAlgorithmException(CommonResourceBundle.getInstance().getString("message.addToTableNotSupported"));
-                    }
+                    final boolean addToTable = (b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0;
 
                     _identifier = (b & 0x0F) << 4;
                     b = read();
@@ -1420,7 +1413,7 @@
 
                     decodeOctetsOnFifthBitOfNonIdentifyingStringOnFirstBit(b);
 
-                    processAIIEncodingAlgorithm(name);
+                    processAIIEncodingAlgorithm(name, addToTable);
                     break;
                 }
                 case DecoderStateTables.NISTRING_INDEX_SMALL:
@@ -1529,7 +1522,7 @@
         }
     }
 
-    protected final void processCIIEncodingAlgorithm() throws FastInfosetException, IOException {
+    protected final void processCIIEncodingAlgorithm(boolean addToTable) throws FastInfosetException, IOException {
         if (_identifier < EncodingConstants.ENCODING_ALGORITHM_BUILTIN_END) {
             if (_primitiveHandler != null) {
                 processCIIBuiltInEncodingAlgorithmAsPrimitive();
@@ -1551,18 +1544,28 @@
                     throw new FastInfosetException(e);
                 }
             }
+
+            if (addToTable) {
+                StringBuffer buffer = new StringBuffer();
+                processBuiltInEncodingAlgorithmAsCharacters(buffer);
+                _characterContentChunkTable.add(buffer.toString().toCharArray(), buffer.length());
+            }
         } else if (_identifier == EncodingAlgorithmIndexes.CDATA) {
-                // Set back buffer position to start of encoded string
-                _octetBufferOffset -= _octetBufferLength;
-                decodeUtf8StringIntoCharBuffer();
+            // Set back buffer position to start of encoded string
+            _octetBufferOffset -= _octetBufferLength;
+            decodeUtf8StringIntoCharBuffer();
 
-                try {
-                    _lexicalHandler.startCDATA();
-                    _contentHandler.characters(_charBuffer, 0, _charBufferLength);
-                    _lexicalHandler.endCDATA();
-                } catch (SAXException e) {
-                    throw new FastInfosetException(e);
-                }
+            try {
+                _lexicalHandler.startCDATA();
+                _contentHandler.characters(_charBuffer, 0, _charBufferLength);
+                _lexicalHandler.endCDATA();
+            } catch (SAXException e) {
+                throw new FastInfosetException(e);
+            }
+
+            if (addToTable) {
+                _characterContentChunkTable.add(_charBuffer, _charBufferLength);
+            }
         } else if (_identifier >= EncodingConstants.ENCODING_ALGORITHM_APPLICATION_START && _algorithmHandler != null) {
             final String URI = _v.encodingAlgorithm.get(_identifier - EncodingConstants.ENCODING_ALGORITHM_APPLICATION_START);
             if (URI == null) {
@@ -1585,6 +1588,9 @@
                     throw new FastInfosetException(e);
                 }
             }
+            if (addToTable) {
+                throw new EncodingAlgorithmException(CommonResourceBundle.getInstance().getString("message.addToTableNotSupported"));
+            }
         } else if (_identifier >= EncodingConstants.ENCODING_ALGORITHM_APPLICATION_START) {
             // TODO should have property to ignore
             throw new EncodingAlgorithmException(
@@ -1723,7 +1729,7 @@
     }
 
 
-    protected final void processAIIEncodingAlgorithm(QualifiedName name) throws FastInfosetException, IOException {
+    protected final void processAIIEncodingAlgorithm(QualifiedName name, boolean addToTable) throws FastInfosetException, IOException {
         if (_identifier < EncodingConstants.ENCODING_ALGORITHM_BUILTIN_END) {
             if (_primitiveHandler != null || _algorithmHandler != null) {
                 Object data = processBuiltInEncodingAlgorithmAsObject();
@@ -1761,18 +1767,22 @@
             // reported, allows for support through handler if required.
             throw new EncodingAlgorithmException(CommonResourceBundle.getInstance().getString("message.identifiers10to31Reserved"));
         }
+
+        if (addToTable) {
+            _attributeValueTable.add(_attributes.getValue(_attributes.getIndex(name.qName)));
+        }
     }
 
     protected final void processBuiltInEncodingAlgorithmAsCharacters(StringBuffer buffer) throws FastInfosetException, IOException {
         // TODO not very efficient, need to reuse buffers
-        Object array = BuiltInEncodingAlgorithmFactory.table[_identifier].
+        Object array = BuiltInEncodingAlgorithmFactory.getAlgorithm(_identifier).
                 decodeFromBytes(_octetBuffer, _octetBufferStart, _octetBufferLength);
 
-        BuiltInEncodingAlgorithmFactory.table[_identifier].convertToCharacters(array,  buffer);
+        BuiltInEncodingAlgorithmFactory.getAlgorithm(_identifier).convertToCharacters(array,  buffer);
     }
 
     protected final Object processBuiltInEncodingAlgorithmAsObject() throws FastInfosetException, IOException {
-        return BuiltInEncodingAlgorithmFactory.table[_identifier].
+        return BuiltInEncodingAlgorithmFactory.getAlgorithm(_identifier).
                 decodeFromBytes(_octetBuffer, _octetBufferStart, _octetBufferLength);
     }
 }
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/sax/SAXDocumentSerializer.java	Tue Aug  4 09:53:29 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/sax/SAXDocumentSerializer.java	Tue Aug  4 09:53:29 2009
@@ -430,9 +430,8 @@
         try {
             encodeTermination();
 
-            final boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length, _v.characterContentChunk);
-            encodeFourBitCharacters(RestrictedAlphabet.NUMERIC_CHARACTERS_INDEX, NUMERIC_CHARACTERS_TABLE,
-                    ch, start, length, addToTable);
+            final boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length);
+            encodeNumericFourBitCharacters(ch, start, length, addToTable);
         } catch (IOException e) {
             throw new SAXException(e);
         } catch (FastInfosetException e) {
@@ -448,9 +447,8 @@
         try {
             encodeTermination();
 
-            final boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length, _v.characterContentChunk);
-            encodeFourBitCharacters(RestrictedAlphabet.DATE_TIME_CHARACTERS_INDEX, DATE_TIME_CHARACTERS_TABLE,
-                    ch, start, length, addToTable);
+            final boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length);
+            encodeDateTimeFourBitCharacters(ch, start, length, addToTable);
         } catch (IOException e) {
             throw new SAXException(e);
         } catch (FastInfosetException e) {
@@ -466,7 +464,7 @@
         try {
             encodeTermination();
 
-            final boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length, _v.characterContentChunk);
+            final boolean addToTable = isCharacterContentChunkLengthMatchesLimit(length);
             encodeAlphabetCharacters(alphabet, ch, start, length, addToTable);
         } catch (IOException e) {
             throw new SAXException(e);
@@ -518,6 +516,7 @@
 
     protected void encodeAttributes(Attributes atts) throws IOException, FastInfosetException {
         boolean addToTable;
+        boolean mustBeAddedToTable;
         String value;
         if (atts instanceof EncodingAlgorithmAttributes) {
             final EncodingAlgorithmAttributes eAtts = (EncodingAlgorithmAttributes)atts;
@@ -529,24 +528,21 @@
                     // If data is null then there is no algorithm data
                     if (data == null) {
                         value = eAtts.getValue(i);
-                        addToTable = eAtts.getToIndex(i) || isAttributeValueLengthMatchesLimit(value.length());
+                        addToTable = isAttributeValueLengthMatchesLimit(value.length());
+                        mustBeAddedToTable = eAtts.getToIndex(i);
 
                         alphabet = eAtts.getAlpababet(i);
-                        if (alphabet == null)
-                            encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable);
-                        else if (alphabet == RestrictedAlphabet.DATE_TIME_CHARACTERS)
-                            encodeNonIdentifyingStringOnFirstBit(
-                                    RestrictedAlphabet.DATE_TIME_CHARACTERS_INDEX,
-                                    DATE_TIME_CHARACTERS_TABLE,
-                                    value, addToTable);
-                        else if (alphabet == RestrictedAlphabet.DATE_TIME_CHARACTERS)
-                            encodeNonIdentifyingStringOnFirstBit(
-                                    RestrictedAlphabet.NUMERIC_CHARACTERS_INDEX,
-                                    NUMERIC_CHARACTERS_TABLE,
-                                    value, addToTable);
-                        else
-                            encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable);
-
+                        if (alphabet == null) {
+                            encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable, mustBeAddedToTable);
+                        } else if (alphabet == RestrictedAlphabet.DATE_TIME_CHARACTERS) {
+                            encodeDateTimeNonIdentifyingStringOnFirstBit(
+                                    value, addToTable, mustBeAddedToTable);
+                        } else if (alphabet == RestrictedAlphabet.NUMERIC_CHARACTERS) {
+                            encodeNumericNonIdentifyingStringOnFirstBit(
+                                    value, addToTable, mustBeAddedToTable);
+                        } else {
+                            encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable, mustBeAddedToTable);
+                        }
                     } else {
                         encodeNonIdentifyingStringOnFirstBit(eAtts.getAlgorithmURI(i),
                                 eAtts.getAlgorithmIndex(i), data);
@@ -558,7 +554,7 @@
                 if (encodeAttribute(atts.getURI(i), atts.getQName(i), atts.getLocalName(i))) {
                     value = atts.getValue(i);
                     addToTable = isAttributeValueLengthMatchesLimit(value.length());
-                    encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable);
+                    encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable, false);
                 }
             }
         }
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/sax/SAXDocumentSerializerWithPrefixMapping.java	Tue Aug  4 09:53:32 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/sax/SAXDocumentSerializerWithPrefixMapping.java	Tue Aug  4 09:53:31 2009
@@ -148,6 +148,7 @@
 
     protected final void encodeAttributes(Attributes atts) throws IOException, FastInfosetException {
         boolean addToTable;
+        boolean mustToBeAddedToTable;
         String value;
         if (atts instanceof EncodingAlgorithmAttributes) {
             final EncodingAlgorithmAttributes eAtts = (EncodingAlgorithmAttributes)atts;
@@ -160,8 +161,8 @@
                     // If data is null then there is no algorithm data
                     if (data == null) {
                         value = eAtts.getValue(i);
-                        addToTable = eAtts.getToIndex(i) || isAttributeValueLengthMatchesLimit(value.length());
-
+                        addToTable = isAttributeValueLengthMatchesLimit(value.length());
+                        mustToBeAddedToTable = eAtts.getToIndex(i);
                         alphabet = eAtts.getAlpababet(i);
                         if (alphabet == null) {
                             if (uri == "http://www.w3.org/2001/XMLSchema-instance" ||
@@ -168,20 +169,16 @@
                                     uri.equals("http://www.w3.org/2001/XMLSchema-instance")) {
                                 value = convertQName(value);
                             }
-                            encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable);
-                        } else if (alphabet == RestrictedAlphabet.DATE_TIME_CHARACTERS)
-                            encodeNonIdentifyingStringOnFirstBit(
-                                    RestrictedAlphabet.DATE_TIME_CHARACTERS_INDEX,
-                                    DATE_TIME_CHARACTERS_TABLE,
-                                    value, addToTable);
-                        else if (alphabet == RestrictedAlphabet.DATE_TIME_CHARACTERS)
-                            encodeNonIdentifyingStringOnFirstBit(
-                                    RestrictedAlphabet.NUMERIC_CHARACTERS_INDEX,
-                                    NUMERIC_CHARACTERS_TABLE,
-                                    value, addToTable);
-                        else
-                            encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable);
-
+                            encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable, mustToBeAddedToTable);
+                        } else if (alphabet == RestrictedAlphabet.DATE_TIME_CHARACTERS) {
+                            encodeDateTimeNonIdentifyingStringOnFirstBit(
+                                    value, addToTable, mustToBeAddedToTable);
+                        } else if (alphabet == RestrictedAlphabet.NUMERIC_CHARACTERS) {
+                            encodeNumericNonIdentifyingStringOnFirstBit(
+                                    value, addToTable, mustToBeAddedToTable);
+                        } else {
+                            encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable, mustToBeAddedToTable);
+                        }
                     } else {
                         encodeNonIdentifyingStringOnFirstBit(eAtts.getAlgorithmURI(i),
                                 eAtts.getAlgorithmIndex(i), data);
@@ -199,7 +196,7 @@
                             uri.equals("http://www.w3.org/2001/XMLSchema-instance")) {
                         value = convertQName(value);
                     }
-                    encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable);
+                    encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable, false);
                 }
             }
         }
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/stax/StAXDocumentParser.java	Tue Aug  4 09:53:35 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/stax/StAXDocumentParser.java	Tue Aug  4 09:53:35 2009
@@ -51,6 +51,7 @@
 import com.sun.xml.internal.org.jvnet.fastinfoset.FastInfosetException;
 import com.sun.xml.internal.fastinfoset.CommonResourceBundle;
 import com.sun.xml.internal.fastinfoset.org.apache.xerces.util.XMLChar;
+import com.sun.xml.internal.fastinfoset.util.DuplicateAttributeVerifier;
 import com.sun.xml.internal.org.jvnet.fastinfoset.stax.FastInfosetStreamReader;
 
 /**
@@ -151,11 +152,13 @@
         _manager = manager;
     }
 
+    @Override
     public void setInputStream(InputStream s) {
         super.setInputStream(s);
         reset();
     }
 
+    @Override
     public void reset() {
         super.reset();
         if (_internalState != INTERNAL_STATE_START_DOCUMENT &&
@@ -269,7 +272,7 @@
 
             // Process information item
             final int b = read();
-            switch(DecoderStateTables.EII[b]) {
+            switch(DecoderStateTables.EII(b)) {
                 case DecoderStateTables.EII_NO_AIIS_INDEX_SMALL:
                     processEII(_elementNameTable._array[b], false);
                     return _eventType;
@@ -351,10 +354,7 @@
                 }
                 case DecoderStateTables.CII_EA:
                 {
-                    if ((b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0) {
-                        throw new EncodingAlgorithmException(CommonResourceBundle.getInstance().getString("message.addToTableNotSupported"));
-                    }
-
+                    final boolean addToTable = (b & EncodingConstants.CHARACTER_CHUNK_ADD_TO_TABLE_FLAG) > 0;
                     // Decode encoding algorithm integer
                     _algorithmId = (b & 0x02) << 6;
                     final int b2 = read();
@@ -361,7 +361,7 @@
                     _algorithmId |= (b2 & 0xFC) >> 2;
 
                     decodeOctetsOnSeventhBitOfNonIdentifyingStringOnThirdBit(b2);
-                    processCIIEncodingAlgorithm();
+                    processCIIEncodingAlgorithm(addToTable);
 
                     return _eventType = CHARACTERS;
                 }
@@ -817,9 +817,10 @@
         }
 
         try {
-            System.arraycopy(_characters, sourceStart, target,
-                    targetStart, length);
-            return length;
+            int bytesToCopy = Math.min(_charBufferLength, length);
+            System.arraycopy(_characters, _charactersOffset + sourceStart,
+                    target, targetStart, bytesToCopy);
+            return bytesToCopy;
         } catch (IndexOutOfBoundsException e) {
             throw new XMLStreamException(e);
         }
@@ -983,7 +984,7 @@
 
     public final int peekNext() throws XMLStreamException {
         try {
-            switch(DecoderStateTables.EII[peek(this)]) {
+            switch(DecoderStateTables.EII(peek(this))) {
                 case DecoderStateTables.EII_NO_AIIS_INDEX_SMALL:
                 case DecoderStateTables.EII_AIIS_INDEX_SMALL:
                 case DecoderStateTables.EII_INDEX_MEDIUM:
@@ -1213,7 +1214,7 @@
         _currentNamespaceAIIsEnd = _namespaceAIIsIndex;
 
         b = read();
-        switch(DecoderStateTables.EII[b]) {
+        switch(DecoderStateTables.EII(b)) {
             case DecoderStateTables.EII_NO_AIIS_INDEX_SMALL:
                 processEII(_elementNameTable._array[b], hasAttributes);
                 break;
@@ -1288,7 +1289,7 @@
         do {
             // AII qualified name
             b = read();
-            switch (DecoderStateTables.AII[b]) {
+            switch (DecoderStateTables.AII(b)) {
                 case DecoderStateTables.AII_INDEX_SMALL:
                     name = _attributeNameTable._array[b];
                     break;
@@ -1310,7 +1311,7 @@
                     name = processLiteralQualifiedName(
                             b & EncodingConstants.LITERAL_QNAME_PREFIX_NAMESPACE_NAME_MASK,
                             _attributeNameTable.getNext());
-                    name.createAttributeValues(_duplicateAttributeVerifier.MAP_SIZE);
+                    name.createAttributeValues(DuplicateAttributeVerifier.MAP_SIZE);
                     _attributeNameTable.add(name);
                     break;
                 case DecoderStateTables.AII_TERMINATOR_DOUBLE:
@@ -1332,7 +1333,7 @@
             _duplicateAttributeVerifier.checkForDuplicateAttribute(name.attributeHash, name.attributeId);
 
             b = read();
-            switch(DecoderStateTables.NISTRING[b]) {
+            switch(DecoderStateTables.NISTRING(b)) {
                 case DecoderStateTables.NISTRING_UTF8_SMALL_LENGTH:
                     _octetBufferLength = (b & EncodingConstants.OCTET_STRING_LENGTH_5TH_BIT_SMALL_MASK) + 1;
                     value = decodeUtf8StringAsString();
@@ -1415,10 +1416,7 @@
                 }
                 case DecoderStateTables.NISTRING_EA:
                 {
-                    if ((b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0) {
-                        throw new EncodingAlgorithmException(CommonResourceBundle.getInstance().getString("message.addToTableNotSupported"));
-                    }
-
+                    final boolean addToTable = (b & EncodingConstants.NISTRING_ADD_TO_TABLE_FLAG) > 0;
                     // Decode encoding algorithm integer
                     _identifier = (b & 0x0F) << 4;
                     b = read();
@@ -1425,7 +1423,7 @@
                     _identifier |= (b & 0xF0) >> 4;
 
                     decodeOctetsOnFifthBitOfNonIdentifyingStringOnFirstBit(b);
-                    processAIIEncodingAlgorithm(name);
+                    processAIIEncodingAlgorithm(name, addToTable);
                     break;
                 }
                 case DecoderStateTables.NISTRING_INDEX_SMALL:
@@ -1596,7 +1594,7 @@
         ? decodeIdentifyingNonEmptyStringOnFirstBit(_v.otherURI) : "";
     }
 
-    protected final void processCIIEncodingAlgorithm() throws FastInfosetException, IOException {
+    protected final void processCIIEncodingAlgorithm(boolean addToTable) throws FastInfosetException, IOException {
         _algorithmData = _octetBuffer;
         _algorithmDataOffset = _octetBufferStart;
         _algorithmDataLength = _octetBufferLength;
@@ -1613,9 +1611,14 @@
             // reported, allows for support through handler if required.
             throw new EncodingAlgorithmException(CommonResourceBundle.getInstance().getString("message.identifiers10to31Reserved"));
         }
+
+        if (addToTable) {
+            convertEncodingAlgorithmDataToCharacters();
+            _characterContentChunkTable.add(_characters, _characters.length);
+        }
     }
 
-    protected final void processAIIEncodingAlgorithm(QualifiedName name) throws FastInfosetException, IOException {
+    protected final void processAIIEncodingAlgorithm(QualifiedName name, boolean addToTable) throws FastInfosetException, IOException {
         String URI = null;
         if (_identifier >= EncodingConstants.ENCODING_ALGORITHM_APPLICATION_START) {
             URI = _v.encodingAlgorithm.get(_identifier - EncodingConstants.ENCODING_ALGORITHM_APPLICATION_START);
@@ -1636,6 +1639,9 @@
         final byte[] data = new byte[_octetBufferLength];
         System.arraycopy(_octetBuffer, _octetBufferStart, data, 0, _octetBufferLength);
         _attributes.addAttributeWithAlgorithmData(name, URI, _identifier, data);
+        if (addToTable) {
+            _attributeValueTable.add(_attributes.getValue(_attributes.getIndex(name.qName)));
+        }
     }
 
     protected final void convertEncodingAlgorithmDataToCharacters() throws FastInfosetException, IOException {
@@ -1643,9 +1649,9 @@
         if (_algorithmId == EncodingAlgorithmIndexes.BASE64) {
             convertBase64AlorithmDataToCharacters(buffer);
         } else if (_algorithmId < EncodingConstants.ENCODING_ALGORITHM_BUILTIN_END) {
-            Object array = BuiltInEncodingAlgorithmFactory.table[_algorithmId].
+            Object array = BuiltInEncodingAlgorithmFactory.getAlgorithm(_algorithmId).
                     decodeFromBytes(_algorithmData, _algorithmDataOffset, _algorithmDataLength);
-            BuiltInEncodingAlgorithmFactory.table[_algorithmId].convertToCharacters(array,  buffer);
+            BuiltInEncodingAlgorithmFactory.getAlgorithm(_algorithmId).convertToCharacters(array,  buffer);
         } else if (_algorithmId == EncodingAlgorithmIndexes.CDATA) {
             _octetBufferOffset -= _octetBufferLength;
             decodeUtf8StringIntoCharBuffer();
@@ -1745,7 +1751,7 @@
     public boolean isBase64Follows() throws IOException {
         // Process information item
         int b = peek(this);
-        switch (DecoderStateTables.EII[b]) {
+        switch (DecoderStateTables.EII(b)) {
             case DecoderStateTables.CII_EA:
                 int algorithmId = (b & 0x02) << 6;
                 int b2 = peek2(this);
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/stax/StAXDocumentSerializer.java	Tue Aug  4 09:53:38 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/stax/StAXDocumentSerializer.java	Tue Aug  4 09:53:37 2009
@@ -197,7 +197,7 @@
     public void writeStartElement(String namespaceURI, String localName)
         throws XMLStreamException
     {
-        writeStartElement(getPrefix(namespaceURI), localName, namespaceURI);
+        writeStartElement("", localName, namespaceURI);
     }
 
     public void writeStartElement(String prefix, String localName,
@@ -231,7 +231,7 @@
     public void writeEmptyElement(String namespaceURI, String localName)
         throws XMLStreamException
     {
-        writeEmptyElement(getPrefix(namespaceURI), localName, namespaceURI);
+        writeEmptyElement("", localName, namespaceURI);
     }
 
     public void writeEmptyElement(String prefix, String localName,
@@ -581,8 +581,15 @@
                 }
 
                 // If element's prefix is empty - apply default scope namespace
-                if (_currentPrefix.length() == 0 && _currentUri.length() == 0) {
-                    _currentUri = _nsContext.getNamespaceURI("");
+                if (_currentPrefix.length() == 0) {
+                    if (_currentUri.length() == 0) {
+                        _currentUri = _nsContext.getNamespaceURI("");
+                    } else {
+                        String tmpPrefix = getPrefix(_currentUri);
+                        if (tmpPrefix != null) {
+                            _currentPrefix = tmpPrefix;
+                        }
+                    }
                 }
 
                 encodeElementQualifiedNameOnThirdBit(_currentUri, _currentPrefix, _currentLocalName);
@@ -594,7 +601,7 @@
                     final String value = _attributesArray[i];
                     _attributesArray[i++] = null;
                     final boolean addToTable = isAttributeValueLengthMatchesLimit(value.length());
-                    encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable);
+                    encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable, false);
 
                     _b = EncodingConstants.TERMINATOR;
                     _terminate = true;
@@ -701,7 +708,7 @@
     public final void writeLowLevelAttributeValue(String value) throws IOException
     {
         final boolean addToTable = isAttributeValueLengthMatchesLimit(value.length());
-        encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable);
+        encodeNonIdentifyingStringOnFirstBit(value, _v.attributeValue, addToTable, false);
     }
 
     public final void writeLowLevelStartNameLiteral(int type, String prefix, byte[] utf8LocalName,
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/tools/VocabularyGenerator.java	Tue Aug  4 09:53:41 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/tools/VocabularyGenerator.java	Tue Aug  4 09:53:40 2009
@@ -55,9 +55,9 @@
     protected ParserVocabulary _parserVocabulary;
     protected com.sun.xml.internal.org.jvnet.fastinfoset.Vocabulary _v;
 
-    protected int attributeValueSizeConstraint = FastInfosetSerializer.ATTRIBUTE_VALUE_SIZE_CONSTRAINT;
+    protected int attributeValueSizeConstraint = FastInfosetSerializer.MAX_ATTRIBUTE_VALUE_SIZE;
 
-    protected int characterContentChunkSizeContraint = FastInfosetSerializer.CHARACTER_CONTENT_CHUNK_SIZE_CONSTRAINT;
+    protected int characterContentChunkSizeContraint = FastInfosetSerializer.MAX_CHARACTER_CONTENT_CHUNK_SIZE;
 
     /** Creates a new instance of VocabularyGenerator */
     public VocabularyGenerator() {
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/util/CharArrayIntMap.java	Tue Aug  4 09:53:45 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/util/CharArrayIntMap.java	Tue Aug  4 09:53:45 2009
@@ -114,6 +114,26 @@
         }
     }
 
+    /**
+     * Method returns an index of the passed character buffer in
+     * <code>CharArrayIntMap</code>.
+     *
+     * @return index of character buffer in <code>CharArrayIntMap</code>,
+     * otherwise NOT_PRESENT.
+     */
+    public final int get(char[] ch, int start, int length) {
+        final int hash = hashHash(CharArray.hashCode(ch, start, length));
+        return get(ch, start, length, hash);
+    }
+
+    /**
+     * Method returns an index of the passed character buffer in
+     * <code>CharArrayIntMap</code>. If character buffer is not in
+     * <code>CharArrayIntMap</code> - it will be added.
+     *
+     * @return index of character buffer in <code>CharArrayIntMap</code>, or
+     * NOT_PRESENT if character buffer was just added.
+     */
     public final int obtainIndex(char[] ch, int start, int length, boolean clone) {
         final int hash = hashHash(CharArray.hashCode(ch, start, length));
 
@@ -162,7 +182,7 @@
             }
         }
 
-        return -1;
+        return NOT_PRESENT;
     }
 
     private final void addEntry(char[] ch, int start, int length, int hash, int value, int bucketIndex) {
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/util/DuplicateAttributeVerifier.java	Tue Aug  4 09:53:49 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/util/DuplicateAttributeVerifier.java	Tue Aug  4 09:53:49 2009
@@ -35,7 +35,7 @@
 
     public int _currentIteration;
 
-    private static class Entry {
+    public static class Entry {
         private int iteration;
         private int value;
 
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/util/NamespaceContextImplementation.java	Tue Aug  4 09:53:53 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/util/NamespaceContextImplementation.java	Tue Aug  4 09:53:52 2009
@@ -84,11 +84,16 @@
                 final String declaredPrefix = prefixes[i];
 
                 // Check if prefix is out of scope
-                for (++i; i < namespacePosition; i++)
-                    if (declaredPrefix == prefixes[i])
-                        return null;
+                boolean isOutOfScope = false;
+                for (int j = i + 1; j < namespacePosition; j++)
+                    if (declaredPrefix == prefixes[j]) {
+                        isOutOfScope = true;
+                        break;
+                    }
 
-                return declaredPrefix;
+                if (!isOutOfScope) {
+                    return declaredPrefix;
+                }
             }
         }
 
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/util/StringIntMap.java	Tue Aug  4 09:53:56 2009
+++ new/src/share/classes/com/sun/xml/internal/fastinfoset/util/StringIntMap.java	Tue Aug  4 09:53:55 2009
@@ -166,7 +166,7 @@
             }
         }
 
-        return -1;
+        return NOT_PRESENT;
     }
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/SOAPExceptionImpl.java	Tue Aug  4 09:53:58 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/SOAPExceptionImpl.java	Tue Aug  4 09:53:58 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: SOAPExceptionImpl.java,v 1.3 2006/01/27 12:49:17 vj135062 Exp $
- * $Revision: 1.3 $
- * $Date: 2006/01/27 12:49:17 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/client/p2p/HttpSOAPConnection.java	Tue Aug  4 09:54:00 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/client/p2p/HttpSOAPConnection.java	Tue Aug  4 09:54:00 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: HttpSOAPConnection.java,v 1.41 2006/01/27 12:49:17 vj135062 Exp $
- * $Revision: 1.41 $
- * $Date: 2006/01/27 12:49:17 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.client.p2p;
@@ -66,8 +61,8 @@
         Logger.getLogger(LogDomainConstants.HTTP_CONN_DOMAIN,
                          "com.sun.xml.internal.messaging.saaj.client.p2p.LocalStrings");
 
-    public static final String defaultProxyHost = null;
-    public static  final int defaultProxyPort = -1;
+    private static final String defaultProxyHost = null;
+    private static final int defaultProxyPort = -1;
 
     MessageFactory messageFactory = null;
 
@@ -80,8 +75,8 @@
         try {
             messageFactory = MessageFactory.newInstance(SOAPConstants.DYNAMIC_SOAP_PROTOCOL);
         } catch (NoSuchMethodError ex) {
-                    //fallback to default SOAP 1.1 in this case for backward compatibility
-                    messageFactory = MessageFactory.newInstance();
+            //fallback to default SOAP 1.1 in this case for backward compatibility
+            messageFactory = MessageFactory.newInstance();
         } catch (Exception ex) {
             log.log(Level.SEVERE, "SAAJ0001.p2p.cannot.create.msg.factory", ex);
             throw new SOAPExceptionImpl("Unable to create message factory", ex);
@@ -107,17 +102,16 @@
 
         Class urlEndpointClass = null;
         ClassLoader loader = Thread.currentThread().getContextClassLoader();
-
         try {
-                if (loader != null) {
-                        urlEndpointClass = loader.loadClass(JAXM_URLENDPOINT);
-                } else {
-                        urlEndpointClass = Class.forName(JAXM_URLENDPOINT);
-                    }
-                } catch (ClassNotFoundException ex) {
-                    //Do nothing. URLEndpoint is available only when JAXM is there.
-                    log.finest("SAAJ0090.p2p.endpoint.available.only.for.JAXM");
-                }
+            if (loader != null) {
+                urlEndpointClass = loader.loadClass(JAXM_URLENDPOINT);
+            } else {
+                urlEndpointClass = Class.forName(JAXM_URLENDPOINT);
+            }
+        } catch (ClassNotFoundException ex) {
+            //Do nothing. URLEndpoint is available only when JAXM is there.
+            log.finest("SAAJ0090.p2p.endpoint.available.only.for.JAXM");
+        }
 
         if (urlEndpointClass != null) {
             if (urlEndpointClass.isInstance(endPoint)) {
@@ -654,23 +648,24 @@
 
         return ret;
     }
+
     //private static String SSL_PKG = "com.sun.net.ssl.internal.www.protocol";
     //private static String SSL_PROVIDER =
-              //  "com.sun.net.ssl.internal.ssl.Provider";
+      //  "com.sun.net.ssl.internal.ssl.Provider";
     private static final String SSL_PKG;
-    private static  final String SSL_PROVIDER;
+    private static final String SSL_PROVIDER;
 
-
     static {
-                if (isIBMVM) {
-                    SSL_PKG ="com.ibm.net.ssl.internal.www.protocol";
-                    SSL_PROVIDER ="com.ibm.net.ssl.internal.ssl.Provider";
-                } else {
-                    //if not IBM VM default to Sun.
-                    SSL_PKG = "com.sun.net.ssl.internal.www.protocol";
-                    SSL_PROVIDER ="com.sun.net.ssl.internal.ssl.Provider";
-                }
-            }
+        if (isIBMVM) {
+            SSL_PKG ="com.ibm.net.ssl.internal.www.protocol";
+            SSL_PROVIDER ="com.ibm.net.ssl.internal.ssl.Provider";
+        } else {
+            //if not IBM VM default to Sun.
+            SSL_PKG = "com.sun.net.ssl.internal.www.protocol";
+            SSL_PROVIDER ="com.sun.net.ssl.internal.ssl.Provider";
+        }
+    }
+
     private void initHttps() {
         //if(!setHttps) {
         String pkgs = System.getProperty("java.protocol.handler.pkgs");
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/client/p2p/HttpSOAPConnectionFactory.java	Tue Aug  4 09:54:03 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/client/p2p/HttpSOAPConnectionFactory.java	Tue Aug  4 09:54:02 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: HttpSOAPConnectionFactory.java,v 1.6 2006/01/27 12:49:18 vj135062 Exp $
- * $Revision: 1.6 $
- * $Date: 2006/01/27 12:49:18 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.client.p2p;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/client/p2p/LocalStrings.properties	Tue Aug  4 09:54:05 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/client/p2p/LocalStrings.properties	Tue Aug  4 09:54:05 2009
@@ -53,4 +53,3 @@
 # Trace messages
 SAAJ0090.p2p.endpoint.available.only.for.JAXM=SAAJ0090: URLEndpoint is available only when JAXM is there
 SAAJ0091.p2p.https.auth.in.POST.true=SAAJ0091: HTTPS Authorization in POST set to true
- 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/AttachmentPartImpl.java	Tue Aug  4 09:54:07 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/AttachmentPartImpl.java	Tue Aug  4 09:54:07 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: AttachmentPartImpl.java,v 1.1.1.1.2.1 2007/11/27 07:19:29 kumarjayanti Exp $
- * $Revision: 1.1.1.1.2.1 $
- * $Date: 2007/11/27 07:19:29 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
@@ -100,7 +95,7 @@
                 mailMap.addMailcap(
                     "image/gif"
                         + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.GifDataContentHandler");*/
+                        + "com.sun.xml.internal.messaging.saaj.soap.GifDataContentHandler"); */
                 /*mailMap.addMailcap(
                     "multipart/*"
                         + hndlrStr
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/Envelope.java	Tue Aug  4 09:54:10 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/Envelope.java	Tue Aug  4 09:54:09 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: Envelope.java,v 1.8 2006/01/27 12:49:26 vj135062 Exp $
- * $Revision: 1.8 $
- * $Date: 2006/01/27 12:49:26 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/EnvelopeFactory.java	Tue Aug  4 09:54:12 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/EnvelopeFactory.java	Tue Aug  4 09:54:11 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- *
- *
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
@@ -85,6 +80,9 @@
                     e);
             }
             InputSource is = SAXSource.sourceToInputSource(src);
+            if (is.getEncoding()== null && soapPart.getSourceCharsetEncoding() != null) {
+                is.setEncoding(soapPart.getSourceCharsetEncoding());
+            }
             XMLReader rejectFilter;
             try {
                 rejectFilter = new RejectDoctypeSaxFilter(saxParser);
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/FastInfosetDataContentHandler.java	Tue Aug  4 09:54:14 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/FastInfosetDataContentHandler.java	Tue Aug  4 09:54:14 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: FastInfosetDataContentHandler.java,v 1.1.1.1 2006/01/27 13:10:56 kumarjayanti Exp $
- * $Revision: 1.1.1.1 $
- * $Date: 2006/01/27 13:10:56 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/GifDataContentHandler.java	Tue Aug  4 09:54:16 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/GifDataContentHandler.java	Tue Aug  4 09:54:16 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: GifDataContentHandler.java,v 1.2.2.1 2007/11/27 07:19:29 kumarjayanti Exp $
- * $Revision: 1.2.2.1 $
- * $Date: 2007/11/27 07:19:29 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
@@ -34,6 +29,7 @@
 import java.awt.datatransfer.DataFlavor;
 import java.io.*;
 import java.awt.*;
+
 import javax.activation.*;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ImageDataContentHandler.java	Tue Aug  4 09:54:18 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ImageDataContentHandler.java	Tue Aug  4 09:54:18 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: ImageDataContentHandler.java,v 1.1.1.1.2.1 2007/11/27 07:19:28 kumarjayanti Exp $
- * $Revision: 1.1.1.1.2.1 $
- * $Date: 2007/11/27 07:19:28 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/JpegDataContentHandler.java	Tue Aug  4 09:54:21 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/JpegDataContentHandler.java	Tue Aug  4 09:54:20 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: JpegDataContentHandler.java,v 1.1.1.1.2.1 2007/11/27 07:19:29 kumarjayanti Exp $
- * $Revision: 1.1.1.1.2.1 $
- * $Date: 2007/11/27 07:19:29 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
@@ -157,7 +152,6 @@
                 Graphics g = bufImage.createGraphics();
                 g.drawImage(img, 0, 0, null);
             }
-
             ImageIO.write(bufImage, "jpeg", os);
 
         } catch (Exception ex) {
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/LocalStrings.properties	Tue Aug  4 09:54:23 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/LocalStrings.properties	Tue Aug  4 09:54:22 2009
@@ -105,4 +105,3 @@
 
 # Info messages
 SAAJ0580.soap.set.Content-Type=SAAJ0580: Content-Type set to {0}
- 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/MessageFactoryImpl.java	Tue Aug  4 09:54:25 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/MessageFactoryImpl.java	Tue Aug  4 09:54:25 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- *
- *
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/MessageImpl.java	Tue Aug  4 09:54:27 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/MessageImpl.java	Tue Aug  4 09:54:27 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- *
- *
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
@@ -151,7 +146,7 @@
      *      must be all lower case
      */
     private static boolean isSoap1_1Type(String primary, String sub) {
-        return primary.equals("text") && sub.equals("xml")
+        return primary.equalsIgnoreCase("text") && sub.equalsIgnoreCase("xml")
             || primary.equals("application")
                && sub.equals("fastinfoset");
     }
@@ -848,6 +843,7 @@
             }
         }
         attachments = f;
+       // needsSave();
     }
 
     public AttachmentPart createAttachmentPart() {
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/MultipartDataContentHandler.java	Tue Aug  4 09:54:30 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/MultipartDataContentHandler.java	Tue Aug  4 09:54:29 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: MultipartDataContentHandler.java,v 1.3 2006/01/27 12:49:28 vj135062 Exp $
- * $Revision: 1.3 $
- * $Date: 2006/01/27 12:49:28 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SAAJMetaFactoryImpl.java	Tue Aug  4 09:54:32 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SAAJMetaFactoryImpl.java	Tue Aug  4 09:54:31 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.messaging.saaj.soap;
 
 import javax.xml.soap.SAAJMetaFactory;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPDocument.java	Tue Aug  4 09:54:34 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPDocument.java	Tue Aug  4 09:54:34 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: SOAPDocument.java,v 1.5 2006/01/27 12:49:28 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPDocumentFragment.java	Tue Aug  4 09:54:36 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPDocumentFragment.java	Tue Aug  4 09:54:36 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: SOAPDocumentFragment.java,v 1.6 2006/01/27 12:49:28 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPDocumentImpl.java	Tue Aug  4 09:54:38 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPDocumentImpl.java	Tue Aug  4 09:54:38 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
@@ -45,7 +42,7 @@
 
 public class SOAPDocumentImpl extends DocumentImpl implements SOAPDocument {
 
-    protected static final  Logger log =
+    protected static final Logger log =
         Logger.getLogger(LogDomainConstants.SOAP_DOMAIN,
                          "com.sun.xml.internal.messaging.saaj.soap.LocalStrings");
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPFactoryImpl.java	Tue Aug  4 09:54:41 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPFactoryImpl.java	Tue Aug  4 09:54:40 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- *
- *
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPIOException.java	Tue Aug  4 09:54:43 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPIOException.java	Tue Aug  4 09:54:42 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 /**
  * Created on Nov 19, 2002
  *
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPPartImpl.java	Tue Aug  4 09:54:45 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPPartImpl.java	Tue Aug  4 09:54:45 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- *
- *
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
@@ -612,20 +607,20 @@
 
             InputStream inputStream = ((StreamSource) source).getInputStream();
             if (inputStream != null) {
-                if (sourceCharsetEncoding == null) {
+                if (getSourceCharsetEncoding() == null) {
                     reader = new InputStreamReader(inputStream);
                 } else {
                     try {
                         reader =
                             new InputStreamReader(
-                                inputStream, sourceCharsetEncoding);
+                                inputStream, getSourceCharsetEncoding());
                     } catch (UnsupportedEncodingException uee) {
                         log.log(
                             Level.SEVERE,
                             "SAAJ0551.soap.unsupported.encoding",
-                            new Object[] {sourceCharsetEncoding});
+                            new Object[] {getSourceCharsetEncoding()});
                         throw new SOAPExceptionImpl(
-                            "Unsupported encoding " + sourceCharsetEncoding,
+                            "Unsupported encoding " + getSourceCharsetEncoding(),
                             uee);
                     }
                 }
@@ -797,4 +792,8 @@
     public void detachNode() {
         // Nothing seems to be required to be done here
     }
+
+    public String getSourceCharsetEncoding() {
+        return sourceCharsetEncoding;
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPVersionMismatchException.java	Tue Aug  4 09:54:47 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/SOAPVersionMismatchException.java	Tue Aug  4 09:54:47 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: SOAPVersionMismatchException.java,v 1.6 2006/01/27 12:49:29 vj135062 Exp $
- * $Revision: 1.6 $
- * $Date: 2006/01/27 12:49:29 $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/StringDataContentHandler.java	Tue Aug  4 09:54:50 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/StringDataContentHandler.java	Tue Aug  4 09:54:49 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: StringDataContentHandler.java,v 1.6 2006/01/27 12:49:29 vj135062 Exp $
- * $Revision: 1.6 $
- * $Date: 2006/01/27 12:49:29 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
@@ -35,127 +30,139 @@
 import java.io.*;
 
 import javax.activation.*;
+import com.sun.xml.internal.messaging.saaj.packaging.mime.internet.MimeUtility;
+import com.sun.xml.internal.messaging.saaj.packaging.mime.util.ASCIIUtility;
+import com.sun.xml.internal.messaging.saaj.packaging.mime.internet.ContentType;
 
 /**
  * JAF data content handler for text/plain --> String
  *
- * @author Anil Vijendran
  */
 public class StringDataContentHandler implements DataContentHandler {
-    /**
-     * return the DataFlavors for this <code>DataContentHandler</code>
-     * @return The DataFlavors.
-     */
-    public DataFlavor[] getTransferDataFlavors() { // throws Exception;
-        DataFlavor flavors[] = new DataFlavor[2];
+    private static ActivationDataFlavor myDF = new ActivationDataFlavor(
+        java.lang.String.class,
+        "text/plain",
+        "Text String");
 
-        try {
-            flavors[0] =
-                new ActivationDataFlavor(
-                    Class.forName("java.lang.String"),
-                    "text/plain",
-                    "text string");
-        } catch (Exception e) {
-        }
+    protected ActivationDataFlavor getDF() {
+        return myDF;
+    }
 
-        flavors[1] = new DataFlavor("text/plain", "Plain Text");
-        return flavors;
+    /**
+     * Return the DataFlavors for this <code>DataContentHandler</code>.
+     *
+     * @return The DataFlavors
+     */
+    public DataFlavor[] getTransferDataFlavors() {
+        return new DataFlavor[] { getDF() };
     }
 
     /**
-     * return the Transfer Data of type DataFlavor from InputStream
-     * @param df The DataFlavor.
-     * @param ins The InputStream corresponding to the data.
-     * @return The constructed Object.
+     * Return the Transfer Data of type DataFlavor from InputStream.
+     *
+     * @param df The DataFlavor
+     * @param ds The DataSource corresponding to the data
+     * @return String object
      */
-    public Object getTransferData(DataFlavor df, DataSource ds) {
+    public Object getTransferData(DataFlavor df, DataSource ds)
+                        throws IOException {
+        // use myDF.equals to be sure to get ActivationDataFlavor.equals,
+        // which properly ignores Content-Type parameters in comparison
+        if (getDF().equals(df))
+            return getContent(ds);
+        else
+            return null;
+    }
 
-        // this is sort of hacky, but will work for the
-        // sake of testing...
-        if (df.getMimeType().startsWith("text/plain")) {
-            if (df
-                .getRepresentationClass()
-                .getName()
-                .equals("java.lang.String")) {
-                // spit out String
-                StringBuffer buf = new StringBuffer();
-                char data[] = new char[1024];
-                // InputStream is = null;
-                InputStreamReader isr = null;
-                int bytes_read = 0;
-                int total_bytes = 0;
+    public Object getContent(DataSource ds) throws IOException {
+        String enc = null;
+        InputStreamReader is = null;
 
-                try {
-                    isr = new InputStreamReader(ds.getInputStream());
+        try {
+            enc = getCharset(ds.getContentType());
+            is = new InputStreamReader(ds.getInputStream(), enc);
+        } catch (IllegalArgumentException iex) {
+            /*
+             * An unknown charset of the form ISO-XXX-XXX will cause
+             * the JDK to throw an IllegalArgumentException.  The
+             * JDK will attempt to create a classname using this string,
+             * but valid classnames must not contain the character '-',
+             * and this results in an IllegalArgumentException, rather than
+             * the expected UnsupportedEncodingException.  Yikes.
+             */
+            throw new UnsupportedEncodingException(enc);
+        }
 
-                    while (true) {
-                        bytes_read = isr.read(data);
-                        if (bytes_read > 0)
-                            buf.append(data, 0, bytes_read);
-                        else
-                            break;
-                        total_bytes += bytes_read;
-                    }
-                } catch (Exception e) {
-                }
+        try {
+            int pos = 0;
+            int count;
+            char buf[] = new char[1024];
 
-                return buf.toString();
-
-            } else if (
-                df.getRepresentationClass().getName().equals(
-                    "java.io.InputStream")) {
-                // spit out InputStream
-                try {
-                    return ds.getInputStream();
-                } catch (Exception e) {
+            while ((count = is.read(buf, pos, buf.length - pos)) != -1) {
+                pos += count;
+                if (pos >= buf.length) {
+                    int size = buf.length;
+                    if (size < 256*1024)
+                        size += size;
+                    else
+                        size += 256*1024;
+                    char tbuf[] = new char[size];
+                    System.arraycopy(buf, 0, tbuf, 0, pos);
+                    buf = tbuf;
                 }
             }
-
+            return new String(buf, 0, pos);
+        } finally {
+            try {
+                is.close();
+            } catch (IOException ex) { }
         }
-        return null;
     }
 
     /**
-     *
+     * Write the object to the output stream, using the specified MIME type.
      */
-    public Object getContent(DataSource ds) { // throws Exception;
-        StringBuffer buf = new StringBuffer();
-        char data[] = new char[1024];
-        // InputStream is = null;
-        InputStreamReader isr = null;
-        int bytes_read = 0;
-        int total_bytes = 0;
+    public void writeTo(Object obj, String type, OutputStream os)
+                        throws IOException {
+        if (!(obj instanceof String))
+            throw new IOException("\"" + getDF().getMimeType() +
+                "\" DataContentHandler requires String object, " +
+                "was given object of type " + obj.getClass().toString());
 
-        try {
-            isr = new InputStreamReader(ds.getInputStream());
+        String enc = null;
+        OutputStreamWriter osw = null;
 
-            while (true) {
-                bytes_read = isr.read(data);
-                if (bytes_read > 0)
-                    buf.append(data, 0, bytes_read);
-                else
-                    break;
-                total_bytes += bytes_read;
-            }
-        } catch (Exception e) {
+        try {
+            enc = getCharset(type);
+            osw = new OutputStreamWriter(os, enc);
+        } catch (IllegalArgumentException iex) {
+            /*
+             * An unknown charset of the form ISO-XXX-XXX will cause
+             * the JDK to throw an IllegalArgumentException.  The
+             * JDK will attempt to create a classname using this string,
+             * but valid classnames must not contain the character '-',
+             * and this results in an IllegalArgumentException, rather than
+             * the expected UnsupportedEncodingException.  Yikes.
+             */
+            throw new UnsupportedEncodingException(enc);
         }
 
-        return buf.toString();
+        String s = (String)obj;
+        osw.write(s, 0, s.length());
+        osw.flush();
     }
-    /**
-     * construct an object from a byte stream
-     * (similar semantically to previous method, we are deciding
-     *  which one to support)
-     */
-    public void writeTo(Object obj, String mimeType, OutputStream os)
-        throws IOException {
-        if (!mimeType.startsWith("text/plain"))
-            throw new IOException(
-                "Invalid type \"" + mimeType + "\" on StringDCH");
 
-        Writer out = new OutputStreamWriter(os);
-        out.write((String) obj);
-        out.flush();
+    private String getCharset(String type) {
+        try {
+            ContentType ct = new ContentType(type);
+            String charset = ct.getParameter("charset");
+            if (charset == null)
+                // If the charset parameter is absent, use US-ASCII.
+                charset = "us-ascii";
+            return MimeUtility.javaCharset(charset);
+        } catch (Exception ex) {
+            return null;
+        }
     }
 
 }
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/XmlDataContentHandler.java	Tue Aug  4 09:54:52 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/XmlDataContentHandler.java	Tue Aug  4 09:54:51 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: XmlDataContentHandler.java,v 1.12 2006/01/27 12:49:30 vj135062 Exp $
- * $Revision: 1.12 $
- * $Date: 2006/01/27 12:49:30 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap;
@@ -104,7 +99,7 @@
      */
     public void writeTo(Object obj, String mimeType, OutputStream os)
         throws IOException {
-        if (!mimeType.equals("text/xml") && !mimeType.equals("application/xml"))
+        if (!mimeType.startsWith("text/xml") && !mimeType.startsWith("application/xml"))
             throw new IOException(
                 "Invalid content type \"" + mimeType + "\" for XmlDCH");
 
@@ -116,7 +111,13 @@
                 // Streaming transform applies only to javax.xml.transform.StreamSource
                 transformer.transform((Source) getContent((DataSource)obj), result);
             } else {
-                transformer.transform((Source) obj, result);
+                Source src=null;
+                if (obj instanceof String) {
+                     src= new StreamSource(new java.io.StringReader((String) obj));
+                } else {
+                    src=(Source) obj;
+                }
+                transformer.transform(src, result);
             }
         } catch (Exception ex) {
             throw new IOException(
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/dynamic/SOAPFactoryDynamicImpl.java	Tue Aug  4 09:54:54 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/dynamic/SOAPFactoryDynamicImpl.java	Tue Aug  4 09:54:54 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: SOAPFactoryDynamicImpl.java,v 1.2 2006/01/27 12:49:32 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/dynamic/SOAPMessageFactoryDynamicImpl.java	Tue Aug  4 09:54:56 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/dynamic/SOAPMessageFactoryDynamicImpl.java	Tue Aug  4 09:54:56 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: SOAPMessageFactoryDynamicImpl.java,v 1.4 2006/01/27 12:49:32 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/BodyElementImpl.java	Tue Aug  4 09:54:58 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/BodyElementImpl.java	Tue Aug  4 09:54:58 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: BodyElementImpl.java,v 1.14 2006/01/27 12:49:33 vj135062 Exp $
- * $Revision: 1.14 $
- * $Date: 2006/01/27 12:49:33 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/BodyImpl.java	Tue Aug  4 09:55:01 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/BodyImpl.java	Tue Aug  4 09:55:00 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: BodyImpl.java,v 1.41 2006/01/27 12:49:34 vj135062 Exp $
- * $Revision: 1.41 $
- * $Date: 2006/01/27 12:49:34 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/CDATAImpl.java	Tue Aug  4 09:55:03 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/CDATAImpl.java	Tue Aug  4 09:55:02 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- *
- *
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/CommentImpl.java	Tue Aug  4 09:55:05 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/CommentImpl.java	Tue Aug  4 09:55:05 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- *
- *
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/DetailEntryImpl.java	Tue Aug  4 09:55:07 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/DetailEntryImpl.java	Tue Aug  4 09:55:07 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: DetailEntryImpl.java,v 1.8 2006/01/27 12:49:34 vj135062 Exp $
- * $Revision: 1.8 $
- * $Date: 2006/01/27 12:49:34 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/DetailImpl.java	Tue Aug  4 09:55:09 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/DetailImpl.java	Tue Aug  4 09:55:09 2009
@@ -22,13 +22,9 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: DetailImpl.java,v 1.16 2006/01/27 12:49:34 vj135062 Exp $
- * $Revision: 1.16 $
- * $Date: 2006/01/27 12:49:34 $
- */
 
 
+
 package com.sun.xml.internal.messaging.saaj.soap.impl;
 
 import java.util.Iterator;
@@ -125,4 +121,28 @@
        return true;
    }
 
+    //overriding this method since the only two uses of this method
+    // are in ElementImpl and DetailImpl
+    //whereas the original base impl does the correct job for calls to it inside ElementImpl
+    // But it would not work for DetailImpl.
+    protected SOAPElement circumventBug5034339(SOAPElement element) {
+
+        Name elementName = element.getElementName();
+        if (!isNamespaceQualified(elementName)) {
+            String prefix = elementName.getPrefix();
+            String defaultNamespace = getNamespaceURI(prefix);
+            if (defaultNamespace != null) {
+                Name newElementName =
+                    NameImpl.create(
+                        elementName.getLocalName(),
+                        elementName.getPrefix(),
+                        defaultNamespace);
+                SOAPElement newElement = createDetailEntry(newElementName);
+                replaceChild(newElement, element);
+                return newElement;
+            }
+        }
+        return element;
+    }
+
 }
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/ElementFactory.java	Tue Aug  4 09:55:12 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/ElementFactory.java	Tue Aug  4 09:55:11 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: ElementFactory.java,v 1.16 2006/01/27 12:49:35 vj135062 Exp $
- * $Revision: 1.16 $
- * $Date: 2006/01/27 12:49:35 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/ElementImpl.java	Tue Aug  4 09:55:14 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/ElementImpl.java	Tue Aug  4 09:55:13 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- *
- *
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
@@ -38,7 +33,6 @@
 import javax.xml.namespace.QName;
 import javax.xml.soap.*;
 
-import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
 import org.w3c.dom.*;
 import org.w3c.dom.Node;
 
@@ -64,6 +58,19 @@
         Logger.getLogger(LogDomainConstants.SOAP_IMPL_DOMAIN,
                          "com.sun.xml.internal.messaging.saaj.soap.impl.LocalStrings");
 
+    /**
+     * XML Information Set REC
+     * all namespace attributes (including those named xmlns,
+     * whose [prefix] property has no value) have a namespace URI of http://www.w3.org/2000/xmlns/
+     */
+    public final static String XMLNS_URI = "http://www.w3.org/2000/xmlns/".intern();
+
+    /**
+     * The XML Namespace ("http://www.w3.org/XML/1998/namespace"). This is
+     * the Namespace URI that is automatically mapped to the "xml" prefix.
+     */
+    public final static String XML_URI = "http://www.w3.org/XML/1998/namespace".intern();
+
     public ElementImpl(SOAPDocumentImpl ownerDoc, Name name) {
         super(
             ownerDoc,
@@ -141,11 +148,11 @@
     public String getNamespaceURI(String prefix) {
 
         if ("xmlns".equals(prefix)) {
-            return NamespaceContext.XMLNS_URI;
+            return XMLNS_URI;
         }
 
         if("xml".equals(prefix)) {
-            return NamespaceContext.XML_URI;
+            return XML_URI;
         }
 
         if ("".equals(prefix)) {
@@ -167,11 +174,11 @@
                         }
                     }*/
                     if (((Element) currentAncestor).hasAttributeNS(
-                            NamespaceContext.XMLNS_URI, "xmlns")) {
+                            XMLNS_URI, "xmlns")) {
 
                         String uri =
                             ((Element) currentAncestor).getAttributeNS(
-                                NamespaceContext.XMLNS_URI, "xmlns");
+                                XMLNS_URI, "xmlns");
                         if ("".equals(uri))
                             return null;
                         else {
@@ -204,9 +211,9 @@
                 //}
 
                 if (((Element) currentAncestor).hasAttributeNS(
-                        NamespaceContext.XMLNS_URI, prefix)) {
+                        XMLNS_URI, prefix)) {
                     return ((Element) currentAncestor).getAttributeNS(
-                               NamespaceContext.XMLNS_URI, prefix);
+                               XMLNS_URI, prefix);
                 }
 
                 currentAncestor = currentAncestor.getParentNode();
@@ -492,7 +499,7 @@
 
         uri = uri.length() == 0 ? null : uri;
         if (qualifiedName.equals("xmlns")) {
-            uri = NamespaceContext.XMLNS_URI;
+            uri = XMLNS_URI;
         }
 
         if (uri == null) {
@@ -505,9 +512,9 @@
     public SOAPElement addNamespaceDeclaration(String prefix, String uri)
         throws SOAPException {
         if (prefix.length() > 0) {
-            setAttributeNS(NamespaceContext.XMLNS_URI, "xmlns:" + prefix, uri);
+            setAttributeNS(XMLNS_URI, "xmlns:" + prefix, uri);
         } else {
-            setAttributeNS(NamespaceContext.XMLNS_URI, "xmlns", uri);
+            setAttributeNS(XMLNS_URI, "xmlns", uri);
         }
         //Fix for CR:6474641
         //tryToFindEncodingStyleAttributeName();
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/EnvelopeImpl.java	Tue Aug  4 09:55:16 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/EnvelopeImpl.java	Tue Aug  4 09:55:16 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: EnvelopeImpl.java,v 1.1.1.1 2006/01/27 13:10:56 kumarjayanti Exp $
- * $Revision: 1.1.1.1 $
- * $Date: 2006/01/27 13:10:56 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/FaultElementImpl.java	Tue Aug  4 09:55:18 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/FaultElementImpl.java	Tue Aug  4 09:55:18 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: FaultElementImpl.java,v 1.10 2006/01/27 12:49:35 vj135062 Exp $
- * $Revision: 1.10 $
- * $Date: 2006/01/27 12:49:35 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/FaultImpl.java	Tue Aug  4 09:55:21 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/FaultImpl.java	Tue Aug  4 09:55:20 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: FaultImpl.java,v 1.2 2006/11/16 17:39:10 kumarjayanti Exp $
- * $Revision: 1.2 $
- * $Date: 2006/11/16 17:39:10 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
@@ -100,7 +95,7 @@
         throws SOAPException {
 
         if (prefix == null || prefix.equals("")) {
-            if (uri == null || uri.equals("")) {
+            if (uri == null) {
                 log.severe("SAAJ0140.impl.no.ns.URI");
                 throw new SOAPExceptionImpl("No NamespaceURI, SOAP requires faultcode content to be a QName");
             }
@@ -121,7 +116,7 @@
         if (uri == null || uri.equals("")) {
             uri = this.faultCodeElement.getNamespaceURI(prefix);
         }
-        if (uri == null || uri.equals("")) {
+        if (uri == null) {
             log.severe("SAAJ0140.impl.no.ns.URI");
             throw new SOAPExceptionImpl("No NamespaceURI, SOAP requires faultcode content to be a QName");
         } else {
@@ -256,7 +251,7 @@
         }
     }
 
-    private SOAPFaultElement addFaultCodeElement() throws SOAPException {
+    protected SOAPFaultElement addFaultCodeElement() throws SOAPException {
         if (this.faultCodeElement == null)
             findFaultCodeElement();
         if (this.faultCodeElement == null) {
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/HeaderElementImpl.java	Tue Aug  4 09:55:23 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/HeaderElementImpl.java	Tue Aug  4 09:55:23 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: HeaderElementImpl.java,v 1.26 2006/01/27 12:49:35 vj135062 Exp $
- * $Revision: 1.26 $
- * $Date: 2006/01/27 12:49:35 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/HeaderImpl.java	Tue Aug  4 09:55:25 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/HeaderImpl.java	Tue Aug  4 09:55:25 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: HeaderImpl.java,v 1.33 2006/01/27 12:49:35 vj135062 Exp $
- * $Revision: 1.33 $
- * $Date: 2006/01/27 12:49:35 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/LocalStrings.properties	Tue Aug  4 09:55:27 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/LocalStrings.properties	Tue Aug  4 09:55:27 2009
@@ -46,7 +46,7 @@
 SAAJ0123.impl.no.reserved.xmlns=SAAJ0123: Cannot declare reserved xmlns prefix
 SAAJ0124.impl.qualified.name.cannot.be.xmlns=SAAJ0124: Qualified name cannot be xmlns
 #SAAJ0125.impl.URI.cannot.be.null=SAAJ0125: URI cannot be null
-SAAJ0126.impl.cannot.locate.ns=SAAJ0126: Unable to locate namespace for prefix {0} 
+SAAJ0126.impl.cannot.locate.ns=SAAJ0126: Unable to locate namespace for prefix {0}
 SAAJ0127.impl.no.null.for.parent.elem=SAAJ0127: Cannot pass NULL to setParentElement
 
 SAAJ0130.impl.header.elem.parent.mustbe.header=SAAJ0130: Parent of a SOAPHeaderElement has to be a SOAPHeader
@@ -83,4 +83,3 @@
 # Info messages
 SAAJ0190.impl.set.xml.declaration=SAAJ0190: Omit XML declaration set to {0}
 SAAJ0191.impl.set.encoding=SAAJ0191: Encoding is set to {0}
- 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/TextImpl.java	Tue Aug  4 09:55:30 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/TextImpl.java	Tue Aug  4 09:55:29 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- *
- *
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/TreeException.java	Tue Aug  4 09:55:32 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/impl/TreeException.java	Tue Aug  4 09:55:32 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: TreeException.java,v 1.5 2006/01/27 12:49:36 vj135062 Exp $
- * $Revision: 1.5 $
- * $Date: 2006/01/27 12:49:36 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.impl;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/name/LocalStrings.properties	Tue Aug  4 09:55:34 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/name/LocalStrings.properties	Tue Aug  4 09:55:34 2009
@@ -28,4 +28,3 @@
 # Error messages
 SAAJ0201.name.not.created.from.null.tag=SAAJ0201: Cannot create a name from a null tag
 SAAJ0202.name.invalid.arg.format=SAAJ0202: Argument "{0}" must be of the form: prefix:localName
- 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/name/NameImpl.java	Tue Aug  4 09:55:36 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/name/NameImpl.java	Tue Aug  4 09:55:36 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- *
- *
- */
 
 
 package com.sun.xml.internal.messaging.saaj.soap.name;
@@ -38,10 +33,8 @@
 import javax.xml.soap.Name;
 import javax.xml.soap.SOAPConstants;
 
-import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
+//import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
 import org.w3c.dom.Element;
-
-import com.sun.xml.internal.messaging.saaj.soap.impl.ElementImpl;
 import com.sun.xml.internal.messaging.saaj.util.LogDomainConstants;
 
 public class NameImpl implements Name {
@@ -67,6 +60,13 @@
         Logger.getLogger(LogDomainConstants.NAMING_DOMAIN,
                          "com.sun.xml.internal.messaging.saaj.soap.name.LocalStrings");
 
+    /**
+     * XML Information Set REC
+     * all namespace attributes (including those named xmlns,
+     * whose [prefix] property has no value) have a namespace URI of http://www.w3.org/2000/xmlns/
+     */
+    public final static String XMLNS_URI = "http://www.w3.org/2000/xmlns/".intern();
+
     protected NameImpl(String name) {
         this.localName = name == null ? "" : name;
     }
@@ -77,9 +77,9 @@
         this.prefix = prefix == null ? "" : prefix;
 
         if (this.prefix.equals("xmlns") && this.uri.equals("")) {
-            this.uri = NamespaceContext.XMLNS_URI;
+            this.uri = XMLNS_URI;
         }
-        if (this.uri.equals(NamespaceContext.XMLNS_URI) && this.prefix.equals("")) {
+        if (this.uri.equals(XMLNS_URI) && this.prefix.equals("")) {
             this.prefix = "xmlns";
         }
     }
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Body1_1Impl.java	Tue Aug  4 09:55:39 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Body1_1Impl.java	Tue Aug  4 09:55:38 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: Body1_1Impl.java,v 1.14 2006/01/27 12:49:38 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/BodyElement1_1Impl.java	Tue Aug  4 09:55:41 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/BodyElement1_1Impl.java	Tue Aug  4 09:55:40 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: BodyElement1_1Impl.java,v 1.13 2006/01/27 12:49:39 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Detail1_1Impl.java	Tue Aug  4 09:55:43 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Detail1_1Impl.java	Tue Aug  4 09:55:43 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: Detail1_1Impl.java,v 1.12 2006/01/27 12:49:40 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/DetailEntry1_1Impl.java	Tue Aug  4 09:55:45 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/DetailEntry1_1Impl.java	Tue Aug  4 09:55:45 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: DetailEntry1_1Impl.java,v 1.13 2006/01/27 12:49:40 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Envelope1_1Impl.java	Tue Aug  4 09:55:47 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Envelope1_1Impl.java	Tue Aug  4 09:55:47 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: Envelope1_1Impl.java,v 1.8 2006/01/27 12:49:41 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Fault1_1Impl.java	Tue Aug  4 09:55:50 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Fault1_1Impl.java	Tue Aug  4 09:55:49 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
@@ -315,4 +312,65 @@
                        (NameImpl)qname);
     }
 
+    public void setFaultCode(String faultCode, String prefix, String uri)
+        throws SOAPException {
+        if (prefix == null || prefix.equals("")) {
+            if (uri != null && !"".equals(uri)) {
+                prefix = getNamespacePrefix(uri);
+                if (prefix == null || prefix.equals("")) {
+                    prefix = "ns0";
+                }
+            }
+        }
+
+
+        if (this.faultCodeElement == null)
+            findFaultCodeElement();
+
+        if (this.faultCodeElement == null)
+            this.faultCodeElement = addFaultCodeElement();
+        else
+            this.faultCodeElement.removeContents();
+
+        if (uri == null || uri.equals("")) {
+            if (prefix != null && !"".equals("prefix")) {
+                uri = this.faultCodeElement.getNamespaceURI(prefix);
+            }
+        }
+
+//        if (standardFaultCode(faultCode) &&
+//                ((uri == null) || uri.equals(""))) {
+//             log.log(Level.WARNING, "SAAJ0306.ver1_1.faultcode.incorrect.namespace", new Object[]{faultCode});
+//               // throw new SOAPExceptionImpl("Namespace Error, Standard Faultcode: " +  faultCode + ", should be in SOAP 1.1 Namespace");
+//        }
+
+        if (uri == null) {
+            //SOAP 1.1 Allows this
+            if (prefix != null && !"".equals(prefix)) {
+                log.severe("SAAJ0140.impl.no.ns.URI");
+                throw new SOAPExceptionImpl("No NamespaceURI, SOAP requires faultcode content to be a QName");
+            }
+        } else {
+            checkIfStandardFaultCode(faultCode, uri);
+            ((FaultElementImpl) this.faultCodeElement).ensureNamespaceIsDeclared(prefix, uri);
+        }
+
+        if (prefix == null || "".equals(prefix)) {
+            finallySetFaultCode(faultCode);
+        } else {
+            finallySetFaultCode(prefix + ":" + faultCode);
+        }
+    }
+
+    private boolean standardFaultCode(String faultCode) {
+        if (faultCode.equals("VersionMismatch") || faultCode.equals("MustUnderstand")
+            || faultCode.equals("Client") || faultCode.equals("Server")) {
+            return true;
+        }
+        if (faultCode.startsWith("VersionMismatch.") || faultCode.startsWith("MustUnderstand.")
+            || faultCode.startsWith("Client.") || faultCode.startsWith("Server.")) {
+            return true;
+        }
+        return false;
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/FaultElement1_1Impl.java	Tue Aug  4 09:55:52 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/FaultElement1_1Impl.java	Tue Aug  4 09:55:52 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: FaultElement1_1Impl.java,v 1.12 2006/01/27 12:49:41 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Header1_1Impl.java	Tue Aug  4 09:55:54 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Header1_1Impl.java	Tue Aug  4 09:55:54 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/HeaderElement1_1Impl.java	Tue Aug  4 09:55:56 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/HeaderElement1_1Impl.java	Tue Aug  4 09:55:56 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/LocalStrings.properties	Tue Aug  4 09:55:59 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/LocalStrings.properties	Tue Aug  4 09:55:58 2009
@@ -29,7 +29,7 @@
 # Error messages
 SAAJ0301.ver1_1.hdr.op.unsupported.in.SOAP1.1=SAAJ0301: Operation {0} not supported by SOAP 1.1
 SAAJ0302.ver1_1.hdr.attr.unsupported.in.SOAP1.1=SAAJ0302: {0} not supported by SOAP 1.1
-SAAJ0303.ver1_1.msg.op.unsupported.in.SOAP1.1=SAAJ0303: Operation {0} not supported by SOAP 1.1 
-SAAJ0304.ver1_1.msg.invalid.SOAP1.1=SAAJ0304: InputStream does not represent a valid SOAP 1.1 Message 
+SAAJ0303.ver1_1.msg.op.unsupported.in.SOAP1.1=SAAJ0303: Operation {0} not supported by SOAP 1.1
+SAAJ0304.ver1_1.msg.invalid.SOAP1.1=SAAJ0304: InputStream does not represent a valid SOAP 1.1 Message
 SAAJ0305.ver1_2.detail.exists.error=SAAJ0305: Cannot add Detail, Detail already exists
- 
+SAAJ0306.ver1_1.faultcode.incorrect.namespace=SAAJ0306: Namespace Warning, Standard Faultcode {0}, should ideally be in SOAP 1.1 Namespace
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Message1_1Impl.java	Tue Aug  4 09:56:01 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/Message1_1Impl.java	Tue Aug  4 09:56:00 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/SOAPFactory1_1Impl.java	Tue Aug  4 09:56:03 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/SOAPFactory1_1Impl.java	Tue Aug  4 09:56:03 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: SOAPFactory1_1Impl.java,v 1.1.1.1 2006/01/27 13:10:57 kumarjayanti Exp $
- */
 
 
 
@@ -61,10 +58,8 @@
             throw new IllegalArgumentException("reasonText argument for createFault was passed NULL");
         }
         Fault1_1Impl fault = new Fault1_1Impl(createDocument(), null);
-        fault.setFaultString(reasonText);
-
         fault.setFaultCode(faultCode);
-
+        fault.setFaultString(reasonText);
         return fault;
     }
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/SOAPMessageFactory1_1Impl.java	Tue Aug  4 09:56:05 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/SOAPMessageFactory1_1Impl.java	Tue Aug  4 09:56:05 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: SOAPMessageFactory1_1Impl.java,v 1.7 2006/01/27 12:49:42 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/SOAPPart1_1Impl.java	Tue Aug  4 09:56:07 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_1/SOAPPart1_1Impl.java	Tue Aug  4 09:56:07 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Body1_2Impl.java	Tue Aug  4 09:56:10 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Body1_2Impl.java	Tue Aug  4 09:56:09 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
@@ -50,7 +47,7 @@
 
 public class Body1_2Impl extends BodyImpl {
 
-    protected static  final Logger log =
+    protected static final Logger log =
         Logger.getLogger(Body1_2Impl.class.getName(),
                          "com.sun.xml.internal.messaging.saaj.soap.ver1_2.LocalStrings");
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/BodyElement1_2Impl.java	Tue Aug  4 09:56:12 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/BodyElement1_2Impl.java	Tue Aug  4 09:56:11 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: BodyElement1_2Impl.java,v 1.13 2006/01/27 12:49:44 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Detail1_2Impl.java	Tue Aug  4 09:56:14 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Detail1_2Impl.java	Tue Aug  4 09:56:14 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/DetailEntry1_2Impl.java	Tue Aug  4 09:56:17 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/DetailEntry1_2Impl.java	Tue Aug  4 09:56:16 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: DetailEntry1_2Impl.java,v 1.13 2006/01/27 12:49:45 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Envelope1_2Impl.java	Tue Aug  4 09:56:19 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Envelope1_2Impl.java	Tue Aug  4 09:56:19 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Fault1_2Impl.java	Tue Aug  4 09:56:21 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Fault1_2Impl.java	Tue Aug  4 09:56:21 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/FaultElement1_2Impl.java	Tue Aug  4 09:56:24 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/FaultElement1_2Impl.java	Tue Aug  4 09:56:23 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: FaultElement1_2Impl.java,v 1.13 2006/01/27 12:49:48 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Header1_2Impl.java	Tue Aug  4 09:56:26 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Header1_2Impl.java	Tue Aug  4 09:56:25 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/HeaderElement1_2Impl.java	Tue Aug  4 09:56:28 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/HeaderElement1_2Impl.java	Tue Aug  4 09:56:28 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/LocalStrings.properties	Tue Aug  4 09:56:30 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/LocalStrings.properties	Tue Aug  4 09:56:30 2009
@@ -53,4 +53,3 @@
 SAAJ0435.ver1_2.code.not.standard=SAAJ0435: {0} is not a standard Code value
 SAAJ0436.ver1_2.detail.exists.error=SAAJ0436: Cannot add Detail, Detail already exists
 SAAJ0437.ver1_2.version.mismatch.error=SAAJ0437: Incorrect SOAP version for Detail element, expected SOAP 1.2
- 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Message1_2Impl.java	Tue Aug  4 09:56:33 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/Message1_2Impl.java	Tue Aug  4 09:56:32 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: Message1_2Impl.java,v 1.18 2006/01/27 12:49:48 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/SOAPFactory1_2Impl.java	Tue Aug  4 09:56:35 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/SOAPFactory1_2Impl.java	Tue Aug  4 09:56:34 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: SOAPFactory1_2Impl.java,v 1.1.1.1 2006/01/27 13:10:57 kumarjayanti Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/SOAPMessageFactory1_2Impl.java	Tue Aug  4 09:56:37 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/SOAPMessageFactory1_2Impl.java	Tue Aug  4 09:56:37 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: SOAPMessageFactory1_2Impl.java,v 1.7 2006/01/27 12:49:48 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/SOAPPart1_2Impl.java	Tue Aug  4 09:56:39 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/soap/ver1_2/SOAPPart1_2Impl.java	Tue Aug  4 09:56:39 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- *
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/Base64.java	Tue Aug  4 09:56:41 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/Base64.java	Tue Aug  4 09:56:41 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: Base64.java,v 1.4 2006/01/27 12:49:50 vj135062 Exp $
- * $Revision: 1.4 $
- * $Date: 2006/01/27 12:49:50 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.util;
@@ -43,7 +38,7 @@
  * This class is used by XML Schema binary format validation
  *
  * @author Jeffrey Rodriguez
- * @version $Revision: 1.4 $ $Date: 2006/01/27 12:49:50 $
+ * @version
  */
 public final class Base64 {
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/ByteInputStream.java	Tue Aug  4 09:56:44 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/ByteInputStream.java	Tue Aug  4 09:56:43 2009
@@ -22,12 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: ByteInputStream.java,v 1.6 2006/01/27 12:49:51 vj135062 Exp $ $Revision:
- * 1.3 $ $Date: 2006/01/27 12:49:51 $
- */
-
-
 package com.sun.xml.internal.messaging.saaj.util;
 
 import java.io.ByteArrayInputStream;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/ByteOutputStream.java	Tue Aug  4 09:56:46 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/ByteOutputStream.java	Tue Aug  4 09:56:45 2009
@@ -22,10 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: ByteOutputStream.java,v 1.7 2006/01/27 12:49:51 vj135062 Exp $
- * $Revision: 1.7 $ $Date: 2006/01/27 12:49:51 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.util;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/CharReader.java	Tue Aug  4 09:56:48 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/CharReader.java	Tue Aug  4 09:56:48 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: CharReader.java,v 1.6 2006/01/27 12:49:51 vj135062 Exp $
- * $Revision: 1.6 $
- * $Date: 2006/01/27 12:49:51 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.util;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/CharWriter.java	Tue Aug  4 09:56:50 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/CharWriter.java	Tue Aug  4 09:56:50 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: CharWriter.java,v 1.6 2006/01/27 12:49:51 vj135062 Exp $
- * $Revision: 1.6 $
- * $Date: 2006/01/27 12:49:51 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.util;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/FastInfosetReflection.java	Tue Aug  4 09:56:52 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/FastInfosetReflection.java	Tue Aug  4 09:56:52 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: FastInfosetReflection.java,v 1.2 2006/06/06 18:46:01 sandoz Exp $
- * $Revision: 1.2 $
- * $Date: 2006/06/06 18:46:01 $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/FinalArrayList.java	Tue Aug  4 09:56:55 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/FinalArrayList.java	Tue Aug  4 09:56:54 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.messaging.saaj.util;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/JAXMStreamSource.java	Tue Aug  4 09:56:57 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/JAXMStreamSource.java	Tue Aug  4 09:56:56 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: JAXMStreamSource.java,v 1.9 2006/01/27 12:49:51 vj135062 Exp $
- * $Revision: 1.9 $
- * $Date: 2006/01/27 12:49:51 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.util;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/JaxmURI.java	Tue Aug  4 09:56:59 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/JaxmURI.java	Tue Aug  4 09:56:59 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: JaxmURI.java,v 1.4 2006/01/27 12:49:51 vj135062 Exp $
- * $Revision: 1.4 $
- * $Date: 2006/01/27 12:49:51 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.util;
@@ -67,7 +62,7 @@
 * default port for a specific scheme). Rather, it only knows the
 * grammar and basic set of operations that can be applied to a URI.
 *
-* @version  $Id: JaxmURI.java,v 1.4 2006/01/27 12:49:51 vj135062 Exp $
+* @version
 *
 **********************************************************************/
  public class JaxmURI implements Serializable {
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/LocalStrings.properties	Tue Aug  4 09:57:01 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/LocalStrings.properties	Tue Aug  4 09:57:01 2009
@@ -31,4 +31,3 @@
 SAAJ0603.util.setProperty.exception=SAAJ0603: Can't create RejectDoctypSaxFilter because XMLReader.setProperty threw an exception. See stack trace for detalis
 
 # Info messages
- 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/LogDomainConstants.java	Tue Aug  4 09:57:03 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/LogDomainConstants.java	Tue Aug  4 09:57:03 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: LogDomainConstants.java,v 1.5 2006/01/27 12:49:52 vj135062 Exp $
- * $Revision: 1.5 $
- * $Date: 2006/01/27 12:49:52 $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/MimeHeadersUtil.java	Tue Aug  4 09:57:06 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/MimeHeadersUtil.java	Tue Aug  4 09:57:05 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: MimeHeadersUtil.java,v 1.5 2006/01/27 12:49:52 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/NamespaceContextIterator.java	Tue Aug  4 09:57:08 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/NamespaceContextIterator.java	Tue Aug  4 09:57:07 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: NamespaceContextIterator.java,v 1.8 2006/01/27 12:49:52 vj135062 Exp $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/ParseUtil.java	Tue Aug  4 09:57:10 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/ParseUtil.java	Tue Aug  4 09:57:10 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: ParseUtil.java,v 1.5 2006/01/27 12:49:52 vj135062 Exp $
- * $Revision: 1.5 $
- * $Date: 2006/01/27 12:49:52 $
- */
 
 
 package com.sun.xml.internal.messaging.saaj.util;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/ParserPool.java	Tue Aug  4 09:57:12 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/ParserPool.java	Tue Aug  4 09:57:12 2009
@@ -22,11 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: ParserPool.java,v 1.5 2006/01/27 12:49:52 vj135062 Exp $
- * $Revision: 1.5 $
- * $Date: 2006/01/27 12:49:52 $
- */
 
 
 
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/RejectDoctypeSaxFilter.java	Tue Aug  4 09:57:14 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/RejectDoctypeSaxFilter.java	Tue Aug  4 09:57:14 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 package com.sun.xml.internal.messaging.saaj.util;
 
 import java.util.logging.Logger;
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/TeeInputStream.java	Tue Aug  4 09:57:17 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/TeeInputStream.java	Tue Aug  4 09:57:16 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 /*
  * Created on Feb 28, 2003
  *
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/XMLDeclarationParser.java	Tue Aug  4 09:57:19 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/XMLDeclarationParser.java	Tue Aug  4 09:57:19 2009
@@ -22,7 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-
 package com.sun.xml.internal.messaging.saaj.util;
 
 import java.io.*;
@@ -36,7 +35,7 @@
  *  <?xml ... ?>
  *
  * @author Panos Kougiouris (panos@acm.org)
- * @version $Revision: 1.1.1.1 $ $Date: 2006/01/27 13:10:58 $
+ * @version
  */
 
 public class XMLDeclarationParser {
--- old/src/share/classes/com/sun/xml/internal/messaging/saaj/util/transform/EfficientStreamingTransformer.java	Tue Aug  4 09:57:21 2009
+++ new/src/share/classes/com/sun/xml/internal/messaging/saaj/util/transform/EfficientStreamingTransformer.java	Tue Aug  4 09:57:21 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 /*
  * EfficientStreamingTransformer.java
  *
@@ -64,21 +63,21 @@
 
   //static final String version;
   //static final String vendor;
+  //removing the static :security issue : see CR 6813167
+  private final TransformerFactory transformerFactory = TransformerFactory.newInstance();
 
-  protected static final TransformerFactory transformerFactory = TransformerFactory.newInstance();
+  /**
+  removing support for Java 1.4 and 1.3 : CR6658158
+  static {
+        version = System.getProperty("java.vm.version");
+        vendor = System.getProperty("java.vm.vendor");
+        if (vendor.startsWith("Sun") &&
+            (version.startsWith("1.4") || version.startsWith("1.3"))) {
+            transformerFactory =
+                new com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl();
+        }
+  }*/
 
-   //removing support for Java 1.4 and 1.3 : CR6658158
-    /*static {
-    version = System.getProperty("java.vm.version");
-    vendor = System.getProperty("java.vm.vendor");
-    if (vendor.startsWith("Sun") &&
-    (version.startsWith("1.4") || version.startsWith("1.3"))) {
-    transformerFactory =
-    new com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl();
-    }
-}
-*/
-
     /**
      * TransformerFactory instance.
      */
@@ -396,8 +395,9 @@
 
     /**
      * Threadlocal to hold a Transformer instance for this thread.
+     * removing this optimiztion :  see CR 6813167
      */
-    private static ThreadLocal effTransformer = new ThreadLocal();
+    //private static ThreadLocal effTransformer = new ThreadLocal();
 
     /**
      * Return Transformer instance for this thread, allocating a new one if
@@ -405,11 +405,14 @@
      * properties or any other data set on a previously used transformer.
      */
     public static Transformer newTransformer() {
-        Transformer tt = (Transformer) effTransformer.get();
+       //removing this optimiztion: see CR 6813167
+        /* Transformer tt = (Transformer) ef U15 :fTransformer.get();
         if (tt == null) {
             effTransformer.set(tt = new EfficientStreamingTransformer());
         }
         return tt;
+        */
+        return new EfficientStreamingTransformer();
     }
 
 }
--- old/src/share/classes/com/sun/xml/internal/org/jvnet/fastinfoset/FastInfosetSerializer.java	Tue Aug  4 09:57:23 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/fastinfoset/FastInfosetSerializer.java	Tue Aug  4 09:57:23 2009
@@ -102,12 +102,18 @@
         "http://jvnet.org/fastinfoset/parser/properties/external-vocabularies";
 
     /**
-     * The default value for the limit on the size of character content chunks
+     * The default minimum size of the character content chunks,
      * that will be indexed.
      */
-    public final static int CHARACTER_CONTENT_CHUNK_SIZE_CONSTRAINT = 32;
+    public final static int MIN_CHARACTER_CONTENT_CHUNK_SIZE = 0;
 
     /**
+     * The default maximum size of the character content chunks,
+     * that will be indexed.
+     */
+    public final static int MAX_CHARACTER_CONTENT_CHUNK_SIZE = 32;
+
+    /**
      * The default value for limit on the size of indexed Map for attribute values
      * Limit is measured in bytes not in number of entries
      */
@@ -114,13 +120,17 @@
     public static final int CHARACTER_CONTENT_CHUNK_MAP_MEMORY_CONSTRAINT = Integer.MAX_VALUE;
 
     /**
-     * The default value for the limit on the size of attribute values
-     * that will be indexed.
+     * The default minimum size of the attribute values, that will be indexed.
      */
-    public final static int ATTRIBUTE_VALUE_SIZE_CONSTRAINT = 32;
+    public final static int MIN_ATTRIBUTE_VALUE_SIZE = 0;
 
     /**
-     * The default value for limit on the size of indexed Map for character content chunks
+     * The default maximum size of the attribute values, that will be indexed.
+     */
+    public final static int MAX_ATTRIBUTE_VALUE_SIZE = 32;
+
+    /**
+     * The default value for limit on the size of indexed Map for attribute values
      * Limit is measured in bytes not in number of entries
      */
     public static final int ATTRIBUTE_VALUE_MAP_MEMORY_CONSTRAINT = Integer.MAX_VALUE;
@@ -217,32 +227,38 @@
     public Map getRegisteredEncodingAlgorithms();
 
     /**
-     * Sets the limit on the size of character content chunks
+     * Gets the minimum size of character content chunks
      * that will be indexed.
      *
-     * @param size The character content chunk size limit. Any chunk less
-     * that a length of size limit will be indexed.
+     * @return The minimum character content chunk size.
      */
-    public void setCharacterContentChunkSizeLimit(int size);
+    public int getMinCharacterContentChunkSize();
 
     /**
-     * Gets the limit on the size of character content chunks
+     * Sets the minimum size of character content chunks
      * that will be indexed.
      *
-     * @return The character content chunk size limit.
+     * @param size the minimum character content chunk size.
      */
-    public int getCharacterContentChunkSizeLimit();
+    public void setMinCharacterContentChunkSize(int size);
 
     /**
-     * Sets the limit on the memory size of Map of attribute values
+     * Gets the maximum size of character content chunks
      * that will be indexed.
      *
-     * @param size The attribute value size limit. Any value less
-     * that a length of size limit will be indexed.
+     * @return The maximum character content chunk size.
      */
-    public void setCharacterContentChunkMapMemoryLimit(int size);
+    public int getMaxCharacterContentChunkSize();
 
     /**
+     * Sets the maximum size of character content chunks
+     * that will be indexed.
+     *
+     * @param size the maximum character content chunk size.
+     */
+    public void setMaxCharacterContentChunkSize(int size);
+
+    /**
      * Gets the limit on the memory size of Map of attribute values
      * that will be indexed.
      *
@@ -251,32 +267,47 @@
     public int getCharacterContentChunkMapMemoryLimit();
 
     /**
-     * Sets the limit on the size of attribute values
+     * Sets the limit on the memory size of Map of attribute values
      * that will be indexed.
      *
      * @param size The attribute value size limit. Any value less
      * that a length of size limit will be indexed.
      */
-    public void setAttributeValueSizeLimit(int size);
+    public void setCharacterContentChunkMapMemoryLimit(int size);
 
     /**
-     * Gets the limit on the size of attribute values
+     * Gets the minimum size of attribute values
      * that will be indexed.
      *
-     * @return The attribute value size limit.
+     * @return The minimum attribute values size.
      */
-    public int getAttributeValueSizeLimit();
+    public int getMinAttributeValueSize();
 
     /**
-     * Sets the limit on the memory size of Map of attribute values
+     * Sets the minimum size of attribute values
      * that will be indexed.
      *
-     * @param size The attribute value size limit. Any value less
-     * that a length of size limit will be indexed.
+     * @param size the minimum attribute values size.
      */
-    public void setAttributeValueMapMemoryLimit(int size);
+    public void setMinAttributeValueSize(int size);
 
     /**
+     * Gets the maximum size of attribute values
+     * that will be indexed.
+     *
+     * @return The maximum attribute values size.
+     */
+    public int getMaxAttributeValueSize();
+
+    /**
+     * Sets the maximum size of attribute values
+     * that will be indexed.
+     *
+     * @param size the maximum attribute values size.
+     */
+    public void setMaxAttributeValueSize(int size);
+
+    /**
      * Gets the limit on the memory size of Map of attribute values
      * that will be indexed.
      *
@@ -285,6 +316,15 @@
     public int getAttributeValueMapMemoryLimit();
 
     /**
+     * Sets the limit on the memory size of Map of attribute values
+     * that will be indexed.
+     *
+     * @param size The attribute value size limit. Any value less
+     * that a length of size limit will be indexed.
+     */
+    public void setAttributeValueMapMemoryLimit(int size);
+
+    /**
      * Set the external vocabulary that shall be used when serializing.
      *
      * @param v the vocabulary.
--- old/src/share/classes/com/sun/xml/internal/org/jvnet/fastinfoset/sax/helpers/EncodingAlgorithmAttributesImpl.java	Tue Aug  4 09:57:26 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/fastinfoset/sax/helpers/EncodingAlgorithmAttributesImpl.java	Tue Aug  4 09:57:25 2009
@@ -148,7 +148,7 @@
      * to see if the attribute is already in the list: that is
      * the responsibility of the application.</p>
      *
-     * @param uri The Namespace URI, or the empty string if
+     * @param URI The Namespace URI, or the empty string if
      *        none is available or Namespace processing is not
      *        being performed.
      * @param localName The local name, or the empty string if
@@ -183,7 +183,7 @@
      * to see if the attribute is already in the list: that is
      * the responsibility of the application.</p>
      *
-     * @param uri The Namespace URI, or the empty string if
+     * @param URI The Namespace URI, or the empty string if
      *        none is available or Namespace processing is not
      *        being performed.
      * @param localName The local name, or the empty string if
@@ -193,7 +193,7 @@
      * @param type The attribute type as a string.
      * @param value The attribute value.
      * @param index True if attribute should be indexed.
-     * @param index The alphabet associated with the attribute value,
+     * @param alphabet The alphabet associated with the attribute value,
      *              may be null if there is no associated alphabet.
      */
     public void addAttribute(String URI, String localName, String qName,
@@ -221,7 +221,7 @@
      * to see if the attribute is already in the list: that is
      * the responsibility of the application.</p>
      *
-     * @param uri The Namespace URI, or the empty string if
+     * @param URI The Namespace URI, or the empty string if
      *        none is available or Namespace processing is not
      *        being performed.
      * @param localName The local name, or the empty string if
@@ -259,7 +259,7 @@
      * to see if the attribute is already in the list: that is
      * the responsibility of the application.</p>
      *
-     * @param uri The Namespace URI, or the empty string if
+     * @param URI The Namespace URI, or the empty string if
      *        none is available or Namespace processing is not
      *        being performed.
      * @param localName The local name, or the empty string if
@@ -573,7 +573,7 @@
             int identifier, String URI, Object data) throws FastInfosetException, IOException {
         EncodingAlgorithm ea = null;
         if (identifier < EncodingConstants.ENCODING_ALGORITHM_BUILTIN_END) {
-            ea = BuiltInEncodingAlgorithmFactory.table[identifier];
+            ea = BuiltInEncodingAlgorithmFactory.getAlgorithm(identifier);
         } else if (identifier == EncodingAlgorithmIndexes.CDATA) {
             throw new EncodingAlgorithmException(
                     CommonResourceBundle.getInstance().getString("message.CDATAAlgorithmNotSupported"));
--- old/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/Base64Data.java	Tue Aug  4 09:57:28 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/Base64Data.java	Tue Aug  4 09:57:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.org.jvnet.staxex;
 
 import javax.activation.DataHandler;
@@ -44,6 +45,7 @@
 public class Base64Data implements CharSequence, Cloneable {
 
     // either dataHandler or (data,dataLen,mimeType?) must be present
+    // (note that having both is allowed)
 
     private DataHandler dataHandler;
 
@@ -73,6 +75,7 @@
 
     /**
      * Clone constructor
+     * @param that needs to be cloned
      */
     public Base64Data(Base64Data that) {
         that.get();
@@ -92,8 +95,10 @@
     /**
      * Fills in the data object by a portion of the byte[].
      *
+     * @param data actual data
      * @param len
      *      data[0] to data[len-1] are treated as the data.
+     * @param mimeType MIME type
      * @param cloneByRef
      *      true if data[] can be cloned by reference
      */
@@ -108,8 +113,10 @@
     /**
      * Fills in the data object by a portion of the byte[].
      *
+     * @param data actual data bytes
      * @param len
      *      data[0] to data[len-1] are treated as the data.
+     * @param mimeType MIME type
      */
     public void set(byte[] data, int len, String mimeType) {
         set(data,len,mimeType,false);
@@ -120,6 +127,7 @@
      *
      * @param data
      *      this buffer may be owned directly by the unmarshaleld JAXB object.
+     * @param mimeType MIME type
      */
     public void set(byte[] data,String mimeType) {
         set(data,data.length,mimeType,false);
@@ -127,6 +135,8 @@
 
     /**
      * Fills in the data object by a {@link DataHandler}.
+     *
+     * @param data DataHandler for the data
      */
     public void set(DataHandler data) {
         assert data!=null;
@@ -135,7 +145,11 @@
     }
 
     /**
-     * Gets the raw data.
+     * Gets the raw data. If the returned DataHandler is {@link StreamingDataHandler},
+     * callees may need to downcast to take advantage of its capabilities.
+     *
+     * @see StreamingDataHandler
+     * @return DataHandler for the data
      */
     public DataHandler getDataHandler() {
         if(dataHandler==null){
@@ -162,6 +176,8 @@
 
     /**
      * Gets the byte[] of the exact length.
+     *
+     * @return byte[] for data
      */
     public byte[] getExact() {
         get();
@@ -175,6 +191,9 @@
 
     /**
      * Gets the data as an {@link InputStream}.
+     *
+     * @return data as InputStream
+     * @throws IOException if i/o error occurs
      */
     public InputStream getInputStream() throws IOException {
         if(dataHandler!=null)
@@ -186,6 +205,8 @@
     /**
      * Returns false if this object only has {@link DataHandler} and therefore
      * {@link #get()} operation is likely going to be expensive.
+     *
+     * @return false if it has only DataHandler
      */
     public boolean hasData() {
         return data!=null;
@@ -193,6 +214,8 @@
 
     /**
      * Gets the raw data. The size of the byte array maybe larger than the actual length.
+     *
+     * @return data as byte[], the array may be larger
      */
     public byte[] get() {
         if(data==null) {
@@ -212,7 +235,18 @@
         return data;
     }
 
+    /**
+     * Gets the length of the binary data counted in bytes.
+     *
+     * Note that if this object encapsulates {@link DataHandler},
+     * this method would have to read the whole thing into {@code byte[]}
+     * just to count the length, because {@link DataHandler}
+     * doesn't easily expose the length.
+     *
+     * @return no of bytes
+     */
     public int getDataLen() {
+        get();
         return dataLen;
     }
 
--- old/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/Base64Encoder.java	Tue Aug  4 09:57:30 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/Base64Encoder.java	Tue Aug  4 09:57:30 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.org.jvnet.staxex;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/ByteArrayOutputStreamEx.java	Tue Aug  4 09:57:33 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/ByteArrayOutputStreamEx.java	Tue Aug  4 09:57:32 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.org.jvnet.staxex;
 
 import java.io.ByteArrayOutputStream;
--- old/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/NamespaceContextEx.java	Tue Aug  4 09:57:35 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/NamespaceContextEx.java	Tue Aug  4 09:57:34 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.org.jvnet.staxex;
 
 import javax.xml.namespace.NamespaceContext;
--- old/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/XMLStreamReaderEx.java	Tue Aug  4 09:57:37 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/XMLStreamReaderEx.java	Tue Aug  4 09:57:37 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.org.jvnet.staxex;
 
 import javax.xml.stream.XMLStreamReader;
--- old/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/XMLStreamWriterEx.java	Tue Aug  4 09:57:39 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/XMLStreamWriterEx.java	Tue Aug  4 09:57:39 2009
@@ -22,13 +22,12 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.org.jvnet.staxex;
 
-import com.sun.xml.internal.org.jvnet.staxex.XMLStreamReaderEx;
-
-import javax.xml.stream.XMLStreamWriter;
-import javax.xml.stream.XMLStreamException;
 import javax.activation.DataHandler;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
 import java.io.OutputStream;
 
 /**
@@ -85,6 +84,7 @@
      *
      * <p>
      * (data,start,len) triplet identifies the binary data to be written.
+     * After the method invocation, the callee owns the buffer.
      *
      * @param contentType
      *      this mandatory parameter identifies the MIME type of the binary data.
@@ -103,7 +103,7 @@
      * {@link DataHandler#getInputStream()}.
      *
      * @param data
-     *      always non-null.
+     *      always non-null. After this method call, the callee owns the data handler.
      */
     void writeBinary(DataHandler data) throws XMLStreamException;
 
@@ -132,7 +132,7 @@
      * Writes like {@link #writeCharacters(String)} but hides
      * actual data format.
      *
-     * @return
+     * @param data
      *      The {@link CharSequence} that represents the
      *      character infoset items to be written.
      *
@@ -144,10 +144,6 @@
      *      as binary data may take advantage of mor efficient
      *      data representation.)
      *
-     *      <p>
-     *      The object returned from this method belongs to the parser,
-     *      and its content is guaranteed to be the same only until
-     *      the {@link #next()} method is invoked.
      */
     void writePCDATA(CharSequence data) throws XMLStreamException;
 
--- old/src/share/classes/com/sun/xml/internal/rngom/binary/Messages.properties	Tue Aug  4 09:57:41 2009
+++ new/src/share/classes/com/sun/xml/internal/rngom/binary/Messages.properties	Tue Aug  4 09:57:41 2009
@@ -125,4 +125,3 @@
 # Fragments
 name_absent_namespace=\"{0}\"
 name_with_namespace=\"{1}\" from namespace \"{0}\"
- 
--- old/src/share/classes/com/sun/xml/internal/rngom/dt/builtin/Messages.properties	Tue Aug  4 09:57:44 2009
+++ new/src/share/classes/com/sun/xml/internal/rngom/dt/builtin/Messages.properties	Tue Aug  4 09:57:43 2009
@@ -25,4 +25,3 @@
 
 # Properties file specifying messages
 builtin_param=builtin datatypes do not have any parameters
- 
--- old/src/share/classes/com/sun/xml/internal/rngom/parse/Messages.properties	Tue Aug  4 09:57:46 2009
+++ new/src/share/classes/com/sun/xml/internal/rngom/parse/Messages.properties	Tue Aug  4 09:57:45 2009
@@ -26,4 +26,3 @@
 # common messages between XML and compact syntax parser
 parent_ref_outside_grammar=parentRef is used outside a grammar
 ref_outside_grammar=ref is used outside a grammar
- 
--- old/src/share/classes/com/sun/xml/internal/rngom/parse/compact/Messages.properties	Tue Aug  4 09:57:48 2009
+++ new/src/share/classes/com/sun/xml/internal/rngom/parse/compact/Messages.properties	Tue Aug  4 09:57:48 2009
@@ -45,4 +45,3 @@
 illegal_surrogate_pair=illegal surrogate pair
 relax_ng_namespace=annotations cannot have namespace URI \"http://relaxng.org/ns/structure/1.0\"
 top_level_follow_annotation=top-level pattern cannot have following annotations
- 
--- old/src/share/classes/com/sun/xml/internal/rngom/parse/xml/Messages.properties	Tue Aug  4 09:57:50 2009
+++ new/src/share/classes/com/sun/xml/internal/rngom/parse/xml/Messages.properties	Tue Aug  4 09:57:50 2009
@@ -61,4 +61,3 @@
 undefined_prefix=undefined prefix \"{0}\"
 value_contains_foreign_element=\"value\" element cannot contain foreign elements
 wrong_uri_version=namespace URI has wrong version: expected \"{0}\" but got \"{1}\"
- 
--- old/src/share/classes/com/sun/xml/internal/stream/buffer/AbstractProcessor.java	Tue Aug  4 09:57:52 2009
+++ new/src/share/classes/com/sun/xml/internal/stream/buffer/AbstractProcessor.java	Tue Aug  4 09:57:52 2009
@@ -48,13 +48,13 @@
     protected  static final int STATE_COMMENT_AS_STRING             = 15;
     protected  static final int STATE_PROCESSING_INSTRUCTION        = 16;
     protected  static final int STATE_END                           = 17;
-    protected  static final int[] _eiiStateTable = new int[256];
+    private  static final int[] _eiiStateTable = new int[256];
 
     protected  static final int STATE_NAMESPACE_ATTRIBUTE           = 1;
     protected  static final int STATE_NAMESPACE_ATTRIBUTE_P         = 2;
     protected  static final int STATE_NAMESPACE_ATTRIBUTE_P_U       = 3;
     protected  static final int STATE_NAMESPACE_ATTRIBUTE_U         = 4;
-    protected  static final int[] _niiStateTable = new int[256];
+    private  static final int[] _niiStateTable = new int[256];
 
     protected  static final int STATE_ATTRIBUTE_U_LN_QN             = 1;
     protected  static final int STATE_ATTRIBUTE_P_U_LN              = 2;
@@ -64,7 +64,7 @@
     protected  static final int STATE_ATTRIBUTE_P_U_LN_OBJECT       = 6;
     protected  static final int STATE_ATTRIBUTE_U_LN_OBJECT         = 7;
     protected  static final int STATE_ATTRIBUTE_LN_OBJECT           = 8;
-    protected  static final int[] _aiiStateTable = new int[256];
+    private  static final int[] _aiiStateTable = new int[256];
 
     static {
         /*
@@ -172,6 +172,18 @@
         return _eiiStateTable[readStructure()];
     }
 
+    protected static int getEIIState(int item) {
+        return _eiiStateTable[item];
+    }
+
+    protected static int getNIIState(int item) {
+        return _niiStateTable[item];
+    }
+
+    protected static int getAIIState(int item) {
+        return _aiiStateTable[item];
+    }
+
     protected final int readStructure16() {
         return (readStructure() << 8) | readStructure();
     }
--- old/src/share/classes/com/sun/xml/internal/stream/buffer/MutableXMLStreamBuffer.java	Tue Aug  4 09:57:55 2009
+++ new/src/share/classes/com/sun/xml/internal/stream/buffer/MutableXMLStreamBuffer.java	Tue Aug  4 09:57:54 2009
@@ -61,7 +61,7 @@
      * The default array size for the arrays used in internal representation
      * of the XML infoset.
      */
-    public static int DEFAULT_ARRAY_SIZE = 512;
+    public static final int DEFAULT_ARRAY_SIZE = 512;
 
     /**
      * Create a new MutableXMLStreamBuffer using the
--- old/src/share/classes/com/sun/xml/internal/stream/buffer/sax/SAXBufferCreator.java	Tue Aug  4 09:57:57 2009
+++ new/src/share/classes/com/sun/xml/internal/stream/buffer/sax/SAXBufferCreator.java	Tue Aug  4 09:57:56 2009
@@ -158,7 +158,7 @@
         _namespaceAttributes[_namespaceAttributesPtr++] = uri;
 
         if (_namespaceAttributesPtr == _namespaceAttributes.length) {
-            final String[] namespaceAttributes = new String[_namespaceAttributesPtr * 3 / 2 + 1];
+            final String[] namespaceAttributes = new String[_namespaceAttributesPtr * 2];
             System.arraycopy(_namespaceAttributes, 0, namespaceAttributes, 0, _namespaceAttributesPtr);
             _namespaceAttributes = namespaceAttributes;
         }
@@ -182,6 +182,10 @@
 
     private void storeAttributes(Attributes attributes) {
         for (int i = 0; i < attributes.getLength(); i++) {
+            // Skip NS attributes. Some versions of JDK seem to send wrong local name
+            // Also it is not stored correctly by the following.
+            if (attributes.getQName(i).startsWith("xmlns"))
+                continue;
             storeQualifiedName(T_ATTRIBUTE_LN,
                     attributes.getURI(i),
                     attributes.getLocalName(i),
--- old/src/share/classes/com/sun/xml/internal/stream/buffer/sax/SAXBufferProcessor.java	Tue Aug  4 09:57:59 2009
+++ new/src/share/classes/com/sun/xml/internal/stream/buffer/sax/SAXBufferProcessor.java	Tue Aug  4 09:57:59 2009
@@ -551,7 +551,7 @@
 
     private int processNamespaceAttributes(int item) throws SAXException {
         do {
-            switch(_niiStateTable[item]) {
+            switch(getNIIState(item)) {
                 case STATE_NAMESPACE_ATTRIBUTE:
                     // Undeclaration of default namespace
                     processNamespaceAttribute("", "");
@@ -584,7 +584,7 @@
 
     private void processAttributes(int item) throws SAXException {
         do {
-            switch(_aiiStateTable[item]) {
+            switch(getAIIState(item)) {
                 case STATE_ATTRIBUTE_U_LN_QN:
                     _attributes.addAttributeWithQName(readStructureString(), readStructureString(), readStructureString(), readStructureString(), readContentString());
                     break;
--- old/src/share/classes/com/sun/xml/internal/stream/buffer/stax/StreamBufferCreator.java	Tue Aug  4 09:58:01 2009
+++ new/src/share/classes/com/sun/xml/internal/stream/buffer/stax/StreamBufferCreator.java	Tue Aug  4 09:58:01 2009
@@ -25,6 +25,8 @@
 package com.sun.xml.internal.stream.buffer.stax;
 
 import com.sun.xml.internal.stream.buffer.AbstractCreator;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
  * {@link AbstractCreator} with additional convenience code.
@@ -34,6 +36,11 @@
  * @author Kohsuke Kawaguchi
  */
 abstract class StreamBufferCreator extends AbstractCreator {
+
+    private boolean checkAttributeValue = false;
+
+    protected List<String> attributeValuePrefixes = new ArrayList<String>();
+
     protected void storeQualifiedName(int item, String prefix, String uri, String localName) {
         if (uri != null && uri.length() > 0) {
             if (prefix != null && prefix.length() > 0) {
@@ -71,11 +78,33 @@
 
         storeStructureString(type);
         storeContentString(value);
+        if(checkAttributeValue && value.indexOf("://") == -1){  // the condition after && avoids looking inside URIs
+            int firstIndex = value.indexOf(":");
+            int lastIndex = value.lastIndexOf(":");  // Check last index of : as some SAML namespace have multiple ":"s
+            if(firstIndex != -1 && lastIndex == firstIndex){
+                String valuePrefix = value.substring(0, firstIndex);
+                if(!attributeValuePrefixes.contains(valuePrefix)){
+                    attributeValuePrefixes.add(valuePrefix);
+                }
+            }
+        }
     }
 
+    public final List getAttributeValuePrefixes(){
+        return attributeValuePrefixes;
+    }
+
     protected final void storeProcessingInstruction(String target, String data) {
         storeStructure(T_PROCESSING_INSTRUCTION);
         storeStructureString(target);
         storeStructureString(data);
     }
+
+    public final boolean isCheckAttributeValue(){
+        return checkAttributeValue;
+    }
+
+    public final void setCheckAttributeValue(boolean value){
+        this.checkAttributeValue = value;
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/stream/buffer/stax/StreamReaderBufferCreator.java	Tue Aug  4 09:58:04 2009
+++ new/src/share/classes/com/sun/xml/internal/stream/buffer/stax/StreamReaderBufferCreator.java	Tue Aug  4 09:58:03 2009
@@ -313,6 +313,28 @@
         }
     }
 
+    /**
+     * A low level method a create a structure element explicitly. This is useful when xsb is
+     * created from a fragment's XMLStreamReader and inscope namespaces can be passed using
+     * this method. Note that there is no way to enumerate namespaces from XMLStreamReader.
+     *
+     * For e.g: Say the SOAP message is as follows
+     *
+     *  <S:Envelope xmlns:n1=".."><S:Body><ns2:A> ...
+     *
+     * when xsb is to be created using a reader that is at <ns2:A> tag, the inscope
+     * namespace like 'n1' can be passed using this method.
+     *
+     * WARNING: Instead of using this, try other methods(if you don't know what you are
+     * doing).
+     *
+     * @param ns an array of the even length of the form { prefix0, uri0, prefix1, uri1, ... }.
+     */
+    public void storeElement(String nsURI, String localName, String prefix, String[] ns) {
+        storeQualifiedName(T_ELEMENT_LN, prefix, nsURI, localName);
+        storeNamespaceAttributes(ns);
+    }
+
     private void storeNamespaceAttributes(XMLStreamReader reader) {
         int count = reader.getNamespaceCount();
         for (int i = 0; i < count; i++) {
@@ -319,6 +341,15 @@
             storeNamespaceAttribute(reader.getNamespacePrefix(i), reader.getNamespaceURI(i));
         }
     }
+
+    /**
+     * @param ns an array of the even length of the form { prefix0, uri0, prefix1, uri1, ... }.
+     */
+    private void storeNamespaceAttributes(String[] ns) {
+        for (int i = 0; i < ns.length; i=i+2) {
+            storeNamespaceAttribute(ns[i], ns[i+1]);
+        }
+    }
 
     private void storeAttributes(XMLStreamReader reader) {
         int count = reader.getAttributeCount();
--- old/src/share/classes/com/sun/xml/internal/stream/buffer/stax/StreamReaderBufferProcessor.java	Tue Aug  4 09:58:06 2009
+++ new/src/share/classes/com/sun/xml/internal/stream/buffer/stax/StreamReaderBufferProcessor.java	Tue Aug  4 09:58:05 2009
@@ -215,7 +215,8 @@
         _characters = null;
         _charSequence = null;
         while(true) {// loop only if we read STATE_DOCUMENT
-            switch(readEiiState()) {
+            int eiiState = readEiiState();
+            switch(eiiState) {
                 case STATE_DOCUMENT:
                     // we'll always produce a full document, and we've already report START_DOCUMENT event.
                     // so simply skil this
@@ -311,7 +312,7 @@
                         return _eventType = END_DOCUMENT;
                     }
                 default:
-                    throw new XMLStreamException("Invalid State");
+                    throw new XMLStreamException("Internal XSB error: Invalid State="+eiiState);
             }
             // this should be unreachable
         }
@@ -597,9 +598,11 @@
         }
 
         try {
-            System.arraycopy(_characters, sourceStart, target,
-                    targetStart, length);
-            return length;
+            int remaining = _textLen - sourceStart;
+            int len = remaining > length ? length : remaining;
+            sourceStart += _textOffset;
+            System.arraycopy(_characters, sourceStart, target, targetStart, len);
+            return len;
         } catch (IndexOutOfBoundsException e) {
             throw new XMLStreamException(e);
         }
@@ -748,7 +751,7 @@
                 resizeNamespaceAttributes();
             }
 
-            switch(_niiStateTable[item]){
+            switch(getNIIState(item)){
                 case STATE_NAMESPACE_ATTRIBUTE:
                     // Undeclaration of default namespace
                     _namespaceAIIsPrefix[_namespaceAIIsEnd] =
@@ -782,7 +785,7 @@
 
     private void processAttributes(int item){
         do {
-            switch(_aiiStateTable[item]){
+            switch(getAIIState(item)){
                 case STATE_ATTRIBUTE_U_LN_QN: {
                     final String uri = readStructureString();
                     final String localName = readStructureString();
@@ -801,6 +804,8 @@
                     _attributeCache.addAttributeWithPrefix("", "", readStructureString(), readStructureString(), readContentString());
                     break;
                 }
+                default :
+                    assert false : "Internal XSB Error: wrong attribute state, Item="+item;
             }
             readStructure();
 
--- old/src/share/classes/com/sun/xml/internal/stream/buffer/stax/StreamWriterBufferCreator.java	Tue Aug  4 09:58:08 2009
+++ new/src/share/classes/com/sun/xml/internal/stream/buffer/stax/StreamWriterBufferCreator.java	Tue Aug  4 09:58:08 2009
@@ -258,8 +258,10 @@
     }
 
     public void writeBinary(DataHandler dataHandler) throws XMLStreamException {
-        // TODO
-        throw new UnsupportedOperationException();
+        Base64Data d = new Base64Data();
+        d.set(dataHandler);
+        storeStructure(T_TEXT_AS_OBJECT);
+        storeContentObject(d);
     }
 
     public OutputStream writeBinary(String endpointURL) throws XMLStreamException {
--- old/src/share/classes/com/sun/xml/internal/stream/buffer/stax/StreamWriterBufferProcessor.java	Tue Aug  4 09:58:10 2009
+++ new/src/share/classes/com/sun/xml/internal/stream/buffer/stax/StreamWriterBufferProcessor.java	Tue Aug  4 09:58:10 2009
@@ -27,6 +27,12 @@
 
 import com.sun.xml.internal.stream.buffer.AbstractProcessor;
 import com.sun.xml.internal.stream.buffer.XMLStreamBuffer;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
 import com.sun.xml.internal.org.jvnet.staxex.XMLStreamWriterEx;
 
 import javax.xml.stream.XMLStreamException;
@@ -96,6 +102,8 @@
     /**
      * Writes a full XML infoset event to the given writer,
      * including start/end document.
+     * Any inscope namespaces present will be written as namespace
+     * delcarations on each top-level element.
      */
     public void write(XMLStreamWriter writer) throws XMLStreamException{
 
@@ -105,11 +113,8 @@
             writer.writeStartDocument();
         }
 
-        // TODO: if we are writing a fragment XMLStreamBuffer as a full document,
-        // we need to put in-scope namespaces as top-level ns decls.
-
         while(true) {
-            int item = _eiiStateTable[peekStructure()];
+            int item = getEIIState(peekStructure());
             writer.flush();
 
             switch(item) {
@@ -162,7 +167,8 @@
     /**
      * Writes the buffer as a fragment, meaning
      * the writer will not receive start/endDocument events.
-     *
+     * Any inscope namespaces present will be written as namespace
+     * delcarations on each top-level element.
      * <p>
      * If {@link XMLStreamBuffer} has a forest, this method will write all the forests.
      */
@@ -177,7 +183,7 @@
     public void writeFragmentEx(XMLStreamWriterEx writer) throws XMLStreamException {
         int depth = 0;  // used to determine when we are done with a tree.
 
-        int item = _eiiStateTable[peekStructure()];
+        int item = getEIIState(peekStructure());
         if(item==STATE_DOCUMENT)
             readStructure();    // skip STATE_DOCUMENT
 
@@ -194,7 +200,7 @@
                     final String localName = readStructureString();
                     final String prefix = getPrefixFromQName(readStructureString());
                     writer.writeStartElement(prefix,localName,uri);
-                    writeAttributes(writer);
+                    writeAttributes(writer, isInscope(depth));
                     break;
                 }
                 case STATE_ELEMENT_P_U_LN: {
@@ -203,7 +209,7 @@
                     final String uri = readStructureString();
                     final String localName = readStructureString();
                     writer.writeStartElement(prefix,localName,uri);
-                    writeAttributes(writer);
+                    writeAttributes(writer, isInscope(depth));
                     break;
                 }
                 case STATE_ELEMENT_U_LN: {
@@ -211,7 +217,7 @@
                     final String uri = readStructureString();
                     final String localName = readStructureString();
                     writer.writeStartElement("",localName,uri);
-                    writeAttributes(writer);
+                    writeAttributes(writer, isInscope(depth));
                     break;
                 }
                 case STATE_ELEMENT_LN: {
@@ -218,7 +224,7 @@
                     depth ++;
                     final String localName = readStructureString();
                     writer.writeStartElement(localName);
-                    writeAttributes(writer);
+                    writeAttributes(writer, isInscope(depth));
                     break;
                 }
                 case STATE_TEXT_AS_CHAR_ARRAY_SMALL: {
@@ -286,7 +292,7 @@
     public void writeFragmentNoEx(XMLStreamWriter writer) throws XMLStreamException {
         int depth = 0;
 
-        int item = _eiiStateTable[peekStructure()];
+        int item = getEIIState(peekStructure());
         if(item==STATE_DOCUMENT)
             readStructure();    // skip STATE_DOCUMENT
 
@@ -302,7 +308,7 @@
                     final String localName = readStructureString();
                     final String prefix = getPrefixFromQName(readStructureString());
                     writer.writeStartElement(prefix,localName,uri);
-                    writeAttributes(writer);
+                    writeAttributes(writer, isInscope(depth));
                     break;
                 }
                 case STATE_ELEMENT_P_U_LN: {
@@ -311,7 +317,7 @@
                     final String uri = readStructureString();
                     final String localName = readStructureString();
                     writer.writeStartElement(prefix,localName,uri);
-                    writeAttributes(writer);
+                    writeAttributes(writer, isInscope(depth));
                     break;
                 }
                 case STATE_ELEMENT_U_LN: {
@@ -319,7 +325,7 @@
                     final String uri = readStructureString();
                     final String localName = readStructureString();
                     writer.writeStartElement("",localName,uri);
-                    writeAttributes(writer);
+                    writeAttributes(writer, isInscope(depth));
                     break;
                 }
                 case STATE_ELEMENT_LN: {
@@ -326,7 +332,7 @@
                     depth ++;
                     final String localName = readStructureString();
                     writer.writeStartElement(localName);
-                    writeAttributes(writer);
+                    writeAttributes(writer, isInscope(depth));
                     break;
                 }
                 case STATE_TEXT_AS_CHAR_ARRAY_SMALL: {
@@ -391,37 +397,81 @@
 
     }
 
-    private void writeAttributes(XMLStreamWriter writer) throws XMLStreamException {
+    private boolean isInscope(int depth) {
+        return _buffer.getInscopeNamespaces().size() > 0 && depth ==1;
+    }
+
+    /*
+     * @param inscope: true means write inscope namespaces
+     */
+    private void writeAttributes(XMLStreamWriter writer, boolean inscope) throws XMLStreamException {
+        // prefixSet to collect prefixes that are written before writing inscope namespaces
+        Set<String> prefixSet = inscope ? new HashSet<String>() : Collections.<String>emptySet();
         int item = peekStructure();
         if ((item & TYPE_MASK) == T_NAMESPACE_ATTRIBUTE) {
             // Skip the namespace declarations on the element
             // they will have been added already
-            item = writeNamespaceAttributes(item, writer);
+            item = writeNamespaceAttributes(item, writer, inscope, prefixSet);
         }
+        if (inscope) {
+            writeInscopeNamespaces(writer, prefixSet);
+        }
         if ((item & TYPE_MASK) == T_ATTRIBUTE) {
             writeAttributes(item, writer);
         }
     }
 
-    private int writeNamespaceAttributes(int item, XMLStreamWriter writer) throws XMLStreamException {
+    private static String fixNull(String s) {
+        if (s == null) return "";
+        else return s;
+    }
+
+    /*
+     * @param prefixSet: already written prefixes
+     */
+    private void writeInscopeNamespaces(XMLStreamWriter writer, Set<String> prefixSet) throws XMLStreamException {
+        for (Map.Entry<String, String> e : _buffer.getInscopeNamespaces().entrySet()) {
+            String key = fixNull(e.getKey());
+            // If the prefix is already written, do not write the prefix
+            if (!prefixSet.contains(key)) {
+                writer.writeNamespace(key, e.getValue());
+            }
+        }
+    }
+
+    private int writeNamespaceAttributes(int item, XMLStreamWriter writer, boolean collectPrefixes, Set<String> prefixSet) throws XMLStreamException {
         do {
-            switch(_niiStateTable[item]){
+            switch(getNIIState(item)){
                 case STATE_NAMESPACE_ATTRIBUTE:
                     // Undeclaration of default namespace
                     writer.writeDefaultNamespace("");
+                    if (collectPrefixes) {
+                        prefixSet.add("");
+                    }
                     break;
                 case STATE_NAMESPACE_ATTRIBUTE_P:
                     // Undeclaration of namespace
                     // Declaration with prefix
-                    writer.writeNamespace(readStructureString(), "");
+                    String prefix = readStructureString();
+                    writer.writeNamespace(prefix, "");
+                    if (collectPrefixes) {
+                        prefixSet.add(prefix);
+                    }
                     break;
                 case STATE_NAMESPACE_ATTRIBUTE_P_U:
                     // Declaration with prefix
-                    writer.writeNamespace(readStructureString(), readStructureString());
+                    prefix = readStructureString();
+                    writer.writeNamespace(prefix, readStructureString());
+                    if (collectPrefixes) {
+                        prefixSet.add(prefix);
+                    }
                     break;
                 case STATE_NAMESPACE_ATTRIBUTE_U:
                     // Default declaration
                     writer.writeDefaultNamespace(readStructureString());
+                    if (collectPrefixes) {
+                        prefixSet.add("");
+                    }
                     break;
             }
             readStructure();
@@ -434,7 +484,7 @@
 
     private void writeAttributes(int item, XMLStreamWriter writer) throws XMLStreamException {
         do {
-            switch(_aiiStateTable[item]) {
+            switch(getAIIState(item)) {
                 case STATE_ATTRIBUTE_U_LN_QN: {
                     final String uri = readStructureString();
                     final String localName = readStructureString();
--- old/src/share/classes/com/sun/xml/internal/txw2/NamespaceSupport.java	Tue Aug  4 09:58:13 2009
+++ new/src/share/classes/com/sun/xml/internal/txw2/NamespaceSupport.java	Tue Aug  4 09:58:12 2009
@@ -27,7 +27,6 @@
 // http://www.saxproject.org
 // Written by David Megginson
 // This class is in the Public Domain.  NO WARRANTY!
-// $Id: NamespaceSupport.java,v 1.1 2005/04/14 21:45:18 kohsuke Exp $
 
 package com.sun.xml.internal.txw2;
 
--- old/src/share/classes/com/sun/xml/internal/txw2/TXW.java	Tue Aug  4 09:58:15 2009
+++ new/src/share/classes/com/sun/xml/internal/txw2/TXW.java	Tue Aug  4 09:58:15 2009
@@ -26,6 +26,7 @@
 package com.sun.xml.internal.txw2;
 
 import com.sun.xml.internal.txw2.output.XmlSerializer;
+import com.sun.xml.internal.txw2.output.TXWSerializer;
 import com.sun.xml.internal.txw2.annotation.XmlElement;
 import com.sun.xml.internal.txw2.annotation.XmlNamespace;
 
@@ -84,6 +85,11 @@
      *      The target of the writing.
      */
     public static <T extends TypedXmlWriter> T create( Class<T> rootElement, XmlSerializer out ) {
+        if (out instanceof TXWSerializer) {
+            TXWSerializer txws = (TXWSerializer) out;
+            return txws.txw._element(rootElement);
+        }
+
         Document doc = new Document(out);
         QName n = getTagName(rootElement);
         return new ContainerElement(doc,null,n.getNamespaceURI(),n.getLocalPart())._cast(rootElement);
@@ -102,6 +108,10 @@
      * @see #create(Class,XmlSerializer)
      */
     public static <T extends TypedXmlWriter> T create( QName tagName, Class<T> rootElement, XmlSerializer out ) {
+        if (out instanceof TXWSerializer) {
+            TXWSerializer txws = (TXWSerializer) out;
+            return txws.txw._element(tagName,rootElement);
+        }
         return new ContainerElement(new Document(out),null,tagName.getNamespaceURI(),tagName.getLocalPart())._cast(rootElement);
     }
 }
--- old/src/share/classes/com/sun/xml/internal/txw2/annotation/XmlValue.java	Tue Aug  4 09:58:17 2009
+++ new/src/share/classes/com/sun/xml/internal/txw2/annotation/XmlValue.java	Tue Aug  4 09:58:17 2009
@@ -26,11 +26,7 @@
 package com.sun.xml.internal.txw2.annotation;
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 import static java.lang.annotation.ElementType.METHOD;
-
-import com.sun.xml.internal.txw2.DatatypeWriter;
-
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
--- old/src/share/classes/com/sun/xml/internal/txw2/output/ResultFactory.java	Tue Aug  4 09:58:20 2009
+++ new/src/share/classes/com/sun/xml/internal/txw2/output/ResultFactory.java	Tue Aug  4 09:58:19 2009
@@ -58,6 +58,8 @@
             return new DomSerializer((DOMResult) result);
         if (result instanceof StreamResult)
             return new StreamSerializer((StreamResult) result);
+        if (result instanceof TXWResult)
+            return new TXWSerializer(((TXWResult)result).getWriter());
 
         throw new UnsupportedOperationException("Unsupported Result type: " + result.getClass().getName());
     }
--- old/src/share/classes/com/sun/xml/internal/ws/addressing/EndpointReferenceUtil.java	Tue Aug  4 09:58:22 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/EndpointReferenceUtil.java	Tue Aug  4 09:58:21 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 package com.sun.xml.internal.ws.addressing;
 
 import com.sun.istack.internal.NotNull;
@@ -238,7 +237,7 @@
                                 msEpr.referenceParameters = new MemberSubmissionEndpointReference.Elements();
                                 msEpr.referenceParameters.elements = new ArrayList<Element>();
                             }
-                            msEpr.referenceParameters.elements.add((Element) refParams.item(i));
+                            msEpr.referenceParameters.elements.add((Element) refParams.item(j));
                         }
                     }
                 } else if (child.getNamespaceURI().equals(AddressingVersion.W3C.nsUri) &&
--- old/src/share/classes/com/sun/xml/internal/ws/addressing/WsaClientTube.java	Tue Aug  4 09:58:24 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/WsaClientTube.java	Tue Aug  4 09:58:24 2009
@@ -27,9 +27,7 @@
 
 import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.ws.addressing.model.ActionNotSupportedException;
-import com.sun.xml.internal.ws.addressing.model.MapRequiredException;
 import com.sun.xml.internal.ws.api.WSBinding;
-import com.sun.xml.internal.ws.api.message.HeaderList;
 import com.sun.xml.internal.ws.api.message.Packet;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundOperation;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
@@ -44,10 +42,13 @@
  * WsaClientTube appears in the Tubeline only if addressing is enabled.
  * This tube checks the validity of addressing headers in the incoming messages
  * based on the WSDL model.
- *
+ * @author Rama Pulavarthi
  * @author Arun Gupta
  */
-public final class WsaClientTube extends WsaTube {
+public class WsaClientTube extends WsaTube {
+    // capture if the request expects a reply so that it can be used to
+    // determine if its oneway for response validation.
+    protected boolean expectReply = true;
     public WsaClientTube(WSDLPort wsdlPort, WSBinding binding, Tube next) {
         super(wsdlPort, binding, next);
     }
@@ -61,13 +62,16 @@
     }
 
     public @NotNull NextAction processRequest(Packet request) {
+        expectReply = request.expectReply;
         return doInvoke(next,request);
    }
 
     public @NotNull NextAction processResponse(Packet response) {
         // if one-way then, no validation
-        if (response.getMessage() != null)
+        if (response.getMessage() != null) {
             response = validateInboundHeaders(response);
+            response.addSatellite(new WsaPropertyBag(addressingVersion,soapVersion,response));
+        }
 
         return doReturnWith(response);
     }
@@ -74,7 +78,7 @@
 
 
     @Override
-    public void validateAction(Packet packet) {
+    protected void validateAction(Packet packet) {
         //There may not be a WSDL operation.  There may not even be a WSDL.
         //For instance this may be a RM CreateSequence message.
         WSDLBoundOperation wbo = getWSDLBoundOperation(packet);
@@ -91,14 +95,4 @@
             throw new ActionNotSupportedException(gotA);
     }
 
-    @Override
-    protected void checkMandatoryHeaders(Packet packet, boolean foundAction, boolean foundTo, boolean foundMessageID, boolean foundRelatesTo) {
-        super.checkMandatoryHeaders(packet, foundAction, foundTo, foundMessageID, foundRelatesTo);
-
-//        if(!foundRelatesTo)
-//            // RelatesTo required as per
-//            // Table 5-3 of http://www.w3.org/TR/2006/WD-ws-addr-wsdl-20060216/#wsdl11requestresponse
-//            throw new MapRequiredException(addressingVersion.relatesToTag);
-
-    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/addressing/WsaServerTube.java	Tue Aug  4 09:58:26 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/WsaServerTube.java	Tue Aug  4 09:58:26 2009
@@ -29,8 +29,8 @@
 import static com.sun.xml.internal.ws.addressing.W3CAddressingConstants.ONLY_ANONYMOUS_ADDRESS_SUPPORTED;
 import static com.sun.xml.internal.ws.addressing.W3CAddressingConstants.ONLY_NON_ANONYMOUS_ADDRESS_SUPPORTED;
 import com.sun.xml.internal.ws.addressing.model.ActionNotSupportedException;
-import com.sun.xml.internal.ws.addressing.model.InvalidMapException;
-import com.sun.xml.internal.ws.addressing.model.MapRequiredException;
+import com.sun.xml.internal.ws.addressing.model.InvalidAddressingHeaderException;
+import com.sun.xml.internal.ws.addressing.model.MissingAddressingHeaderException;
 import com.sun.xml.internal.ws.api.EndpointAddress;
 import com.sun.xml.internal.ws.api.SOAPVersion;
 import com.sun.xml.internal.ws.api.WSBinding;
@@ -42,12 +42,9 @@
 import com.sun.xml.internal.ws.api.message.Packet;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundOperation;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
-import com.sun.xml.internal.ws.api.pipe.ClientTubeAssemblerContext;
-import com.sun.xml.internal.ws.api.pipe.Fiber;
-import com.sun.xml.internal.ws.api.pipe.NextAction;
-import com.sun.xml.internal.ws.api.pipe.TransportTubeFactory;
-import com.sun.xml.internal.ws.api.pipe.Tube;
-import com.sun.xml.internal.ws.api.pipe.TubeCloner;
+import com.sun.xml.internal.ws.api.pipe.*;
+import com.sun.xml.internal.ws.api.server.WSEndpoint;
+import com.sun.xml.internal.ws.developer.JAXWSProperties;
 import com.sun.xml.internal.ws.message.FaultDetailHeader;
 import com.sun.xml.internal.ws.resources.AddressingMessages;
 
@@ -54,16 +51,18 @@
 import javax.xml.soap.SOAPFault;
 import javax.xml.ws.WebServiceException;
 import java.net.URI;
+import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
  * Handles WS-Addressing for the server.
  *
+ * @author Rama Pulavarthi
  * @author Kohsuke Kawaguchi
  * @author Arun Gupta
  */
-public final class WsaServerTube extends WsaTube {
-
+public class WsaServerTube extends WsaTube {
+    private WSEndpoint endpoint;
     // store the replyTo/faultTo of the message currently being processed.
     // both will be set to non-null in processRequest
     private WSEndpointReference replyTo;
@@ -74,12 +73,15 @@
      * Used for determining ReplyTo or Fault Action for non-anonymous responses     *
      */
     private WSDLBoundOperation wbo;
-    public WsaServerTube(@NotNull WSDLPort wsdlPort, WSBinding binding, Tube next) {
+    public WsaServerTube(WSEndpoint endpoint, @NotNull WSDLPort wsdlPort, WSBinding binding, Tube next) {
         super(wsdlPort, binding, next);
+        this.endpoint = endpoint;
+
     }
 
     public WsaServerTube(WsaServerTube that, TubeCloner cloner) {
         super(that, cloner);
+        endpoint = that.endpoint;
     }
 
     public WsaServerTube copy(TubeCloner cloner) {
@@ -90,6 +92,8 @@
         Message msg = request.getMessage();
         if(msg==null)   return doInvoke(next,request); // hmm?
 
+        // expose bunch of addressing related properties for advanced applications
+        request.addSatellite(new WsaPropertyBag(addressingVersion,soapVersion,request));
 
         // Store request ReplyTo and FaultTo in requestPacket.invocationProperties
         // so that they can be used after responsePacket is received.
@@ -97,19 +101,21 @@
 
         HeaderList hl = request.getMessage().getHeaders();
         try {
-        replyTo = hl.getReplyTo(addressingVersion, soapVersion);
-        faultTo = hl.getFaultTo(addressingVersion, soapVersion);
-        } catch (InvalidMapException e) {
-            SOAPFault soapFault = helper.newInvalidMapFault(e, addressingVersion);
+            replyTo = hl.getReplyTo(addressingVersion, soapVersion);
+            faultTo = hl.getFaultTo(addressingVersion, soapVersion);
+        } catch (InvalidAddressingHeaderException e) {
+            LOGGER.log(Level.WARNING,
+                    addressingVersion.getInvalidMapText()+", Problem header:" + e.getProblemHeader()+ ", Reason: "+ e.getSubsubcode(),e);
+            SOAPFault soapFault = helper.createInvalidAddressingHeaderFault(e, addressingVersion);
             // WS-A fault processing for one-way methods
-            if (request.getMessage().isOneWay(wsdlPort)) {
-                request.createServerResponse(null, wsdlPort, null, binding);
-                return doInvoke(next, request);
+            if ((wsdlPort!=null) && request.getMessage().isOneWay(wsdlPort)) {
+                Packet response = request.createServerResponse(null, wsdlPort, null, binding);
+                return doReturnWith(response);
             }
 
             Message m = Messages.create(soapFault);
             if (soapVersion == SOAPVersion.SOAP_11) {
-                FaultDetailHeader s11FaultDetailHeader = new FaultDetailHeader(addressingVersion, addressingVersion.problemHeaderQNameTag.getLocalPart(), e.getMapQName());
+                FaultDetailHeader s11FaultDetailHeader = new FaultDetailHeader(addressingVersion, addressingVersion.problemHeaderQNameTag.getLocalPart(), e.getProblemHeader());
                 m.getHeaders().add(s11FaultDetailHeader);
             }
 
@@ -116,15 +122,7 @@
             Packet response = request.createServerResponse(m, wsdlPort, null, binding);
             return doReturnWith(response);
         }
-        String messageId = hl.getMessageID(addressingVersion, soapVersion);
 
-        // TODO: This is probably not a very good idea.
-        // if someone wants to get this data, let them get from HeaderList.
-        // we can even provide a convenience method
-        //  -- KK.
-        request.invocationProperties.put(REQUEST_MESSAGE_ID, messageId);
-
-
         // defaulting
         if (replyTo == null)    replyTo = addressingVersion.anonymousEpr;
         if (faultTo == null)    faultTo = replyTo;
@@ -136,7 +134,7 @@
         // if one-way message and WS-A header processing fault has occurred,
         // then do no further processing
         if (p.getMessage() == null)
-            // TODO: record the problem that we are dropping this problem on the floor.
+            // request message is invalid, exception is logged by now  and response is sent back  with null message
             return doReturnWith(p);
 
         // if we find an error in addressing header, just turn around the direction here
@@ -201,7 +199,7 @@
         if (packet.transportBackChannel != null)
             packet.transportBackChannel.close();
 
-        if (packet.getMessage().isOneWay(wsdlPort)) {
+        if ((wsdlPort!=null) && packet.getMessage().isOneWay(wsdlPort)) {
             // one way message but with replyTo. I believe this is a hack for WS-TX - KK.
             LOGGER.fine(AddressingMessages.NON_ANONYMOUS_RESPONSE_ONEWAY());
             return;
@@ -219,7 +217,7 @@
         // we need to assemble a pipeline to talk to this endpoint.
         // TODO: what to pass as WSService?
         Tube transport = TransportTubeFactory.create(Thread.currentThread().getContextClassLoader(),
-            new ClientTubeAssemblerContext(adrs, wsdlPort, null, binding));
+            new ClientTubeAssemblerContext(adrs, wsdlPort, null, binding,endpoint.getContainer()));
 
         packet.endpointAddress = adrs;
         String action = packet.getMessage().isFault() ?
@@ -227,11 +225,12 @@
                 helper.getOutputAction(wbo);
         //set the SOAPAction, as its got to be same as wsa:Action
         packet.soapAction = action;
+        packet.expectReply = false;
         Fiber.current().runSync(transport, packet);
     }
 
     @Override
-    public void validateAction(Packet packet) {
+    protected void validateAction(Packet packet) {
         //There may not be a WSDL operation.  There may not even be a WSDL.
         //For instance this may be a RM CreateSequence message.
         WSDLBoundOperation wbo = getWSDLBoundOperation(packet);
@@ -254,9 +253,8 @@
         }
     }
 
-    @Override
-    public void checkCardinality(Packet packet) {
-        super.checkCardinality(packet);
+    protected void checkMessageAddressingProperties(Packet packet) {
+        super.checkMessageAddressingProperties(packet);
 
         // wsaw:Anonymous validation
         WSDLBoundOperation wbo = getWSDLBoundOperation(packet);
@@ -270,7 +268,7 @@
             try {
                 new EndpointAddress(URI.create(replyTo.getAddress()));
             } catch (Exception e) {
-                throw new InvalidMapException(addressingVersion.replyToTag, addressingVersion.invalidAddressTag);
+                throw new InvalidAddressingHeaderException(addressingVersion.replyToTag, addressingVersion.invalidAddressTag);
             }
         }
         //for now only validate ReplyTo
@@ -279,7 +277,7 @@
             try {
                 new EndpointAddress(URI.create(faultTo.getAddress()));
             } catch (IllegalArgumentException e) {
-                throw new InvalidMapException(addressingVersion.faultToTag, addressingVersion.invalidAddressTag);
+                throw new InvalidAddressingHeaderException(addressingVersion.faultToTag, addressingVersion.invalidAddressTag);
             }
         }
         */
@@ -286,24 +284,6 @@
 
     }
 
-    protected void checkMandatoryHeaders(
-        Packet packet, boolean foundAction, boolean foundTo, boolean foundMessageId, boolean foundRelatesTo) {
-        super.checkMandatoryHeaders(packet, foundAction, foundTo, foundMessageId, foundRelatesTo);
-        WSDLBoundOperation wbo = getWSDLBoundOperation(packet);
-        // no need to check for for non-application messages
-        if (wbo == null)
-            return;
-
-        // if no wsa:To header is found
-        if (!foundTo)
-            throw new MapRequiredException(addressingVersion.toTag);
-
-        // if two-way and no wsa:MessageID is found
-        if (!wbo.getOperation().isOneWay() && !foundMessageId)
-            throw new MapRequiredException(addressingVersion.messageIDTag);
-    }
-
-
     final void checkAnonymousSemantics(WSDLBoundOperation wbo, WSEndpointReference replyTo, WSEndpointReference faultTo) {
         // no check if Addressing is not enabled or is Member Submission
         if (addressingVersion == null || addressingVersion == AddressingVersion.MEMBER)
@@ -329,17 +309,17 @@
             break;
         case prohibited:
             if (replyToValue != null && replyToValue.equals(addressingVersion.anonymousUri))
-                throw new InvalidMapException(addressingVersion.replyToTag, ONLY_NON_ANONYMOUS_ADDRESS_SUPPORTED);
+                throw new InvalidAddressingHeaderException(addressingVersion.replyToTag, ONLY_NON_ANONYMOUS_ADDRESS_SUPPORTED);
 
             if (faultToValue != null && faultToValue.equals(addressingVersion.anonymousUri))
-                throw new InvalidMapException(addressingVersion.faultToTag, ONLY_NON_ANONYMOUS_ADDRESS_SUPPORTED);
+                throw new InvalidAddressingHeaderException(addressingVersion.faultToTag, ONLY_NON_ANONYMOUS_ADDRESS_SUPPORTED);
             break;
         case required:
             if (replyToValue != null && !replyToValue.equals(addressingVersion.anonymousUri))
-                throw new InvalidMapException(addressingVersion.replyToTag, ONLY_ANONYMOUS_ADDRESS_SUPPORTED);
+                throw new InvalidAddressingHeaderException(addressingVersion.replyToTag, ONLY_ANONYMOUS_ADDRESS_SUPPORTED);
 
             if (faultToValue != null && !faultToValue.equals(addressingVersion.anonymousUri))
-                throw new InvalidMapException(addressingVersion.faultToTag, ONLY_ANONYMOUS_ADDRESS_SUPPORTED);
+                throw new InvalidAddressingHeaderException(addressingVersion.faultToTag, ONLY_ANONYMOUS_ADDRESS_SUPPORTED);
             break;
         default:
             // cannot reach here
@@ -347,6 +327,10 @@
         }
     }
 
+    /**
+     * @deprecated
+     *      Use {@link JAXWSProperties#ADDRESSING_MESSAGEID}.
+     */
     public static final String REQUEST_MESSAGE_ID = "com.sun.xml.internal.ws.addressing.request.messageID";
 
     private static final Logger LOGGER = Logger.getLogger(WsaServerTube.class.getName());
--- old/src/share/classes/com/sun/xml/internal/ws/addressing/WsaTube.java	Tue Aug  4 09:58:28 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/WsaTube.java	Tue Aug  4 09:58:28 2009
@@ -26,8 +26,8 @@
 package com.sun.xml.internal.ws.addressing;
 
 import com.sun.istack.internal.NotNull;
-import com.sun.xml.internal.ws.addressing.model.InvalidMapException;
-import com.sun.xml.internal.ws.addressing.model.MapRequiredException;
+import com.sun.xml.internal.ws.addressing.model.InvalidAddressingHeaderException;
+import com.sun.xml.internal.ws.addressing.model.MissingAddressingHeaderException;
 import com.sun.xml.internal.ws.api.SOAPVersion;
 import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.addressing.AddressingVersion;
@@ -50,7 +50,10 @@
 import javax.xml.stream.XMLStreamException;
 import javax.xml.ws.WebServiceException;
 import javax.xml.ws.soap.AddressingFeature;
+import javax.xml.ws.soap.SOAPBinding;
 import java.util.Iterator;
+import java.util.logging.Logger;
+import java.util.logging.Level;
 
 /**
  * WS-Addressing processing code shared between client and server.
@@ -58,6 +61,7 @@
  * <p>
  * This tube is used only when WS-Addressing is enabled.
  *
+ * @author Rama Pulavarthi
  * @author Arun Gupta
  */
 abstract class WsaTube extends AbstractFilterTubeImpl {
@@ -119,25 +123,27 @@
      * a fault message and returns that. Otherwise
      * it will pass through the parameter 'packet' object to the return value.
      */
-    protected final Packet validateInboundHeaders(Packet packet) {
+    protected Packet validateInboundHeaders(Packet packet) {
         SOAPFault soapFault;
         FaultDetailHeader s11FaultDetailHeader;
 
         try {
-            checkCardinality(packet);
-
+            checkMessageAddressingProperties(packet);
             return packet;
-        } catch (InvalidMapException e) {
-            soapFault = helper.newInvalidMapFault(e, addressingVersion);
-            s11FaultDetailHeader = new FaultDetailHeader(addressingVersion, addressingVersion.problemHeaderQNameTag.getLocalPart(), e.getMapQName());
-        } catch (MapRequiredException e) {
-            soapFault = helper.newMapRequiredFault(e, addressingVersion);
-            s11FaultDetailHeader = new FaultDetailHeader(addressingVersion, addressingVersion.problemHeaderQNameTag.getLocalPart(), e.getMapQName());
+        } catch (InvalidAddressingHeaderException e) {
+            LOGGER.log(Level.WARNING,
+                    addressingVersion.getInvalidMapText()+", Problem header:" + e.getProblemHeader()+ ", Reason: "+ e.getSubsubcode(),e);
+            soapFault = helper.createInvalidAddressingHeaderFault(e, addressingVersion);
+            s11FaultDetailHeader = new FaultDetailHeader(addressingVersion, addressingVersion.problemHeaderQNameTag.getLocalPart(), e.getProblemHeader());
+        } catch (MissingAddressingHeaderException e) {
+            LOGGER.log(Level.WARNING,addressingVersion.getMapRequiredText()+", Problem header:"+ e.getMissingHeaderQName(),e);
+            soapFault = helper.newMapRequiredFault(e);
+            s11FaultDetailHeader = new FaultDetailHeader(addressingVersion, addressingVersion.problemHeaderQNameTag.getLocalPart(), e.getMissingHeaderQName());
         }
 
         if (soapFault != null) {
             // WS-A fault processing for one-way methods
-            if (packet.getMessage().isOneWay(wsdlPort)) {
+            if ((wsdlPort !=null)  && packet.getMessage().isOneWay(wsdlPort)) {
                 return packet.createServerResponse(null, wsdlPort, null, binding);
             }
 
@@ -146,13 +152,28 @@
                 m.getHeaders().add(s11FaultDetailHeader);
             }
 
-            Packet response = packet.createServerResponse(m, wsdlPort, null,  binding);
-            return response;
+            return packet.createServerResponse(m, wsdlPort, null,  binding);
         }
 
         return packet;
     }
 
+    /**
+     * This method checks all the WS-Addressing headers are valid and as per the spec definded rules.
+     * Mainly it checks the cardinality of the WSA headers and checks that mandatory headers exist.
+     * It also checks if the SOAPAction is equal to wsa:Action value when non-empty.
+     *
+     * Override this method if you need to additional checking of headers other than just existence of the headers.
+     * For ex: On server-side, check Anonymous and Non-Anonymous semantics in addition to checking cardinality.
+     *
+     * Override checkMandatoryHeaders(Packet p) to have different validation rules for different versions
+     *
+     * @param packet
+     */
+    protected void checkMessageAddressingProperties(Packet packet) {
+        checkCardinality(packet);
+    }
+
     final boolean isAddressingEngagedOrRequired(Packet packet, WSBinding binding) {
         if (AddressingVersion.isRequired(binding))
             return true;
@@ -187,7 +208,7 @@
      * <li>an uknown WS-Addressing header is present</li>
      * </ul>
      */
-    public void checkCardinality(Packet packet) {
+    protected void checkCardinality(Packet packet) {
         Message message = packet.getMessage();
         if (message == null) {
             if (addressingRequired)
@@ -202,7 +223,7 @@
             // no WS-A headers are found
             if (addressingRequired)
                 // if WS-A is required, then throw an exception looking for wsa:Action header
-                throw new MapRequiredException(addressingVersion.actionTag);
+                throw new MissingAddressingHeaderException(addressingVersion.actionTag,packet);
             else
                 // else no need to process
                 return;
@@ -284,7 +305,7 @@
 
         // check for invalid cardinality first before checking for mandatory headers
         if (duplicateHeader != null) {
-            throw new InvalidMapException(duplicateHeader, addressingVersion.invalidCardinalityTag);
+            throw new InvalidAddressingHeaderException(duplicateHeader, addressingVersion.invalidCardinalityTag);
         }
 
         // WS-A is engaged if wsa:Action header is found
@@ -296,7 +317,16 @@
         // Both wsa:Action and wsa:To MUST be present on request (for oneway MEP) and
         // response messages (for oneway and request/response MEP only)
         if (engaged || addressingRequired) {
-            checkMandatoryHeaders(packet, foundAction, foundTo, foundMessageId, foundRelatesTo);
+            // Check for mandatory headers always (even for Protocol messages).
+            // If it breaks any interop scenarios, Remove the comments.
+            /*
+            WSDLBoundOperation wbo = getWSDLBoundOperation(packet);
+            // no need to check for for non-application messages
+            if (wbo == null)
+                return;
+            */
+            checkMandatoryHeaders(packet, foundAction, foundTo, foundReplyTo,
+                    foundFaultTo, foundMessageId, foundRelatesTo);
         }
     }
 
@@ -306,18 +336,14 @@
         // TODO: always in current role, this may not to be fixed.
         if (binding == null)
             return true;
+        return ((SOAPBinding)binding).getRoles().contains(header.getRole(soapVersion));
 
-
-        if (soapVersion == SOAPVersion.SOAP_11) {
-            // Rama: Why not checking for SOAP 1.1?
-            return true;
-        } else {
-            String role = header.getRole(soapVersion);
-            return (role.equals(SOAPVersion.SOAP_12.implicitRole));
-        }
     }
 
     protected final WSDLBoundOperation getWSDLBoundOperation(Packet packet) {
+        //we can find Req/Response or Oneway only with WSDLModel
+        if(wsdlPort == null)
+            return null;
         return packet.getMessage().getOperation(wsdlPort);
     }
 
@@ -326,21 +352,34 @@
         if (gotA == null)
             throw new WebServiceException(AddressingMessages.VALIDATION_SERVER_NULL_ACTION());
         if(packet.soapAction != null && !packet.soapAction.equals("\"\"") && !packet.soapAction.equals("\""+gotA+"\"")) {
-            throw new InvalidMapException(addressingVersion.actionTag, addressingVersion.actionMismatchTag);
+            throw new InvalidAddressingHeaderException(addressingVersion.actionTag, addressingVersion.actionMismatchTag);
         }
     }
 
     protected abstract void validateAction(Packet packet);
-    protected void checkMandatoryHeaders(
-        Packet packet, boolean foundAction, boolean foundTo, boolean foundMessageId, boolean foundRelatesTo) {
-        WSDLBoundOperation wbo = getWSDLBoundOperation(packet);
-        // no need to check for for non-application messages
-        if (wbo == null)
-            return;
 
+    /**
+     * This should be called only when Addressing is engaged.
+     *
+     * Checks only for presence of wsa:Action and validates that wsa:Action
+     * equals SOAPAction header when non-empty
+     * Should be overridden if other wsa headers need to be checked based on version.
+     *
+     * @param packet
+     * @param foundAction
+     * @param foundTo
+     * @param foundReplyTo
+     * @param foundFaultTo
+     * @param foundMessageId
+     * @param foundRelatesTo
+     */
+    protected void checkMandatoryHeaders(
+        Packet packet, boolean foundAction, boolean foundTo, boolean foundReplyTo,
+            boolean foundFaultTo, boolean foundMessageId, boolean foundRelatesTo) {
         // if no wsa:Action header is found
         if (!foundAction)
-            throw new MapRequiredException(addressingVersion.actionTag);
+            throw new MissingAddressingHeaderException(addressingVersion.actionTag,packet);
         validateSOAPAction(packet);
     }
+    private static final Logger LOGGER = Logger.getLogger(WsaTube.class.getName());
 }
--- old/src/share/classes/com/sun/xml/internal/ws/addressing/WsaTubeHelper.java	Tue Aug  4 09:58:31 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/WsaTubeHelper.java	Tue Aug  4 09:58:30 2009
@@ -25,8 +25,8 @@
 
 package com.sun.xml.internal.ws.addressing;
 
-import com.sun.xml.internal.ws.addressing.model.InvalidMapException;
-import com.sun.xml.internal.ws.addressing.model.MapRequiredException;
+import com.sun.xml.internal.ws.addressing.model.InvalidAddressingHeaderException;
+import com.sun.xml.internal.ws.addressing.model.MissingAddressingHeaderException;
 import com.sun.xml.internal.ws.api.SOAPVersion;
 import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.addressing.AddressingVersion;
@@ -41,11 +41,8 @@
 import com.sun.xml.internal.ws.model.JavaMethodImpl;
 import com.sun.xml.internal.ws.model.CheckedExceptionImpl;
 import com.sun.istack.internal.Nullable;
-import com.sun.istack.internal.NotNull;
 import org.w3c.dom.Element;
 
-import javax.xml.bind.Marshaller;
-import javax.xml.bind.Unmarshaller;
 import javax.xml.namespace.QName;
 import javax.xml.soap.Detail;
 import javax.xml.soap.SOAPConstants;
@@ -218,10 +215,10 @@
     public String getSOAPAction(Packet packet) {
         String action = "";
 
-        if (packet == null)
+        if (packet == null || packet.getMessage() == null)
             return action;
 
-        if (packet.getMessage() == null)
+        if (wsdlPort == null)
             return action;
 
         WSDLBoundOperation op = packet.getMessage().getOperation(wsdlPort);
@@ -234,10 +231,11 @@
     }
 
     public String getOutputAction(Packet packet) {
-        String action = AddressingVersion.UNSET_OUTPUT_ACTION;
+        //String action = AddressingVersion.UNSET_OUTPUT_ACTION;
+        String action = null;
         if(seiModel!= null) {
             JavaMethodImpl jm = (JavaMethodImpl) packet.getMessage().getMethod(seiModel);
-            if(jm.getOutputAction() != null && !jm.getOutputAction().equals("")) {
+            if(jm != null && jm.getOutputAction() != null && !jm.getOutputAction().equals("")) {
                 return jm.getOutputAction();
             }
         }
@@ -257,8 +255,8 @@
         }
         return action;
     }
-    public SOAPFault newInvalidMapFault(InvalidMapException e, AddressingVersion av) {
-        QName name = e.getMapQName();
+    public SOAPFault createInvalidAddressingHeaderFault(InvalidAddressingHeaderException e, AddressingVersion av) {
+        QName name = e.getProblemHeader();
         QName subsubcode = e.getSubsubcode();
         QName subcode = av.invalidMapTag;
         String faultstring = String.format(av.getInvalidMapText(), name, subsubcode);
@@ -287,10 +285,10 @@
         }
     }
 
-    public SOAPFault newMapRequiredFault(MapRequiredException e, AddressingVersion av) {
-        QName subcode = av.mapRequiredTag;
-        QName subsubcode = av.mapRequiredTag;
-        String faultstring = av.getMapRequiredText();
+    public SOAPFault newMapRequiredFault(MissingAddressingHeaderException e) {
+        QName subcode = addVer.mapRequiredTag;
+        QName subsubcode = addVer.mapRequiredTag;
+        String faultstring = addVer.getMapRequiredText();
 
         try {
             SOAPFactory factory;
@@ -301,7 +299,7 @@
                 fault.setFaultCode(SOAPConstants.SOAP_SENDER_FAULT);
                 fault.appendFaultSubcode(subcode);
                 fault.appendFaultSubcode(subsubcode);
-                getMapRequiredDetail(e.getMapQName(), fault.addDetail());
+                getMapRequiredDetail(e.getMissingHeaderQName(), fault.addDetail());
             } else {
                 factory = SOAPVersion.SOAP_11.saajSoapFactory;
                 fault = factory.createFault();
@@ -320,8 +318,6 @@
     public abstract void getInvalidMapDetail(QName name, Element element);
     public abstract void getMapRequiredDetail(QName name, Element element);
 
-    protected Unmarshaller unmarshaller;
-    protected Marshaller marshaller;
     protected SEIModel seiModel;
     protected WSDLPort wsdlPort;
     protected WSBinding binding;
--- old/src/share/classes/com/sun/xml/internal/ws/addressing/WsaTubeHelperImpl.java	Tue Aug  4 09:58:33 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/WsaTubeHelperImpl.java	Tue Aug  4 09:58:33 2009
@@ -53,20 +53,19 @@
 
     public WsaTubeHelperImpl(WSDLPort wsdlPort, SEIModel seiModel, WSBinding binding) {
         super(binding,seiModel,wsdlPort);
-        try {
-            unmarshaller = jc.createUnmarshaller();
-            marshaller = jc.createMarshaller();
-            marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);
-        } catch (JAXBException e) {
-            throw new WebServiceException(e);
-        }
     }
 
+    private Marshaller createMarshaller() throws JAXBException {
+        Marshaller marshaller = jc.createMarshaller();
+        marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);
+        return marshaller;
+    }
+
     @Override
     public final void getProblemActionDetail(String action, Element element) {
         ProblemAction pa = new ProblemAction(action);
         try {
-            marshaller.marshal(pa, element);
+            createMarshaller().marshal(pa, element);
         } catch (JAXBException e) {
             throw new WebServiceException(e);
         }
@@ -76,7 +75,7 @@
     public final void getInvalidMapDetail(QName name, Element element) {
         ProblemHeaderQName phq = new ProblemHeaderQName(name);
         try {
-            marshaller.marshal(phq, element);
+            createMarshaller().marshal(phq, element);
         } catch (JAXBException e) {
             throw new WebServiceException(e);
         }
--- old/src/share/classes/com/sun/xml/internal/ws/addressing/model/ActionNotSupportedException.java	Tue Aug  4 09:58:35 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/model/ActionNotSupportedException.java	Tue Aug  4 09:58:35 2009
@@ -25,6 +25,8 @@
 
 package com.sun.xml.internal.ws.addressing.model;
 
+import com.sun.xml.internal.ws.resources.AddressingMessages;
+
 import javax.xml.ws.WebServiceException;
 
 /**
@@ -31,13 +33,10 @@
  * @author Arun Gupta
  */
 public class ActionNotSupportedException extends WebServiceException {
-    String action;
+    private String action;
 
-    protected ActionNotSupportedException() {
-        super();
-    }
-
     public ActionNotSupportedException(String action) {
+        super(AddressingMessages.ACTION_NOT_SUPPORTED_EXCEPTION(action));
         this.action = action;
     }
 
--- old/src/share/classes/com/sun/xml/internal/ws/addressing/v200408/WsaTubeHelperImpl.java	Tue Aug  4 09:58:37 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/v200408/WsaTubeHelperImpl.java	Tue Aug  4 09:58:37 2009
@@ -54,20 +54,19 @@
 
     public WsaTubeHelperImpl(WSDLPort wsdlPort, SEIModel seiModel, WSBinding binding) {
         super(binding,seiModel,wsdlPort);
-        try {
-            unmarshaller = jc.createUnmarshaller();
-            marshaller = jc.createMarshaller();
-            marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);
-        } catch (JAXBException e) {
-            throw new WebServiceException(e);
-        }
     }
 
+    private Marshaller createMarshaller() throws JAXBException {
+        Marshaller marshaller = jc.createMarshaller();
+        marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);
+        return marshaller;
+    }
+
     @Override
     public final void getProblemActionDetail(String action, Element element) {
         ProblemAction pa = new ProblemAction(action);
         try {
-            marshaller.marshal(pa, element);
+            createMarshaller().marshal(pa, element);
         } catch (JAXBException e) {
             throw new WebServiceException(e);
         }
@@ -77,7 +76,7 @@
     public final void getInvalidMapDetail(QName name, Element element) {
         ProblemHeaderQName phq = new ProblemHeaderQName(name);
         try {
-            marshaller.marshal(phq, element);
+            createMarshaller().marshal(phq, element);
         } catch (JAXBException e) {
             throw new WebServiceException(e);
         }
--- old/src/share/classes/com/sun/xml/internal/ws/api/BindingID.java	Tue Aug  4 09:58:40 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/BindingID.java	Tue Aug  4 09:58:39 2009
@@ -34,7 +34,10 @@
 import com.sun.xml.internal.ws.binding.WebServiceFeatureList;
 import com.sun.xml.internal.ws.encoding.SOAPBindingCodec;
 import com.sun.xml.internal.ws.encoding.XMLHTTPBindingCodec;
+import com.sun.xml.internal.ws.encoding.soap.streaming.SOAPNamespaceConstants;
+import com.sun.xml.internal.ws.encoding.soap.streaming.SOAP12NamespaceConstants;
 import com.sun.xml.internal.ws.util.ServiceFinder;
+import com.sun.xml.internal.ws.developer.JAXWSProperties;
 
 import javax.xml.ws.BindingType;
 import javax.xml.ws.WebServiceException;
@@ -96,6 +99,18 @@
         return BindingImpl.create(this);
     }
 
+    /**
+     * Returns wsdl:binding@transport attribute. Sub classes
+     * are expected to override this method to provide their transport
+     * attribute.
+     *
+     * @return wsdl:binding@transport attribute
+     * @since JAX-WS RI 2.1.6
+     */
+    public @NotNull String getTransport() {
+        return SOAPNamespaceConstants.TRANSPORT_HTTP;
+    }
+
     public final @NotNull WSBinding createBinding(WebServiceFeature... features) {
         return BindingImpl.create(this, features);
     }
@@ -228,6 +243,8 @@
     public static @NotNull BindingID parse(String lexical) {
         if(lexical.equals(XML_HTTP.toString()))
             return XML_HTTP;
+        if(lexical.equals(REST_HTTP.toString()))
+            return REST_HTTP;
         if(belongsTo(lexical,SOAP11_HTTP.toString()))
             return customize(lexical,SOAP11_HTTP);
         if(belongsTo(lexical,SOAP12_HTTP.toString()))
@@ -335,9 +352,18 @@
      */
     public static final BindingID XML_HTTP = new Impl(SOAPVersion.SOAP_11, HTTPBinding.HTTP_BINDING,false) {
         public Codec createEncoder(WSBinding binding) {
-            return new XMLHTTPBindingCodec();
+            return new XMLHTTPBindingCodec(binding);
         }
     };
+
+    /**
+     * Constant that represents REST.
+     */
+    private static final BindingID REST_HTTP = new Impl(SOAPVersion.SOAP_11, JAXWSProperties.REST_BINDING,true) {
+        public Codec createEncoder(WSBinding binding) {
+            return new XMLHTTPBindingCodec(binding);
+        }
+    };
 
     private static abstract class Impl extends BindingID {
         final SOAPVersion version;
--- old/src/share/classes/com/sun/xml/internal/ws/api/EndpointAddress.java	Tue Aug  4 09:58:42 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/EndpointAddress.java	Tue Aug  4 09:58:42 2009
@@ -193,6 +193,9 @@
      */
     public URLConnection openConnection() throws IOException {
         assert url!=null : uri+" doesn't have the corresponding URL";
+        if (url == null) {
+            throw new WebServiceException("URI="+uri+" doesn't have the corresponding URL");
+        }
         if(proxy!=null)
             return url.openConnection(proxy);
         else
--- old/src/share/classes/com/sun/xml/internal/ws/api/SOAPVersion.java	Tue Aug  4 09:58:44 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/SOAPVersion.java	Tue Aug  4 09:58:44 2009
@@ -25,6 +25,7 @@
 
 package com.sun.xml.internal.ws.api;
 
+import com.sun.xml.internal.bind.util.Which;
 import com.sun.xml.internal.ws.encoding.soap.SOAP12Constants;
 
 import javax.xml.namespace.QName;
@@ -167,6 +168,11 @@
             saajSoapFactory = SOAPFactory.newInstance(saajFactoryString);
         } catch (SOAPException e) {
             throw new Error(e);
+        } catch (NoSuchMethodError e) {
+            // SAAJ 1.3 is not in the classpath
+            LinkageError x = new LinkageError("You are loading old SAAJ from "+ Which.which(MessageFactory.class));
+            x.initCause(e);
+            throw x;
         }
         this.faultCodeMustUnderstand = faultCodeMustUnderstand;
         this.requiredRoles = requiredRoles;
--- old/src/share/classes/com/sun/xml/internal/ws/api/WSService.java	Tue Aug  4 09:58:46 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/WSService.java	Tue Aug  4 09:58:46 2009
@@ -25,7 +25,11 @@
 
 package com.sun.xml.internal.ws.api;
 
+import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.ws.api.addressing.WSEndpointReference;
+import com.sun.xml.internal.ws.api.server.Container;
+import com.sun.xml.internal.ws.api.server.ContainerResolver;
+import com.sun.xml.internal.ws.api.server.WSEndpoint;
 import com.sun.xml.internal.ws.client.WSServiceDelegate;
 
 import javax.xml.bind.JAXBContext;
@@ -84,6 +88,19 @@
     public abstract Dispatch<Object> createDispatch(QName portName, WSEndpointReference wsepr, JAXBContext jaxbContext, Service.Mode mode, WebServiceFeature... features);
 
     /**
+     * Gets the {@link Container} object.
+     *
+     * <p>
+     * The components inside {@link WSEndpoint} uses this reference
+     * to communicate with the hosting environment.
+     *
+     * @return
+     *      always same object. If no "real" {@link Container} instance
+     *      is given, {@link Container#NONE} will be returned.
+     */
+    public abstract @NotNull Container getContainer();
+
+    /**
      * Create a <code>Service</code> instance.
      *
      * The specified WSDL document location and service qualified name MUST
@@ -117,6 +134,69 @@
         return create(null,new QName(WSService.class.getName(),"dummy"));
     }
 
+    /**
+     * Typed parameter bag used by {@link WSService#create(URL, QName, InitParams)}
+     *
+     * @since 2.1.3
+     */
+    public static final class InitParams {
+        private Container container;
+        /**
+         * Sets the {@link Container} object used by the created service.
+         * This allows the client to use a specific {@link Container} instance
+         * as opposed to the one obtained by {@link ContainerResolver}.
+         */
+        public void setContainer(Container c) {
+            this.container = c;
+        }
+        public Container getContainer() {
+            return container;
+        }
+    }
+
+    /**
+     * To create a {@link Service}, we need to go through the API that doesn't let us
+     * pass parameters, so as a hack we use thread local.
+     */
+    protected static final ThreadLocal<InitParams> INIT_PARAMS = new ThreadLocal<InitParams>();
+
+    /**
+     * Used as a immutable constant so that we can avoid null check.
+     */
+    protected static final InitParams EMPTY_PARAMS = new InitParams();
+
+    /**
+     * Creates a {@link Service} instance.
+     *
+     * <p>
+     * This method works really like {@link Service#create(URL, QName)}
+     * except it takes one more RI specific parameter.
+     *
+     * @param wsdlDocumentLocation
+     *          {@code URL} for the WSDL document location for the service.
+     *          Can be null, in which case WSDL is not loaded.
+     * @param serviceName
+     *          {@code QName} for the service.
+     * @param properties
+     *          Additional RI specific initialization parameters. Can be null.
+     * @throws WebServiceException
+     *          If any error in creation of the specified service.
+     **/
+    public static Service create( URL wsdlDocumentLocation, QName serviceName, InitParams properties) {
+        if(INIT_PARAMS.get()!=null)
+            throw new IllegalStateException("someone left non-null InitParams");
+        INIT_PARAMS.set(properties);
+        try {
+            Service svc = Service.create(wsdlDocumentLocation, serviceName);
+            if(INIT_PARAMS.get()!=null)
+                throw new IllegalStateException("Service "+svc+" didn't recognize InitParams");
+            return svc;
+        } finally {
+            // even in case of an exception still reset INIT_PARAMS
+            INIT_PARAMS.set(null);
+        }
+    }
+
     /**
      * Obtains the {@link WSService} that's encapsulated inside a {@link Service}.
      *
--- old/src/share/classes/com/sun/xml/internal/ws/api/addressing/AddressingVersion.java	Tue Aug  4 09:58:49 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/addressing/AddressingVersion.java	Tue Aug  4 09:58:48 2009
@@ -522,6 +522,10 @@
      * {@link WSBinding} and for the {@link WSDLPort} port.
      *
      * @return WS-A version specific helper
+     *
+     * @deprecated
+     *     TODO  why are we exposing implementation specificc class through api?
+     *     TODO  Remove it if no one elase uses it.
      */
     public abstract WsaTubeHelper getWsaHelper(WSDLPort wsdlPort, SEIModel seiModel, WSBinding binding);
 
--- old/src/share/classes/com/sun/xml/internal/ws/api/addressing/OutboundReferenceParameterHeader.java	Tue Aug  4 09:58:51 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/addressing/OutboundReferenceParameterHeader.java	Tue Aug  4 09:58:50 2009
@@ -110,17 +110,18 @@
             reader.nextTag();   // move to the first element, which is the header element
 
             attributes = new FinalArrayList<Attribute>();
-
+            boolean refParamAttrWritten = false;
             for (int i = 0; i < reader.getAttributeCount(); i++) {
                 final String localName = reader.getAttributeLocalName(i);
                 final String namespaceURI = reader.getAttributeNamespace(i);
                 final String value = reader.getAttributeValue(i);
-
+                if(namespaceURI.equals(AddressingVersion.W3C.nsUri)&& localName.equals("IS_REFERENCE_PARAMETER"))
+                    refParamAttrWritten = true;
                 attributes.add(new Attribute(namespaceURI,localName,value));
             }
-
-            // we are adding one more attribute "wsa:IsReferenceParameter"
-            attributes.add(new Attribute(AddressingVersion.W3C.nsUri,IS_REFERENCE_PARAMETER,TRUE_VALUE));
+            // we are adding one more attribute "wsa:IsReferenceParameter", if its not alrady there
+            if(!refParamAttrWritten)
+                attributes.add(new Attribute(AddressingVersion.W3C.nsUri,IS_REFERENCE_PARAMETER,TRUE_VALUE));
         } catch (XMLStreamException e) {
             throw new WebServiceException("Unable to read the attributes for {"+nsUri+"}"+localName+" header",e);
         }
@@ -209,7 +210,7 @@
     public void writeTo(XMLStreamWriter w) throws XMLStreamException {
         infoset.writeToXMLStreamWriter(new XMLStreamWriterFilter(w) {
             private boolean root=true;
-
+            private boolean onRootEl = true;
             public void writeStartElement(String localName) throws XMLStreamException {
                 super.writeStartElement(localName);
                 writeAddedAttribute();
@@ -216,7 +217,10 @@
             }
 
             private void writeAddedAttribute() throws XMLStreamException {
-                if(!root)   return;
+                if(!root) {
+                    onRootEl = false;
+                    return;
+                }
                 root=false;
                 writeNamespace("wsa",AddressingVersion.W3C.nsUri);
                 super.writeAttribute("wsa",AddressingVersion.W3C.nsUri,IS_REFERENCE_PARAMETER,TRUE_VALUE);
@@ -245,6 +249,19 @@
                     super.writeNamespace(prefix,namespaceURI);
             }
 
+            public void writeAttribute(String prefix, String namespaceURI, String localName, String value) throws XMLStreamException {
+                //skip if its on root element and attribute is wsa;IsReferenceParameter, as we write it.
+                if(onRootEl && namespaceURI.equals(AddressingVersion.W3C.nsUri)
+                            && localName.equals(IS_REFERENCE_PARAMETER))
+                    return;
+
+                writer.writeAttribute(prefix, namespaceURI, localName, value);
+            }
+            public void writeAttribute(String namespaceURI, String localName, String value) throws XMLStreamException {
+
+
+                writer.writeAttribute(namespaceURI, localName, value);
+            }
             private boolean isPrefixDeclared(String prefix, String namespaceURI ) {
                 return namespaceURI.equals(getNamespaceContext().getNamespaceURI(prefix));
             }
@@ -271,14 +288,18 @@
                 if(depth++==0) {
                     // add one more attribute
                     super.startPrefixMapping("wsa",AddressingVersion.W3C.nsUri);
-                    AttributesImpl atts2 = new AttributesImpl(atts);
-                    atts2.addAttribute(
-                        AddressingVersion.W3C.nsUri,
-                        IS_REFERENCE_PARAMETER,
-                        "wsa:IsReferenceParameter",
-                        "CDATA",
-                        TRUE_VALUE);
-                    atts = atts2;
+
+                    //Add the attirbute wsa:IsReferenceParameter if not present already
+                    if(atts.getIndex(AddressingVersion.W3C.nsUri,IS_REFERENCE_PARAMETER) == -1) {
+                        AttributesImpl atts2 = new AttributesImpl(atts);
+                        atts2.addAttribute(
+                                AddressingVersion.W3C.nsUri,
+                                IS_REFERENCE_PARAMETER,
+                                "wsa:IsReferenceParameter",
+                                "CDATA",
+                                TRUE_VALUE);
+                        atts = atts2;
+                    }
                 }
 
                 super.startElement(uri, localName, qName, atts);
--- old/src/share/classes/com/sun/xml/internal/ws/api/addressing/WSEndpointReference.java	Tue Aug  4 09:58:53 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/addressing/WSEndpointReference.java	Tue Aug  4 09:58:53 2009
@@ -36,7 +36,7 @@
 import com.sun.xml.internal.stream.buffer.stax.StreamWriterBufferCreator;
 import com.sun.xml.internal.ws.addressing.EndpointReferenceUtil;
 import com.sun.xml.internal.ws.addressing.W3CAddressingConstants;
-import com.sun.xml.internal.ws.addressing.model.InvalidMapException;
+import com.sun.xml.internal.ws.addressing.model.InvalidAddressingHeaderException;
 import com.sun.xml.internal.ws.addressing.v200408.MemberSubmissionAddressingConstants;
 import com.sun.xml.internal.ws.api.message.Header;
 import com.sun.xml.internal.ws.api.message.HeaderList;
@@ -625,8 +625,8 @@
             } else
             if(localName.equals("Address")) {
                 if(address!=null) // double <Address>. That's an error.
-                    throw new InvalidMapException(new QName(version.nsUri,rootLocalName),AddressingVersion.fault_duplicateAddressInEpr);
-                address = xsr.getElementText();
+                    throw new InvalidAddressingHeaderException(new QName(version.nsUri,rootLocalName),AddressingVersion.fault_duplicateAddressInEpr);
+                address = xsr.getElementText().trim();
             } else {
                 XMLStreamReaderUtil.skipElement(xsr);
             }
@@ -641,7 +641,7 @@
         }
 
         if(address==null)
-            throw new InvalidMapException(new QName(version.nsUri,rootLocalName),version.fault_missingAddressInEpr);
+            throw new InvalidAddressingHeaderException(new QName(version.nsUri,rootLocalName),version.fault_missingAddressInEpr);
     }
 
 
@@ -656,8 +656,8 @@
     public XMLStreamReader read(final @NotNull String localName) throws XMLStreamException {
         return new StreamReaderBufferProcessor(infoset) {
             protected void processElement(String prefix, String uri, String _localName) {
-                if(_depth==0)
-                        _localName = localName;
+                if (_depth == 0)
+                    _localName = localName;
                 super.processElement(prefix, uri, _localName);
             }
         };
@@ -834,6 +834,8 @@
         private @Nullable QName portName;
         private @Nullable QName portTypeName; //interfaceName
         private @Nullable Source wsdlSource;
+        private @Nullable String wsdliLocation;
+
         public @Nullable QName getServiceName(){
             return serviceName;
         }
@@ -846,6 +848,9 @@
         public @Nullable Source getWsdlSource(){
             return wsdlSource;
         }
+        public @Nullable String getWsdliLocation(){
+            return wsdliLocation;
+        }
 
         private Metadata() {
             try {
@@ -875,6 +880,9 @@
                 do {
                     //If the current element is metadata enclosure, look inside
                     if (xsr.getLocalName().equals(version.eprType.wsdlMetadata.getLocalPart())) {
+                        String wsdlLoc = xsr.getAttributeValue("http://www.w3.org/ns/wsdl-instance","wsdlLocation");
+                        if (wsdlLoc != null)
+                            wsdliLocation = wsdlLoc.trim();
                         XMLStreamBuffer mark;
                         while ((mark = xsr.nextTagAndMark()) != null) {
                             localName = xsr.getLocalName();
@@ -881,10 +889,14 @@
                             ns = xsr.getNamespaceURI();
                             if (localName.equals(version.eprType.serviceName)) {
                                 String portStr = xsr.getAttributeValue(null, version.eprType.portName);
+                                if(serviceName != null)
+                                    throw new RuntimeException("More than one "+ version.eprType.serviceName +" element in EPR Metadata");
                                 serviceName = getElementTextAsQName(xsr);
-                                if (serviceName != null)
+                                if (serviceName != null && portStr != null)
                                     portName = new QName(serviceName.getNamespaceURI(), portStr);
                             } else if (localName.equals(version.eprType.portTypeName)) {
+                                if(portTypeName != null)
+                                    throw new RuntimeException("More than one "+ version.eprType.portTypeName +" element in EPR Metadata");
                                 portTypeName = getElementTextAsQName(xsr);
                             } else if (ns.equals(WSDLConstants.NS_WSDL)
                                     && localName.equals(WSDLConstants.QNAME_DEFINITIONS.getLocalPart())) {
@@ -922,7 +934,7 @@
                     } else if (localName.equals(version.eprType.serviceName)) {
                         String portStr = xsr.getAttributeValue(null, version.eprType.portName);
                         serviceName = getElementTextAsQName(xsr);
-                        if (serviceName != null)
+                        if (serviceName != null && portStr != null)
                             portName = new QName(serviceName.getNamespaceURI(), portStr);
                     } else if (localName.equals(version.eprType.portTypeName)) {
                         portTypeName = getElementTextAsQName(xsr);
@@ -936,7 +948,7 @@
         }
 
         private QName getElementTextAsQName(StreamReaderBufferProcessor xsr) throws XMLStreamException {
-            String text = xsr.getElementText();
+            String text = xsr.getElementText().trim();
             String prefix = XmlUtil.getPrefix(text);
             String name = XmlUtil.getLocalPart(text);
             if (name != null) {
--- old/src/share/classes/com/sun/xml/internal/ws/api/message/Message.java	Tue Aug  4 09:58:55 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/message/Message.java	Tue Aug  4 09:58:55 2009
@@ -42,6 +42,7 @@
 import com.sun.xml.internal.ws.client.dispatch.DispatchImpl;
 import com.sun.xml.internal.ws.message.AttachmentSetImpl;
 import com.sun.xml.internal.ws.message.jaxb.JAXBMessage;
+import com.sun.xml.internal.ws.fault.SOAPFaultBuilder;
 import com.sun.xml.internal.org.jvnet.staxex.XMLStreamReaderEx;
 import com.sun.xml.internal.org.jvnet.staxex.XMLStreamWriterEx;
 import org.xml.sax.ContentHandler;
@@ -54,11 +55,13 @@
 import javax.xml.namespace.QName;
 import javax.xml.soap.SOAPException;
 import javax.xml.soap.SOAPMessage;
+import javax.xml.soap.Detail;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 import javax.xml.stream.XMLStreamWriter;
 import javax.xml.transform.Source;
 import javax.xml.ws.Dispatch;
+import javax.xml.ws.WebServiceException;
 import java.io.InputStream;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
@@ -428,6 +431,27 @@
     }
 
     /**
+     * It gives S:Envelope/S:Body/S:Fault/detail 's first child's name. Should
+     * be called for messages that have SOAP Fault.
+     *
+     * <p> This implementation is expensive so concrete implementations are
+     * expected to override this one.
+     *
+     * @return first detail entry's name, if there is one
+     *         else null
+     */
+    public @Nullable QName getFirstDetailEntryName() {
+        assert isFault();
+        Message msg = copy();
+        try {
+            SOAPFaultBuilder fault = SOAPFaultBuilder.create(msg);
+            return fault.getFirstDetailEntryName();
+        } catch (JAXBException e) {
+            throw new WebServiceException(e);
+        }
+    }
+
+    /**
      * Consumes this message including the envelope.
      * returns it as a {@link Source} object.
      */
@@ -484,6 +508,8 @@
      *
      * This consumes the message.
      *
+     * @return null
+     *      if there's no payload.
      * @throws JAXBException
      *      If JAXB reports an error during the processing.
      */
--- old/src/share/classes/com/sun/xml/internal/ws/api/message/Messages.java	Tue Aug  4 09:58:58 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/message/Messages.java	Tue Aug  4 09:58:57 2009
@@ -31,10 +31,10 @@
 import com.sun.xml.internal.bind.v2.runtime.MarshallerImpl;
 import com.sun.xml.internal.stream.buffer.XMLStreamBuffer;
 import com.sun.xml.internal.ws.api.SOAPVersion;
+import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.addressing.AddressingVersion;
 import com.sun.xml.internal.ws.api.pipe.Tube;
 import com.sun.xml.internal.ws.api.pipe.Codecs;
-import com.sun.xml.internal.ws.encoding.StreamSOAPCodec;
 import com.sun.xml.internal.ws.fault.SOAPFaultBuilder;
 import com.sun.xml.internal.ws.message.AttachmentSetImpl;
 import com.sun.xml.internal.ws.message.DOMMessage;
@@ -48,6 +48,9 @@
 import com.sun.xml.internal.ws.streaming.XMLStreamReaderException;
 import com.sun.xml.internal.ws.streaming.XMLStreamReaderUtil;
 import com.sun.xml.internal.ws.util.DOMUtil;
+import com.sun.xml.internal.ws.addressing.WsaTubeHelper;
+import com.sun.xml.internal.ws.addressing.model.MissingAddressingHeaderException;
+import com.sun.xml.internal.ws.resources.AddressingMessages;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 
@@ -303,7 +306,36 @@
     }
 
     /**
+     * @deprecated
+     *      Use {@link #createAddressingFaultMessage(WSBinding, Packet, QName)}
+     */
+    public static Message createAddressingFaultMessage(WSBinding binding, QName missingHeader) {
+        return createAddressingFaultMessage(binding,null,missingHeader);
+    }
+
+    /**
      * Creates a fault {@link Message} that captures the code/subcode/subsubcode
+     * defined by WS-Addressing if one of the expected WS-Addressing headers is
+     * missing in the message
+     *
+     * @param binding WSBinding
+     * @param p
+     *      {@link Packet} that was missing a WS-Addressing header.
+     * @param missingHeader The missing WS-Addressing Header
+     * @return
+     *      A message representing SOAPFault that contains the WS-Addressing code/subcode/subsubcode.
+     */
+    public static Message createAddressingFaultMessage(WSBinding binding, Packet p, QName missingHeader) {
+        AddressingVersion av = binding.getAddressingVersion();
+        if(av == null) {
+            // Addressing is not enabled.
+            throw new WebServiceException(AddressingMessages.ADDRESSING_SHOULD_BE_ENABLED());
+        }
+        WsaTubeHelper helper = av.getWsaHelper(null,null,binding);
+        return create(helper.newMapRequiredFault(new MissingAddressingHeaderException(missingHeader,p)));
+    }
+    /**
+     * Creates a fault {@link Message} that captures the code/subcode/subsubcode
      * defined by WS-Addressing if wsa:Action is not supported.
      *
      * @param unsupportedAction The unsupported Action. Must not be null.
--- old/src/share/classes/com/sun/xml/internal/ws/api/message/Packet.java	Tue Aug  4 09:59:00 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/message/Packet.java	Tue Aug  4 09:59:00 2009
@@ -28,7 +28,7 @@
 import com.sun.istack.internal.Nullable;
 import com.sun.xml.internal.bind.marshaller.SAX2DOMEx;
 import com.sun.xml.internal.ws.addressing.WsaTubeHelper;
-import com.sun.xml.internal.ws.addressing.model.InvalidMapException;
+import com.sun.xml.internal.ws.addressing.model.InvalidAddressingHeaderException;
 import com.sun.xml.internal.ws.api.DistributedPropertySet;
 import com.sun.xml.internal.ws.api.EndpointAddress;
 import com.sun.xml.internal.ws.api.PropertySet;
@@ -36,9 +36,9 @@
 import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.addressing.AddressingVersion;
 import com.sun.xml.internal.ws.api.addressing.WSEndpointReference;
+import com.sun.xml.internal.ws.api.model.SEIModel;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLOperation;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
-import com.sun.xml.internal.ws.api.model.SEIModel;
 import com.sun.xml.internal.ws.api.pipe.Tube;
 import com.sun.xml.internal.ws.api.server.TransportBackChannel;
 import com.sun.xml.internal.ws.api.server.WSEndpoint;
@@ -52,7 +52,6 @@
 import com.sun.xml.internal.ws.message.StringHeader;
 import com.sun.xml.internal.ws.util.DOMUtil;
 import com.sun.xml.internal.ws.util.xml.XmlUtil;
-import com.sun.xml.internal.ws.model.JavaMethodImpl;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.xml.sax.SAXException;
@@ -174,9 +173,29 @@
         this.handlerScopePropertyNames = that.handlerScopePropertyNames;
         this.contentNegotiation = that.contentNegotiation;
         this.wasTransportSecure = that.wasTransportSecure;
+        this.endpointAddress = that.endpointAddress;
         // copy other properties that need to be copied. is there any?
     }
 
+    /**
+     * Creates a copy of this {@link Packet}.
+     *
+     * @param copyMessage determines whether the {@link Message} from the original {@link Packet} should be copied as
+     *        well, or not. If the value is {@code false}, the {@link Message} in the copy of the {@link Packet} is {@code null}.
+     * @return copy of the original packet
+     */
+    public Packet copy(boolean copyMessage) {
+        // the copy constructor is originally designed for creating a response packet,
+        // but so far the implementation is usable for this purpose as well, so calling the copy constructor
+        // to avoid code dupliation.
+        Packet copy = new Packet(this);
+        if (copyMessage) {
+            copy.message = this.message.copy();
+        }
+
+        return copy;
+    }
+
     private Message message;
 
     /**
@@ -391,7 +410,7 @@
      * <p>
      * This field can be null. While a message is being processed,
      * this field can be set explicitly to null, to prevent
-     * future pipes from closing a transport.
+     * future pipes from closing a transport (see {@link #keepTransportBackChannelOpen()})
      *
      * <p>
      * This property is set from the parameter
@@ -400,11 +419,24 @@
     public @Nullable TransportBackChannel transportBackChannel;
 
     /**
+     * Keeps the transport back channel open (by seeting {@link #transportBackChannel} to null.)
+     *
+     * @return
+     *      The previous value of {@link #transportBackChannel}.
+     */
+    public TransportBackChannel keepTransportBackChannelOpen() {
+        TransportBackChannel r = transportBackChannel;
+        transportBackChannel = null;
+        return r;
+    }
+
+    /**
      * The governing {@link WSEndpoint} in which this message is floating.
      *
      * <p>
      * This property is set if and only if this is on the server side.
      */
+    @Property(JAXWSProperties.WSENDPOINT)
     public WSEndpoint endpoint;
 
     /**
@@ -641,12 +673,12 @@
             return r;
         }
         // if one-way, then dont populate any WS-A headers
-        if (message == null || (wsdlPort != null && message.isOneWay(wsdlPort)))
+        if (responseMessage == null || (wsdlPort != null && message.isOneWay(wsdlPort)))
             return r;
 
         // otherwise populate WS-Addressing headers
-        return populateAddressingHeaders(binding, r, wsdlPort,seiModel);
-
+        populateAddressingHeaders(binding, r, wsdlPort,seiModel);
+        return r;
     }
 
     /**
@@ -677,20 +709,32 @@
             return responsePacket;
         }
 
-        return populateAddressingHeaders(responsePacket,
-                addressingVersion,
-                soapVersion,
-                action);
+        populateAddressingHeaders(responsePacket, addressingVersion, soapVersion, action);
+        return responsePacket;
     }
 
-    private Packet populateAddressingHeaders(Packet responsePacket, AddressingVersion av, SOAPVersion sv, String action) {
+    /**
+     * Overwrites the {@link Message} of the response packet ({@code this}) by the given {@link Message}.
+     * Unlike {@link #setMessage(Message)}, fill in the addressing headers correctly, and this process
+     * requires the access to the request packet.
+     *
+     * <p>
+     * This method is useful when the caller needs to swap a response message completely to a new one.
+     *
+     * @see #createServerResponse(Message, AddressingVersion, SOAPVersion, String)
+     */
+    public void setResponseMessage(@NotNull Packet request, @Nullable Message responseMessage, @NotNull AddressingVersion addressingVersion, @NotNull SOAPVersion soapVersion, @NotNull String action) {
+       Packet temp = request.createServerResponse(responseMessage, addressingVersion, soapVersion, action);
+       setMessage(temp.getMessage());
+    }
+
+    private void populateAddressingHeaders(Packet responsePacket, AddressingVersion av, SOAPVersion sv, String action) {
         // populate WS-A headers only if WS-A is enabled
-        if (av == null)
-            return responsePacket;
+        if (av == null) return;
 
         // if one-way, then dont populate any WS-A headers
         if (responsePacket.getMessage() == null)
-            return responsePacket;
+            return;
 
         HeaderList hl = responsePacket.getMessage().getHeaders();
 
@@ -700,19 +744,23 @@
         replyTo = message.getHeaders().getReplyTo(av, sv);
         if (replyTo != null)
             hl.add(new StringHeader(av.toTag, replyTo.getAddress()));
-        } catch (InvalidMapException e) {
+        } catch (InvalidAddressingHeaderException e) {
             replyTo = null;
         }
 
-        // wsa:Action
-        hl.add(new StringHeader(av.actionTag, action));
+        // wsa:Action, add if the message doesn't already contain it,
+        // generally true for SEI case where there is SEIModel or WSDLModel
+        //           false for Provider with no wsdl, Expects User to set the coresponding header on the Message.
+        if(responsePacket.getMessage().getHeaders().getAction(av,sv) == null) {
+            //wsa:Action header is not set in the message, so use the wsa:Action  passed as the parameter.
+            hl.add(new StringHeader(av.actionTag, action));
+        }
 
         // wsa:MessageID
         hl.add(new StringHeader(av.messageIDTag, responsePacket.getMessage().getID(av, sv)));
 
         // wsa:RelatesTo
-        // TODO: this property is defined in WsaServerTube.REQUEST_MESSAGE_ID
-        String mid = (String)responsePacket.invocationProperties.get("com.sun.xml.internal.ws.addressing.request.messageID");
+        String mid = getMessage().getHeaders().getMessageID(av,sv);
         if (mid != null)
             hl.add(new RelatesToHeader(av.relatesToTag, mid));
 
@@ -732,15 +780,12 @@
         if (refpEPR != null) {
             refpEPR.addReferenceParameters(hl);
         }
-
-        return responsePacket;
     }
 
-    private Packet populateAddressingHeaders(WSBinding binding, Packet responsePacket, WSDLPort wsdlPort, SEIModel seiModel) {
+    private void populateAddressingHeaders(WSBinding binding, Packet responsePacket, WSDLPort wsdlPort, SEIModel seiModel) {
         AddressingVersion addressingVersion = binding.getAddressingVersion();
 
-        if (addressingVersion == null)
-            return responsePacket;
+        if (addressingVersion == null)  return;
 
         WsaTubeHelper wsaHelper = addressingVersion.getWsaHelper(wsdlPort,seiModel, binding);
         String action = responsePacket.message.isFault() ?
@@ -747,7 +792,7 @@
                 wsaHelper.getFaultAction(this, responsePacket) :
                 wsaHelper.getOutputAction(this);
 
-        return populateAddressingHeaders(responsePacket, addressingVersion, binding.getSOAPVersion(), action);
+        populateAddressingHeaders(responsePacket, addressingVersion, binding.getSOAPVersion(), action);
     }
 
     // completes TypedMap
--- old/src/share/classes/com/sun/xml/internal/ws/api/model/JavaMethod.java	Tue Aug  4 09:59:02 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/JavaMethod.java	Tue Aug  4 09:59:02 2009
@@ -29,6 +29,7 @@
 import com.sun.istack.internal.Nullable;
 import com.sun.xml.internal.ws.api.model.soap.SOAPBinding;
 
+import javax.xml.namespace.QName;
 import java.lang.reflect.Method;
 
 /**
@@ -66,6 +67,7 @@
      */
     @NotNull Method getMethod();
 
+
     /**
      * This should be used if you want to access annotations on WebMethod
      * Returns the SEI method if there is one.
@@ -119,4 +121,20 @@
      */
     @Nullable String getResponseMessageName();
 
+    /**
+     * Gives soap:Body's first child's name for request message.
+     *
+     * @return
+     *      null if this operation doesn't have any request parameter bound to the body.
+     */
+    @Nullable QName getRequestPayloadName();
+
+    /**
+     * Gives soap:Body's first child's name for response message.
+     *
+     * @return
+     *      null if this operation doesn't have any response parameter bound to the body.
+     */
+    @Nullable QName getResponsePayloadName();
+
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLBoundOperation.java	Tue Aug  4 09:59:04 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLBoundOperation.java	Tue Aug  4 09:59:04 2009
@@ -28,8 +28,9 @@
 import com.sun.istack.internal.NotNull;
 import com.sun.istack.internal.Nullable;
 
+import javax.jws.WebParam.Mode;
 import javax.xml.namespace.QName;
-import java.util.List;
+import java.util.Map;
 
 /**
  * Abstracts wsdl:binding/wsdl:operation. It can be used to determine the parts and their binding.
@@ -57,11 +58,48 @@
     @NotNull WSDLOperation getOperation();
 
     /**
+     * Gives the owner {@link WSDLBoundPortType}
+     */
+    @NotNull WSDLBoundPortType getBoundPortType();
+
+    /**
      * Gets the soapbinding:binding/operation/wsaw:Anonymous. A default value of OPTIONAL is returned.
      *
      * @return Anonymous value of the operation
      */
-    public ANONYMOUS getAnonymous();
+    ANONYMOUS getAnonymous();
 
     enum ANONYMOUS { optional, required, prohibited }
+
+    /**
+     * Gets {@link WSDLPart} for the given wsdl:input or wsdl:output part
+     *
+     * @return null if no part is found
+     */
+    @Nullable WSDLPart getPart(@NotNull String partName, @NotNull Mode mode);
+
+    /**
+     * Gets all inbound {@link WSDLPart} by its {@link WSDLPart#getName() name}.
+     */
+    @NotNull Map<String,WSDLPart> getInParts();
+
+    /**
+     * Gets all outbound {@link WSDLPart} by its {@link WSDLPart#getName() name}.
+     */
+    @NotNull Map<String,WSDLPart> getOutParts();
+
+    /**
+     * Gets all the {@link WSDLFault} bound to this operation.
+     */
+    @NotNull Iterable<? extends WSDLBoundFault> getFaults();
+
+    /**
+     * Gets the payload QName of the request message.
+     *
+     * <p>
+     * It's possible for an operation to define no body part, in which case
+     * this method returns null.
+     */
+    @Nullable QName getReqPayloadName();
+
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLBoundPortType.java	Tue Aug  4 09:59:07 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLBoundPortType.java	Tue Aug  4 09:59:06 2009
@@ -30,6 +30,7 @@
 import com.sun.xml.internal.ws.api.BindingID;
 import com.sun.xml.internal.ws.api.message.Message;
 
+import javax.jws.soap.SOAPBinding;
 import javax.xml.namespace.QName;
 
 /**
@@ -73,6 +74,14 @@
     Iterable<? extends WSDLBoundOperation> getBindingOperations();
 
     /**
+     * Is this a document style or RPC style?
+     *
+     * Since we only support literal and not encoding, this means
+     * either doc/lit or rpc/lit.
+     */
+    @NotNull SOAPBinding.Style getStyle();
+
+    /**
      * Returns the binding ID.
      * This would typically determined by the binding extension elements in wsdl:binding.
      */
--- old/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLExtensible.java	Tue Aug  4 09:59:09 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLExtensible.java	Tue Aug  4 09:59:08 2009
@@ -53,7 +53,7 @@
      *      The type of the extension to obtain. Must not be null.
      *
      * @return
-     *      Can be an empty collection but never null.
+     *      Can be an empty fromjava.collection but never null.
      */
     <T extends WSDLExtension> Iterable<T> getExtensions(Class<T> type);
 
--- old/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLFault.java	Tue Aug  4 09:59:11 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLFault.java	Tue Aug  4 09:59:11 2009
@@ -25,6 +25,10 @@
 
 package com.sun.xml.internal.ws.api.model.wsdl;
 
+import com.sun.istack.internal.NotNull;
+
+import javax.xml.namespace.QName;
+
 /**
  * Abstracts wsdl:portType/wsdl:operation/wsdl:fault
  *
@@ -45,4 +49,19 @@
      * @return Always returns null when called from inside WSDL extensions.
      */
     WSDLMessage getMessage();
+
+    /**
+     * Gives the owning {@link WSDLOperation}
+     */
+    @NotNull
+    WSDLOperation getOperation();
+
+    /**
+     * Gives qualified name of the wsdl:fault 'name' attribute value.
+     * <p/>
+     *
+     * The namespace uri is determined from the enclosing wsdl:operation.
+     */
+    @NotNull
+    QName getQName();
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLInput.java	Tue Aug  4 09:59:13 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLInput.java	Tue Aug  4 09:59:13 2009
@@ -25,6 +25,11 @@
 
 package com.sun.xml.internal.ws.api.model.wsdl;
 
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
+
+import javax.xml.namespace.QName;
+
 /**
  * Abstraction of wsdl:portType/wsdl:operation/wsdl:input
  *
@@ -58,4 +63,27 @@
      * @return Action
      */
     String getAction();
+
+    /**
+     * Gives the owning {@link WSDLOperation}
+     */
+    @NotNull
+    WSDLOperation getOperation();
+
+    /**
+     * Gives qualified name of the wsdl:input 'name' attribute value. If there is no name, then it computes the name from:
+     *
+     * If the wsdl:operation is oneway:
+     *
+     * wsdl:operation@name value, which is local name of {@link WSDLOperation#getName()}
+     * <p/>
+     * otherwise
+     *
+     * wsdl:operation@name+"Request", which is local name of {@link WSDLOperation#getName()} + "Request"
+     * <p/>
+     *
+     * The namespace uri is determined from the enclosing wsdl:operation.
+     */
+    @NotNull
+    QName getQName();
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLMessage.java	Tue Aug  4 09:59:15 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLMessage.java	Tue Aug  4 09:59:15 2009
@@ -37,4 +37,9 @@
      * Gives wsdl:message@name value.
      */
     QName getName();
+
+    /**
+     * Gets all the parts.
+     */
+    Iterable<? extends WSDLPart> parts();
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLModel.java	Tue Aug  4 09:59:18 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLModel.java	Tue Aug  4 09:59:17 2009
@@ -27,6 +27,7 @@
 
 
 import com.sun.istack.internal.NotNull;
+import com.sun.xml.internal.ws.api.server.Container;
 import com.sun.xml.internal.ws.api.wsdl.parser.WSDLParserExtension;
 import com.sun.xml.internal.ws.api.wsdl.parser.XMLEntityResolver;
 import com.sun.xml.internal.ws.wsdl.parser.RuntimeWSDLParser;
@@ -118,7 +119,24 @@
          * @throws org.xml.sax.SAXException
          */
         public static @NotNull WSDLModel parse(XMLEntityResolver.Parser wsdlEntityParser, XMLEntityResolver resolver, boolean isClientSide, WSDLParserExtension... extensions) throws IOException, XMLStreamException, SAXException {
-            return RuntimeWSDLParser.parse(wsdlEntityParser, resolver, isClientSide, extensions);
+            return RuntimeWSDLParser.parse(wsdlEntityParser, resolver, isClientSide, Container.NONE, extensions);
         }
+
+        /**
+         * Parses WSDL from the given wsdlLoc and gives a {@link WSDLModel} built from it.
+         *
+         * @param wsdlEntityParser  Works like an entityResolver to resolve WSDLs
+         * @param resolver  {@link XMLEntityResolver}, works at XML infoset level
+         * @param isClientSide  true - its invoked on the client, false means its invoked on the server
+         * @param container - container in which the parser is run
+         * @param extensions var args of {@link com.sun.xml.internal.ws.api.wsdl.parser.WSDLParserExtension}s
+         * @return A {@link WSDLModel} built from the given wsdlLocation}
+         * @throws java.io.IOException
+         * @throws javax.xml.stream.XMLStreamException
+         * @throws org.xml.sax.SAXException
+         */
+        public static @NotNull WSDLModel parse(XMLEntityResolver.Parser wsdlEntityParser, XMLEntityResolver resolver, boolean isClientSide, @NotNull Container container, WSDLParserExtension... extensions) throws IOException, XMLStreamException, SAXException {
+            return RuntimeWSDLParser.parse(wsdlEntityParser, resolver, isClientSide, container, extensions);
+        }
     }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLOperation.java	Tue Aug  4 09:59:20 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLOperation.java	Tue Aug  4 09:59:19 2009
@@ -64,7 +64,7 @@
     boolean isOneWay();
 
     /**
-     * Gets the {link WSDLFault} corresponding to wsdl:fault of this operation.
+     * Gets the {@link WSDLFault} corresponding to wsdl:fault of this operation.
      */
     Iterable<? extends WSDLFault> getFaults();
 
--- old/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLOutput.java	Tue Aug  4 09:59:22 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLOutput.java	Tue Aug  4 09:59:22 2009
@@ -25,6 +25,10 @@
 
 package com.sun.xml.internal.ws.api.model.wsdl;
 
+import com.sun.istack.internal.NotNull;
+
+import javax.xml.namespace.QName;
+
 /**
  * Abstraction of wsdl:portType/wsdl:operation/wsdl:output
  *
@@ -58,4 +62,21 @@
      * @return Action
      */
     String getAction();
+
+    /**
+     * Gives the owning {@link WSDLOperation}
+     */
+    @NotNull
+    WSDLOperation getOperation();
+
+    /**
+     * Gives qualified name of the wsdl:output 'name' attribute value. If there is no name, then it computes the name from:
+     *
+     * wsdl:operation@name+"Response", which is local name of {@link WSDLOperation#getName()} + "Response"
+     * <p/>
+     *
+     * The namespace uri is determined from the enclosing wsdl:operation.
+     */
+    @NotNull
+    QName getQName();
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLPortType.java	Tue Aug  4 09:59:24 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLPortType.java	Tue Aug  4 09:59:24 2009
@@ -52,7 +52,7 @@
 
 
     /**
-     * Gets {@link Iterable}<{$link WSDLOperation}>
+     * Gets {@link Iterable}<{@link WSDLOperation}>
      */
     public Iterable<? extends WSDLOperation> getOperations();
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/pipe/ClientPipeAssemblerContext.java	Tue Aug  4 09:59:26 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/pipe/ClientPipeAssemblerContext.java	Tue Aug  4 09:59:26 2009
@@ -79,6 +79,13 @@
     }
 
     /**
+     * creates a {@link Pipe} that validates messages against schema
+     */
+    public Pipe createValidationPipe(Pipe next) {
+        return PipeAdapter.adapt(super.createValidationTube(PipeAdapter.adapt(next)));
+    }
+
+    /**
      * Creates a {@link Pipe} that invokes protocol and logical handlers.
      */
     public Pipe createHandlerPipe(Pipe next) {
--- old/src/share/classes/com/sun/xml/internal/ws/api/pipe/ClientTubeAssemblerContext.java	Tue Aug  4 09:59:29 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/pipe/ClientTubeAssemblerContext.java	Tue Aug  4 09:59:28 2009
@@ -28,16 +28,24 @@
 import com.sun.istack.internal.NotNull;
 import com.sun.istack.internal.Nullable;
 import com.sun.xml.internal.ws.addressing.WsaClientTube;
+import com.sun.xml.internal.ws.addressing.W3CWsaServerTube;
+import com.sun.xml.internal.ws.addressing.W3CWsaClientTube;
+import com.sun.xml.internal.ws.addressing.v200408.MemberSubmissionWsaServerTube;
+import com.sun.xml.internal.ws.addressing.v200408.MemberSubmissionWsaClientTube;
 import com.sun.xml.internal.ws.api.EndpointAddress;
 import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.WSService;
 import com.sun.xml.internal.ws.api.addressing.AddressingVersion;
 import com.sun.xml.internal.ws.api.client.ClientPipelineHook;
+import com.sun.xml.internal.ws.api.model.SEIModel;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
 import com.sun.xml.internal.ws.api.pipe.helper.PipeAdapter;
 import com.sun.xml.internal.ws.api.server.Container;
 import com.sun.xml.internal.ws.binding.BindingImpl;
+import com.sun.xml.internal.ws.client.ClientSchemaValidationTube;
+import com.sun.xml.internal.ws.developer.SchemaValidationFeature;
 import com.sun.xml.internal.ws.handler.ClientLogicalHandlerTube;
+import com.sun.xml.internal.ws.handler.ClientMessageHandlerTube;
 import com.sun.xml.internal.ws.handler.ClientSOAPHandlerTube;
 import com.sun.xml.internal.ws.handler.HandlerTube;
 import com.sun.xml.internal.ws.protocol.soap.ClientMUTube;
@@ -57,19 +65,33 @@
 public class ClientTubeAssemblerContext {
 
     private final @NotNull EndpointAddress address;
-    private final @NotNull WSDLPort wsdlModel;
+    private final @Nullable WSDLPort wsdlModel;
+    private final @Nullable SEIModel seiModel;
     private final @NotNull WSService rootOwner;
     private final @NotNull WSBinding binding;
     private final @NotNull Container container;
     private @NotNull Codec codec;
 
-    public ClientTubeAssemblerContext(@NotNull EndpointAddress address, @NotNull WSDLPort wsdlModel, @NotNull WSService rootOwner, @NotNull WSBinding binding) {
+    public ClientTubeAssemblerContext(@NotNull EndpointAddress address, @Nullable WSDLPort wsdlModel, @NotNull WSService rootOwner, @NotNull WSBinding binding) {
         this(address, wsdlModel, rootOwner, binding, Container.NONE);
     }
 
-    public ClientTubeAssemblerContext(@NotNull EndpointAddress address, @NotNull WSDLPort wsdlModel,
+    public ClientTubeAssemblerContext(@NotNull EndpointAddress address, @Nullable WSDLPort wsdlModel,
                                       @NotNull WSService rootOwner, @NotNull WSBinding binding,
+                                      @NotNull Container container) {
+        // WSBinding is actually BindingImpl
+        this(address, wsdlModel, rootOwner, binding, container, ((BindingImpl)binding).createCodec() );
+    }
+
+    public ClientTubeAssemblerContext(@NotNull EndpointAddress address, @Nullable WSDLPort wsdlModel,
+                                      @NotNull WSService rootOwner, @NotNull WSBinding binding,
                                       @NotNull Container container, Codec codec) {
+        this(address, wsdlModel, rootOwner, binding, container, codec, null);
+    }
+
+    public ClientTubeAssemblerContext(@NotNull EndpointAddress address, @Nullable WSDLPort wsdlModel,
+                                      @NotNull WSService rootOwner, @NotNull WSBinding binding,
+                                      @NotNull Container container, Codec codec, SEIModel seiModel) {
         this.address = address;
         this.wsdlModel = wsdlModel;
         this.rootOwner = rootOwner;
@@ -76,14 +98,9 @@
         this.binding = binding;
         this.container = container;
         this.codec = codec;
+        this.seiModel = seiModel;
     }
 
-    public ClientTubeAssemblerContext(@NotNull EndpointAddress address, @NotNull WSDLPort wsdlModel,
-                                      @NotNull WSService rootOwner, @NotNull WSBinding binding,
-                                      @NotNull Container container) {
-        // WSBinding is actually BindingImpl
-        this(address, wsdlModel, rootOwner, binding, container, ((BindingImpl)binding).createCodec() );
-    }
 
     /**
      * The endpoint address. Always non-null. This parameter is taken separately
@@ -120,6 +137,16 @@
     }
 
     /**
+     * The created pipeline will use seiModel to get java concepts for the endpoint
+     *
+     * @return Null if the service doesn't have SEI model e.g. Dispatch,
+     *         and otherwise non-null.
+     */
+    public @Nullable SEIModel getSEIModel() {
+        return seiModel;
+    }
+
+    /**
      * Returns the Container in which the client is running
      *
      * @return Container in which client is running
@@ -153,7 +180,11 @@
      */
     public Tube createWsaTube(Tube next) {
         if (binding instanceof SOAPBinding && AddressingVersion.isEnabled(binding) && wsdlModel!=null)
-            return new WsaClientTube(wsdlModel, binding, next);
+            if(AddressingVersion.fromBinding(binding) == AddressingVersion.MEMBER) {
+                return new MemberSubmissionWsaClientTube(wsdlModel, binding, next);
+            } else {
+                return new W3CWsaClientTube(wsdlModel, binding, next);
+            }
         else
             return next;
     }
@@ -162,13 +193,18 @@
      * Creates a {@link Tube} that invokes protocol and logical handlers.
      */
     public Tube createHandlerTube(Tube next) {
-        HandlerTube soapHandlerTube = null;
+        HandlerTube cousinHandlerTube = null;
         //XML/HTTP Binding can have only LogicalHandlerPipe
         if (binding instanceof SOAPBinding) {
-            soapHandlerTube = new ClientSOAPHandlerTube(binding, wsdlModel, next);
-            next = soapHandlerTube;
+            //Add MessageHandlerTube
+            HandlerTube messageHandlerTube = new ClientMessageHandlerTube(seiModel, binding, wsdlModel, next);
+            next = cousinHandlerTube = messageHandlerTube;
+
+            //Add SOAPHandlerTuber
+            HandlerTube soapHandlerTube = new ClientSOAPHandlerTube(binding, next, cousinHandlerTube);
+            next = cousinHandlerTube = soapHandlerTube;
         }
-        return new ClientLogicalHandlerTube(binding, next, soapHandlerTube);
+        return new ClientLogicalHandlerTube(binding, next, cousinHandlerTube);
     }
 
     /**
@@ -183,24 +219,26 @@
     }
 
     /**
+     * creates a {@link Tube} that validates messages against schema
+     */
+    public Tube createValidationTube(Tube next) {
+        if (binding instanceof SOAPBinding && binding.isFeatureEnabled(SchemaValidationFeature.class) && wsdlModel!=null)
+            return new ClientSchemaValidationTube(binding, wsdlModel, next);
+        else
+            return next;
+    }
+
+    /**
      * Creates a transport pipe (for client), which becomes the terminal pipe.
      */
     public Tube createTransportTube() {
         ClassLoader cl = Thread.currentThread().getContextClassLoader();
 
-        // wsgen generates a WSDL with the address attribute that says "REPLACE_WITH_ACTUAL_URL".
-        // while it's technically correct to reject such address (since there's no transport registered
-        // with it), it's desirable to allow the user a benefit of doubt, and wait until the runtime
-        // to see if the user configures the endpoint address through request context.
+        // The application may configure the endpoint address through request context
+        // using {@link BindingProvider#ENDPOINT_ADDRESS_PROPERTY}. Let us
+        // defer the creation of actual transport until the service invocation,
         // DeferredTransportPipe is used for this purpose.
-        //
-        // Ideally, we shouldn't have @address at all for such cases, but due to the backward
-        // compatibility and the fact that this attribute is mandatory, we have no option but
-        // to check for REPLACE_WITH_ACTUAL_URL.
-        if(address.toString().equals("") || address.toString().equals("REPLACE_WITH_ACTUAL_URL"))
-            return new DeferredTransportPipe(cl,this);
-
-        return TransportTubeFactory.create(cl, this);
+        return new DeferredTransportPipe(cl,this);
     }
 
     /**
--- old/src/share/classes/com/sun/xml/internal/ws/api/pipe/Engine.java	Tue Aug  4 09:59:31 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/pipe/Engine.java	Tue Aug  4 09:59:31 2009
@@ -59,7 +59,7 @@
     void addRunnable(Fiber fiber) {
         if(threadPool==null) {
             synchronized(this) {
-                threadPool = Executors.newFixedThreadPool(5, new DaemonThreadFactory());
+                threadPool = Executors.newCachedThreadPool(new DaemonThreadFactory());
             }
         }
         threadPool.execute(fiber);
@@ -79,12 +79,29 @@
     }
 
     private static class DaemonThreadFactory implements ThreadFactory {
-        private final AtomicInteger threadNumber = new AtomicInteger(1);
+        static final AtomicInteger poolNumber = new AtomicInteger(1);
+        final ThreadGroup group;
+        final AtomicInteger threadNumber = new AtomicInteger(1);
+        final String namePrefix;
 
+        DaemonThreadFactory() {
+            SecurityManager s = System.getSecurityManager();
+            group = (s != null)? s.getThreadGroup() :
+                                 Thread.currentThread().getThreadGroup();
+            namePrefix = "jaxws-engine-" +
+                          poolNumber.getAndIncrement() +
+                         "-thread-";
+        }
+
         public Thread newThread(Runnable r) {
-            Thread daemonThread = new Thread(r, "JAXWS-Engine-"+threadNumber.getAndIncrement());
-            daemonThread.setDaemon(Boolean.TRUE);
-            return daemonThread;
+            Thread t = new Thread(group, r,
+                                  namePrefix + threadNumber.getAndIncrement(),
+                                  0);
+            if (!t.isDaemon())
+                t.setDaemon(true);
+            if (t.getPriority() != Thread.NORM_PRIORITY)
+                t.setPriority(Thread.NORM_PRIORITY);
+            return t;
         }
     }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/pipe/Fiber.java	Tue Aug  4 09:59:33 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/pipe/Fiber.java	Tue Aug  4 09:59:33 2009
@@ -249,26 +249,29 @@
      * Wakes up a suspended fiber.
      *
      * <p>
-     * If a fiber was suspended from the {@link Tube#processRequest(Packet)} method,
-     * then the execution will be resumed from the corresponding
-     * {@link Tube#processResponse(Packet)} method with the specified response packet
-     * as the parameter.
+     * If a fiber was suspended without specifying the next {@link Tube},
+     * then the execution will be resumed in the response processing direction,
+     * by calling the {@link Tube#processResponse(Packet)} method on the next/first
+     * {@link Tube} in the {@link Fiber}'s processing stack with the specified resume
+     * packet as the parameter.
      *
      * <p>
-     * If a fiber was suspended from the {@link Tube#processResponse(Packet)} method,
-     * then the execution will be resumed from the next tube's
-     * {@link Tube#processResponse(Packet)} method with the specified response packet
-     * as the parameter.
+     * If a fiber was suspended with specifying the next {@link Tube},
+     * then the execution will be resumed in the request processing direction,
+     * by calling the next tube's {@link Tube#processRequest(Packet)} method with the
+     * specified resume packet as the parameter.
      *
      * <p>
      * This method is implemented in a race-free way. Another thread can invoke
      * this method even before this fiber goes into the suspension mode. So the caller
      * need not worry about synchronizing {@link NextAction#suspend()} and this method.
+     *
+     * @param resumePacket packet used in the resumed processing
      */
-    public synchronized void resume(@NotNull Packet response) {
+    public synchronized void resume(@NotNull Packet resumePacket) {
         if(isTraceEnabled())
             LOGGER.fine(getName()+" resumed");
-        packet = response;
+        packet = resumePacket;
         if( --suspendedCount == 0 ) {
             if(synchronous) {
                 notifyAll();
@@ -618,7 +621,7 @@
                         break;
                     case NextAction.SUSPEND:
                         pushCont(last);
-                        next = null;
+                        next = na.next;
                         suspend();
                         break;
                     default:
@@ -686,6 +689,7 @@
         return "engine-"+owner.id+"fiber-"+id;
     }
 
+    @Override
     public String toString() {
         return getName();
     }
--- old/src/share/classes/com/sun/xml/internal/ws/api/pipe/NextAction.java	Tue Aug  4 09:59:35 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/pipe/NextAction.java	Tue Aug  4 09:59:35 2009
@@ -111,6 +111,15 @@
     }
 
     /**
+     * Indicates that the fiber should be suspended.
+     * Once {@link Fiber#resume(Packet) resumed}, resume with the
+     * {@link Tube#processRequest(Packet)} on the given next tube.
+     */
+    public void suspend(Tube next) {
+        set(SUSPEND, next, null, null);
+    }
+
+    /**
      * Dumps the contents to assist debugging.
      */
     public String toString() {
--- old/src/share/classes/com/sun/xml/internal/ws/api/pipe/ServerPipeAssemblerContext.java	Tue Aug  4 09:59:38 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/pipe/ServerPipeAssemblerContext.java	Tue Aug  4 09:59:37 2009
@@ -79,6 +79,13 @@
     }
 
     /**
+     * creates a {@link Pipe} that validates messages against schema
+     */
+    public @NotNull Pipe createValidationPipe(@NotNull Pipe next) {
+       return PipeAdapter.adapt(super.createValidationTube(PipeAdapter.adapt(next)));
+    }
+
+    /**
      * Creates a {@link Pipe} that invokes protocol and logical handlers.
      */
     public @NotNull Pipe createHandlerPipe(@NotNull Pipe next) {
--- old/src/share/classes/com/sun/xml/internal/ws/api/pipe/ServerTubeAssemblerContext.java	Tue Aug  4 09:59:40 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/pipe/ServerTubeAssemblerContext.java	Tue Aug  4 09:59:39 2009
@@ -28,6 +28,8 @@
 import com.sun.istack.internal.NotNull;
 import com.sun.istack.internal.Nullable;
 import com.sun.xml.internal.ws.addressing.WsaServerTube;
+import com.sun.xml.internal.ws.addressing.W3CWsaServerTube;
+import com.sun.xml.internal.ws.addressing.v200408.MemberSubmissionWsaServerTube;
 import com.sun.xml.internal.ws.api.addressing.AddressingVersion;
 import com.sun.xml.internal.ws.api.model.SEIModel;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
@@ -35,10 +37,13 @@
 import com.sun.xml.internal.ws.api.server.ServerPipelineHook;
 import com.sun.xml.internal.ws.api.server.WSEndpoint;
 import com.sun.xml.internal.ws.binding.BindingImpl;
+import com.sun.xml.internal.ws.developer.SchemaValidationFeature;
 import com.sun.xml.internal.ws.handler.HandlerTube;
 import com.sun.xml.internal.ws.handler.ServerLogicalHandlerTube;
+import com.sun.xml.internal.ws.handler.ServerMessageHandlerTube;
 import com.sun.xml.internal.ws.handler.ServerSOAPHandlerTube;
 import com.sun.xml.internal.ws.protocol.soap.ServerMUTube;
+import com.sun.xml.internal.ws.server.ServerSchemaValidationTube;
 import com.sun.xml.internal.ws.util.pipe.DumpTube;
 
 import javax.xml.ws.soap.SOAPBinding;
@@ -148,7 +153,11 @@
             HandlerTube cousin = new ServerLogicalHandlerTube(binding, wsdlModel, next);
             next = cousin;
             if (binding instanceof SOAPBinding) {
-                return new ServerSOAPHandlerTube(binding, next, cousin);
+                //Add SOAPHandlerTube
+                next = cousin = new ServerSOAPHandlerTube(binding, next, cousin);
+
+                //Add MessageHandlerTube
+                next = new ServerMessageHandlerTube(seiModel, binding, next, cousin);
             }
         }
         return next;
@@ -187,12 +196,26 @@
     }
 
     /**
+     * creates a {@link Tube} that validates messages against schema
+     */
+    public Tube createValidationTube(Tube next) {
+        if (binding instanceof SOAPBinding && binding.isFeatureEnabled(SchemaValidationFeature.class) && wsdlModel!=null)
+            return new ServerSchemaValidationTube(endpoint, binding, next);
+        else
+            return next;
+    }
+
+    /**
      * Creates WS-Addressing pipe
      */
     public Tube createWsaTube(Tube next) {
-        if (binding instanceof SOAPBinding && AddressingVersion.isEnabled(binding) && wsdlModel!=null)
-            return new WsaServerTube(wsdlModel, binding, next);
-        else
+        if (binding instanceof SOAPBinding && AddressingVersion.isEnabled(binding)) {
+            if(AddressingVersion.fromBinding(binding) == AddressingVersion.MEMBER) {
+                return new MemberSubmissionWsaServerTube(endpoint, wsdlModel, binding, next);
+            } else {
+                return new W3CWsaServerTube(endpoint, wsdlModel, binding, next);
+            }
+        } else
             return next;
     }
 
--- old/src/share/classes/com/sun/xml/internal/ws/api/pipe/StreamSOAPCodec.java	Tue Aug  4 09:59:42 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/pipe/StreamSOAPCodec.java	Tue Aug  4 09:59:42 2009
@@ -27,6 +27,7 @@
 
 import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.ws.api.message.Message;
+import com.sun.xml.internal.ws.api.message.AttachmentSet;
 
 import javax.xml.stream.XMLStreamReader;
 
@@ -49,4 +50,14 @@
      * @return a {@link Message} for SOAP envelope
      */
     public @NotNull Message decode(@NotNull XMLStreamReader reader);
+
+    /**
+     * Reads events from {@link XMLStreamReader} and constructs a
+     * {@link Message} for SOAP envelope.
+     *
+     * @param reader that represents SOAP envelope infoset
+     * @param att attachments for the message
+     * @return a {@link Message} for SOAP envelope
+     */
+    public @NotNull Message decode(@NotNull XMLStreamReader reader, @NotNull AttachmentSet att);
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/pipe/TransportTubeFactory.java	Tue Aug  4 09:59:44 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/pipe/TransportTubeFactory.java	Tue Aug  4 09:59:44 2009
@@ -127,7 +127,7 @@
         String scheme = context.getAddress().getURI().getScheme();
         if (scheme != null) {
             if(scheme.equalsIgnoreCase("http") || scheme.equalsIgnoreCase("https"))
-                return new HttpTransportPipe(context.getCodec());
+                return new HttpTransportPipe(context.getCodec(), context.getBinding());
         }
 
         throw new WebServiceException("Unsupported endpoint address: "+context.getAddress());    // TODO: i18n
--- old/src/share/classes/com/sun/xml/internal/ws/api/pipe/helper/AbstractFilterTubeImpl.java	Tue Aug  4 09:59:46 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/pipe/helper/AbstractFilterTubeImpl.java	Tue Aug  4 09:59:46 2009
@@ -50,7 +50,11 @@
 
     protected AbstractFilterTubeImpl(AbstractFilterTubeImpl that, TubeCloner cloner) {
         super(that, cloner);
-        this.next = cloner.copy(that.next);
+        if (that.next != null) {
+            this.next = cloner.copy(that.next);
+        } else {
+            this.next = null;
+        }
     }
 
     /**
--- old/src/share/classes/com/sun/xml/internal/ws/api/pipe/helper/AbstractTubeImpl.java	Tue Aug  4 09:59:49 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/pipe/helper/AbstractTubeImpl.java	Tue Aug  4 09:59:48 2009
@@ -81,6 +81,12 @@
         return na;
     }
 
+    protected final NextAction doSuspend(Tube next) {
+        NextAction na = new NextAction();
+        na.suspend(next);
+        return na;
+    }
+
     protected final NextAction doThrow(Throwable t) {
         NextAction na = new NextAction();
         na.throwException(t);
--- old/src/share/classes/com/sun/xml/internal/ws/api/server/BoundEndpoint.java	Tue Aug  4 09:59:51 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/server/BoundEndpoint.java	Tue Aug  4 09:59:50 2009
@@ -42,6 +42,8 @@
      * <p>
      * Multiple {@link BoundEndpoint}s may point to the same {@link WSEndpoint},
      * if it's bound to multiple transports.
+     *
+     * @return the endpoint
      */
     @NotNull WSEndpoint getEndpoint();
 
@@ -52,6 +54,24 @@
      * For example, if this endpoint is bound to a servlet endpoint
      * "http://foobar/myapp/myservice", then this method should
      * return that address.
+     *
+     * @return address of the endpoint
      */
     @NotNull URI getAddress();
+
+    /**
+     * The address of the bound endpoint using the base address. Often
+     * times, baseAddress is only avaialble during the request.
+     *
+     * <p>
+     * If the endpoint is bound to a servlet endpoint, the base address
+     * won't include the url-pattern, so the base address would be
+     * "http://host:port/context". This method would include url-pattern
+     * for the endpoint and return that address
+     * for e.g. "http://host:port/context/url-pattern"
+     *
+     * @param baseAddress that is used in computing the full address
+     * @return address of the endpoint
+     */
+    @NotNull URI getAddress(String baseAddress);
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/server/InstanceResolver.java	Tue Aug  4 09:59:53 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/server/InstanceResolver.java	Tue Aug  4 09:59:53 2009
@@ -82,9 +82,29 @@
      *      Always non-null. Represents the request message to be served.
      *      The caller may not consume the {@link Message}.
      */
-    public abstract @NotNull T resolve(Packet request);
+    public abstract @NotNull T resolve(@NotNull Packet request);
 
     /**
+     * Called by the default {@link Invoker} after the method call is done.
+     * This gives {@link InstanceResolver} a chance to do clean up.
+     *
+     * <p>
+     * Alternatively, one could override {@link #createInvoker()} to
+     * create a custom invoker to do this in more flexible way.
+     *
+     * <p>
+     * The default implementation is a no-op.
+     *
+     * @param request
+     *      The same request packet given to {@link #resolve(Packet)} method.
+     * @param servant
+     *      The object returned from the {@link #resolve(Packet)} method.
+     * @since 2.1.2
+     */
+    public void postInvoke(@NotNull Packet request, @NotNull T servant) {
+    }
+
+    /**
      * Called by {@link WSEndpoint} when it's set up.
      *
      * <p>
@@ -210,12 +230,22 @@
 
             @Override
             public Object invoke(Packet p, Method m, Object... args) throws InvocationTargetException, IllegalAccessException {
-                return m.invoke( resolve(p), args );
+                T t = resolve(p);
+                try {
+                    return m.invoke(t, args );
+                } finally {
+                    postInvoke(p,t);
+                }
             }
 
             @Override
-            public <T> T invokeProvider(@NotNull Packet p, T arg) {
-                return ((Provider<T>)resolve(p)).invoke(arg);
+            public <U> U invokeProvider(@NotNull Packet p, U arg) {
+                T t = resolve(p);
+                try {
+                    return ((Provider<U>) t).invoke(arg);
+                } finally {
+                    postInvoke(p,t);
+                }
             }
 
             public String toString() {
--- old/src/share/classes/com/sun/xml/internal/ws/api/server/PortAddressResolver.java	Tue Aug  4 09:59:55 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/server/PortAddressResolver.java	Tue Aug  4 09:59:55 2009
@@ -59,4 +59,22 @@
      *      is written as it is (without any patching).
      */
     public abstract @Nullable String getAddressFor(@NotNull QName serviceName, @NotNull String portName);
+
+    /**
+     * Gets the endpoint address for a WSDL port
+     *
+     * @param serviceName
+     *       WSDL service name(wsd:service in WSDL) for which address is needed. Always non-null.
+     * @param portName
+     *       WSDL port name(wsdl:port in WSDL) for which address is needed. Always non-null.
+     * @param currentAddress
+     *       Whatever current address specified for the port in the WSDL
+     * @return
+     *      The address needs to be put in WSDL for port element's location
+     *      attribute. Can be null. If it is null, existing port address
+     *      is written as it is (without any patching).
+     */
+    public @Nullable String getAddressFor(@NotNull QName serviceName, @NotNull String portName, String currentAddress) {
+        return getAddressFor(serviceName, portName);
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/server/SDDocument.java	Tue Aug  4 09:59:57 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/server/SDDocument.java	Tue Aug  4 09:59:57 2009
@@ -32,6 +32,7 @@
 import java.io.OutputStream;
 import java.io.IOException;
 import java.net.URL;
+import java.util.Set;
 
 /**
  * Represents an individual document that forms a {@link ServiceDefinition}.
@@ -69,6 +70,11 @@
     boolean isSchema();
 
     /**
+     * returns the referenced documents
+     */
+    Set<String> getImports();
+
+    /**
      * Gets the system ID of the document where it's taken from. Generated documents
      * use a fake URL that can be used to resolve relative URLs. So donot use this URL
      * for reading or writing.
@@ -150,5 +156,11 @@
          * TODO: does this info need to be exposed?
          */
         boolean hasService();
+
+        /**
+         * All &lt;service> names that were in this WSDL, or empty set if there was none.
+         * Used for error diagnostics.
+         */
+        Set<QName> getAllServices();
     }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/server/WSEndpoint.java	Tue Aug  4 10:00:00 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/server/WSEndpoint.java	Tue Aug  4 09:59:59 2009
@@ -31,6 +31,7 @@
 import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.message.Message;
 import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.model.SEIModel;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
 import com.sun.xml.internal.ws.api.pipe.Codec;
 import com.sun.xml.internal.ws.api.pipe.Engine;
@@ -47,6 +48,7 @@
 import javax.xml.ws.WebServiceException;
 import java.net.URL;
 import java.util.Collection;
+import java.util.Set;
 import java.util.concurrent.Executor;
 
 /**
@@ -342,8 +344,39 @@
      */
     public abstract @Nullable ServiceDefinition getServiceDefinition();
 
+    /**
+     * Gets the list of {@link EndpointComponent} that are associated
+     * with this endpoint.
+     *
+     * <p>
+     * Components (such as codec, tube, handler, etc) who wish to provide
+     * some service to other components in the endpoint can iterate the
+     * registry and call its {@link EndpointComponent#getSPI(Class)} to
+     * establish a private contract between components.
+     * <p>
+     * Components who wish to subscribe to such a service can add itself
+     * to this set.
+     *
+     * @return
+     *      always return the same set.
+     */
+    public abstract @NotNull Set<EndpointComponent> getComponentRegistry();
 
+    /**
+     * Gets the {@link com.sun.xml.internal.ws.api.model.SEIModel} that represents the relationship
+     * between WSDL and Java SEI.
+     *
+     * <p>
+     * This method returns a non-null value if and only if this
+     * endpoint is ultimately serving an application through an SEI.
+     *
+     * @return
+     *      maybe null. See above for more discussion.
+     *      Always the same value.
+     */
+    public abstract @Nullable SEIModel getSEIModel();
 
+
     /**
      * Creates an endpoint from deployment or programmatic configuration
      *
--- old/src/share/classes/com/sun/xml/internal/ws/api/streaming/XMLStreamReaderFactory.java	Tue Aug  4 10:00:02 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/streaming/XMLStreamReaderFactory.java	Tue Aug  4 10:00:01 2009
@@ -35,11 +35,15 @@
 import javax.xml.stream.XMLStreamReader;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.io.Reader;
 import java.io.StringReader;
+import java.io.UnsupportedEncodingException;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.net.URL;
+import java.util.logging.Logger;
+import java.security.AccessController;
 
 /**
  * Factory for {@link XMLStreamReader}.
@@ -52,6 +56,8 @@
  */
 public abstract class XMLStreamReaderFactory {
 
+    private static final Logger LOGGER = Logger.getLogger(XMLStreamReaderFactory.class.getName());
+
     /**
      * Singleton instance.
      */
@@ -58,15 +64,12 @@
     private static volatile @NotNull XMLStreamReaderFactory theInstance;
 
     static {
-        XMLInputFactory xif = XMLInputFactory.newInstance();
-        xif.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, true);
-        xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);
-
+        XMLInputFactory xif = getXMLInputFactory();
         XMLStreamReaderFactory f=null;
 
         // this system property can be used to disable the pooling altogether,
         // in case someone hits an issue with pooling in the production system.
-        if(!Boolean.getBoolean(XMLStreamReaderFactory.class.getName()+".noPool"))
+        if(!getProperty(XMLStreamReaderFactory.class.getName()+".noPool"))
             f = Zephyr.newInstance(xif);
 
         if(f==null) {
@@ -76,11 +79,30 @@
         }
 
         if(f==null)
-            f = new Default(xif);
+            f = new Default();
 
         theInstance = f;
+        LOGGER.fine("XMLStreamReaderFactory instance is = "+theInstance);
     }
 
+    private static XMLInputFactory getXMLInputFactory() {
+        XMLInputFactory xif = null;
+        if (getProperty(XMLStreamReaderFactory.class.getName()+".woodstox")) {
+            try {
+                xif = (XMLInputFactory)Class.forName("com.ctc.wstx.stax.WstxInputFactory").newInstance();
+            } catch (Exception e) {
+                // Ignore and fallback to default XMLInputFactory
+            }
+        }
+        if (xif == null) {
+            xif = XMLInputFactory.newInstance();
+        }
+        xif.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, true);
+        xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);
+        return xif;
+    }
+
+
     /**
      * Overrides the singleton {@link XMLStreamReaderFactory} instance that
      * the JAX-WS RI uses.
@@ -117,6 +139,12 @@
         return get().doCreate(systemId,in,rejectDTDs);
     }
 
+    public static XMLStreamReader create(@Nullable String systemId, InputStream in, @Nullable String encoding, boolean rejectDTDs) {
+        return (encoding == null)
+                ? create(systemId, in, rejectDTDs)
+                : get().doCreate(systemId,in,encoding,rejectDTDs);
+    }
+
     public static XMLStreamReader create(@Nullable String systemId, Reader reader, boolean rejectDTDs) {
         return get().doCreate(systemId,reader,rejectDTDs);
     }
@@ -152,6 +180,16 @@
 
     public abstract XMLStreamReader doCreate(String systemId, InputStream in, boolean rejectDTDs);
 
+    private XMLStreamReader doCreate(String systemId, InputStream in, @NotNull String encoding, boolean rejectDTDs) {
+        Reader reader;
+        try {
+            reader = new InputStreamReader(in, encoding);
+        } catch(UnsupportedEncodingException ue) {
+            throw new XMLReaderException("stax.cantCreate", ue);
+        }
+        return doCreate(systemId, reader, rejectDTDs);
+    }
+
     public abstract XMLStreamReader doCreate(String systemId, Reader reader, boolean rejectDTDs);
 
     public abstract void doRecycle(XMLStreamReader r);
@@ -200,10 +238,10 @@
             // check if this is from Zephyr
             try {
                 Class<?> clazz = xif.createXMLStreamReader(new StringReader("<foo/>")).getClass();
-
-                if(!clazz.getName().startsWith("com.sun.xml.internal.stream."))
+                // JDK has different XMLStreamReader impl class. Even if we check for that,
+                // it doesn't have setInputSource(InputSource). Let it use Default
+                if(!(clazz.getName().startsWith("com.sun.xml.internal.stream.")) )
                     return null;    // nope
-
                 return new Zephyr(xif,clazz);
             } catch (NoSuchMethodException e) {
                 return null;    // this factory is not for zephyr
@@ -278,7 +316,11 @@
             } catch (IllegalAccessException e) {
                 throw new XMLReaderException("stax.cantCreate",e);
             } catch (InvocationTargetException e) {
-                throw new XMLReaderException("stax.cantCreate",e);
+                Throwable cause = e.getCause();
+                if (cause == null) {
+                    cause = e;
+                }
+                throw new XMLReaderException("stax.cantCreate", cause);
             } catch (XMLStreamException e) {
                 throw new XMLReaderException("stax.cantCreate",e);
             }
@@ -295,21 +337,40 @@
      * that can work with any {@link XMLInputFactory}.
      *
      * <p>
-     * {@link XMLInputFactory} is not required to be thread-safe, so the
-     * create method on this implementation is synchronized.
+     * {@link XMLInputFactory} is not required to be thread-safe, but
+     * if the create method on this implementation is synchronized,
+     * it may run into (see <a href="https://jax-ws.dev.java.net/issues/show_bug.cgi?id=555">
+     * race condition</a>). Hence, using a XMLInputFactory per theread.
      */
-    public static final class Default extends NoLock {
-        public Default(XMLInputFactory xif) {
-            super(xif);
+    public static final class Default extends XMLStreamReaderFactory {
+
+        private final ThreadLocal<XMLInputFactory> xif = new ThreadLocal<XMLInputFactory>() {
+            @Override
+            public XMLInputFactory initialValue() {
+                return getXMLInputFactory();
+            }
+        };
+
+        public XMLStreamReader doCreate(String systemId, InputStream in, boolean rejectDTDs) {
+            try {
+                return xif.get().createXMLStreamReader(systemId,in);
+            } catch (XMLStreamException e) {
+                throw new XMLReaderException("stax.cantCreate",e);
+            }
         }
 
-        public synchronized XMLStreamReader doCreate(String systemId, InputStream in, boolean rejectDTDs) {
-            return super.doCreate(systemId, in, rejectDTDs);
+        public XMLStreamReader doCreate(String systemId, Reader in, boolean rejectDTDs) {
+            try {
+                return xif.get().createXMLStreamReader(systemId,in);
+            } catch (XMLStreamException e) {
+                throw new XMLReaderException("stax.cantCreate",e);
+            }
         }
 
-        public synchronized XMLStreamReader doCreate(String systemId, Reader in, boolean rejectDTDs) {
-            return super.doCreate(systemId, in, rejectDTDs);
+        public void doRecycle(XMLStreamReader r) {
+            // there's no way to recycle with the default StAX API.
         }
+
     }
 
     /**
@@ -364,4 +425,16 @@
             return super.doCreate(systemId, in, rejectDTDs);
         }
     }
+
+    private static Boolean getProperty(final String prop) {
+        Boolean b = AccessController.doPrivileged(
+            new java.security.PrivilegedAction<Boolean>() {
+                public Boolean run() {
+                    String value = System.getProperty(prop);
+                    return value != null ? Boolean.valueOf(value) : Boolean.FALSE;
+                }
+            }
+        );
+        return Boolean.FALSE;
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/streaming/XMLStreamWriterFactory.java	Tue Aug  4 10:00:04 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/streaming/XMLStreamWriterFactory.java	Tue Aug  4 10:00:04 2009
@@ -39,6 +39,7 @@
 import java.io.StringWriter;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.util.logging.Logger;
 
 /**
  * Factory for {@link XMLStreamWriter}.
@@ -51,6 +52,8 @@
  */
 public abstract class XMLStreamWriterFactory {
 
+    private static final Logger LOGGER = Logger.getLogger(XMLStreamWriterFactory.class.getName());
+
     /**
      * Singleton instance.
      */
@@ -58,7 +61,17 @@
 
 
     static {
-        XMLOutputFactory xof = XMLOutputFactory.newInstance();
+        XMLOutputFactory  xof = null;
+        if (Boolean.getBoolean(XMLStreamWriterFactory.class.getName()+".woodstox")) {
+            try {
+                xof = (XMLOutputFactory)Class.forName("com.ctc.wstx.stax.WstxOutputFactory").newInstance();
+            } catch (Exception e) {
+                // Ignore and fallback to default XMLOutputFactory
+            }
+        }
+        if (xof == null) {
+            xof = XMLOutputFactory.newInstance();
+        }
 
         XMLStreamWriterFactory f=null;
 
@@ -66,10 +79,16 @@
         // in case someone hits an issue with pooling in the production system.
         if(!Boolean.getBoolean(XMLStreamWriterFactory.class.getName()+".noPool"))
             f = Zephyr.newInstance(xof);
-        if(f==null)
+        if(f==null) {
+            // is this Woodstox?
+            if(xof.getClass().getName().equals("com.ctc.wstx.stax.WstxOutputFactory"))
+                f = new NoLock(xof);
+        }
+        if (f == null)
             f = new Default(xof);
 
         theInstance = f;
+        LOGGER.fine("XMLStreamWriterFactory instance is = "+theInstance);
     }
 
     /**
@@ -302,4 +321,33 @@
                 ((RecycleAware)r).onRecycled();
         }
     }
+
+    /**
+     *
+     * For {@link javax.xml.stream.XMLOutputFactory} is thread safe.
+     */
+    public static final class NoLock extends XMLStreamWriterFactory {
+        private final XMLOutputFactory xof;
+
+        public NoLock(XMLOutputFactory xof) {
+            this.xof = xof;
+        }
+
+        public XMLStreamWriter doCreate(OutputStream out) {
+            return doCreate(out,"UTF-8");
+        }
+
+        public XMLStreamWriter doCreate(OutputStream out, String encoding) {
+            try {
+                return xof.createXMLStreamWriter(out,encoding);
+            } catch (XMLStreamException e) {
+                throw new XMLReaderException("stax.cantCreate",e);
+            }
+        }
+
+        public void doRecycle(XMLStreamWriter r) {
+            // no recycling
+        }
+
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/api/wsdl/parser/WSDLParserExtension.java	Tue Aug  4 10:00:06 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/wsdl/parser/WSDLParserExtension.java	Tue Aug  4 10:00:06 2009
@@ -26,19 +26,7 @@
 package com.sun.xml.internal.ws.api.wsdl.parser;
 
 import com.sun.xml.internal.ws.api.WSService;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundOperation;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundPortType;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLExtensible;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLExtension;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLFault;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLInput;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLMessage;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLModel;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLOperation;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLPortType;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLService;
+import com.sun.xml.internal.ws.api.model.wsdl.*;
 import com.sun.xml.internal.ws.api.pipe.Tube;
 import com.sun.xml.internal.ws.wsdl.parser.RuntimeWSDLParser;
 
@@ -255,11 +243,11 @@
     public void bindingOperationOutputAttributes(WSDLBoundOperation operation, XMLStreamReader reader) {
     }
 
-    public boolean bindingOperationFaultElements(WSDLBoundOperation operation, XMLStreamReader reader) {
+    public boolean bindingOperationFaultElements(WSDLBoundFault fault, XMLStreamReader reader) {
         return false;
     }
 
-    public void bindingOperationFaultAttributes(WSDLBoundOperation operation, XMLStreamReader reader) {
+    public void bindingOperationFaultAttributes(WSDLBoundFault fault, XMLStreamReader reader) {
     }
 
     // TODO: complete the rest of the callback
--- old/src/share/classes/com/sun/xml/internal/ws/api/wsdl/parser/WSDLParserExtensionContext.java	Tue Aug  4 10:00:09 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/wsdl/parser/WSDLParserExtensionContext.java	Tue Aug  4 10:00:08 2009
@@ -24,12 +24,15 @@
  */
 package com.sun.xml.internal.ws.api.wsdl.parser;
 
+import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLModel;
+import com.sun.xml.internal.ws.api.server.Container;
 
 /**
  * Provides contextual information for {@link WSDLParserExtension}s.
  *
  * @author Vivek Pandey
+ * @author Fabian Ritzmann
  */
 public interface WSDLParserExtensionContext {
     /**
@@ -43,4 +46,12 @@
      * {@link WSDLParserExtension#finished(WSDLParserExtensionContext)} is called.
      */
     WSDLModel getWSDLModel();
+
+    /**
+     * Provides the {@link Container} in which this service or client is running.
+     * May return null.
+     *
+     * @return The container in which this service or client is running.
+     */
+    @NotNull Container getContainer();
 }
--- old/src/share/classes/com/sun/xml/internal/ws/binding/BindingImpl.java	Tue Aug  4 10:00:11 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/binding/BindingImpl.java	Tue Aug  4 10:00:10 2009
@@ -34,6 +34,7 @@
 import com.sun.xml.internal.ws.api.pipe.Codec;
 import com.sun.xml.internal.ws.client.HandlerConfiguration;
 import com.sun.xml.internal.ws.developer.MemberSubmissionAddressingFeature;
+import com.sun.xml.internal.ws.developer.BindingTypeFeature;
 
 import javax.xml.ws.WebServiceFeature;
 import javax.xml.ws.soap.AddressingFeature;
@@ -134,6 +135,13 @@
     }
 
     public static BindingImpl create(@NotNull BindingID bindingId, WebServiceFeature[] features) {
+        // Override the BindingID from the features
+        for(WebServiceFeature feature : features) {
+            if (feature instanceof BindingTypeFeature) {
+                BindingTypeFeature f = (BindingTypeFeature)feature;
+                bindingId = BindingID.parse(f.getBindingId());
+            }
+        }
         if (bindingId.equals(BindingID.XML_HTTP))
             return new HTTPBindingImpl();
         else
--- old/src/share/classes/com/sun/xml/internal/ws/binding/HTTPBindingImpl.java	Tue Aug  4 10:00:13 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/binding/HTTPBindingImpl.java	Tue Aug  4 10:00:13 2009
@@ -68,6 +68,6 @@
         return new HandlerConfiguration(
                 Collections.<String>emptySet(),
                 Collections.<QName>emptySet(),
-                handlerChain,logicalHandlers,null,null);
+                handlerChain,logicalHandlers,null,null,null);
     }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/binding/SOAPBindingImpl.java	Tue Aug  4 10:00:15 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/binding/SOAPBindingImpl.java	Tue Aug  4 10:00:15 2009
@@ -28,6 +28,7 @@
 import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.ws.api.BindingID;
 import com.sun.xml.internal.ws.api.SOAPVersion;
+import com.sun.xml.internal.ws.api.handler.MessageHandler;
 import com.sun.xml.internal.ws.client.HandlerConfiguration;
 import com.sun.xml.internal.ws.encoding.soap.streaming.SOAP12NamespaceConstants;
 import com.sun.xml.internal.ws.handler.HandlerException;
@@ -43,11 +44,7 @@
 import javax.xml.ws.handler.soap.SOAPHandler;
 import javax.xml.ws.soap.MTOMFeature;
 import javax.xml.ws.soap.SOAPBinding;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
+import java.util.*;
 
 
 /**
@@ -113,6 +110,7 @@
     protected HandlerConfiguration createHandlerConfig(List<Handler> handlerChain) {
         List<LogicalHandler> logicalHandlers = new ArrayList<LogicalHandler>();
         List<SOAPHandler> soapHandlers = new ArrayList<SOAPHandler>();
+        List<MessageHandler> messageHandlers = new ArrayList<MessageHandler>();
         Set<QName> handlerKnownHeaders = new HashSet<QName>();
 
         for (Handler handler : handlerChain) {
@@ -124,13 +122,19 @@
                 if (headers != null) {
                     handlerKnownHeaders.addAll(headers);
                 }
-            } else {
+            } else if (handler instanceof MessageHandler) {
+                messageHandlers.add((MessageHandler) handler);
+                Set<QName> headers = ((MessageHandler<?>) handler).getHeaders();
+                if (headers != null) {
+                    handlerKnownHeaders.addAll(headers);
+                }
+            }else {
                 throw new HandlerException("handler.not.valid.type",
                     handler.getClass());
             }
         }
         return new HandlerConfiguration(roles,portKnownHeaders,handlerChain,
-                logicalHandlers,soapHandlers,handlerKnownHeaders);
+                logicalHandlers,soapHandlers,messageHandlers,handlerKnownHeaders);
     }
 
     protected void addRequiredRoles() {
@@ -157,7 +161,7 @@
         addRequiredRoles();
         HandlerConfiguration oldConfig = getHandlerConfig();
         setHandlerConfig(new HandlerConfiguration(this.roles, portKnownHeaders, oldConfig.getHandlerChain(),
-                oldConfig.getLogicalHandlers(),oldConfig.getSoapHandlers(),
+                oldConfig.getLogicalHandlers(),oldConfig.getSoapHandlers(), oldConfig.getMessageHandlers(),
                 oldConfig.getHandlerKnownHeaders()));
     }
 
--- old/src/share/classes/com/sun/xml/internal/ws/binding/WebServiceFeatureList.java	Tue Aug  4 10:00:18 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/binding/WebServiceFeatureList.java	Tue Aug  4 10:00:17 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 package com.sun.xml.internal.ws.binding;
 
 import com.sun.istack.internal.NotNull;
@@ -264,6 +263,14 @@
         this.parent = parent;
     }
 
+    public static @Nullable <F extends WebServiceFeature> F getFeature(@NotNull WebServiceFeature[] features, @NotNull Class<F> featureType) {
+        for(WebServiceFeature f : features) {
+            if (f.getClass() == featureType)
+                return (F)f;
+        }
+        return null;
+    }
+
     /**
      * A Union of this WebServiceFeatureList and the parent.
      */
--- old/src/share/classes/com/sun/xml/internal/ws/client/AsyncInvoker.java	Tue Aug  4 10:00:20 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/AsyncInvoker.java	Tue Aug  4 10:00:19 2009
@@ -29,6 +29,8 @@
 import com.sun.xml.internal.ws.api.pipe.Fiber.CompletionCallback;
 import com.sun.xml.internal.ws.api.pipe.Tube;
 
+import javax.xml.ws.WebServiceException;
+
 /**
  * Invokes {@link Tube}line asynchronously for the client's async API(for e.g.: Dispatch#invokeAsync}
  * The concrete classes need to call {@link Stub#processAsync(Packet, RequestContext, CompletionCallback)} in
@@ -47,4 +49,17 @@
         this.responseImpl = responseImpl;
     }
 
+    public void run () {
+        try {
+            do_run();
+        }catch(WebServiceException e) {
+            throw e;
+        }catch(Throwable t) {
+            //Wrap it in WebServiceException
+            throw new WebServiceException(t);
+        }
+    }
+
+    public abstract void do_run();
+
 }
--- old/src/share/classes/com/sun/xml/internal/ws/client/AsyncResponseImpl.java	Tue Aug  4 10:00:22 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/AsyncResponseImpl.java	Tue Aug  4 10:00:22 2009
@@ -39,10 +39,6 @@
  * request to Fiber and returns. When the Fiber finishes the execution, it sets
  * response in the {@link FutureTask}
  *
- * <p>
- * {@link ResponseImpl} executes things synchronously and waits for the return
- * parameter.
- *
  * @author Jitendra Kotamraju
  */
 public final class AsyncResponseImpl<T> extends FutureTask<T> implements Response<T>, ResponseContextReceiver {
--- old/src/share/classes/com/sun/xml/internal/ws/client/BindingProviderProperties.java	Tue Aug  4 10:00:24 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/BindingProviderProperties.java	Tue Aug  4 10:00:24 2009
@@ -42,10 +42,6 @@
         "com.sun.xml.internal.ws.server.OneWayOperation";
 
 
-    // Proprietary
-    public static final String REQUEST_TIMEOUT =
-        "com.sun.xml.internal.ws.request.timeout";
-
     //JAXWS 2.0
     public static final String JAXWS_HANDLER_CONFIG =
         "com.sun.xml.internal.ws.handler.config";
--- old/src/share/classes/com/sun/xml/internal/ws/client/HandlerConfiguration.java	Tue Aug  4 10:00:26 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/HandlerConfiguration.java	Tue Aug  4 10:00:26 2009
@@ -24,15 +24,13 @@
  */
 package com.sun.xml.internal.ws.client;
 
+import com.sun.xml.internal.ws.api.handler.MessageHandler;
+
 import javax.xml.namespace.QName;
 import javax.xml.ws.handler.Handler;
 import javax.xml.ws.handler.LogicalHandler;
 import javax.xml.ws.handler.soap.SOAPHandler;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
+import java.util.*;
 
 /**
  * This class holds the handler information on the BindingProvider.
@@ -54,6 +52,7 @@
     private final List<Handler> handlerChain;
     private final List<LogicalHandler> logicalHandlers;
     private final List<SOAPHandler> soapHandlers;
+    private final List<MessageHandler> messageHandlers;
     private Set<QName> knownHeaders;
     private Set<QName> handlerKnownHeaders;
     /**
@@ -68,11 +67,13 @@
     public HandlerConfiguration(Set<String> roles, Set<QName> portKnownHeaders,
                                 List<Handler> handlerChain,
                                 List<LogicalHandler> logicalHandlers, List<SOAPHandler> soapHandlers,
+                                List<MessageHandler> messageHandlers,
                                 Set<QName> handlerKnownHeaders) {
         this.roles = roles;
         this.handlerChain = handlerChain;
         this.logicalHandlers = logicalHandlers;
         this.soapHandlers = soapHandlers;
+        this.messageHandlers = messageHandlers;
         this.handlerKnownHeaders = handlerKnownHeaders;
         this.knownHeaders = new HashSet<QName>();
         if(portKnownHeaders != null)
@@ -104,6 +105,10 @@
         return soapHandlers;
     }
 
+    public List<MessageHandler> getMessageHandlers() {
+        return messageHandlers;
+    }
+
     public Set<QName> getKnownHeaders() {
         return knownHeaders;
     }
--- old/src/share/classes/com/sun/xml/internal/ws/client/Stub.java	Tue Aug  4 10:00:29 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/Stub.java	Tue Aug  4 10:00:28 2009
@@ -27,7 +27,6 @@
 
 import com.sun.istack.internal.NotNull;
 import com.sun.istack.internal.Nullable;
-import com.sun.xml.internal.ws.Closeable;
 import com.sun.xml.internal.ws.model.wsdl.WSDLProperties;
 import com.sun.xml.internal.ws.api.EndpointAddress;
 import com.sun.xml.internal.ws.api.WSBinding;
@@ -70,7 +69,7 @@
  *
  * @author Kohsuke Kawaguchi
  */
-public abstract class Stub implements WSBindingProvider, ResponseContextReceiver, Closeable {
+public abstract class Stub implements WSBindingProvider, ResponseContextReceiver  {
 
     /**
      * Reuse pipelines as it's expensive to create.
@@ -199,33 +198,7 @@
      *                       So we take a setter that abstracts that away.
      */
     protected final Packet process(Packet packet, RequestContext requestContext, ResponseContextReceiver receiver) {
-        {// fill in Packet
-            packet.proxy = this;
-            packet.handlerConfig = binding.getHandlerConfig();
-            requestContext.fill(packet);
-            if (wsdlProperties != null) {
-                packet.addSatellite(wsdlProperties);
-            }
-            if (addrVersion != null) {
-                // populate request WS-Addressing headers
-                HeaderList headerList = packet.getMessage().getHeaders();
-                headerList.fillRequestAddressingHeaders(wsdlPort, binding, packet);
-
-
-                // Spec is not clear on if ReferenceParameters are to be added when addressing is not enabled,
-                // but the EPR has ReferenceParameters.
-                // Current approach: Add ReferenceParameters only if addressing enabled.
-                if (endpointReference != null)
-                    endpointReference.addReferenceParameters(packet.getMessage().getHeaders());
-            }
-
-            // to make it multi-thread safe we need to first get a stable snapshot
-            Header[] hl = userOutboundHeaders;
-            if(hl!=null)
-                packet.getMessage().getHeaders().addAll(hl);
-        }
-
-
+        configureRequestPacket(packet, requestContext);
         Pool<Tube> pool = tubes;
         if (pool == null)
             throw new WebServiceException("close method has already been invoked"); // TODO: i18n
@@ -250,6 +223,33 @@
         }
     }
 
+    private void configureRequestPacket(Packet packet, RequestContext requestContext) {
+        // fill in Packet
+        packet.proxy = this;
+        packet.handlerConfig = binding.getHandlerConfig();
+        requestContext.fill(packet);
+        if (wsdlProperties != null) {
+            packet.addSatellite(wsdlProperties);
+        }
+        if (addrVersion != null) {
+            // populate request WS-Addressing headers
+            HeaderList headerList = packet.getMessage().getHeaders();
+            headerList.fillRequestAddressingHeaders(wsdlPort, binding, packet);
+
+
+            // Spec is not clear on if ReferenceParameters are to be added when addressing is not enabled,
+            // but the EPR has ReferenceParameters.
+            // Current approach: Add ReferenceParameters only if addressing enabled.
+            if (endpointReference != null)
+                endpointReference.addReferenceParameters(packet.getMessage().getHeaders());
+        }
+
+        // to make it multi-thread safe we need to first get a stable snapshot
+        Header[] hl = userOutboundHeaders;
+        if(hl!=null)
+                packet.getMessage().getHeaders().addAll(hl);
+    }
+
     /**
      * Passes a message through a {@link Tube}line for processing. The processing happens
      * asynchronously and when the response is available, Fiber.CompletionCallback is
@@ -269,16 +269,7 @@
      */
     protected final void processAsync(Packet request, RequestContext requestContext, final Fiber.CompletionCallback completionCallback) {
         // fill in Packet
-        request.proxy = this;
-        request.handlerConfig = binding.getHandlerConfig();
-        requestContext.fill(request);
-        if (wsdlProperties != null) {
-            request.addSatellite(wsdlProperties);
-        }
-        if (AddressingVersion.isEnabled(binding)) {
-            if(endpointReference!=null)
-                endpointReference.addReferenceParameters(request.getMessage().getHeaders());
-        }
+        configureRequestPacket(request, requestContext);
 
         final Pool<Tube> pool = tubes;
         if (pool == null)
@@ -403,4 +394,8 @@
         return Collections.unmodifiableList((HeaderList)
             responseContext.get(JAXWSProperties.INBOUND_HEADER_LIST_PROPERTY));
     }
+
+    public final void setAddress(String address) {
+        requestContext.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, address);
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/client/WSServiceDelegate.java	Tue Aug  4 10:00:31 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/WSServiceDelegate.java	Tue Aug  4 10:00:31 2009
@@ -35,7 +35,7 @@
 import com.sun.xml.internal.ws.api.addressing.WSEndpointReference;
 import com.sun.xml.internal.ws.api.client.ServiceInterceptor;
 import com.sun.xml.internal.ws.api.client.ServiceInterceptorFactory;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLModel;
+import com.sun.xml.internal.ws.api.model.SEIModel;
 import com.sun.xml.internal.ws.api.pipe.*;
 import com.sun.xml.internal.ws.api.server.Container;
 import com.sun.xml.internal.ws.api.server.ContainerResolver;
@@ -46,6 +46,7 @@
 import com.sun.xml.internal.ws.client.HandlerConfigurator.HandlerResolverImpl;
 import com.sun.xml.internal.ws.client.sei.SEIStub;
 import com.sun.xml.internal.ws.developer.WSBindingProvider;
+import com.sun.xml.internal.ws.developer.UsesJAXBContextFeature;
 import com.sun.xml.internal.ws.model.AbstractSEIModelImpl;
 import com.sun.xml.internal.ws.model.RuntimeModeler;
 import com.sun.xml.internal.ws.model.SOAPSEIModel;
@@ -55,6 +56,7 @@
 import com.sun.xml.internal.ws.resources.ClientMessages;
 import com.sun.xml.internal.ws.resources.DispatchMessages;
 import com.sun.xml.internal.ws.resources.ProviderApiMessages;
+import com.sun.xml.internal.ws.util.JAXWSUtils;
 import com.sun.xml.internal.ws.util.ServiceConfigurationError;
 import com.sun.xml.internal.ws.util.ServiceFinder;
 import static com.sun.xml.internal.ws.util.xml.XmlUtil.createDefaultCatalogResolver;
@@ -62,6 +64,7 @@
 import org.xml.sax.SAXException;
 
 import javax.jws.HandlerChain;
+import javax.jws.WebService;
 import javax.xml.bind.JAXBContext;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLStreamException;
@@ -172,9 +175,18 @@
         //we cant create a Service without serviceName
         if (serviceName == null)
             throw new WebServiceException(ClientMessages.INVALID_SERVICE_NAME_NULL(serviceName));
+
+        InitParams initParams = INIT_PARAMS.get();
+        INIT_PARAMS.set(null);  // mark it as consumed
+        if(initParams==null)    initParams = EMPTY_PARAMS;
+
         this.serviceName = serviceName;
         this.serviceClass = serviceClass;
-        this.container = ContainerResolver.getInstance().getContainer();
+        Container tContainer = initParams.getContainer()!=null ? initParams.getContainer() : ContainerResolver.getInstance().getContainer();
+        if (tContainer == Container.NONE) {
+            tContainer = new ClientContainer();
+        }
+        this.container = tContainer;
 
         // load interceptor
         ServiceInterceptor interceptor = ServiceInterceptorFactory.load(this, Thread.currentThread().getContextClassLoader());
@@ -185,6 +197,19 @@
         this.serviceInterceptor = interceptor;
 
 
+        //if wsdl is null, try and get it from the WebServiceClient.wsdlLocation
+        if(wsdl == null){
+            if(serviceClass != Service.class){
+                WebServiceClient wsClient = AccessController.doPrivileged(new PrivilegedAction<WebServiceClient>() {
+                        public WebServiceClient run() {
+                            return serviceClass.getAnnotation(WebServiceClient.class);
+                        }
+                    });
+                String wsdlLocation = wsClient.wsdlLocation();
+                wsdlLocation = JAXWSUtils.absolutize(JAXWSUtils.getFileOrURLName(wsdlLocation));
+                wsdl = new StreamSource(wsdlLocation);
+            }
+        }
         WSDLServiceImpl service=null;
         if (wsdl != null) {
             try {
@@ -219,7 +244,7 @@
     }
 
     /**
-     * Parses the WSDL and builds {@link WSDLModel}.
+     * Parses the WSDL and builds {@link com.sun.xml.internal.ws.api.model.wsdl.WSDLModel}.
      * @param wsdlDocumentLocation
      *      Either this or <tt>wsdl</tt> parameter must be given.
      *      Null location means the system won't be able to resolve relative references in the WSDL,
@@ -227,7 +252,7 @@
     private WSDLModelImpl parseWSDL(URL wsdlDocumentLocation, Source wsdlSource) {
         try {
             return RuntimeWSDLParser.parse(wsdlDocumentLocation, wsdlSource, createDefaultCatalogResolver(),
-                true, ServiceFinder.find(WSDLParserExtension.class).toArray());
+                true, getContainer(), ServiceFinder.find(WSDLParserExtension.class).toArray());
         } catch (IOException e) {
             throw new WebServiceException(e);
         } catch (XMLStreamException e) {
@@ -273,8 +298,19 @@
     public <T> T getPort(QName portName, Class<T> portInterface, WebServiceFeature... features) {
         if (portName == null || portInterface == null)
             throw new IllegalArgumentException();
-        WSDLPortImpl portModel = getPortModel(portName);
-        return getPort(portModel.getEPR(),portName,portInterface,features);
+        WSDLServiceImpl tWsdlService = this.wsdlService;
+        if (tWsdlService == null) {
+            // assigning it to local variable and not setting it back to this.wsdlService intentionally
+            // as we don't want to include the service instance with information gathered from sei
+            tWsdlService = getWSDLModelfromSEI(portInterface);
+            //still null? throw error need wsdl metadata to create a proxy
+            if (tWsdlService == null) {
+                throw new WebServiceException(ProviderApiMessages.NO_WSDL_NO_PORT(portInterface.getName()));
+            }
+
+        }
+        WSDLPortImpl portModel = getPortModel(tWsdlService, portName);
+        return getPort(portModel.getEPR(), portName, portInterface, features);
     }
 
     public <T> T getPort(EndpointReference epr, Class<T> portInterface, WebServiceFeature... features) {
@@ -291,12 +327,22 @@
 
     private <T> T getPort(WSEndpointReference wsepr, QName portName, Class<T> portInterface,
                           WebServiceFeature... features) {
-        addSEI(portName, portInterface);
-        return createEndpointIFBaseProxy(wsepr,portName,portInterface,features);
+        SEIPortInfo spi = addSEI(portName, portInterface, features);
+        return createEndpointIFBaseProxy(wsepr,portName,portInterface,features, spi);
     }
     public <T> T getPort(Class<T> portInterface, WebServiceFeature... features) {
         //get the portType from SEI
         QName portTypeName = RuntimeModeler.getPortTypeName(portInterface);
+        WSDLServiceImpl wsdlService = this.wsdlService;
+        if(wsdlService == null) {
+            // assigning it to local variable and not setting it back to this.wsdlService intentionally
+            // as we don't want to include the service instance with information gathered from sei
+            wsdlService = getWSDLModelfromSEI(portInterface);
+            //still null? throw error need wsdl metadata to create a proxy
+            if(wsdlService == null) {
+                throw new WebServiceException(ProviderApiMessages.NO_WSDL_NO_PORT(portInterface.getName()));
+            }
+        }
         //get the first port corresponding to the SEI
         WSDLPortImpl port = wsdlService.getMatchingPort(portTypeName);
         if (port == null)
@@ -376,7 +422,10 @@
     private Tube createPipeline(PortInfo portInfo, WSBinding binding) {
         //Check all required WSDL extensions are understood
         checkAllWSDLExtensionsUnderstood(portInfo,binding);
-
+        SEIModel seiModel = null;
+        if(portInfo instanceof SEIPortInfo) {
+            seiModel = ((SEIPortInfo)portInfo).model;
+        }
         BindingID bindingId = portInfo.bindingId;
 
         TubelineAssembler assembler = TubelineAssemblerFactory.create(
@@ -387,7 +436,7 @@
                 new ClientTubeAssemblerContext(
                         portInfo.targetEndpoint,
                         portInfo.portModel,
-                        this, binding, container));
+                        this, binding, container,((BindingImpl)binding).createCodec(),seiModel));
     }
 
     /**
@@ -422,6 +471,11 @@
          return dispatch;
     }
 
+    @Override
+    public @NotNull Container getContainer() {
+        return container;
+    }
+
     public Dispatch<Object> createDispatch(QName portName, JAXBContext jaxbContext, Service.Mode mode, WebServiceFeature... webServiceFeatures) {
         WebServiceFeatureList featureList =  new WebServiceFeatureList(webServiceFeatures);
         WSEndpointReference wsepr = null;
@@ -445,7 +499,7 @@
         // TODO: what if it has different epr address?
         {
             PortInfo portInfo = new PortInfo(this, (wsepr.getAddress() == null) ? null : EndpointAddress.create(wsepr.getAddress()), eprPortName,
-                    getPortModel(eprPortName).getBinding().getBindingId());
+                    getPortModel(wsdlService, eprPortName).getBinding().getBindingId());
             if (!ports.containsKey(eprPortName)) {
                 ports.put(eprPortName, portInfo);
             }
@@ -506,6 +560,34 @@
         return portName;
 
     }
+
+    private WSDLServiceImpl getWSDLModelfromSEI(final Class sei) {
+        WebService ws = AccessController.doPrivileged(new PrivilegedAction<WebService>() {
+            public WebService run() {
+                return (WebService) sei.getAnnotation(WebService.class);
+            }
+        });
+        if (ws == null || ws.wsdlLocation().equals(""))
+            return null;
+        String wsdlLocation = ws.wsdlLocation();
+        wsdlLocation = JAXWSUtils.absolutize(JAXWSUtils.getFileOrURLName(wsdlLocation));
+        Source wsdl = new StreamSource(wsdlLocation);
+        WSDLServiceImpl service = null;
+
+        try {
+            URL url = wsdl.getSystemId() == null ? null : new URL(wsdl.getSystemId());
+            WSDLModelImpl model = parseWSDL(url, wsdl);
+            service = model.getService(this.serviceName);
+            if (service == null)
+                throw new WebServiceException(
+                        ClientMessages.INVALID_SERVICE_NAME(this.serviceName,
+                                buildNameList(model.getServices().keySet())));
+        } catch (MalformedURLException e) {
+            throw new WebServiceException(ClientMessages.INVALID_WSDL_URL(wsdl.getSystemId()));
+        }
+        return service;
+    }
+
     public QName getServiceName() {
         return serviceName;
     }
@@ -531,7 +613,8 @@
         }
     }
 
-    private <T> T createEndpointIFBaseProxy(@Nullable WSEndpointReference epr,QName portName, Class<T> portInterface, WebServiceFeature[] webServiceFeatures) {
+    private <T> T createEndpointIFBaseProxy(@Nullable WSEndpointReference epr,QName portName, Class<T> portInterface,
+                                            WebServiceFeature[] webServiceFeatures, SEIPortInfo eif) {
         //fail if service doesnt have WSDL
         if (wsdlService == null)
             throw new WebServiceException(ClientMessages.INVALID_SERVICE_NO_WSDL(serviceName));
@@ -541,8 +624,6 @@
                 ClientMessages.INVALID_PORT_NAME(portName,buildWsdlPortNames()));
         }
 
-        SEIPortInfo eif = seiContext.get(portName);
-
         BindingImpl binding = eif.createBinding(webServiceFeatures,portInterface);
         SEIStub pis = new SEIStub(this, binding, eif.model, createPipeline(eif, binding), epr);
 
@@ -569,11 +650,11 @@
      *
      * @return guaranteed to be non-null.
      */
-    public @NotNull WSDLPortImpl getPortModel(QName portName) {
+    private @NotNull WSDLPortImpl getPortModel(WSDLServiceImpl wsdlService, QName portName) {
         WSDLPortImpl port = wsdlService.get(portName);
         if (port == null)
             throw new WebServiceException(
-                ClientMessages.INVALID_PORT_NAME(portName,buildWsdlPortNames()));
+                    ClientMessages.INVALID_PORT_NAME(portName, buildWsdlPortNames()));
         return port;
     }
 
@@ -582,19 +663,33 @@
      * {@link SEIPortInfo} about a given SEI (linked from the {@link Service}-derived class.)
      */
     //todo: valid port in wsdl
-    private void addSEI(QName portName, Class portInterface) throws WebServiceException {
+    private SEIPortInfo addSEI(QName portName, Class portInterface, WebServiceFeature... features) throws WebServiceException {
+        boolean ownModel = useOwnSEIModel(features);
+        if (ownModel) {
+            // Create a new model and do not cache it
+            return createSEIPortInfo(portName, portInterface, features);
+        }
+
         SEIPortInfo spi = seiContext.get(portName);
-        if (spi != null) return;
-        WSDLPortImpl wsdlPort = getPortModel(portName);
-        RuntimeModeler modeler = new RuntimeModeler(portInterface, serviceName, wsdlPort);
+        if (spi == null) {
+            spi = createSEIPortInfo(portName, portInterface, features);
+            seiContext.put(spi.portName, spi);
+            ports.put(spi.portName, spi);
+        }
+        return spi;
+    }
+
+    private SEIPortInfo createSEIPortInfo(QName portName, Class portInterface, WebServiceFeature... features) {
+        WSDLPortImpl wsdlPort = getPortModel(wsdlService, portName);
+        RuntimeModeler modeler = new RuntimeModeler(portInterface, serviceName, wsdlPort, features);
+        modeler.setClassLoader(portInterface.getClassLoader());
         modeler.setPortName(portName);
         AbstractSEIModelImpl model = modeler.buildRuntimeModel();
+        return new SEIPortInfo(this, portInterface, (SOAPSEIModel) model, wsdlPort);
+    }
 
-        spi = new SEIPortInfo(this, portInterface, (SOAPSEIModel) model, wsdlPort);
-        seiContext.put(spi.portName, spi);
-        //seiContext.put(spi.sei, spi);
-        ports.put(spi.portName, spi);
-
+    private boolean useOwnSEIModel(WebServiceFeature... features) {
+        return WebServiceFeatureList.getFeature(features, UsesJAXBContextFeature.class) != null;
     }
 
     public WSDLServiceImpl getWsdlService() {
--- old/src/share/classes/com/sun/xml/internal/ws/client/dispatch/DataSourceDispatch.java	Tue Aug  4 10:00:33 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/dispatch/DataSourceDispatch.java	Tue Aug  4 10:00:33 2009
@@ -57,7 +57,7 @@
             case PAYLOAD:
                 throw new IllegalArgumentException("DataSource use is not allowed in Service.Mode.PAYLOAD\n");
             case MESSAGE:
-                return new Packet(XMLMessage.create(arg));
+                return new Packet(XMLMessage.create(arg, binding));
             default:
                 throw new WebServiceException("Unrecognized message mode");
         }
@@ -72,7 +72,7 @@
             // TODO Need to call hasUnconsumedDataSource()
             return hasDS.getDataSource();
         } else if (message instanceof PayloadSourceMessage) {
-            return XMLMessage.getDataSource(message);
+            return XMLMessage.getDataSource(message, binding);
         }
         return null;
     }
--- old/src/share/classes/com/sun/xml/internal/ws/client/dispatch/DispatchImpl.java	Tue Aug  4 10:00:35 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/dispatch/DispatchImpl.java	Tue Aug  4 10:00:35 2009
@@ -66,11 +66,10 @@
 import javax.xml.ws.http.HTTPBinding;
 import javax.xml.ws.soap.SOAPBinding;
 import javax.xml.ws.soap.SOAPFaultException;
-import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URISyntaxException;
-import java.net.URLDecoder;
+import java.net.URL;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -179,12 +178,12 @@
         } catch (JAXBException e) {
             //TODO: i18nify
             throw new DeserializationException(DispatchMessages.INVALID_RESPONSE_DESERIALIZATION(),e);
-        } catch(RuntimeException e){
-            //it could be a WebServiceException or a ProtocolException or any RuntimeException
-            // resulting due to some internal bug.
+        } catch(WebServiceException e){
+            //it could be a WebServiceException or a ProtocolException
             throw e;
         } catch(Throwable e){
-            //its some other exception resulting from user error, wrap it in
+            // it could be a RuntimeException resulting due to some internal bug or
+            // its some other exception resulting from user error, wrap it in
             // WebServiceException
             throw new WebServiceException(e);
         }
@@ -197,12 +196,21 @@
     }
 
     public final void invokeOneWay(T in) {
+        try {
+            checkNullAllowed(in, requestContext, binding, mode);
 
-        checkNullAllowed(in, requestContext, binding, mode);
-
-        Packet request = createPacket(in);
-        setProperties(request,false);
-        Packet response = process(request,requestContext,this);
+            Packet request = createPacket(in);
+            setProperties(request,false);
+            Packet response = process(request,requestContext,this);
+        } catch(WebServiceException e){
+            //it could be a WebServiceException or a ProtocolException
+            throw e;
+        } catch(Throwable e){
+            // it could be a RuntimeException resulting due to some internal bug or
+            // its some other exception resulting from user error, wrap it in
+            // WebServiceException
+            throw new WebServiceException(e);
+        }
     }
 
     void setProperties(Packet packet, boolean expectReply) {
@@ -310,11 +318,27 @@
 
         final String path = (pathInfo != null) ? pathInfo : endpointURI.getPath();
         try {
-            final URI temp = new URI(null, null, path, query, fragment);
-            return endpointURI.resolve(temp).toURL().toExternalForm();
-        } catch (URISyntaxException e) {
-            throw new WebServiceException(DispatchMessages.INVALID_URI_PATH_QUERY(path ,query));
-        } catch (MalformedURLException e) {
+            //final URI temp = new URI(null, null, path, query, fragment);
+            //return endpointURI.resolve(temp).toURL().toExternalForm();
+            // Using the following HACK instead of the above to avoid double encoding of
+            // the query. Application's QUERY_STRING is encoded using URLEncoder.encode().
+            // If we use that query in URI's constructor, it is encoded again.
+            // URLEncoder's encoding is not the same as URI's encoding of the query.
+            // See {@link URL}
+            StringBuilder spec = new StringBuilder();
+            if (path != null) {
+                spec.append(path);
+            }
+            if (query != null) {
+                spec.append("?");
+                spec.append(query);
+            }
+            if (fragment != null) {
+                spec.append("#");
+                spec.append(fragment);
+            }
+            return new URL(endpointURI.toURL(), spec.toString()).toExternalForm();
+       } catch (MalformedURLException e) {
             throw new WebServiceException(DispatchMessages.INVALID_URI_RESOLUTION(path));
         }
     }
@@ -402,7 +426,7 @@
             this.param = param;
         }
 
-        public void run () {
+        public void do_run () {
             checkNullAllowed(param, rc, binding, mode);
             Packet message = createPacket(param);
             resolveEndpointAddress(message, rc);
@@ -422,18 +446,25 @@
                     } catch (JAXBException e) {
                         //TODO: i18nify
                         responseImpl.set(null, new DeserializationException(DispatchMessages.INVALID_RESPONSE_DESERIALIZATION(),e));
-                    } catch(RuntimeException e){
-                        //it could be a WebServiceException or a ProtocolException or any RuntimeException
-                        // resulting due to some internal bug.
+                    } catch(WebServiceException e){
+                        //it could be a WebServiceException or a ProtocolException
                         responseImpl.set(null, e);
                     } catch(Throwable e){
-                        //its some other exception resulting from user error, wrap it in
+                        // It could be any RuntimeException resulting due to some internal bug.
+                        // or its some other exception resulting from user error, wrap it in
                         // WebServiceException
                         responseImpl.set(null, new WebServiceException(e));
                     }
                 }
                 public void onCompletion(@NotNull Throwable error) {
-                    responseImpl.set(null, error);
+                    if (error instanceof WebServiceException) {
+                        responseImpl.set(null, error);
+
+                    } else {
+                        //its RuntimeException or some other exception resulting from user error, wrap it in
+                        // WebServiceException
+                        responseImpl.set(null, new WebServiceException(error));
+                    }
                 }
             };
             processAsync(message,rc, callback);
--- old/src/share/classes/com/sun/xml/internal/ws/client/dispatch/RESTSourceDispatch.java	Tue Aug  4 10:00:38 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/dispatch/RESTSourceDispatch.java	Tue Aug  4 10:00:37 2009
@@ -60,7 +60,7 @@
     Source toReturnValue(Packet response) {
         Message msg = response.getMessage();
         try {
-            return new StreamSource(XMLMessage.getDataSource(msg).getInputStream());
+            return new StreamSource(XMLMessage.getDataSource(msg, binding).getInputStream());
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
--- old/src/share/classes/com/sun/xml/internal/ws/client/dispatch/SOAPMessageDispatch.java	Tue Aug  4 10:00:40 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/dispatch/SOAPMessageDispatch.java	Tue Aug  4 10:00:40 2009
@@ -32,20 +32,17 @@
 import com.sun.xml.internal.ws.client.WSServiceDelegate;
 import com.sun.xml.internal.ws.message.saaj.SAAJMessage;
 import com.sun.xml.internal.ws.resources.DispatchMessages;
+import com.sun.xml.internal.ws.transport.Headers;
 
 import javax.xml.namespace.QName;
 import javax.xml.soap.MimeHeader;
-import javax.xml.soap.MimeHeaders;
 import javax.xml.soap.SOAPException;
 import javax.xml.soap.SOAPMessage;
 import javax.xml.ws.Service;
 import javax.xml.ws.WebServiceException;
 import javax.xml.ws.handler.MessageContext;
-import java.util.ArrayList;
-import java.util.HashMap;
+
 import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
 
 /**
  * The <code>SOAPMessageDispatch</code> class provides support
@@ -63,26 +60,14 @@
     }
 
     Packet createPacket(SOAPMessage arg) {
-
-        if (arg == null && !isXMLHttp(binding))
-           throw new WebServiceException(DispatchMessages.INVALID_NULLARG_SOAP_MSGMODE(mode.name(), Service.Mode.PAYLOAD.toString()));
-
-        MimeHeaders mhs = arg.getMimeHeaders();
-        // TODO: these two lines seem dangerous. It should be left up to the transport and codec
-        // to decide how they are sent. remove after 2.1 FCS - KK.
-        mhs.addHeader("Content-Type", "text/xml");
-        mhs.addHeader("Content-Transfer-Encoding", "binary");
-        Map<String, List<String>> ch = new HashMap<String, List<String>>();
-        for (Iterator iter = arg.getMimeHeaders().getAllHeaders(); iter.hasNext();)
-        {
+        Iterator iter = arg.getMimeHeaders().getAllHeaders();
+        Headers ch = new Headers();
+        while(iter.hasNext()) {
             MimeHeader mh = (MimeHeader) iter.next();
-            List<String> h = new ArrayList<String>();
-            h.add(mh.getValue());
-            ch.put(mh.getName(), h);
+            ch.add(mh.getName(), mh.getValue());
         }
-
         Packet packet = new Packet(new SAAJMessage(arg));
-        packet.invocationProperties.put(MessageContext.HTTP_REQUEST_HEADERS,ch);
+        packet.invocationProperties.put(MessageContext.HTTP_REQUEST_HEADERS, ch);
         return packet;
     }
 
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/AsyncMethodHandler.java	Tue Aug  4 10:00:42 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/AsyncMethodHandler.java	Tue Aug  4 10:00:42 2009
@@ -27,9 +27,16 @@
 
 //import com.sun.tools.internal.ws.wsdl.document.soap.SOAPBinding;
 
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
+import com.sun.xml.internal.ws.api.message.Message;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.pipe.Fiber;
+import com.sun.xml.internal.ws.client.AsyncInvoker;
+import com.sun.xml.internal.ws.client.AsyncResponseImpl;
 import com.sun.xml.internal.ws.client.RequestContext;
-import com.sun.xml.internal.ws.client.ResponseContextReceiver;
-import com.sun.xml.internal.ws.client.ResponseImpl;
+import com.sun.xml.internal.ws.client.ResponseContext;
+import com.sun.xml.internal.ws.fault.SOAPFaultBuilder;
 import com.sun.xml.internal.ws.model.JavaMethodImpl;
 import com.sun.xml.internal.ws.model.ParameterImpl;
 import com.sun.xml.internal.ws.model.WrapperParameter;
@@ -36,13 +43,9 @@
 
 import javax.jws.soap.SOAPBinding.Style;
 import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.Holder;
 import javax.xml.ws.Response;
 import javax.xml.ws.WebServiceException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.Callable;
 
 /**
  * Common part between {@link CallbackMethodHandler} and {@link PollingMethodHandler}.
@@ -50,61 +53,26 @@
  * @author Kohsuke Kawaguchi
  * @author Jitendra Kotamraju
  */
-abstract class AsyncMethodHandler extends MethodHandler {
+abstract class AsyncMethodHandler extends SEIMethodHandler {
 
-    private final JavaMethodImpl jm;
-    private final AsyncBuilder asyncBuilder;
-    private final SyncMethodHandler core;
+    private final ResponseBuilder responseBuilder;
     /**
-     * Async Wrapper bean.
+     * Async bean class that has setters for all out parameters
      */
-    //private final Class wrapper;
+    private final @Nullable Class asyncBeanClass;
 
-    protected AsyncMethodHandler(SEIStub owner, JavaMethodImpl jm, SyncMethodHandler core) {
-        super(owner);
-        this.jm = jm;
-        this.core = core;
+    AsyncMethodHandler(SEIStub owner, JavaMethodImpl jm, JavaMethodImpl sync) {
+        super(owner, sync);
 
-        List<ParameterImpl> rp = jm.getResponseParameters();
-
-
-
-        Class tempWrap = null;
-        for(ParameterImpl param : rp) {
-            if (param.isWrapperStyle()) {
-                WrapperParameter wrapParam = (WrapperParameter)param;
-                if (core.getJavaMethod().getBinding().getStyle() == Style.DOCUMENT) {
-                    // doc/wrapper style
-                    tempWrap = (Class)wrapParam.getTypeReference().type;
-                    break;
-                }
-                for(ParameterImpl p : wrapParam.getWrapperChildren()) {
-                    if (p.getIndex() == -1) {
-                        tempWrap = (Class)p.getTypeReference().type;
-                        break;
-                    }
-                }
-                if (tempWrap != null) {
-                    break;
-                }
-            } else {
-                if (param.getIndex() == -1) {
-                    tempWrap = (Class)param.getTypeReference().type;
-                    break;
-                }
-            }
-        }
-        Class wrapper = tempWrap;
-
-        rp = core.getJavaMethod().getResponseParameters();
+        List<ParameterImpl> rp = sync.getResponseParameters();
         int size = 0;
         for( ParameterImpl param : rp ) {
             if (param.isWrapperStyle()) {
                 WrapperParameter wrapParam = (WrapperParameter)param;
                 size += wrapParam.getWrapperChildren().size();
-                if (core.getJavaMethod().getBinding().getStyle() == Style.DOCUMENT) {
-                    // doc/wrapper - wrapper bean is in async signature
-                    // Add 2 so that it is considered as async bean case
+                if (sync.getBinding().getStyle() == Style.DOCUMENT) {
+                    // doc/asyncBeanClass - asyncBeanClass bean is in async signature
+                    // Add 2 or more so that it is considered as async bean case
                     size += 2;
                 }
             } else {
@@ -112,132 +80,128 @@
             }
         }
 
-        List<AsyncBuilder> builders = new ArrayList<AsyncBuilder>();
-        if (size == 0) {
-            // no mapping
-        } else if (size == 1) {
-            ParameterImpl single = null;
-            for( ParameterImpl param : rp ) {
+        Class tempWrap = null;
+        if (size > 1) {
+            rp = jm.getResponseParameters();
+            for(ParameterImpl param : rp) {
                 if (param.isWrapperStyle()) {
                     WrapperParameter wrapParam = (WrapperParameter)param;
-                    for(ParameterImpl p : wrapParam.getWrapperChildren()) {
-                        single = p;
+                    if (sync.getBinding().getStyle() == Style.DOCUMENT) {
+                        // doc/asyncBeanClass style
+                        tempWrap = (Class)wrapParam.getTypeReference().type;
                         break;
                     }
-                    if (single != null)
+                    for(ParameterImpl p : wrapParam.getWrapperChildren()) {
+                        if (p.getIndex() == -1) {
+                            tempWrap = (Class)p.getTypeReference().type;
+                            break;
+                        }
+                    }
+                    if (tempWrap != null) {
                         break;
+                    }
                 } else {
-                    single = param;
-                    break;
-                }
-            }
-            assert single != null;
-            builders.add(new AsyncBuilder.Filler(single));
-        } else {
-            for( ParameterImpl param : rp ) {
-                switch(param.getOutBinding().kind) {
-                case BODY:
-                    if(param.isWrapperStyle()) {
-                        if(param.getParent().getBinding().isRpcLit())
-                            builders.add(new AsyncBuilder.DocLit(wrapper, (WrapperParameter)param));
-                        else
-                            builders.add(new AsyncBuilder.DocLit(wrapper, (WrapperParameter)param));
-                    } else {
-                        builders.add(new AsyncBuilder.Bare(wrapper, param));
+                    if (param.getIndex() == -1) {
+                        tempWrap = (Class)param.getTypeReference().type;
+                        break;
                     }
-                    break;
-                case HEADER:
-                    builders.add(new AsyncBuilder.Bare(wrapper, param));
-                    break;
-                case ATTACHMENT:
-                    builders.add(new AsyncBuilder.Bare(wrapper, param));
-                    break;
-                case UNBOUND:
-                    /*
-                    builders.add(new AsyncBuilder.NullSetter(setter,
-                        ResponseBuilder.getVMUninitializedValue(param.getTypeReference().type)));
-                     */
-                    break;
-                default:
-                    throw new AssertionError();
                 }
             }
+        }
+        asyncBeanClass = tempWrap;
 
+        switch(size) {
+            case 0 :
+                responseBuilder = buildResponseBuilder(sync, ValueSetterFactory.NONE);
+                break;
+            case 1 :
+                responseBuilder = buildResponseBuilder(sync, ValueSetterFactory.SINGLE);
+                break;
+            default :
+                responseBuilder = buildResponseBuilder(sync, new ValueSetterFactory.AsyncBeanValueSetterFactory(asyncBeanClass));
         }
-        switch(size) {      // Use size, since Composite is creating async bean
-        case 0:
-            asyncBuilder = AsyncBuilder.NONE;
-            break;
-        case 1:
-            asyncBuilder = builders.get(0);
-            break;
-        default:
-            asyncBuilder = new AsyncBuilder.Composite(builders, wrapper);
-        }
 
     }
 
     protected final Response<Object> doInvoke(Object proxy, Object[] args, AsyncHandler handler) {
 
-        AsyncMethodHandler.Invoker invoker = new Invoker(proxy, args);
-        ResponseImpl<Object> ft = new ResponseImpl<Object>(invoker,handler);
+        AsyncInvoker invoker = new SEIAsyncInvoker(proxy, args);
+        AsyncResponseImpl<Object> ft = new AsyncResponseImpl<Object>(invoker,handler);
         invoker.setReceiver(ft);
-
+        // TODO: Do we set this executor on Engine and run the AsyncInvoker in this thread ?
         owner.getExecutor().execute(ft);
         return ft;
     }
 
-    private class Invoker implements Callable<Object> {
-        private final Object proxy;
+    private class SEIAsyncInvoker extends AsyncInvoker {
+        // snapshot the context now. this is necessary to avoid concurrency issue,
+        // and is required by the spec
+        private final RequestContext rc = owner.requestContext.copy();
         private final Object[] args;
-        // need to take a copy. required by the spec
-        private final RequestContext snapshot = owner.requestContext.copy();
-        /**
-         * Because of the object instantiation order,
-         * we can't take this as a constructor parameter.
-         */
-        private ResponseContextReceiver receiver;
 
-        public Invoker(Object proxy, Object[] args) {
-            this.proxy = proxy;
+        SEIAsyncInvoker(Object proxy, Object[] args) {
             this.args = args;
         }
 
-        public Object call() throws Exception {
-            assert receiver!=null;
-            try {
-                // TODO: Calling the sync method has this overhead
-                Object[] newArgs;
-                Method method = core.getJavaMethod().getMethod();
-                int noOfArgs = method.getParameterTypes().length;
-                newArgs = new Object[noOfArgs];
-                for(int i=0; i < noOfArgs; i++) {
-                    if (method.getParameterTypes()[i].isAssignableFrom(Holder.class)) {
-                        Holder holder = new Holder();
-                        if (i < args.length) {
-                            holder.value = args[i];
+        public void do_run () {
+            Packet req = new Packet(createRequestMessage(args));
+            req.soapAction = soapAction;
+            req.expectReply = !isOneWay;
+            req.getMessage().assertOneWay(isOneWay);
+
+            Fiber.CompletionCallback callback = new Fiber.CompletionCallback() {
+
+                public void onCompletion(@NotNull Packet response) {
+                    responseImpl.setResponseContext(new ResponseContext(response));
+                    Message msg = response.getMessage();
+                    if (msg == null) {
+                        return;
+                    }
+                    try {
+                        if(msg.isFault()) {
+                            SOAPFaultBuilder faultBuilder = SOAPFaultBuilder.create(msg);
+                            throw faultBuilder.createException(checkedExceptions);
+                        } else {
+                            Object[] rargs = new Object[1];
+                            if (asyncBeanClass != null) {
+                                rargs[0] = asyncBeanClass.newInstance();
+                            }
+                            responseBuilder.readResponse(msg, rargs);
+                            responseImpl.set(rargs[0], null);
                         }
-                        newArgs[i] = holder;
-                    } else {
-                        newArgs[i] = args[i];
+                   } catch (Throwable t) {
+                        if (t instanceof RuntimeException) {
+                            if (t instanceof WebServiceException) {
+                                responseImpl.set(null, t);
+                                return;
+                            }
+                        }  else if (t instanceof Exception) {
+                            responseImpl.set(null, t);
+                            return;
+                        }
+                        //its RuntimeException or some other exception resulting from user error, wrap it in
+                        // WebServiceException
+                        responseImpl.set(null, new WebServiceException(t));
                     }
                 }
-                Object returnValue = core.invoke(proxy,newArgs,snapshot,receiver);
-                return asyncBuilder.fillAsyncBean(newArgs, returnValue, null);
-            } catch (Throwable t) {
-                if (t instanceof RuntimeException) {
-                    if (t instanceof WebServiceException) {
-                        throw (WebServiceException)t;
+
+
+                public void onCompletion(@NotNull Throwable error) {
+                    if (error instanceof WebServiceException) {
+                        responseImpl.set(null, error);
+                    } else {
+                        //its RuntimeException or some other exception resulting from user error, wrap it in
+                        // WebServiceException
+                        responseImpl.set(null, new WebServiceException(error));
                     }
-                }  else if (t instanceof Exception) {
-                    throw (Exception)t;
                 }
-                throw new WebServiceException(t);
-            }
+            };
+            owner.doProcessAsync(req, rc, callback);
         }
+    }
 
-        void setReceiver(ResponseContextReceiver receiver) {
-            this.receiver = receiver;
-        }
+    ValueGetterFactory getValueGetterFactory() {
+        return ValueGetterFactory.ASYNC;
     }
+
 }
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/BodyBuilder.java	Tue Aug  4 10:00:44 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/BodyBuilder.java	Tue Aug  4 10:00:44 2009
@@ -109,10 +109,10 @@
         /**
          * Creates a {@link BodyBuilder} from a bare parameter.
          */
-        Bare(ParameterImpl p, SOAPVersion soapVersion) {
+        Bare(ParameterImpl p, SOAPVersion soapVersion, ValueGetter getter) {
             super(p.getBridge(), soapVersion);
             this.methodPos = p.getIndex();
-            this.getter = ValueGetter.get(p);
+            this.getter = getter;
         }
 
         /**
@@ -140,7 +140,7 @@
          */
         protected final ValueGetter[] getters;
 
-        protected Wrapped(WrapperParameter wp, SOAPVersion soapVersion) {
+        protected Wrapped(WrapperParameter wp, SOAPVersion soapVersion, ValueGetterFactory getter) {
             super(wp.getBridge(), soapVersion);
 
             List<ParameterImpl> children = wp.getWrapperChildren();
@@ -150,7 +150,7 @@
             for( int i=0; i<indices.length; i++ ) {
                 ParameterImpl p = children.get(i);
                 indices[i] = p.getIndex();
-                getters[i] = ValueGetter.get(p);
+                getters[i] = getter.get(p);
             }
         }
     }
@@ -173,8 +173,8 @@
         /**
          * Creates a {@link BodyBuilder} from a {@link WrapperParameter}.
          */
-        DocLit(WrapperParameter wp, SOAPVersion soapVersion) {
-            super(wp, soapVersion);
+        DocLit(WrapperParameter wp, SOAPVersion soapVersion, ValueGetterFactory getter) {
+            super(wp, soapVersion, getter);
 
             wrapper = (Class)wp.getBridge().getTypeReference().type;
 
@@ -249,8 +249,8 @@
         /**
          * Creates a {@link BodyBuilder} from a {@link WrapperParameter}.
          */
-        RpcLit(WrapperParameter wp, SOAPVersion soapVersion) {
-            super(wp, soapVersion);
+        RpcLit(WrapperParameter wp, SOAPVersion soapVersion, ValueGetterFactory getter) {
+            super(wp, soapVersion, getter);
             // we'll use CompositeStructure to pack requests
             assert wp.getTypeReference().type==CompositeStructure.class;
 
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/CallbackMethodHandler.java	Tue Aug  4 10:00:47 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/CallbackMethodHandler.java	Tue Aug  4 10:00:46 2009
@@ -42,12 +42,12 @@
      */
     private final int handlerPos;
 
-    public CallbackMethodHandler(SEIStub owner, JavaMethodImpl jm, SyncMethodHandler core, int handlerPos) {
+    CallbackMethodHandler(SEIStub owner, JavaMethodImpl jm, JavaMethodImpl core, int handlerPos) {
         super(owner,jm,core);
         this.handlerPos = handlerPos;
     }
 
-    public Future<?> invoke(Object proxy, Object[] args) throws WebServiceException {
+    Future<?> invoke(Object proxy, Object[] args) throws WebServiceException {
         // the spec requires the last argument
         final AsyncHandler handler = (AsyncHandler)args[handlerPos];
 
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/MessageFiller.java	Tue Aug  4 10:00:49 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/MessageFiller.java	Tue Aug  4 10:00:48 2009
@@ -172,7 +172,7 @@
     }
 
     private static boolean isXMLMimeType(String mimeType){
-        return (mimeType.equals("text/xml") || mimeType.equals("application/xml")) ? true : false;
+        return (mimeType.equals("text/xml") || mimeType.equals("application/xml"));
     }
 
 }
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/MethodHandler.java	Tue Aug  4 10:00:51 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/MethodHandler.java	Tue Aug  4 10:00:51 2009
@@ -63,5 +63,5 @@
      * @throws Throwable
      *      some faults are reported in terms of checked exceptions.
      */
-    public abstract Object invoke(Object proxy, Object[] args) throws WebServiceException, Throwable;
+    abstract Object invoke(Object proxy, Object[] args) throws WebServiceException, Throwable;
 }
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/PollingMethodHandler.java	Tue Aug  4 10:00:53 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/PollingMethodHandler.java	Tue Aug  4 10:00:53 2009
@@ -35,11 +35,11 @@
  */
 final class PollingMethodHandler extends AsyncMethodHandler {
 
-    public PollingMethodHandler(SEIStub owner, JavaMethodImpl jm, SyncMethodHandler core) {
+    PollingMethodHandler(SEIStub owner, JavaMethodImpl jm, JavaMethodImpl core) {
         super(owner, jm, core);
     }
 
-    public Response<?> invoke(Object proxy, Object[] args) throws WebServiceException {
+    Response<?> invoke(Object proxy, Object[] args) throws WebServiceException {
         return doInvoke(proxy,args,null);
     }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/ResponseBuilder.java	Tue Aug  4 10:00:55 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/ResponseBuilder.java	Tue Aug  4 10:00:55 2009
@@ -49,6 +49,7 @@
 import javax.xml.soap.SOAPFault;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.XMLStreamConstants;
 import javax.xml.transform.Source;
 import javax.xml.ws.Holder;
 import javax.xml.ws.WebServiceException;
@@ -229,7 +230,7 @@
             } else if(isXMLMimeType(param.getBinding().getMimeType())) {
                 return new JAXBBuilder(param, setter);
             } else {
-                throw new UnsupportedOperationException("Attachment is not mapped");
+                throw new UnsupportedOperationException("Unexpected Attachment type ="+type);
             }
         }
 
@@ -287,10 +288,20 @@
 
         Object mapAttachment(Attachment att, Object[] args) {
             Image image;
+            InputStream is = null;
             try {
-                image = ImageIO.read(att.asInputStream());
+                is = att.asInputStream();
+                image = ImageIO.read(is);
             } catch(IOException ioe) {
                 throw new WebServiceException(ioe);
+            } finally {
+                if (is != null) {
+                    try {
+                        is.close();
+                    } catch(IOException ioe) {
+                        throw new WebServiceException(ioe);
+                    }
+                }
             }
             return setter.put(image, args);
         }
@@ -462,7 +473,7 @@
 
         private final QName wrapperName;
 
-        public DocLit(WrapperParameter wp) {
+        public DocLit(WrapperParameter wp, ValueSetterFactory setterFactory) {
             wrapperName = wp.getName();
             wrapper = wp.getBridge();
             Class wrapperType = (Class) wrapper.getTypeReference().type;
@@ -480,7 +491,7 @@
                             wrapperType,
                             name.getNamespaceURI(),
                             p.getName().getLocalPart()),
-                        ValueSetter.get(p)
+                        setterFactory.get(p)
                     ));
                     // wrapper parameter itself always bind to body, and
                     // so do all its children
@@ -497,7 +508,7 @@
         public Object readResponse(Message msg, Object[] args) throws JAXBException, XMLStreamException {
             Object retVal = null;
 
-            if(parts.length>0) {
+            if (parts.length>0) {
                 XMLStreamReader reader = msg.readPayload();
                 XMLStreamReaderUtil.verifyTag(reader,wrapperName);
                 Object wrapperBean = wrapper.unmarshal(reader, (msg.getAttachments() != null) ?
@@ -521,6 +532,8 @@
                 // we are done with the body
                 reader.close();
                 XMLStreamReaderFactory.recycle(reader);
+            } else {
+                msg.consume();
             }
 
             return retVal;
@@ -567,7 +580,7 @@
 
         private QName wrapperName;
 
-        public RpcLit(WrapperParameter wp) {
+        public RpcLit(WrapperParameter wp, ValueSetterFactory setterFactory) {
             assert wp.getTypeReference().type== CompositeStructure.class;
 
             wrapperName = wp.getName();
@@ -574,7 +587,7 @@
             List<ParameterImpl> children = wp.getWrapperChildren();
             for (ParameterImpl p : children) {
                 parts.put( p.getName(), new PartBuilder(
-                    p.getBridge(), ValueSetter.get(p)
+                    p.getBridge(), setterFactory.get(p)
                 ));
                 // wrapper parameter itself always bind to body, and
                 // so do all its children
@@ -606,6 +619,11 @@
                         retVal = o;
                     }
                 }
+                // skip any whitespace
+                if (reader.getEventType() != XMLStreamConstants.START_ELEMENT &&
+                        reader.getEventType() != XMLStreamConstants.END_ELEMENT) {
+                    XMLStreamReaderUtil.nextElementContent(reader);
+                }
             }
 
             // we are done with the body
@@ -644,6 +662,6 @@
     }
 
     private static boolean isXMLMimeType(String mimeType){
-        return (mimeType.equals("text/xml") || mimeType.equals("application/xml")) ? true : false;
+        return mimeType.equals("text/xml") || mimeType.equals("application/xml");
     }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/SEIStub.java	Tue Aug  4 10:00:58 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/SEIStub.java	Tue Aug  4 10:00:57 2009
@@ -34,6 +34,7 @@
 import com.sun.xml.internal.ws.api.model.MEP;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundOperation;
 import com.sun.xml.internal.ws.api.pipe.Tube;
+import com.sun.xml.internal.ws.api.pipe.Fiber;
 import com.sun.xml.internal.ws.binding.BindingImpl;
 import com.sun.xml.internal.ws.client.RequestContext;
 import com.sun.xml.internal.ws.client.ResponseContextReceiver;
@@ -61,7 +62,7 @@
         this.seiModel = seiModel;
         this.soapVersion = binding.getSOAPVersion();
 
-        Map<WSDLBoundOperation, SyncMethodHandler> syncs = new HashMap<WSDLBoundOperation, SyncMethodHandler>();
+        Map<WSDLBoundOperation, JavaMethodImpl> syncs = new HashMap<WSDLBoundOperation, JavaMethodImpl>();
 
         // fill in methodHandlers.
         // first fill in sychronized versions
@@ -68,13 +69,13 @@
         for (JavaMethodImpl m : seiModel.getJavaMethods()) {
             if (!m.getMEP().isAsync) {
                 SyncMethodHandler handler = new SyncMethodHandler(this, m);
-                syncs.put(m.getOperation(), handler);
+                syncs.put(m.getOperation(), m);
                 methodHandlers.put(m.getMethod(), handler);
             }
         }
 
         for (JavaMethodImpl jm : seiModel.getJavaMethods()) {
-            SyncMethodHandler sync = syncs.get(jm.getOperation());
+            JavaMethodImpl sync = syncs.get(jm.getOperation());
             if (jm.getMEP() == MEP.ASYNC_CALLBACK) {
                 Method m = jm.getMethod();
                 CallbackMethodHandler handler = new CallbackMethodHandler(
@@ -123,6 +124,10 @@
         return super.process(request, rc, receiver);
     }
 
+    public final void doProcessAsync(Packet request, RequestContext rc, Fiber.CompletionCallback callback) {
+        super.processAsync(request, rc, callback);
+    }
+
     protected final @NotNull QName getPortName() {
         return wsdlPort.getName();
     }
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/SyncMethodHandler.java	Tue Aug  4 10:01:00 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/SyncMethodHandler.java	Tue Aug  4 10:00:59 2009
@@ -66,150 +66,15 @@
  *
  * @author Kohsuke Kawaguchi
  */
-final class SyncMethodHandler extends MethodHandler {
-
-    // these objects together create a message from method parameters
-    private final BodyBuilder bodyBuilder;
-    private final MessageFiller[] inFillers;
-
-    private final String soapAction;
-
-    private final boolean isOneWay;
-
-    private final JavaMethodImpl javaMethod;
-
-    /**
-     * Used to get a value from method invocation parameter.
-     *
-     * valueGetters[i] is for methodArgs[i], and so on.
-     */
-    /*package*/ final ValueGetter[] valueGetters;
-
+final class SyncMethodHandler extends SEIMethodHandler {
     private final ResponseBuilder responseBuilder;
-    private final Map<QName, CheckedExceptionImpl> checkedExceptions;
 
-    public SyncMethodHandler(SEIStub owner, JavaMethodImpl method) {
-        super(owner);
-
-        //keep all the CheckedException model for the detail qname
-        this.checkedExceptions = new HashMap<QName, CheckedExceptionImpl>();
-        for(CheckedExceptionImpl ce : method.getCheckedExceptions()){
-            checkedExceptions.put(ce.getBridge().getTypeReference().tagName, ce);
-        }
-        //If a non-"" soapAction is specified, wsa:action the SOAPAction
-        if(method.getInputAction() != null && !method.getBinding().getSOAPAction().equals("") ) {
-            this.soapAction = method.getInputAction();
-        } else {
-            this.soapAction = method.getBinding().getSOAPAction();
-        }
-        this.javaMethod = method;
-
-        {// prepare objects for creating messages
-            List<ParameterImpl> rp = method.getRequestParameters();
-
-            BodyBuilder bodyBuilder = null;
-            List<MessageFiller> fillers = new ArrayList<MessageFiller>();
-            valueGetters = new ValueGetter[rp.size()];
-
-            for (ParameterImpl param : rp) {
-                ValueGetter getter = ValueGetter.get(param);
-
-                switch(param.getInBinding().kind) {
-                case BODY:
-                    if(param.isWrapperStyle()) {
-                        if(param.getParent().getBinding().isRpcLit())
-                            bodyBuilder = new BodyBuilder.RpcLit((WrapperParameter)param, owner.soapVersion);
-                        else
-                            bodyBuilder = new BodyBuilder.DocLit((WrapperParameter)param, owner.soapVersion);
-                    } else {
-                        bodyBuilder = new BodyBuilder.Bare(param, owner.soapVersion);
-                    }
-                    break;
-                case HEADER:
-                    fillers.add(new MessageFiller.Header(
-                        param.getIndex(),
-                        param.getBridge(),
-                        getter ));
-                    break;
-                case ATTACHMENT:
-                    fillers.add(MessageFiller.AttachmentFiller.createAttachmentFiller(param, getter));
-                    break;
-                case UNBOUND:
-                    break;
-                default:
-                    throw new AssertionError(); // impossible
-                }
-            }
-
-            if(bodyBuilder==null) {
-                // no parameter binds to body. we create an empty message
-                switch(owner.soapVersion) {
-                case SOAP_11:
-                    bodyBuilder = BodyBuilder.EMPTY_SOAP11;
-                    break;
-                case SOAP_12:
-                    bodyBuilder = BodyBuilder.EMPTY_SOAP12;
-                    break;
-                default:
-                    throw new AssertionError();
-                }
-            }
-
-            this.bodyBuilder = bodyBuilder;
-            this.inFillers = fillers.toArray(new MessageFiller[fillers.size()]);
-        }
-
-        {// prepare objects for processing response
-            List<ParameterImpl> rp = method.getResponseParameters();
-            List<ResponseBuilder> builders = new ArrayList<ResponseBuilder>();
-
-            for( ParameterImpl param : rp ) {
-                ValueSetter setter = ValueSetter.get(param);
-                switch(param.getOutBinding().kind) {
-                case BODY:
-                    if(param.isWrapperStyle()) {
-                        if(param.getParent().getBinding().isRpcLit())
-                            builders.add(new ResponseBuilder.RpcLit((WrapperParameter)param));
-                        else
-                            builders.add(new ResponseBuilder.DocLit((WrapperParameter)param));
-                    } else {
-                        builders.add(new ResponseBuilder.Body(param.getBridge(),setter));
-                    }
-                    break;
-                case HEADER:
-                    builders.add(new ResponseBuilder.Header(owner.soapVersion, param, setter));
-                    break;
-                case ATTACHMENT:
-                    builders.add(ResponseBuilder.AttachmentBuilder.createAttachmentBuilder(param, setter));
-                    break;
-                case UNBOUND:
-                    builders.add(new ResponseBuilder.NullSetter(setter,
-                        ResponseBuilder.getVMUninitializedValue(param.getTypeReference().type)));
-                    break;
-                default:
-                    throw new AssertionError();
-                }
-            }
-
-            switch(builders.size()) {
-            case 0:
-                responseBuilder = ResponseBuilder.NONE;
-                break;
-            case 1:
-                responseBuilder = builders.get(0);
-                break;
-            default:
-                responseBuilder = new ResponseBuilder.Composite(builders);
-            }
-        }
-        this.isOneWay = method.getMEP().isOneWay();
+    SyncMethodHandler(SEIStub owner, JavaMethodImpl method) {
+        super(owner, method);
+        responseBuilder = buildResponseBuilder(method, ValueSetterFactory.SYNC);
     }
 
-    public JavaMethodImpl getJavaMethod() {
-        return javaMethod;
-    }
-
-    public Object invoke(Object proxy, Object[] args) throws Throwable {
+    Object invoke(Object proxy, Object[] args) throws Throwable {
         return invoke(proxy,args,owner.requestContext,owner);
     }
 
@@ -222,7 +87,7 @@
      *      We take this as a separate parameter because of the async invocation
      *      handling, which requires a separate copy.
      */
-    public Object invoke(Object proxy, Object[] args, RequestContext rc, ResponseContextReceiver receiver) throws Throwable {
+    Object invoke(Object proxy, Object[] args, RequestContext rc, ResponseContextReceiver receiver) throws Throwable {
         Packet req = new Packet(createRequestMessage(args));
 
         req.soapAction = soapAction;
@@ -251,16 +116,8 @@
         }
     }
 
-    /**
-     * Creates a request {@link JAXBMessage} from method arguments.
-     *
-     */
-    private Message createRequestMessage(Object[] args) {
-        Message msg = bodyBuilder.createMessage(args);
-
-        for (MessageFiller filler : inFillers)
-            filler.fillIn(args,msg);
-
-        return msg;
+    ValueGetterFactory getValueGetterFactory() {
+        return ValueGetterFactory.SYNC;
     }
+
 }
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/ValueGetter.java	Tue Aug  4 10:01:02 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/ValueGetter.java	Tue Aug  4 10:01:02 2009
@@ -25,8 +25,6 @@
 
 package com.sun.xml.internal.ws.client.sei;
 
-import com.sun.xml.internal.ws.model.ParameterImpl;
-
 import javax.jws.WebParam.Mode;
 import javax.xml.ws.Holder;
 
@@ -74,17 +72,9 @@
 
     /**
      * Gets the value to be sent, from a parameter given as a method argument.
+     * @param parameter that is passed by proxy
+     * @return if it holder then its value, otherise parameter itself
      */
     abstract Object get(Object parameter);
 
-    /**
-     * Returns a {@link ValueGetter} suitable for the given {@link Parameter}.
-     */
-    static ValueGetter get(ParameterImpl p) {
-        // return value is always PLAIN
-        if(p.getMode()== Mode.IN || p.getIndex() == -1)
-            return PLAIN;
-        else
-            return HOLDER;
-    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/ValueSetter.java	Tue Aug  4 10:01:04 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/ValueSetter.java	Tue Aug  4 10:01:04 2009
@@ -27,8 +27,12 @@
 
 import com.sun.xml.internal.ws.api.model.Parameter;
 import com.sun.xml.internal.ws.model.ParameterImpl;
+import com.sun.xml.internal.bind.api.RawAccessor;
 
 import javax.xml.ws.Holder;
+import javax.xml.ws.WebServiceException;
+import javax.xml.namespace.QName;
+import javax.xml.bind.JAXBException;
 
 /**
  * Moves a Java value unmarshalled from a response message
@@ -82,7 +86,7 @@
     /**
      * Returns a {@link ValueSetter} suitable for the given {@link Parameter}.
      */
-    public static ValueSetter get(ParameterImpl p) {
+    static ValueSetter getSync(ParameterImpl p) {
         int idx = p.getIndex();
 
         if(idx==-1)
@@ -93,6 +97,7 @@
             return new Param(idx);
     }
 
+
     private static final class ReturnValue extends ValueSetter {
         Object put(Object obj, Object[] args) {
             return obj;
@@ -125,4 +130,64 @@
             return null;
         }
     }
+
+    /**
+     * Singleton instance.
+     */
+    static final ValueSetter SINGLE_VALUE = new SingleValue();
+
+    /**
+     * Used in case of async invocation, where there is only one OUT parameter
+     */
+    private static final class SingleValue extends ValueSetter {
+        /**
+         * Set args[0] as the value
+         */
+        Object put(Object obj, Object[] args) {
+            args[0] = obj;
+            return null;
+        }
+    }
+
+    /**
+     * OUT parameters are set in async bean
+     */
+    static final class AsyncBeanValueSetter extends ValueSetter {
+
+        private final RawAccessor accessor;
+
+        AsyncBeanValueSetter(ParameterImpl p, Class wrapper) {
+            QName name = p.getName();
+            try {
+                accessor = p.getOwner().getJAXBContext().getElementPropertyAccessor(
+                            wrapper, name.getNamespaceURI(), name.getLocalPart() );
+            } catch (JAXBException e) {
+                    throw new WebServiceException(  // TODO: i18n
+                        wrapper+" do not have a property of the name "+name,e);
+            }
+        }
+
+        /**
+         * Sets the property in async bean instance
+         *
+         * @param obj property in async bean
+         * @param args args[0] contains async bean instance
+         * @return null always
+         */
+        Object put(Object obj, Object[] args) {
+            assert args != null;
+            assert args.length == 1;
+            assert args[0] != null;
+
+            Object bean = args[0];
+            try {
+                accessor.set(bean, obj);
+            } catch (Exception e) {
+                throw new WebServiceException(e);    // TODO:i18n
+            }
+            return null;
+        }
+
+    }
+
 }
--- old/src/share/classes/com/sun/xml/internal/ws/developer/JAXWSProperties.java	Tue Aug  4 10:01:06 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/JAXWSProperties.java	Tue Aug  4 10:01:06 2009
@@ -25,12 +25,16 @@
 package com.sun.xml.internal.ws.developer;
 
 import com.sun.xml.internal.ws.api.message.HeaderList;
+import com.sun.xml.internal.ws.api.server.WSEndpoint;
+import com.sun.xml.internal.ws.api.addressing.WSEndpointReference;
 
-import javax.xml.ws.BindingProvider;
-import javax.xml.ws.WebServiceContext;
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.HostnameVerifier;
+import javax.xml.ws.BindingProvider;
+import javax.xml.ws.WebServiceContext;
+import javax.xml.ws.BindingType;
+import javax.xml.ws.http.HTTPBinding;
 import java.net.HttpURLConnection;
 
 public interface JAXWSProperties {
@@ -44,11 +48,35 @@
 
     /**
      * Set this property on the {@link BindingProvider#getRequestContext()} to
+     * enable {@link HttpURLConnection#setConnectTimeout(int)}
+     *
+     *<p>
+     * int timeout = ...;
+     * Map<String, Object> ctxt = ((BindingProvider)proxy).getRequestContext();
+     * ctxt.put(CONNECT_TIMEOUT, timeout);
+     */
+    public static final String CONNECT_TIMEOUT =
+        "com.sun.xml.internal.ws.connect.timeout";
+
+    /**
+     * Set this property on the {@link BindingProvider#getRequestContext()} to
+     * enable {@link HttpURLConnection#httpConnection.setReadTimeout(int)}
+     *
+     *<p>
+     * int timeout = ...;
+     * Map<String, Object> ctxt = ((BindingProvider)proxy).getRequestContext();
+     * ctxt.put(REQUEST_TIMEOUT, timeout);
+     */
+     public static final String REQUEST_TIMEOUT =
+        "com.sun.xml.internal.ws.request.timeout";
+
+    /**
+     * Set this property on the {@link BindingProvider#getRequestContext()} to
      * enable {@link HttpURLConnection#setChunkedStreamingMode(int)}
      *
      *<p>
      * int chunkSize = ...;
-     * Map<String, Object> ctxt = (BindingProvider)proxy).getRequestContext();
+     * Map<String, Object> ctxt = ((BindingProvider)proxy).getRequestContext();
      * ctxt.put(HTTP_CLIENT_STREAMING_CHUNK_SIZE, chunkSize);
      */
     public static final String HTTP_CLIENT_STREAMING_CHUNK_SIZE = "com.sun.xml.internal.ws.transport.http.client.streaming.chunk.size";
@@ -61,7 +89,7 @@
      *
      * <p>
      * HostNameVerifier hostNameVerifier = ...;
-     * Map<String, Object> ctxt = (BindingProvider)proxy).getRequestContext();
+     * Map<String, Object> ctxt = ((BindingProvider)proxy).getRequestContext();
      * ctxt.put(HOSTNAME_VERIFIER, hostNameVerifier);
      *
      * <p>
@@ -76,7 +104,7 @@
      *
      * <p>
      * SSLSocketFactory sslFactory = ...;
-     * Map<String, Object> ctxt = (BindingProvider)proxy).getRequestContext();
+     * Map<String, Object> ctxt = ((BindingProvider)proxy).getRequestContext();
      * ctxt.put(SSL_SOCKET_FACTORY, sslFactory);
      *
      * <p>
@@ -101,4 +129,105 @@
      * <b>THIS PROPERTY IS EXPERIMENTAL AND IS SUBJECT TO CHANGE WITHOUT NOTICE IN FUTURE.</b>
      */
     public static final String INBOUND_HEADER_LIST_PROPERTY = "com.sun.xml.internal.ws.api.message.HeaderList";
+
+    /**
+     * Access the {@link WSEndpoint} object that delivered the request.
+     *
+     * <p>
+     * {@link WSEndpoint} is the root of the objects that are together
+     * responsible for delivering requests to the application SEI object.
+     * One can look up this {@link WSEndpoint} from {@link WebServiceContext},
+     * and from there access many parts of the JAX-WS RI runtime.
+     *
+     * <p>
+     * <b>THIS PROPERTY IS EXPERIMENTAL AND IS SUBJECT TO CHANGE WITHOUT NOTICE IN FUTURE.</b>
+     *
+     * @since 2.1.2
+     */
+    public static final String WSENDPOINT = "com.sun.xml.internal.ws.api.server.WSEndpoint";
+
+    /**
+     * Gets the <tt>wsa:To</tt> header.
+     *
+     * The propery value is available on incoming SOAP message. The type of the value
+     * is {@link WSEndpointReference}.
+     *
+     * Null if the incoming SOAP message didn't have the header.
+     *
+     * @since 2.1.3
+     */
+    public static final String ADDRESSING_TO = "com.sun.xml.internal.ws.api.addressing.to";
+
+    /**
+     * Gets the <tt>wsa:From</tt> header.
+     *
+     * The propery value is available on incoming SOAP message. The type of the value
+     * is {@link WSEndpointReference}.
+     *
+     * Null if the incoming SOAP message didn't have the header.
+     *
+     * @since 2.1.3
+     */
+    public static final String ADDRESSING_FROM = "com.sun.xml.internal.ws.api.addressing.from";
+
+    /**
+     * Gets the <tt>wsa:Action</tt> header value.
+     *
+     * The propery value is available on incoming SOAP message. The type of the value
+     * is {@link String}.
+     *
+     * Null if the incoming SOAP message didn't have the header.
+     *
+     * @since 2.1.3
+     */
+    public static final String ADDRESSING_ACTION = "com.sun.xml.internal.ws.api.addressing.action";
+
+    /**
+     * Gets the <tt>wsa:MessageID</tt> header value.
+     *
+     * The propery value is available on incoming SOAP message. The type of the value
+     * is {@link String}.
+     *
+     * Null if the incoming SOAP message didn't have the header.
+     *
+     * @since 2.1.3
+     */
+    public static final String ADDRESSING_MESSAGEID = "com.sun.xml.internal.ws.api.addressing.messageId";
+
+    /**
+     * Reconstructs the URL the client used to make the request. The returned URL
+     * contains a protocol, server name, port number, and server path, but it does
+     * not include query string parameters.
+     * <p>
+     * The property value is available on incoming SOAP message on servlet transport.
+     *
+     * @since 2.1.3
+     */
+    public static final String HTTP_REQUEST_URL = "com.sun.xml.internal.ws.transport.http.servlet.requestURL";
+
+    /**
+     * Binding to represent RESTful services. {@link HTTPBinding#HTTP_BINDING} works
+     * only for Dispatch/Provider services, but this binding works with even SEI based
+     * services. It would be XML, NOT SOAP on the wire. Hence, the SEI parameters
+     * shouldn't be mapped to headers.
+     *
+     * <p>
+     * Note that, this only solves limited RESTful usecases.
+     *
+     * <p>To enable restful binding on the service, specify the binding id via
+     * {@link BindingType} or DD
+     * <pre>
+     * &#64;WebService
+     * &#64;BindingType(JAXWSProperties.REST_BINDING)
+     * </pre>
+     *
+     * <p>To enable restful binding on the client side, specify the binding id via
+     * {@link BindingTypeFeature}
+     * <pre>
+     * proxy = echoImplService.getEchoImplPort(new BindingTypeFeature(JAXWSProperties.REST_BINDING));
+     * </pre>
+     *
+     * @since 2.1.4
+     */
+    public static final String REST_BINDING = "http://jax-ws.dev.java.net/rest";
 }
--- old/src/share/classes/com/sun/xml/internal/ws/developer/MemberSubmissionAddressing.java	Tue Aug  4 10:01:09 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/MemberSubmissionAddressing.java	Tue Aug  4 10:01:08 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 package com.sun.xml.internal.ws.developer;
 
 import java.lang.annotation.Documented;
@@ -90,4 +89,15 @@
      * <code>wsaw:UsingAddressing</code> element in the WSDL.
      */
     boolean required() default false;
+
+    /**
+     * Property to determine if the incoming messsages should be checked for conformance
+     * with MemberSubmission version of WS-Addressing.
+     *
+     * If Validation.LAX, then some WS-Adressing headers are not strictly checked.
+     */
+    public enum Validation { LAX, STRICT };
+
+    Validation validation() default Validation.LAX;
+
 }
--- old/src/share/classes/com/sun/xml/internal/ws/developer/MemberSubmissionAddressingFeature.java	Tue Aug  4 10:01:11 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/MemberSubmissionAddressingFeature.java	Tue Aug  4 10:01:10 2009
@@ -23,12 +23,10 @@
  * have any questions.
  */
 
-
 package com.sun.xml.internal.ws.developer;
 
 import com.sun.xml.internal.ws.api.FeatureConstructor;
 
-import javax.xml.ws.soap.AddressingFeature;
 import javax.xml.ws.WebServiceFeature;
 
 /**
@@ -77,12 +75,31 @@
      * for the <code>required</code> attribute on the
      * <code>wsaw:UsingAddressing</code> element.
      */
-    @FeatureConstructor({"enabled","required"})
     public MemberSubmissionAddressingFeature(boolean enabled, boolean required) {
         this.enabled = enabled;
         this.required = required;
     }
 
+    /**
+     * Create an <code>MemberSubmissionAddressingFeature</code>
+     *
+     * @param enabled specifies whether this feature should
+     * be enabled or not.
+     * @param required specifies the value that will be used
+     * for the <code>required</code> attribute on the
+     * <code>wsaw:UsingAddressing</code> element.
+     * @param validation specifies the value that will be used
+     * for validation for the incoming messages. If LAX, messages are not strictly checked for conformance with  the spec.
+     */
+    @FeatureConstructor({"enabled","required","validation"})
+    public MemberSubmissionAddressingFeature(boolean enabled, boolean required, MemberSubmissionAddressing.Validation validation) {
+        this.enabled = enabled;
+        this.required = required;
+        this.validation = validation;
+    }
+
+
+
     public String getID() {
         return ID;
     }
@@ -94,4 +111,14 @@
     public void setRequired(boolean required) {
         this.required = required;
     }
+
+    private MemberSubmissionAddressing.Validation validation = MemberSubmissionAddressing.Validation.LAX;
+    public void setValidation(MemberSubmissionAddressing.Validation validation) {
+        this.validation = validation;
+
+    }
+
+    public MemberSubmissionAddressing.Validation getValidation() {
+        return validation;
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/developer/MemberSubmissionEndpointReference.java	Tue Aug  4 10:01:13 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/MemberSubmissionEndpointReference.java	Tue Aug  4 10:01:13 2009
@@ -62,7 +62,7 @@
 
 @XmlRootElement(name = "EndpointReference", namespace = MemberSubmissionEndpointReference.MSNS)
 @XmlType(name = "EndpointReferenceType", namespace = MemberSubmissionEndpointReference.MSNS)
-public class MemberSubmissionEndpointReference extends EndpointReference implements MemberSubmissionAddressingConstants {
+public final class MemberSubmissionEndpointReference extends EndpointReference implements MemberSubmissionAddressingConstants {
 
     private final static JAXBContext msjc = MemberSubmissionEndpointReference.getMSJaxbContext();
 
@@ -105,7 +105,7 @@
     public void writeTo(Result result) {
         try {
             Marshaller marshaller = MemberSubmissionEndpointReference.msjc.createMarshaller();
-            marshaller.setProperty(Marshaller.JAXB_FRAGMENT, true);
+            //marshaller.setProperty(Marshaller.JAXB_FRAGMENT, true);
             marshaller.marshal(this, result);
         } catch (JAXBException e) {
             throw new WebServiceException("Error marshalling W3CEndpointReference. ", e);
--- old/src/share/classes/com/sun/xml/internal/ws/developer/StatefulFeature.java	Tue Aug  4 10:01:15 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/StatefulFeature.java	Tue Aug  4 10:01:15 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 package com.sun.xml.internal.ws.developer;
 
 import com.sun.xml.internal.ws.api.FeatureConstructor;
--- old/src/share/classes/com/sun/xml/internal/ws/developer/WSBindingProvider.java	Tue Aug  4 10:01:17 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/WSBindingProvider.java	Tue Aug  4 10:01:17 2009
@@ -35,6 +35,7 @@
 import javax.xml.ws.Service;
 import javax.xml.ws.Service.Mode;
 import java.util.List;
+import java.io.Closeable;
 
 /**
  * {@link BindingProvider} with JAX-WS RI's extension methods.
@@ -43,7 +44,7 @@
  * @author Jitendra Kotamraju
  * @since 2.1EA3
  */
-public interface WSBindingProvider extends BindingProvider {
+public interface WSBindingProvider extends BindingProvider, Closeable {
     /**
      * Sets the out-bound headers to be added to messages sent from
      * this {@link BindingProvider}.
@@ -99,4 +100,21 @@
     void setOutboundHeaders(Object... headers);
 
     List<Header> getInboundHeaders();
+
+    /**
+     * Sets the endpoint address for all the invocations that happen
+     * from {@link BindingProvider}. Instead of doing the following
+     *
+     * <p>
+     * ((BindingProvider)proxy).getRequestContext().put(
+     *      BindingProvider.ENDPOINT_ADDRESS_PROPERTY, "...")
+     * <p>
+     * you could do this:
+     *
+     * <p>
+     * ((WSBindingProvider)proxy).setAddress("...");
+     *
+     * @param address Address of the service
+     */
+    void setAddress(String address);
 }
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/ContentTypeImpl.java	Tue Aug  4 10:01:20 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/ContentTypeImpl.java	Tue Aug  4 10:01:19 2009
@@ -25,34 +25,48 @@
 
 package com.sun.xml.internal.ws.encoding;
 
-import com.sun.xml.internal.ws.api.pipe.ContentType;
+import com.sun.istack.internal.Nullable;
+import com.sun.istack.internal.NotNull;
 
 /**
  * @author Vivek Pandey
  */
-public final class ContentTypeImpl implements ContentType {
-    private final String contentType;
-    private final String soapAction;
-    private final String accept;
+public final class ContentTypeImpl implements com.sun.xml.internal.ws.api.pipe.ContentType {
+    private final @NotNull String contentType;
+    private final @NotNull String soapAction;
+    private final @Nullable String accept;
+    private final @Nullable String charset;
 
     public ContentTypeImpl(String contentType) {
-        this.contentType = contentType;
-        this.soapAction = null;
-        this.accept = null;
+        this(contentType, null, null);
     }
 
-    public ContentTypeImpl(String contentType, String soapAction) {
-        this.contentType = contentType;
-        this.soapAction = getQuotedSOAPAction(soapAction);
-        this.accept = null;
+    public ContentTypeImpl(String contentType, @Nullable String soapAction) {
+        this(contentType, soapAction, null);
     }
 
-    public ContentTypeImpl(String contentType, String soapAction, String accept) {
+    public ContentTypeImpl(String contentType, @Nullable String soapAction, @Nullable String accept) {
         this.contentType = contentType;
         this.accept = accept;
         this.soapAction = getQuotedSOAPAction(soapAction);
+        String tmpCharset = null;
+        try {
+            tmpCharset = new ContentType(contentType).getParameter("charset");
+        } catch(Exception e) {
+            //Ignore the parsing exception.
+        }
+        charset = tmpCharset;
     }
 
+    /**
+     * Returns the character set encoding.
+     *
+     * @return returns the character set encoding.
+     */
+    public @Nullable String getCharSet() {
+        return charset;
+    }
+
     /** BP 1.1 R1109 requires SOAPAction too be a quoted value **/
     private String getQuotedSOAPAction(String soapAction){
         if(soapAction == null || soapAction.length() == 0){
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/MimeCodec.java	Tue Aug  4 10:01:22 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/MimeCodec.java	Tue Aug  4 10:01:21 2009
@@ -25,14 +25,17 @@
 
 package com.sun.xml.internal.ws.encoding;
 
-import com.sun.xml.internal.messaging.saaj.packaging.mime.util.OutputUtil;
 import com.sun.xml.internal.ws.api.SOAPVersion;
+import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.message.Attachment;
 import com.sun.xml.internal.ws.api.message.Message;
 import com.sun.xml.internal.ws.api.message.Packet;
 import com.sun.xml.internal.ws.api.pipe.Codec;
 import com.sun.xml.internal.ws.api.pipe.ContentType;
+import com.sun.xml.internal.ws.developer.StreamingAttachmentFeature;
 
+import javax.activation.CommandMap;
+import javax.activation.MailcapCommandMap;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -57,6 +60,28 @@
  * @author Kohsuke Kawaguchi
  */
 abstract class MimeCodec implements Codec {
+
+    static {
+        // DataHandler.writeTo() may search for DCH. So adding some default ones.
+        try {
+            CommandMap map = CommandMap.getDefaultCommandMap();
+            if (map instanceof MailcapCommandMap) {
+                MailcapCommandMap mailMap = (MailcapCommandMap) map;
+                String hndlrStr = ";;x-java-content-handler=";
+                mailMap.addMailcap(
+                    "text/xml" + hndlrStr + XmlDataContentHandler.class.getName());
+                mailMap.addMailcap(
+                    "application/xml" + hndlrStr + XmlDataContentHandler.class.getName());
+                mailMap.addMailcap(
+                    "image/*" + hndlrStr + ImageDataContentHandler.class.getName());
+                mailMap.addMailcap(
+                    "text/plain" + hndlrStr + StringDataContentHandler.class.getName());
+            }
+        } catch (Throwable t) {
+            // ignore the exception.
+        }
+    }
+
     public static final String MULTIPART_RELATED_MIME_TYPE = "multipart/related";
 
     private String boundary;
@@ -64,9 +89,11 @@
     private boolean hasAttachments;
     protected Codec rootCodec;
     protected final SOAPVersion version;
+    protected final WSBinding binding;
 
-    protected MimeCodec(SOAPVersion version) {
+    protected MimeCodec(SOAPVersion version, WSBinding binding) {
         this.version = version;
+        this.binding = binding;
     }
 
     public String getMimeType() {
@@ -82,31 +109,31 @@
         }
 
         if (hasAttachments) {
-            OutputUtil.writeln("--"+boundary, out);
-            OutputUtil.writeln("Content-Type: " + rootCodec.getMimeType(), out);
-            OutputUtil.writeln(out);
+            writeln("--"+boundary, out);
+            writeln("Content-Type: " + rootCodec.getMimeType(), out);
+            writeln(out);
         }
         ContentType primaryCt = rootCodec.encode(packet, out);
 
         if (hasAttachments) {
-            OutputUtil.writeln(out);
+            writeln(out);
             // Encode all the attchments
             for (Attachment att : msg.getAttachments()) {
-                OutputUtil.writeln("--"+boundary, out);
+                writeln("--"+boundary, out);
                 //SAAJ's AttachmentPart.getContentId() returns content id already enclosed with
                 //angle brackets. For now put angle bracket only if its not there
                 String cid = att.getContentId();
                 if(cid != null && cid.length() >0 && cid.charAt(0) != '<')
                     cid = '<' + cid + '>';
-                OutputUtil.writeln("Content-Id:" + cid, out);
-                OutputUtil.writeln("Content-Type: " + att.getContentType(), out);
-                OutputUtil.writeln("Content-Transfer-Encoding: binary", out);
-                OutputUtil.writeln(out);                    // write \r\n
+                writeln("Content-Id:" + cid, out);
+                writeln("Content-Type: " + att.getContentType(), out);
+                writeln("Content-Transfer-Encoding: binary", out);
+                writeln(out);                    // write \r\n
                 att.writeTo(out);
-                OutputUtil.writeln(out);                    // write \r\n
+                writeln(out);                    // write \r\n
             }
-            OutputUtil.writeAsAscii("--"+boundary, out);
-            OutputUtil.writeAsAscii("--", out);
+            writeAsAscii("--"+boundary, out);
+            writeAsAscii("--", out);
         }
         // TODO not returing correct multipart/related type(no boundary)
         return hasAttachments ? new ContentTypeImpl(messageContentType, packet.soapAction, null) : primaryCt;
@@ -134,10 +161,11 @@
      */
     protected MimeCodec(MimeCodec that) {
         this.version = that.version;
+        this.binding = that.binding;
     }
 
     public void decode(InputStream in, String contentType, Packet packet) throws IOException {
-        MimeMultipartParser parser = new MimeMultipartParser(in, contentType);
+        MimeMultipartParser parser = new MimeMultipartParser(in, contentType, binding.getFeature(StreamingAttachmentFeature.class));
         decode(parser,packet);
     }
 
@@ -151,4 +179,24 @@
     protected abstract void decode(MimeMultipartParser mpp, Packet packet) throws IOException;
 
     public abstract MimeCodec copy();
+
+
+    public static void writeln(String s,OutputStream out) throws IOException {
+        writeAsAscii(s,out);
+        writeln(out);
+    }
+
+    /**
+     * Writes a string as ASCII string.
+     */
+    public static void writeAsAscii(String s,OutputStream out) throws IOException {
+        int len = s.length();
+        for( int i=0; i<len; i++ )
+            out.write((byte)s.charAt(i));
+    }
+
+    public static void writeln(OutputStream out) throws IOException {
+        out.write('\r');
+        out.write('\n');
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/MimeMultipartParser.java	Tue Aug  4 10:01:24 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/MimeMultipartParser.java	Tue Aug  4 10:01:24 2009
@@ -28,20 +28,26 @@
 
 import com.sun.istack.internal.NotNull;
 import com.sun.istack.internal.Nullable;
-import com.sun.xml.internal.messaging.saaj.packaging.mime.MessagingException;
-import com.sun.xml.internal.messaging.saaj.packaging.mime.internet.ContentType;
-import com.sun.xml.internal.messaging.saaj.packaging.mime.internet.InternetHeaders;
-import com.sun.xml.internal.messaging.saaj.packaging.mime.internet.ParseException;
-import com.sun.xml.internal.ws.message.stream.StreamAttachment;
-import com.sun.xml.internal.ws.util.ASCIIUtility;
+import com.sun.xml.internal.ws.api.message.Attachment;
+import com.sun.xml.internal.ws.developer.StreamingAttachmentFeature;
+import com.sun.xml.internal.ws.developer.StreamingDataHandler;
 import com.sun.xml.internal.ws.util.ByteArrayBuffer;
+import com.sun.xml.internal.ws.util.ByteArrayDataSource;
+import com.sun.xml.internal.org.jvnet.mimepull.MIMEMessage;
+import com.sun.xml.internal.org.jvnet.mimepull.MIMEPart;
 
+import javax.activation.DataHandler;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.transform.Source;
+import javax.xml.transform.stream.StreamSource;
 import javax.xml.ws.WebServiceException;
-import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.util.BitSet;
+import java.io.OutputStream;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
 /**
@@ -48,53 +54,35 @@
  * Parses Mime multipart message into primary part and attachment parts. It
  * parses the stream lazily as and when required.
  *
- * TODO need a list to keep all the attachments so that even if Content-Id is
- * not there it is accounted
- *
  * @author Vivek Pandey
  * @author Jitendra Kotamraju
  */
 public final class MimeMultipartParser {
 
-    private final InputStream in;
     private final String start;
-    private final byte[] boundaryBytes;
+    private final MIMEMessage message;
+    private Attachment root;
 
-    private final BitSet lastPartFound = new BitSet(1);
-    // current stream position, set to -1 on EOF
-    private int b = 0;
-    private final int[] bcs = new int[256];
-    private int[] gss;
-    private static final int BUFFER_SIZE = 4096;
-    private byte[] buffer = new byte[BUFFER_SIZE];
-    private byte[] prevBuffer = new byte[BUFFER_SIZE];
-    private boolean firstPart = true;
+    // Attachments without root part
+    private final Map<String, Attachment> attachments = new HashMap<String, Attachment>();
 
-    private final Map<String, StreamAttachment> attachments = new HashMap<String, StreamAttachment>();
-    private StreamAttachment root;
+    private boolean gotAll;
 
-    private int cidCounter = 0;
-
-    public MimeMultipartParser(InputStream in, String contentType) {
-        try {
-            ContentType ct = new ContentType(contentType);
-            String boundary = ct.getParameter("boundary");
-            if (boundary == null || boundary.equals("")) {
-                throw new WebServiceException("MIME boundary parameter not found" + contentType);
-            }
-            String bnd = "--" + boundary;
-            boundaryBytes = ASCIIUtility.getBytes(bnd);
-            start = ct.getParameter("start");
-        } catch (ParseException e) {
-            throw new WebServiceException(e);
+    public MimeMultipartParser(InputStream in, String contentType, StreamingAttachmentFeature feature) {
+        ContentType ct = new ContentType(contentType);
+        String boundary = ct.getParameter("boundary");
+        if (boundary == null || boundary.equals("")) {
+            throw new WebServiceException("MIME boundary parameter not found" + contentType);
         }
-
-        //InputStream MUST support mark()
-        if (!in.markSupported()) {
-            this.in = new BufferedInputStream(in);
-        } else {
-            this.in = in;
+        message = (feature != null)
+                ? new MIMEMessage(in, boundary, feature.getConfig())
+                : new MIMEMessage(in, boundary);
+        // Strip <...> from root part's Content-ID
+        String st = ct.getParameter("start");
+        if (st != null && st.length() > 2 && st.charAt(0) == '<' && st.charAt(st.length()-1) == '>') {
+            st = st.substring(1, st.length()-1);
         }
+        start = st;
     }
 
     /**
@@ -106,13 +94,10 @@
      *         null if root part cannot be found
      *
      */
-    public @Nullable StreamAttachment getRootPart() {
-        if (root != null) {
-            return root;
+    public @Nullable Attachment getRootPart() {
+        if (root == null) {
+            root = new PartAttachment((start != null) ? message.getPart(start) : message.getPart(0));
         }
-        while(!lastBodyPartFound() && (b != -1) && root == null) {
-            getNextPart();
-        }
         return root;
     }
 
@@ -121,9 +106,17 @@
      *
      * @return Map<String, StreamAttachment> for all attachment parts
      */
-    public @NotNull Map<String, StreamAttachment> getAttachmentParts() {
-        while(!lastBodyPartFound() && (b != -1)) {
-            getNextPart();
+    public @NotNull Map<String, Attachment> getAttachmentParts() {
+        if (!gotAll) {
+            MIMEPart rootPart = (start != null) ? message.getPart(start) : message.getPart(0);
+            List<MIMEPart> parts = message.getAttachments();
+            for(MIMEPart part : parts) {
+                if (part != rootPart) {
+                    PartAttachment attach = new PartAttachment(part);
+                    attachments.put(attach.getContentId(), attach);
+                }
+            }
+            gotAll = true;
         }
         return attachments;
     }
@@ -135,346 +128,81 @@
      * @return StreamAttachment attachment for contentId
      *         null if there is no attachment for contentId
      */
-    public @Nullable StreamAttachment getAttachmentPart(String contentId) throws IOException {
+    public @Nullable Attachment getAttachmentPart(String contentId) throws IOException {
         //first see if this attachment is already parsed, if so return it
-        StreamAttachment streamAttach = attachments.get(contentId);
-        if (streamAttach != null) {
-            return streamAttach;
+        Attachment attach = attachments.get(contentId);
+        if (attach == null) {
+            MIMEPart part = message.getPart(contentId);
+            attach = new PartAttachment(part);
+            attachments.put(contentId, attach);
         }
-        //else parse the MIME parts till we get what we want
-        while (!lastBodyPartFound() && (b != -1)) {
-            streamAttach = getNextPart();
-            String newContentId = streamAttach.getContentId();
-            if (newContentId != null && newContentId.equals(contentId)){
-                return streamAttach;
-            }
-        }
-        return null;            // Attachment is not found
+        return attach;
     }
 
-    /**
-     * Parses the stream and returns next available MIME part. This shouldn't
-     * be called if there are no MIME parts in the stream. Attachment
-     * part(not root part) is cached in the {@link Map}<{@link String},{@link StreamAttachment}>
-     * before returning the MIME part. It also finds the root part of the MIME
-     * package and assigns root variable.
-     *
-     * @return StreamAttachment next available MIME part
-     *
-     */
-    private StreamAttachment getNextPart() {
-        assert !lastBodyPartFound();
+    static class PartAttachment implements Attachment {
 
-        try {
-            if (firstPart) {
-                compileBoundaryPattern();
-                // skip the first boundary of the MIME package
-                if (!skipPreamble()) {
-                    throw new WebServiceException("Missing Start Boundary, or boundary does not start on a new line");
-                }
-            }
-            InternetHeaders ih = new InternetHeaders(in);
-            String[] contentTypes = ih.getHeader("content-type");
-            String contentType = (contentTypes != null) ? contentTypes[0] : "application/octet-stream";
-            String [] contentIds = ih.getHeader("content-id");
-            String mimeContentId = (contentIds != null) ? contentIds[0] : null;
-            String contentId = mimeContentId;
-            if(mimeContentId!=null && mimeContentId.length()>2) {
-                if(contentId.charAt(0)=='<')   contentId=mimeContentId.substring(1,mimeContentId.length()-1);
-            }
+        final MIMEPart part;
+        byte[] buf;
 
-            ByteArrayBuffer bos = new ByteArrayBuffer();
-            b = readBody(bos);
-            StreamAttachment as = new StreamAttachment(bos, contentId, contentType);
-            if (start == null && firstPart) {
-                root = as;      // Taking first part as root part
-            } else if (mimeContentId != null && start != null && start.equals(mimeContentId)) {
-                root = as;      // root part as identified by start parameter
-            } else if (contentId != null) {
-                attachments.put(contentId, as);     // Attachment part
-            } else {
-                ++cidCounter;
-                attachments.put(""+cidCounter, as);
-            }
-            firstPart = false;
-            return as;
-        } catch(IOException ioe) {
-            throw new WebServiceException(ioe);
-        } catch(MessagingException me) {
-            throw new WebServiceException(me);
+        PartAttachment(MIMEPart part) {
+            this.part = part;
         }
-    }
 
-    private int readBody(ByteArrayBuffer baos) throws IOException {
-        if (!findMimeBody(baos)) {
-            //TODO: i18n
-            throw new WebServiceException("Missing boundary delimitier ");
+        public @NotNull String getContentId() {
+            return part.getContentId();
         }
-        return b;
-    }
 
-    private boolean findMimeBody(ByteArrayBuffer out) throws IOException {
-        int i;
-        int l = boundaryBytes.length;
-        int lx = l - 1;
-        int bufferLength;
-        int s = 0;
-        byte[] tmp;
-
-        boolean first = true;
-        BitSet eof = new BitSet(1);
-
-        while (true) {
-            in.mark(l);
-            if (!first) {
-                tmp = prevBuffer;
-                prevBuffer = buffer;
-                buffer = tmp;
-            }
-            bufferLength = readNext(in, l, eof);
-
-            if (bufferLength == -1) {
-                b = -1;
-                if ((s == l)) {
-                    out.write(prevBuffer, 0, s);
-                }
-                return true;
-            }
-
-            if (bufferLength < l) {
-                out.write(buffer, 0, bufferLength);
-                b = -1;
-                return true;
-            }
-
-            for (i = lx; i >= 0; i--) {
-                if (buffer[i] != boundaryBytes[i]) {
-                    break;
-                }
-            }
-
-            if (i < 0) {
-                if (s > 0) {
-                    // so if s == 1 : it must be an LF
-                    // if s == 2 : it must be a CR LF
-                    if (s <= 2) {
-                        String crlf = new String(prevBuffer, 0, s);
-                        if (!"\n".equals(crlf) && !"\r\n".equals(crlf)) {
-                            throw new WebServiceException(
-                                    "Boundary characters encountered in part Body " +
-                                            "without a preceeding CRLF");
-                        }
-                    } else if (s > 2) {
-                        if ((prevBuffer[s - 2] == '\r') && (prevBuffer[s - 1] == '\n')) {
-                            out.write(prevBuffer, 0, s - 2);
-                        } else if (prevBuffer[s - 1] == '\n') {
-                            out.write(prevBuffer, 0, s - 1);
-                        } else {
-                            throw new WebServiceException(
-                                    "Boundary characters encountered in part Body " +
-                                            "without a preceeding CRLF");
-                        }
-                    }
-                }
-                // found the boundary, skip *LWSP-char and CRLF
-                if (!skipLWSPAndCRLF(in)) {
-                    //throw new Exception(
-                    //   "Boundary does not terminate with CRLF");
-                }
-                return true;
-            }
-
-            if ((s > 0)) {
-                if (prevBuffer[s - 1] == (byte) 13) {
-                    // if buffer[0] == (byte)10
-                    if (buffer[0] == (byte) 10) {
-                        int j;
-                        for (j = lx - 1; j > 0; j--) {
-                            if (buffer[j + 1] != boundaryBytes[j]) {
-                                break;
-                            }
-                        }
-                        if (j == 0) {
-                            // matched the boundaryBytes excluding the last char of the boundaryBytes
-                            // so dont write the CR into stream
-                            out.write(prevBuffer, 0, s - 1);
-                        } else {
-                            out.write(prevBuffer, 0, s);
-                        }
-                    } else {
-                        out.write(prevBuffer, 0, s);
-                    }
-                } else {
-                    out.write(prevBuffer, 0, s);
-                }
-            }
-
-            s = Math.max(i + 1 - bcs[buffer[i] & 0x7f], gss[i]);
-            in.reset();
-            in.skip(s);
-            if (first) {
-                first = false;
-            }
+        public @NotNull String getContentType() {
+            return part.getContentType();
         }
-    }
 
-
-    private boolean lastBodyPartFound() {
-        return lastPartFound.get(0);
-    }
-
-    private void compileBoundaryPattern() {
-        int l = boundaryBytes.length;
-
-        int i;
-        int j;
-
-        // Copied from J2SE 1.4 regex code
-        // java.util.regex.Pattern.java
-
-        // Initialise Bad Character Shift table
-        for (i = 0; i < l; i++) {
-            bcs[boundaryBytes[i]] = i + 1;
-        }
-
-        // Initialise Good Suffix Shift table
-        gss = new int[l];
-
-        NEXT:
-        for (i = l; i > 0; i--) {
-            // j is the beginning index of suffix being considered
-            for (j = l - 1; j >= i; j--) {
-                // Testing for good suffix
-                if (boundaryBytes[j] == boundaryBytes[j - i]) {
-                    // boundaryBytes[j..len] is a good suffix
-                    gss[j - 1] = i;
-                } else {
-                    // No match. The array has already been
-                    // filled up with correct values before.
-                    continue NEXT;
+        public byte[] asByteArray() {
+            if (buf == null) {
+                ByteArrayBuffer baf = new ByteArrayBuffer();
+                try {
+                    baf.write(part.readOnce());
+                } catch(IOException ioe) {
+                    throw new WebServiceException(ioe);
                 }
+                buf = baf.toByteArray();
             }
-            while (j > 0) {
-                gss[--j] = i;
-            }
+            return buf;
         }
-        gss[l - 1] = 1;
-    }
 
-    private boolean skipPreamble() throws IOException {
-        if (!findBoundary()) {
-            return false;
+        public DataHandler asDataHandler() {
+            return (buf != null)
+                ? new DataSourceStreamingDataHandler(new ByteArrayDataSource(buf,getContentType()))
+                : new MIMEPartStreamingDataHandler(part);
         }
-        if (lastPartFound.get(0)) {
-            throw new WebServiceException("Found closing boundary delimiter while trying to skip preamble");
-        }
-        return true;
-    }
 
-    private boolean findBoundary() throws IOException {
-        int i;
-        int l = boundaryBytes.length;
-        int lx = l - 1;
-        BitSet eof = new BitSet(1);
-
-        while (true) {
-            in.mark(l);
-            readNext(in, l, eof);
-            if (eof.get(0)) {
-                // End of stream
-                return false;
-            }
-
-            for (i = lx; i >= 0; i--) {
-                if (buffer[i] != boundaryBytes[i]) {
-                    break;
-                }
-            }
-
-            if (i < 0) {
-                // found the boundary, skip *LWSP-char and CRLF
-                if (!skipLWSPAndCRLF(in)) {
-                    throw new WebServiceException("Boundary does not terminate with CRLF");
-                }
-                return true;
-            }
-
-            int s = Math.max(i + 1 - bcs[buffer[i] & 0x7f], gss[i]);
-            in.reset();
-            in.skip(s);
+        public Source asSource() {
+            return (buf != null)
+                ? new StreamSource(new ByteArrayInputStream(buf))
+                : new StreamSource(part.read());
         }
-    }
 
-    private boolean skipLWSPAndCRLF(InputStream is) throws IOException {
-
-        b = is.read();
-        //looks like old impl allowed just a \n as well
-        if (b == '\n') {
-            return true;
+        public InputStream asInputStream() {
+            return (buf != null)
+                ? new ByteArrayInputStream(buf) : part.read();
         }
 
-        if (b == '\r') {
-            b = is.read();
-            if (b == '\n') {
-                return true;
+        public void writeTo(OutputStream os) throws IOException {
+            if (buf != null) {
+                os.write(buf);
             } else {
-                throw new WebServiceException(
-                        "transport padding after a Mime Boundary  should end in a CRLF, found CR only");
-            }
-        }
-
-        if (b == '-') {
-            b = is.read();
-            if (b != '-') {
-                throw new WebServiceException(
-                        "Unexpected singular '-' character after Mime Boundary");
-            } else {
-                lastPartFound.flip(0);
-                // read the next char
-                b = is.read();
-            }
-        }
-
-        while ((b != -1) && ((b == ' ') || (b == '\t'))) {
-            b = is.read();
-            if (b == '\r') {
-                b = is.read();
-                if (b == '\n') {
-                    return true;
+                InputStream in = part.read();
+                byte[] temp = new byte[8192];
+                int len;
+                while((len=in.read(temp)) != -1) {
+                    os.write(temp, 0, len);
                 }
+                in.close();
             }
         }
 
-        if (b == -1) {
-            // the last boundary need not have CRLF
-            if (!lastPartFound.get(0)) {
-                throw new WebServiceException(
-                        "End of Multipart Stream before encountering  closing boundary delimiter");
-            }
-            return true;
+        public void writeTo(SOAPMessage saaj) throws SOAPException {
+            saaj.createAttachmentPart().setDataHandler(asDataHandler());
         }
-        return false;
     }
 
-
-    private int readNext(InputStream is, int patternLength, BitSet eof) throws IOException {
-        int bufferLength = is.read(buffer, 0, patternLength);
-        if (bufferLength == -1) {
-            eof.flip(0);
-        } else if (bufferLength < patternLength) {
-            //repeatedly read patternLength - bufferLength
-            int temp ;
-            int i = bufferLength;
-            for (; i < patternLength; i++) {
-                temp = is.read();
-                if (temp == -1) {
-                    eof.flip(0);
-                    break;
-                }
-                buffer[i] = (byte) temp;
-            }
-            bufferLength = i;
-        }
-        return bufferLength;
-    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/MtomCodec.java	Tue Aug  4 10:01:26 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/MtomCodec.java	Tue Aug  4 10:01:26 2009
@@ -28,8 +28,8 @@
 import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.bind.DatatypeConverterImpl;
 import com.sun.xml.internal.bind.v2.runtime.output.Encoded;
-import com.sun.xml.internal.messaging.saaj.packaging.mime.util.OutputUtil;
 import com.sun.xml.internal.ws.api.SOAPVersion;
+import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.message.Attachment;
 import com.sun.xml.internal.ws.api.message.AttachmentSet;
 import com.sun.xml.internal.ws.api.message.Packet;
@@ -38,10 +38,11 @@
 import com.sun.xml.internal.ws.api.streaming.XMLStreamReaderFactory;
 import com.sun.xml.internal.ws.api.streaming.XMLStreamWriterFactory;
 import com.sun.xml.internal.ws.message.MimeAttachmentSet;
-import com.sun.xml.internal.ws.message.stream.StreamAttachment;
 import com.sun.xml.internal.ws.util.ByteArrayDataSource;
 import com.sun.xml.internal.ws.util.xml.XMLStreamReaderFilter;
 import com.sun.xml.internal.ws.util.xml.XMLStreamWriterFilter;
+import com.sun.xml.internal.ws.streaming.MtomStreamWriter;
+import com.sun.xml.internal.ws.streaming.XMLStreamReaderUtil;
 import com.sun.xml.internal.org.jvnet.staxex.Base64Data;
 import com.sun.xml.internal.org.jvnet.staxex.NamespaceContextEx;
 import com.sun.xml.internal.org.jvnet.staxex.XMLStreamReaderEx;
@@ -56,15 +57,16 @@
 import javax.xml.ws.WebServiceException;
 import javax.xml.ws.WebServiceFeature;
 import javax.xml.ws.soap.MTOMFeature;
+import javax.xml.bind.attachment.AttachmentMarshaller;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
 import java.nio.channels.WritableByteChannel;
-import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.UUID;
 
 /**
@@ -71,6 +73,7 @@
  * Mtom messge Codec. It can be used even for non-soap message's mtom encoding.
  *
  * @author Vivek Pandey
+ * @author Jitendra Kotamraju
  */
 public class MtomCodec extends MimeCodec {
     public static final String XOP_XML_MIME_TYPE = "application/xop+xml";
@@ -79,15 +82,13 @@
 
     // encoding related parameters
     private String boundary;
+    private String rootId;
     private final String soapXopContentType;
     private String messageContentType;
     private final MTOMFeature mtomFeature;
 
-    //This is the mtom attachment stream, we should write it just after the root part for decoder
-    private final List<ByteArrayBuffer> mtomAttachmentStream = new ArrayList<ByteArrayBuffer>();
-
-    MtomCodec(SOAPVersion version, StreamSOAPCodec codec, WebServiceFeature mtomFeature){
-        super(version);
+    MtomCodec(SOAPVersion version, StreamSOAPCodec codec, WSBinding binding, WebServiceFeature mtomFeature){
+        super(version, binding);
         this.codec = codec;
         createConteTypeHeader();
         this.soapXopContentType = XOP_XML_MIME_TYPE +";charset=utf-8;type=\""+version.contentType+"\"";
@@ -98,9 +99,12 @@
     }
 
     private void createConteTypeHeader(){
-        boundary = "uuid:" + UUID.randomUUID().toString();
+        String uuid = UUID.randomUUID().toString();
+        boundary = "uuid:" + uuid;
+        rootId = "<rootpart*"+uuid+"@example.jaxws.sun.com>";
         String boundaryParameter = "boundary=\"" + boundary +"\"";
         messageContentType = MULTIPART_RELATED_MIME_TYPE +
+                ";start=\""+rootId +"\"" +
                 ";type=\"" + XOP_XML_MIME_TYPE + "\";" +
                 boundaryParameter +
                 ";start-info=\"" + version.contentType + "\"";
@@ -131,21 +135,24 @@
 
     public ContentType encode(Packet packet, OutputStream out) throws IOException {
         //get the current boundary thaat will be reaturned from this method
-        mtomAttachmentStream.clear();
         ContentType contentType = getContentType(packet);
 
         if(packet.getMessage() != null){
             try {
-                OutputUtil.writeln("--"+boundary, out);
-                OutputUtil.writeln("Content-Type: "+ soapXopContentType,  out);
-                OutputUtil.writeln("Content-Transfer-Encoding: binary", out);
-                OutputUtil.writeln(out);
-                MtomStreamWriter writer = new MtomStreamWriter(XMLStreamWriterFactory.create(out),out);
+                writeln("--"+boundary, out);
+                writeln("Content-Id: " + rootId, out);
+                writeln("Content-Type: "+ soapXopContentType,  out);
+                writeln("Content-Transfer-Encoding: binary", out);
+                writeln(out);
+
+                //mtom attachments that need to be written after the root part
+                List<ByteArrayBuffer> mtomAttachments = new ArrayList<ByteArrayBuffer>();
+                MtomStreamWriterImpl writer = new MtomStreamWriterImpl(XMLStreamWriterFactory.create(out),out, mtomAttachments);
                 packet.getMessage().writeTo(writer);
                 XMLStreamWriterFactory.recycle(writer);
-                OutputUtil.writeln(out);
+                writeln(out);
 
-                for(ByteArrayBuffer bos : mtomAttachmentStream){
+                for(ByteArrayBuffer bos : mtomAttachments){
                     bos.write(out);
                 }
 
@@ -153,8 +160,8 @@
                 writeAttachments(packet.getMessage().getAttachments(),out);
 
                 //write out the end boundary
-                OutputUtil.writeAsAscii("--"+boundary, out);
-                OutputUtil.writeAsAscii("--", out);
+                writeAsAscii("--"+boundary, out);
+                writeAsAscii("--", out);
 
             } catch (XMLStreamException e) {
                 throw new WebServiceException(e);
@@ -177,30 +184,30 @@
 
         void write(OutputStream os) throws IOException {
             //build attachment frame
-            OutputUtil.writeln("--"+boundary, os);
+            writeln("--"+boundary, os);
             writeMimeHeaders(dh.getContentType(), contentId, os);
             dh.writeTo(os);
-            OutputUtil.writeln(os);
+            writeln(os);
         }
     }
 
     private void writeMimeHeaders(String contentType, String contentId, OutputStream out) throws IOException {
-        OutputUtil.writeln("Content-Type: " + contentType, out);
         String cid = contentId;
         if(cid != null && cid.length() >0 && cid.charAt(0) != '<')
             cid = '<' + cid + '>';
-        OutputUtil.writeln("Content-Id: " + cid, out);
-        OutputUtil.writeln("Content-Transfer-Encoding: binary", out);
-        OutputUtil.writeln(out);
+        writeln("Content-Id: " + cid, out);
+        writeln("Content-Type: " + contentType, out);
+        writeln("Content-Transfer-Encoding: binary", out);
+        writeln(out);
     }
 
     private void writeAttachments(AttachmentSet attachments, OutputStream out) throws IOException {
         for(Attachment att : attachments){
             //build attachment frame
-            OutputUtil.writeln("--"+boundary, out);
+            writeln("--"+boundary, out);
             writeMimeHeaders(att.getContentType(), att.getContentId(), out);
             att.writeTo(out);
-            OutputUtil.writeln(out);                    // write \r\n
+            writeln(out);                    // write \r\n
         }
     }
 
@@ -209,7 +216,7 @@
     }
 
     public MtomCodec copy() {
-        return new MtomCodec(version, (StreamSOAPCodec)codec.copy(), mtomFeature);
+        return new MtomCodec(version, (StreamSOAPCodec)codec.copy(), binding, mtomFeature);
     }
 
     private String encodeCid(){
@@ -227,22 +234,20 @@
             XMLStreamReaderFactory.create(null, mpp.getRootPart().asInputStream(), true)
         );
 
-        //TODO: remove this code after {@link StreamSOAPCodec#decode} is modified to
-        //take AttachmentSet.
-        if(codec instanceof com.sun.xml.internal.ws.encoding.StreamSOAPCodec){
-            packet.setMessage(((com.sun.xml.internal.ws.encoding.StreamSOAPCodec)codec).decode(mtomReader, new MimeAttachmentSet(mpp)));
-        }else{
-            packet.setMessage(codec.decode(mtomReader));
-        }
+        packet.setMessage(codec.decode(mtomReader, new MimeAttachmentSet(mpp)));
+
     }
 
-    private class MtomStreamWriter extends XMLStreamWriterFilter implements XMLStreamWriterEx {
+    private class MtomStreamWriterImpl extends XMLStreamWriterFilter implements XMLStreamWriterEx,
+            MtomStreamWriter {
         private final OutputStream out;
         private final Encoded encoded = new Encoded();
+        private final List<ByteArrayBuffer> mtomAttachments;
 
-        public MtomStreamWriter(XMLStreamWriter w, OutputStream out) {
+        public MtomStreamWriterImpl(XMLStreamWriter w, OutputStream out, List<ByteArrayBuffer> mtomAttachments) {
             super(w);
             this.out = out;
+            this.mtomAttachments = mtomAttachments;
         }
 
         public void writeBinary(byte[] data, int start, int len, String contentType) throws XMLStreamException {
@@ -256,9 +261,8 @@
         }
 
         public void writeBinary(DataHandler dataHandler) throws XMLStreamException {
-            Base64Data data  = new Base64Data();
-            data.set(dataHandler);
-            writeBinary(new ByteArrayBuffer(data.getDataHandler()));
+            // TODO how do we check threshold and if less inline the data
+            writeBinary(new ByteArrayBuffer(dataHandler));
         }
 
         public OutputStream writeBinary(String contentType) throws XMLStreamException {
@@ -278,7 +282,7 @@
 
         private void writeBinary(ByteArrayBuffer bab) {
             try {
-                mtomAttachmentStream.add(bab);
+                mtomAttachments.add(bab);
 
                 writer.writeCharacters("");   // Force completion of open elems
                 writer.flush();
@@ -285,10 +289,8 @@
                 //flush the underlying writer to write-out any cached data to the underlying
                 // stream before writing directly to it
                 //write out the xop reference
-                out.write(XOP_PREF);
-                encoded.set(bab.contentId);
+                encoded.set(XOP_PREF+bab.contentId+XOP_SUFF);
                 out.write(encoded.buf,0,encoded.len);
-                out.write(XOP_SUFF);
             } catch (IOException e) {
                 throw new WebServiceException(e);
             } catch (XMLStreamException e) {
@@ -296,6 +298,57 @@
             }
         }
 
+        @Override
+        public Object getProperty(String name) throws IllegalArgumentException {
+            // Hack for JDK6's SJSXP
+            if (name.equals("sjsxp-outputstream") && writer instanceof Map) {
+                Object obj = ((Map) writer).get("sjsxp-outputstream");
+                if (obj != null) {
+                    return obj;
+                }
+            }
+            return super.getProperty(name);
+        }
+
+        /**
+         * JAXBMessage writes envelope directly to the OutputStream(for SJSXP, woodstox).
+         * While writing, it calls the AttachmentMarshaller methods for adding attachments.
+         * JAXB writes xop:Include in this case.
+         */
+        public AttachmentMarshaller getAttachmentMarshaller() {
+            return new AttachmentMarshaller() {
+
+                public String addMtomAttachment(DataHandler data, String elementNamespace, String elementLocalName) {
+                    // Should we do the threshold processing on DataHandler ? But that would be
+                    // expensive as DataHolder need to read the data again from its source
+                    ByteArrayBuffer bab = new ByteArrayBuffer(data);
+                    mtomAttachments.add(bab);
+                    return "cid:"+bab.contentId;
+                }
+
+                public String addMtomAttachment(byte[] data, int offset, int length, String mimeType, String elementNamespace, String elementLocalName) {
+                    // inline the data based on the threshold
+                    if (mtomFeature.getThreshold() > length) {
+                        return null;                // JAXB inlines the attachment data
+                    }
+                    ByteArrayBuffer bab = new ByteArrayBuffer(new DataHandler(new ByteArrayDataSource(data, offset, length, mimeType)));
+                    mtomAttachments.add(bab);
+                    return "cid:"+bab.contentId;
+                }
+
+                public String addSwaRefAttachment(DataHandler data) {
+                    ByteArrayBuffer bab = new ByteArrayBuffer(data);
+                    mtomAttachments.add(bab);
+                    return "cid:"+bab.contentId;
+                }
+
+                @Override
+                public boolean isXOPPackage() {
+                    return true;
+                }
+            };
+        }
+
         private class MtomNamespaceContextEx implements NamespaceContextEx {
             private NamespaceContext nsContext;
 
@@ -320,6 +373,7 @@
             }
         }
 
+        @Override
         public NamespaceContextEx getNamespaceContext() {
             NamespaceContext nsContext = writer.getNamespaceContext();
             return new MtomNamespaceContextEx(nsContext);
@@ -335,10 +389,6 @@
         private boolean xopReferencePresent = false;
         private Base64Data base64AttData;
 
-        //values that will set to whether mtom or not as caller can call getPcData or getTextCharacters
-        private int textLength;
-        private int textStart;
-
         //To be used with #getTextCharacters
         private char[] base64EncodedText;
 
@@ -357,8 +407,6 @@
         public NamespaceContextEx getNamespaceContext() {
             NamespaceContext nsContext = reader.getNamespaceContext();
             return new MtomNamespaceContextEx(nsContext);
-
-
         }
 
         public String getElementTextTrim() throws XMLStreamException {
@@ -365,7 +413,7 @@
             throw new UnsupportedOperationException();
         }
 
-        private class MtomNamespaceContextEx implements NamespaceContextEx {
+        private static class MtomNamespaceContextEx implements NamespaceContextEx {
             private NamespaceContext nsContext;
 
             public MtomNamespaceContextEx(NamespaceContext nsContext) {
@@ -391,15 +439,16 @@
         }
 
         public int getTextLength() {
-            if (xopReferencePresent)
-                return textLength;
+            if (xopReferencePresent) {
+                return base64AttData.length();
+            }
             return reader.getTextLength();
         }
 
         public int getTextStart() {
-            //TODO: check if this is correct
-            if (xopReferencePresent)
+            if (xopReferencePresent) {
                 return 0;
+            }
             return reader.getTextStart();
         }
 
@@ -411,33 +460,25 @@
 
         public int next() throws XMLStreamException {
             int event = reader.next();
-            if ((event == XMLStreamConstants.START_ELEMENT) && reader.getLocalName().equals(XOP_LOCALNAME) && reader.getNamespaceURI().equals(XOP_NAMESPACEURI))
-            {
+            if (event == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(XOP_LOCALNAME) && reader.getNamespaceURI().equals(XOP_NAMESPACEURI)) {
                 //its xop reference, take the URI reference
                 String href = reader.getAttributeValue(null, "href");
                 try {
-                    StreamAttachment att = getAttachment(href);
+                    Attachment att = getAttachment(href);
                     if(att != null){
-                        base64AttData = att.asBase64Data();
-                        textLength = base64AttData.getDataLen();
+                        base64AttData = new Base64Data();
+                        base64AttData.set(att.asDataHandler());
                     }
-                    textStart = 0;
                     xopReferencePresent = true;
                 } catch (IOException e) {
                     throw new WebServiceException(e);
                 }
                 //move to the </xop:Include>
-                try {
-                    reader.next();
-                } catch (XMLStreamException e) {
-                    throw new WebServiceException(e);
-                }
+                XMLStreamReaderUtil.nextElementContent(reader);
                 return XMLStreamConstants.CHARACTERS;
             }
             if(xopReferencePresent){
                 xopReferencePresent = false;
-                textStart = 0;
-                textLength = 0;
                 base64EncodedText = null;
             }
             return event;
@@ -448,36 +489,18 @@
                 cid = URLDecoder.decode(cid, "utf-8");
             } catch (UnsupportedEncodingException e) {
                 //on recceiving side lets not fail now, try to look for it
-                return cid;
             }
             return cid;
         }
 
-        private boolean needToDecode(String cid){
-            int numChars = cid.length();
-            int i=0;
-            char c;
-            while (i < numChars) {
-                c = cid.charAt(i++);
-                switch (c) {
-                    case '%':
-                        return true;
-                }
-            }
-            return false;
-        }
-
-
-        private StreamAttachment getAttachment(String cid) throws IOException {
+        private Attachment getAttachment(String cid) throws IOException {
             if (cid.startsWith("cid:"))
                 cid = cid.substring(4, cid.length());
-            StreamAttachment att = mimeMP.getAttachmentPart(cid);
-            if(att == null && needToDecode(cid)){
-                //try not be url decoding it - this is required for Indigo interop, they write content-id without escaping
+            if (cid.indexOf('%') != -1) {
                 cid = decodeCid(cid);
                 return mimeMP.getAttachmentPart(cid);
             }
-            return att;
+            return mimeMP.getAttachmentPart(cid);
         }
 
         public char[] getTextCharacters() {
@@ -484,7 +507,6 @@
             if (xopReferencePresent) {
                 char[] chars = new char[base64AttData.length()];
                 base64AttData.writeTo(chars, 0);
-                textLength = chars.length;
                 return chars;
             }
             return reader.getTextCharacters();
@@ -492,12 +514,6 @@
 
         public int getTextCharacters(int sourceStart, char[] target, int targetStart, int length) throws XMLStreamException {
             if(xopReferencePresent){
-                int event = reader.getEventType();
-                if(event != XMLStreamConstants.CHARACTERS){
-                    //its invalid state - delegate it to underlying reader to throw the corrrect exception so that user
-                    // always sees the uniform exception from the XMLStreamReader
-                    throw new XMLStreamException("Invalid state: Expected CHARACTERS found :");
-                }
                 if(target == null){
                     throw new NullPointerException("target char array can't be null") ;
                 }
@@ -507,26 +523,17 @@
                     throw new IndexOutOfBoundsException();
                 }
 
-                if(base64EncodedText != null){
+                int textLength = base64AttData.length();
+                if(sourceStart > textLength)
+                    throw new IndexOutOfBoundsException();
+
+                if(base64EncodedText == null){
                     base64EncodedText = new char[base64AttData.length()];
                     base64AttData.writeTo(base64EncodedText, 0);
-                    textLength = base64EncodedText.length;
-                    textStart = 0;
                 }
 
-                if((textStart + sourceStart) > textLength)
-                    throw new IndexOutOfBoundsException();
-
-                int available = textLength - sourceStart;
-                if(available < 0){
-                    throw new IndexOutOfBoundsException("sourceStart is greater than" +
-                            "number of characters associated with this event");
-                }
-
-                int copiedLength = Math.min(available,length);
-
-                System.arraycopy(base64EncodedText, getTextStart() + sourceStart , target, targetStart, copiedLength);
-                textStart = sourceStart;
+                int copiedLength = Math.min(textLength - sourceStart, length);
+                System.arraycopy(base64EncodedText, sourceStart , target, targetStart, copiedLength);
                 return copiedLength;
             }
             return reader.getTextCharacters(sourceStart, target, targetStart, length);
@@ -534,27 +541,15 @@
 
         public String getText() {
             if (xopReferencePresent) {
-                String text =  base64AttData.toString();
-                textLength = text.length();
+                return base64AttData.toString();
             }
             return reader.getText();
         }
     }
 
-    private static final byte[] XOP_PREF = encode("<Include xmlns=\"http://www.w3.org/2004/08/xop/include\" href=\"cid:");
-
-    private static byte[] encode(String str) {
-        try {
-            return str.getBytes("UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            throw new Error(e);
-        }
-    }
-
-    private static final byte[] XOP_SUFF = encode("\"/>");
+    private static final String XOP_PREF = "<Include xmlns=\"http://www.w3.org/2004/08/xop/include\" href=\"cid:";
+    private static final String XOP_SUFF = "\"/>";
     private static final String XOP_LOCALNAME = "Include";
     private static final String XOP_NAMESPACEURI = "http://www.w3.org/2004/08/xop/include";
 
-
-    private static final Charset UTF8 = Charset.forName("UTF-8");
 }
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/SOAPBindingCodec.java	Tue Aug  4 10:01:29 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/SOAPBindingCodec.java	Tue Aug  4 10:01:28 2009
@@ -25,41 +25,34 @@
 
 package com.sun.xml.internal.ws.encoding;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.lang.reflect.Method;
-import java.nio.channels.ReadableByteChannel;
-import java.nio.channels.WritableByteChannel;
-import java.util.StringTokenizer;
-
-import javax.xml.namespace.QName;
-import javax.xml.soap.SOAPException;
-import javax.xml.soap.SOAPFault;
-import javax.xml.ws.WebServiceFeature;
-import javax.xml.ws.soap.MTOMFeature;
-
 import com.sun.xml.internal.ws.api.SOAPVersion;
 import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.client.SelectOptimalEncodingFeature;
 import com.sun.xml.internal.ws.api.fastinfoset.FastInfosetFeature;
-import com.sun.xml.internal.ws.api.message.Header;
-import com.sun.xml.internal.ws.api.message.HeaderList;
 import com.sun.xml.internal.ws.api.message.Message;
-import com.sun.xml.internal.ws.api.message.Messages;
 import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.message.ExceptionHasMessage;
 import com.sun.xml.internal.ws.api.pipe.Codec;
+import com.sun.xml.internal.ws.api.pipe.Codecs;
 import com.sun.xml.internal.ws.api.pipe.ContentType;
 import com.sun.xml.internal.ws.api.pipe.StreamSOAPCodec;
-import com.sun.xml.internal.ws.api.pipe.Codecs;
 import com.sun.xml.internal.ws.binding.SOAPBindingImpl;
 import com.sun.xml.internal.ws.client.ContentNegotiation;
-import com.sun.xml.internal.ws.resources.ServerMessages;
+import com.sun.xml.internal.ws.protocol.soap.MessageCreationException;
 import com.sun.xml.internal.ws.resources.StreamingMessages;
-import com.sun.xml.internal.ws.server.ServerRtException;
 import com.sun.xml.internal.ws.server.UnsupportedMediaException;
-import com.sun.xml.internal.ws.transport.http.WSHTTPConnection;
 
+import javax.xml.ws.WebServiceException;
+import javax.xml.ws.WebServiceFeature;
+import javax.xml.ws.soap.MTOMFeature;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.Method;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.WritableByteChannel;
+import java.util.StringTokenizer;
+
 /**
  * SOAP binding {@link Codec} that can handle MTOM, SwA, and SOAP messages
  * encoded using XML or Fast Infoset.
@@ -178,14 +171,14 @@
     }
 
     public SOAPBindingCodec(WSBinding binding, StreamSOAPCodec xmlSoapCodec) {
-        super(binding.getSOAPVersion());
+        super(binding.getSOAPVersion(), binding);
 
         this.xmlSoapCodec = xmlSoapCodec;
         xmlMimeType = xmlSoapCodec.getMimeType();
 
-        xmlMtomCodec = new MtomCodec(version, xmlSoapCodec, binding.getFeature(MTOMFeature.class));
+        xmlMtomCodec = new MtomCodec(version, xmlSoapCodec, binding, binding.getFeature(MTOMFeature.class));
 
-        xmlSwaCodec = new SwACodec(version, xmlSoapCodec);
+        xmlSwaCodec = new SwACodec(version, binding, xmlSoapCodec);
 
         String clientAcceptedContentTypes = xmlSoapCodec.getMimeType() + ", " +
                 xmlMtomCodec.getMimeType() + ", " +
@@ -197,7 +190,7 @@
             fiSoapCodec = getFICodec(xmlSoapCodec, version);
             if (fiSoapCodec != null) {
                 fiMimeType = fiSoapCodec.getMimeType();
-                fiSwaCodec = new SwACodec(version, fiSoapCodec);
+                fiSwaCodec = new SwACodec(version, binding, fiSoapCodec);
                 connegXmlAccept = fiMimeType + ", " + clientAcceptedContentTypes;
 
                 /**
@@ -238,6 +231,8 @@
 
         xmlAccept = clientAcceptedContentTypes;
 
+        if(!(binding instanceof SOAPBindingImpl))
+            throw new WebServiceException("Expecting a SOAP binding but found "+binding);
         this.binding = (SOAPBindingImpl)binding;
     }
 
@@ -269,19 +264,25 @@
          */
         if (packet.contentNegotiation == null)
             useFastInfosetForEncoding = false;
+        try {
+            if(isMultipartRelated(contentType))
+                // parse the multipart portion and then decide whether it's MTOM or SwA
+                super.decode(in, contentType, packet);
+            else if(isFastInfoset(contentType)) {
+                if (!ignoreContentNegotiationProperty && packet.contentNegotiation == ContentNegotiation.none)
+                    throw noFastInfosetForDecoding();
 
-        if(isMultipartRelated(contentType))
-            // parse the multipart portion and then decide whether it's MTOM or SwA
-            super.decode(in, contentType, packet);
-        else if(isFastInfoset(contentType)) {
-            if (!ignoreContentNegotiationProperty && packet.contentNegotiation == ContentNegotiation.none)
-                throw noFastInfosetForDecoding();
-
-            useFastInfosetForEncoding = true;
-            fiSoapCodec.decode(in, contentType, packet);
-        } else
-            xmlSoapCodec.decode(in, contentType, packet);
-
+                useFastInfosetForEncoding = true;
+                fiSoapCodec.decode(in, contentType, packet);
+            } else
+                xmlSoapCodec.decode(in, contentType, packet);
+        } catch(RuntimeException we) {
+            if (we instanceof ExceptionHasMessage || we instanceof UnsupportedMediaException) {
+                throw we;
+            } else {
+                throw new MessageCreationException(binding.getSOAPVersion(), we);
+            }
+        }
         if (!useFastInfosetForEncoding) {
             useFastInfosetForEncoding = isFastInfosetAcceptable(packet.acceptableMimeTypes);
         }
@@ -297,19 +298,24 @@
          */
         if (packet.contentNegotiation == null)
             useFastInfosetForEncoding = false;
+        try {
+            if(isMultipartRelated(contentType))
+                super.decode(in, contentType, packet);
+            else if(isFastInfoset(contentType)) {
+                if (packet.contentNegotiation == ContentNegotiation.none)
+                    throw noFastInfosetForDecoding();
 
-        if(isMultipartRelated(contentType))
-            super.decode(in, contentType, packet);
-        else if(isFastInfoset(contentType)) {
-            if (packet.contentNegotiation == ContentNegotiation.none)
-                throw noFastInfosetForDecoding();
-
-            useFastInfosetForEncoding = true;
-            fiSoapCodec.decode(in, contentType, packet);
-        } else
-            xmlSoapCodec.decode(in, contentType, packet);
-
-//        checkDuplicateKnownHeaders(packet);
+                useFastInfosetForEncoding = true;
+                fiSoapCodec.decode(in, contentType, packet);
+            } else
+                xmlSoapCodec.decode(in, contentType, packet);
+        } catch(RuntimeException we) {
+            if (we instanceof ExceptionHasMessage || we instanceof UnsupportedMediaException) {
+                throw we;
+            } else {
+                throw new MessageCreationException(binding.getSOAPVersion(), we);
+            }
+        }
         if (!useFastInfosetForEncoding) {
             useFastInfosetForEncoding = isFastInfosetAcceptable(packet.acceptableMimeTypes);
         }
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/StreamSOAP11Codec.java	Tue Aug  4 10:01:31 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/StreamSOAP11Codec.java	Tue Aug  4 10:01:31 2009
@@ -42,7 +42,7 @@
  */
 final class StreamSOAP11Codec extends StreamSOAPCodec {
     public static final String SOAP11_MIME_TYPE = "text/xml";
-    public static final String SOAP11_CONTENT_TYPE = SOAP11_MIME_TYPE+"; charset=utf-8";
+    public static final String SOAP11_CONTENT_TYPE = SOAP11_MIME_TYPE+";charset=\"utf-8\"";
 
     private static final List<String> expectedContentTypes = Collections.singletonList(SOAP11_MIME_TYPE);
 
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/StreamSOAP12Codec.java	Tue Aug  4 10:01:33 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/StreamSOAP12Codec.java	Tue Aug  4 10:01:33 2009
@@ -42,7 +42,7 @@
  */
 final class StreamSOAP12Codec extends StreamSOAPCodec {
     public static final String SOAP12_MIME_TYPE = "application/soap+xml";
-    public static final String SOAP12_CONTENT_TYPE = SOAP12_MIME_TYPE+"; charset=utf-8";
+    public static final String SOAP12_CONTENT_TYPE = SOAP12_MIME_TYPE+";charset=\"utf-8\"";
 
     private static final List<String> expectedContentTypes = Collections.singletonList(SOAP12_MIME_TYPE);
 
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/StreamSOAPCodec.java	Tue Aug  4 10:01:35 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/StreamSOAPCodec.java	Tue Aug  4 10:01:35 2009
@@ -56,6 +56,7 @@
 import java.io.OutputStream;
 import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.WritableByteChannel;
+import java.nio.charset.Charset;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -66,7 +67,7 @@
  * @author Paul Sandoz
  */
 @SuppressWarnings({"StringEquality"})
-public abstract class StreamSOAPCodec implements com.sun.xml.internal.ws.api.pipe.StreamSOAPCodec {
+public abstract class StreamSOAPCodec implements com.sun.xml.internal.ws.api.pipe.StreamSOAPCodec, RootOnlyCodec {
 
     private static final String SOAP_ENVELOPE = "Envelope";
     private static final String SOAP_HEADER = "Header";
@@ -114,14 +115,7 @@
     protected abstract List<String> getExpectedContentTypes();
 
     public void decode(InputStream in, String contentType, Packet packet) throws IOException {
-        List<String> expectedContentTypes = getExpectedContentTypes();
-        if (contentType != null && !isContentTypeSupported(contentType,expectedContentTypes)) {
-            throw new UnsupportedMediaException(contentType, expectedContentTypes);
-        }
-        // TODO: we should definitely let Decode owns one XMLStreamReader instance
-        // instead of going to this generic factory
-        XMLStreamReader reader = new TidyXMLStreamReader(XMLStreamReaderFactory.create(null, in, true), in);
-        packet.setMessage(decode(reader));
+        decode(in, contentType, packet, new AttachmentSetImpl());
     }
 
     /*
@@ -178,6 +172,9 @@
 
         // Collect namespaces on soap:Envelope
         Map<String,String> namespaces = new HashMap<String,String>();
+        for(int i=0; i< reader.getNamespaceCount();i++){
+                namespaces.put(reader.getNamespacePrefix(i), reader.getNamespaceURI(i));
+        }
 
         // Move to next element
         XMLStreamReaderUtil.nextElementContent(reader);
@@ -281,8 +278,25 @@
         return new MutableXMLStreamBuffer();
     }
 
+    public void decode(InputStream in, String contentType, Packet packet, AttachmentSet att ) throws IOException {
+        List<String> expectedContentTypes = getExpectedContentTypes();
+        if (contentType != null && !isContentTypeSupported(contentType,expectedContentTypes)) {
+            throw new UnsupportedMediaException(contentType, expectedContentTypes);
+        }
+        String charset = new ContentTypeImpl(contentType).getCharSet();
+        if (charset != null && !Charset.isSupported(charset)) {
+            throw new UnsupportedMediaException(charset);
+        }
+        XMLStreamReader reader = XMLStreamReaderFactory.create(null, in, charset, true);
+        reader =  new TidyXMLStreamReader(reader, in);
+        packet.setMessage(decode(reader, att));
+    }
 
+    public void decode(ReadableByteChannel in, String contentType, Packet response, AttachmentSet att ) {
+        throw new UnsupportedOperationException();
+    }
 
+
 
     /**
      * Creates a new {@link StreamSOAPCodec} instance.
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/SwACodec.java	Tue Aug  4 10:01:38 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/SwACodec.java	Tue Aug  4 10:01:37 2009
@@ -26,10 +26,13 @@
 package com.sun.xml.internal.ws.encoding;
 
 import com.sun.xml.internal.ws.api.SOAPVersion;
+import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.message.Attachment;
 import com.sun.xml.internal.ws.api.pipe.Codec;
 import com.sun.xml.internal.ws.api.pipe.ContentType;
 import com.sun.xml.internal.ws.message.stream.StreamAttachment;
+import com.sun.xml.internal.ws.message.MimeAttachmentSet;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
@@ -42,8 +45,8 @@
  */
 public final class SwACodec extends MimeCodec {
 
-    public SwACodec(SOAPVersion version, Codec rootCodec) {
-        super(version);
+    public SwACodec(SOAPVersion version, WSBinding binding, Codec rootCodec) {
+        super(version, binding);
         this.rootCodec = rootCodec;
     }
 
@@ -55,11 +58,15 @@
     @Override
     protected void decode(MimeMultipartParser mpp, Packet packet) throws IOException {
         // TODO: handle attachments correctly
-        StreamAttachment root = mpp.getRootPart();
-        rootCodec.decode(root.asInputStream(),root.getContentType(),packet);
-        Map<String, StreamAttachment> atts = mpp.getAttachmentParts();
-        for(Map.Entry<String, StreamAttachment> att : atts.entrySet()) {
-            packet.getMessage().getAttachments().add(att.getValue());
+        Attachment root = mpp.getRootPart();
+        if (rootCodec instanceof RootOnlyCodec) {
+            ((RootOnlyCodec)rootCodec).decode(root.asInputStream(),root.getContentType(),packet, new MimeAttachmentSet(mpp));
+        } else {
+            rootCodec.decode(root.asInputStream(),root.getContentType(),packet);
+            Map<String, Attachment> atts = mpp.getAttachmentParts();
+            for(Map.Entry<String, Attachment> att : atts.entrySet()) {
+                packet.getMessage().getAttachments().add(att.getValue());
+            }
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/TagInfoset.java	Tue Aug  4 10:01:40 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/TagInfoset.java	Tue Aug  4 10:01:39 2009
@@ -59,6 +59,8 @@
     /**
      * Namespace declarations on this tag. Read-only.
      *
+     * This is an array of the even length of the form { prefix0, uri0, prefix1, uri1, ... }.
+     *
      * URIs/prefixes can be null (StAX-style)
      */
     public final @NotNull String[] ns;
@@ -169,12 +171,15 @@
      * Writes the start element event.
      */
     public void writeStart(XMLStreamWriter w) throws XMLStreamException {
-        // write start tag. Arrrgggghhh!!
+        // write start tag.
         if(prefix==null) {
             if(nsUri==null)
                 w.writeStartElement(localName);
-            else
-                w.writeStartElement(nsUri,localName);
+            else {
+                //fix Null prefix. otherwise throws XMLStreamException,
+                // if the namespace URI has not been bound to a prefix
+                w.writeStartElement("",localName,nsUri);
+            }
         } else {
             w.writeStartElement(prefix,localName,nsUri);
         }
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/XMLHTTPBindingCodec.java	Tue Aug  4 10:01:42 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/XMLHTTPBindingCodec.java	Tue Aug  4 10:01:42 2009
@@ -25,13 +25,13 @@
 
 package com.sun.xml.internal.ws.encoding;
 
-import com.sun.xml.internal.messaging.saaj.util.ByteOutputStream;
 import com.sun.xml.internal.ws.api.SOAPVersion;
+import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.message.Packet;
-import com.sun.xml.internal.ws.api.message.Messages;
 import com.sun.xml.internal.ws.api.pipe.Codec;
 import com.sun.xml.internal.ws.api.pipe.ContentType;
 import com.sun.xml.internal.ws.client.ContentNegotiation;
+import com.sun.xml.internal.ws.developer.StreamingAttachmentFeature;
 import com.sun.xml.internal.ws.encoding.xml.XMLCodec;
 import com.sun.xml.internal.ws.encoding.xml.XMLMessage;
 import com.sun.xml.internal.ws.encoding.xml.XMLMessage.MessageDataSource;
@@ -38,6 +38,7 @@
 import com.sun.xml.internal.ws.encoding.xml.XMLMessage.UnknownContent;
 import com.sun.xml.internal.ws.encoding.xml.XMLMessage.XMLMultiPart;
 import com.sun.xml.internal.ws.resources.StreamingMessages;
+import com.sun.xml.internal.ws.util.ByteArrayBuffer;
 
 import javax.activation.DataSource;
 import javax.xml.ws.WebServiceException;
@@ -125,10 +126,10 @@
 
     private AcceptContentType _adaptingContentType = new AcceptContentType();
 
-    public XMLHTTPBindingCodec() {
-        super(SOAPVersion.SOAP_11);
+    public XMLHTTPBindingCodec(WSBinding binding) {
+        super(SOAPVersion.SOAP_11, binding);
 
-        xmlCodec = new XMLCodec();
+        xmlCodec = new XMLCodec(binding);
 
         fiCodec = getFICodec();
 
@@ -192,7 +193,7 @@
         if (contentType == null) {
             xmlCodec.decode(in, contentType, packet);
         } else if (isMultipartRelated(contentType)) {
-            packet.setMessage(new XMLMultiPart(contentType, in));
+            packet.setMessage(new XMLMultiPart(contentType, in, binding.getFeature(StreamingAttachmentFeature.class)));
         } else if(isFastInfoset(contentType)) {
             if (fiCodec == null) {
                 throw new RuntimeException(StreamingMessages.FASTINFOSET_NO_IMPLEMENTATION());
@@ -216,7 +217,7 @@
     }
 
     public MimeCodec copy() {
-        return new XMLHTTPBindingCodec();
+        return new XMLHTTPBindingCodec(binding);
     }
 
     private boolean isMultipartRelated(String contentType) {
@@ -274,7 +275,7 @@
             final boolean isFastInfoset = XMLMessage.isFastInfoset(
                     mds.getDataSource().getContentType());
             DataSource ds = transformDataSource(mds.getDataSource(),
-                    isFastInfoset, useFastInfosetForEncoding);
+                    isFastInfoset, useFastInfosetForEncoding, binding);
 
             InputStream is = ds.getInputStream();
             byte[] buf = new byte[1024];
@@ -313,11 +314,11 @@
     }
 
     public static DataSource transformDataSource(DataSource in,
-            boolean isFastInfoset, boolean useFastInfoset) {
+            boolean isFastInfoset, boolean useFastInfoset, WSBinding binding) {
         try {
             if (isFastInfoset && !useFastInfoset) {
                 // Convert from Fast Infoset to XML
-                Codec codec = new XMLHTTPBindingCodec();
+                Codec codec = new XMLHTTPBindingCodec(binding);
                 Packet p = new Packet();
                 codec.decode(in.getInputStream(), in.getContentType(), p);
 
@@ -324,12 +325,12 @@
                 p.getMessage().getAttachments();
                 codec.getStaticContentType(p);
 
-                ByteOutputStream bos = new ByteOutputStream();
+                ByteArrayBuffer bos = new ByteArrayBuffer();
                 ContentType ct = codec.encode(p, bos);
                 return XMLMessage.createDataSource(ct.getContentType(), bos.newInputStream());
             } else if (!isFastInfoset && useFastInfoset) {
                 // Convert from XML to Fast Infoset
-                Codec codec = new XMLHTTPBindingCodec();
+                Codec codec = new XMLHTTPBindingCodec(binding);
                 Packet p = new Packet();
                 codec.decode(in.getInputStream(), in.getContentType(), p);
 
@@ -337,7 +338,7 @@
                 p.getMessage().getAttachments();
                 codec.getStaticContentType(p);
 
-                ByteOutputStream bos = new ByteOutputStream();
+                ByteArrayBuffer bos = new ByteArrayBuffer();
                 com.sun.xml.internal.ws.api.pipe.ContentType ct = codec.encode(p, bos);
                 return XMLMessage.createDataSource(ct.getContentType(), bos.newInputStream());
             }
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/fastinfoset/FastInfosetCodec.java	Tue Aug  4 10:01:44 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/fastinfoset/FastInfosetCodec.java	Tue Aug  4 10:01:44 2009
@@ -47,7 +47,6 @@
 import java.nio.channels.WritableByteChannel;
 import java.nio.channels.ReadableByteChannel;
 import com.sun.xml.internal.org.jvnet.fastinfoset.FastInfosetSource;
-import com.sun.xml.internal.org.jvnet.fastinfoset.stax.FastInfosetStreamReader;
 
 /**
  * A codec for encoding/decoding XML infosets to/from fast
@@ -196,8 +195,10 @@
              */
             SerializerVocabulary vocabulary = new SerializerVocabulary();
             serializer.setVocabulary(vocabulary);
-            serializer.setAttributeValueSizeLimit(indexedStringSizeLimit);
-            serializer.setCharacterContentChunkSizeLimit(indexedStringSizeLimit);
+            serializer.setMinAttributeValueSize(0);
+            serializer.setMaxAttributeValueSize(indexedStringSizeLimit);
+            serializer.setMinCharacterContentChunkSize(0);
+            serializer.setMaxCharacterContentChunkSize(indexedStringSizeLimit);
             serializer.setAttributeValueMapMemoryLimit(stringsMemoryLimit);
             serializer.setCharacterContentChunkMapMemoryLimit(stringsMemoryLimit);
         }
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/xml/XMLCodec.java	Tue Aug  4 10:01:46 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/xml/XMLCodec.java	Tue Aug  4 10:01:46 2009
@@ -30,6 +30,7 @@
 import com.sun.xml.internal.ws.api.pipe.Codec;
 import com.sun.xml.internal.ws.api.pipe.ContentType;
 import com.sun.xml.internal.ws.api.streaming.XMLStreamWriterFactory;
+import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.encoding.ContentTypeImpl;
 
 import javax.xml.stream.XMLStreamException;
@@ -48,6 +49,12 @@
 
     private static final ContentType contentType = new ContentTypeImpl(XML_TEXT_MIME_TYPE);
 
+    private final WSBinding binding;
+
+    public XMLCodec(WSBinding binding) {
+        this.binding = binding;
+    }
+
     public String getMimeType() {
         return XML_APPLICATION_MIME_TYPE;
     }
@@ -79,7 +86,7 @@
     }
 
     public void decode(InputStream in, String contentType, Packet packet) throws IOException {
-        Message message = XMLMessage.create(contentType, in);
+        Message message = XMLMessage.create(contentType, in, binding);
         packet.setMessage(message);
     }
 
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/xml/XMLMessage.java	Tue Aug  4 10:01:49 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/xml/XMLMessage.java	Tue Aug  4 10:01:48 2009
@@ -26,25 +26,24 @@
 package com.sun.xml.internal.ws.encoding.xml;
 
 import com.sun.istack.internal.NotNull;
-import com.sun.xml.internal.messaging.saaj.packaging.mime.internet.ContentType;
-import com.sun.xml.internal.messaging.saaj.packaging.mime.internet.MimeMultipart;
-import com.sun.xml.internal.messaging.saaj.util.ByteOutputStream;
 import com.sun.xml.internal.ws.api.SOAPVersion;
-import com.sun.xml.internal.ws.api.message.Attachment;
-import com.sun.xml.internal.ws.api.message.AttachmentSet;
-import com.sun.xml.internal.ws.api.message.HeaderList;
-import com.sun.xml.internal.ws.api.message.Message;
-import com.sun.xml.internal.ws.api.message.Messages;
-import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.message.*;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
 import com.sun.xml.internal.ws.api.pipe.Codec;
 import com.sun.xml.internal.ws.api.streaming.XMLStreamReaderFactory;
 import com.sun.xml.internal.ws.api.streaming.XMLStreamWriterFactory;
+import com.sun.xml.internal.ws.developer.StreamingAttachmentFeature;
 import com.sun.xml.internal.ws.encoding.MimeMultipartParser;
 import com.sun.xml.internal.ws.encoding.XMLHTTPBindingCodec;
+import com.sun.xml.internal.ws.encoding.ContentType;
 import com.sun.xml.internal.ws.message.AbstractMessageImpl;
 import com.sun.xml.internal.ws.message.EmptyMessageImpl;
+import com.sun.xml.internal.ws.message.MimeAttachmentSet;
+import com.sun.xml.internal.ws.message.source.PayloadSourceMessage;
 import com.sun.xml.internal.ws.util.xml.XMLStreamReaderToXMLStreamWriter;
+import com.sun.xml.internal.ws.util.ByteArrayBuffer;
+import com.sun.xml.internal.bind.api.Bridge;
 import org.xml.sax.ContentHandler;
 import org.xml.sax.ErrorHandler;
 import org.xml.sax.SAXException;
@@ -56,13 +55,11 @@
 import javax.xml.transform.Source;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.ws.WebServiceException;
-import java.io.BufferedInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.soap.SOAPException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.JAXBException;
+import java.io.*;
 
 /**
  *
@@ -70,11 +67,6 @@
  */
 public final class XMLMessage {
 
-    // So that SAAJ registers DCHs for MIME types
-    static {
-        new com.sun.xml.internal.messaging.saaj.soap.AttachmentPartImpl();
-    }
-
     private static final int PLAIN_XML_FLAG      = 1;       // 00001
     private static final int MIME_MULTIPART_FLAG = 2;       // 00010
     private static final int FI_ENCODED_FLAG     = 16;      // 10000
@@ -107,13 +99,12 @@
     /**
      * Construct a message given a content type and an input stream.
      */
-    public static Message create(final String ct, InputStream in) {
+    public static Message create(final String ct, InputStream in, WSBinding binding) {
         Message data;
         try {
             in = hasSomeData(in);
             if (in == null) {
-                data = Messages.createEmpty(SOAPVersion.SOAP_11);
-                return data;
+                return Messages.createEmpty(SOAPVersion.SOAP_11);
             }
 
             if (ct != null) {
@@ -120,10 +111,9 @@
                 final ContentType contentType = new ContentType(ct);
                 final int contentTypeId = identifyContentType(contentType);
                 if ((contentTypeId & MIME_MULTIPART_FLAG) != 0) {
-                    data = new XMLMultiPart(ct, in);
+                    data = new XMLMultiPart(ct, in, binding.getFeature(StreamingAttachmentFeature.class));
                 } else if ((contentTypeId & PLAIN_XML_FLAG) != 0) {
-                    data = Messages.createUsingPayload(new StreamSource(in),
-                            SOAPVersion.SOAP_11);
+                    data = new XmlContent(ct, in);
                 } else {
                     data = new UnknownContent(ct, in);
                 }
@@ -143,11 +133,11 @@
             Messages.createUsingPayload(source, SOAPVersion.SOAP_11);
     }
 
-    public static Message create(DataSource ds) {
+    public static Message create(DataSource ds, WSBinding binding) {
         try {
             return (ds == null) ?
                 Messages.createEmpty(SOAPVersion.SOAP_11) :
-                create(ds.getContentType(), ds.getInputStream());
+                create(ds.getContentType(), ds.getInputStream(), binding);
         } catch(IOException ioe) {
             throw new WebServiceException(ioe);
         }
@@ -252,26 +242,145 @@
         DataSource getDataSource();
     }
 
+    /**
+     * It's conent-type is some XML type
+     *
+     */
+    private static class XmlContent extends AbstractMessageImpl implements MessageDataSource {
+        private final DataSource dataSource;
+        private boolean consumed;
+        private Message delegate;
+        private final HeaderList headerList;
 
+        public XmlContent(String ct, InputStream in) {
+            super(SOAPVersion.SOAP_11);
+            dataSource = createDataSource(ct, in);
+            this.headerList = new HeaderList();
+        }
+
+        private Message getMessage() {
+            if (delegate == null) {
+                assert !consumed;
+                InputStream in = null;
+                try {
+                    in = dataSource.getInputStream();
+                } catch(IOException ioe) {
+                    // shouldn't happen;
+                }
+                assert in != null;
+                delegate = Messages.createUsingPayload(new StreamSource(in), SOAPVersion.SOAP_11);
+                consumed = true;
+            }
+            return delegate;
+        }
+
+        public boolean hasUnconsumedDataSource() {
+            return !consumed;
+        }
+
+        public DataSource getDataSource() {
+            consumed = true;
+            return dataSource;
+        }
+
+        public boolean hasHeaders() {
+            return false;
+        }
+
+        public @NotNull HeaderList getHeaders() {
+            return headerList;
+        }
+
+        public String getPayloadLocalPart() {
+            return getMessage().getPayloadLocalPart();
+        }
+
+        public String getPayloadNamespaceURI() {
+            return getMessage().getPayloadNamespaceURI();
+        }
+
+        public boolean hasPayload() {
+            return true;
+        }
+
+        public boolean isFault() {
+            return false;
+        }
+
+        public Source readEnvelopeAsSource() {
+            return getMessage().readEnvelopeAsSource();
+        }
+
+        public Source readPayloadAsSource() {
+            return getMessage().readPayloadAsSource();
+        }
+
+        public SOAPMessage readAsSOAPMessage() throws SOAPException {
+            return getMessage().readAsSOAPMessage();
+        }
+
+        public SOAPMessage readAsSOAPMessage(Packet packet, boolean inbound) throws SOAPException {
+            return getMessage().readAsSOAPMessage(packet, inbound);
+        }
+
+        public <T> T readPayloadAsJAXB(Unmarshaller unmarshaller) throws JAXBException {
+            return (T)getMessage().readPayloadAsJAXB(unmarshaller);
+        }
+
+        public <T> T readPayloadAsJAXB(Bridge<T> bridge) throws JAXBException {
+            return getMessage().readPayloadAsJAXB(bridge);
+        }
+
+        public XMLStreamReader readPayload() throws XMLStreamException {
+            return getMessage().readPayload();
+        }
+
+
+        public void writePayloadTo(XMLStreamWriter sw) throws XMLStreamException {
+            getMessage().writePayloadTo(sw);
+        }
+
+        public void writeTo(XMLStreamWriter sw) throws XMLStreamException {
+            getMessage().writeTo(sw);
+        }
+
+        public void writeTo(ContentHandler contentHandler, ErrorHandler errorHandler) throws SAXException {
+            getMessage().writeTo(contentHandler, errorHandler);
+        }
+
+        public Message copy() {
+            throw new UnsupportedOperationException();
+        }
+
+        protected void writePayloadTo(ContentHandler contentHandler, ErrorHandler errorHandler, boolean fragment) throws SAXException {
+            throw new UnsupportedOperationException();
+        }
+
+    }
+
+
+
     /**
      * Data represented as a multi-part MIME message.
      * <p>
-     * The root part may be an XML or an FI document.
-     *
-     * This class parses {@link MimeMultipart} lazily.
+     * The root part may be an XML or an FI document. This class
+     * parses MIME message lazily.
      */
     public static final class XMLMultiPart extends AbstractMessageImpl implements MessageDataSource {
         private final DataSource dataSource;
         private MimeMultipartParser mpp;
+        private final StreamingAttachmentFeature feature;
 
-        public XMLMultiPart(final String contentType, final InputStream is) {
+        public XMLMultiPart(final String contentType, final InputStream is, StreamingAttachmentFeature feature) {
             super(SOAPVersion.SOAP_11);
             dataSource = createDataSource(contentType, is);
+            this.feature = feature;
         }
 
-        public XMLMultiPart(DataSource dataSource) {
+        public XMLMultiPart(DataSource dataSource, StreamingAttachmentFeature feature) {
             super(SOAPVersion.SOAP_11);
             this.dataSource = dataSource;
+            this.feature = feature;
         }
 
         public DataSource getDataSource() {
@@ -284,7 +393,7 @@
                 try {
                     mpp = new MimeMultipartParser(
                             dataSource.getInputStream(),
-                            dataSource.getContentType());
+                            dataSource.getContentType(), feature);
                 } catch(IOException ioe) {
                     throw new WebServiceException(ioe);
                 }
@@ -311,7 +420,7 @@
         @Override
         public AttachmentSet getAttachments() {
             convertDataSourceToMessage();
-            return new XMLAttachmentSet(mpp);
+            return new MimeAttachmentSet(mpp);
         }
 
         public String getPayloadLocalPart() {
@@ -363,45 +472,6 @@
 
     }
 
-    private static final class XMLAttachmentSet implements AttachmentSet {
-
-        private final Map<String, Attachment> attMap;
-
-        public XMLAttachmentSet(MimeMultipartParser mpp) {
-            // TODO
-            attMap = new HashMap<String, Attachment>();
-            attMap.putAll(mpp.getAttachmentParts());
-        }
-
-        /**
-         * Gets the attachment by the content ID.
-         *
-         * @return null
-         *         if no such attachment exist.
-         */
-        public Attachment get(String contentId) {
-            return attMap.get(contentId);
-        }
-
-        public boolean isEmpty() {
-            return attMap.isEmpty();
-        }
-
-        /**
-         * Returns an iterator over a set of elements of type T.
-         *
-         * @return an Iterator.
-         */
-        public Iterator<Attachment> iterator() {
-            return attMap.values().iterator();
-        }
-
-        public void add(Attachment att) {
-            attMap.put(att.getContentId(), att);
-        }
-
-    }
-
     private static class FaultMessage extends EmptyMessageImpl {
 
         public FaultMessage(SOAPVersion version) {
@@ -500,15 +570,15 @@
 
     }
 
-    public static DataSource getDataSource(Message msg) {
+    public static DataSource getDataSource(Message msg, WSBinding binding) {
         if (msg instanceof MessageDataSource) {
             return ((MessageDataSource)msg).getDataSource();
         } else {
             AttachmentSet atts = msg.getAttachments();
             if (atts != null && !atts.isEmpty()) {
-                final ByteOutputStream bos = new ByteOutputStream();
+                final ByteArrayBuffer bos = new ByteArrayBuffer();
                 try {
-                    Codec codec = new XMLHTTPBindingCodec();
+                    Codec codec = new XMLHTTPBindingCodec(binding);
                     com.sun.xml.internal.ws.api.pipe.ContentType ct = codec.getStaticContentType(new Packet(msg));
                     codec.encode(new Packet(msg), bos);
                     return createDataSource(ct.getContentType(), bos.newInputStream());
@@ -517,7 +587,7 @@
                 }
 
             } else {
-                final ByteOutputStream bos = new ByteOutputStream();
+                final ByteArrayBuffer bos = new ByteArrayBuffer();
                 XMLStreamWriter writer = XMLStreamWriterFactory.create(bos);
                 try {
                     msg.writePayloadTo(writer);
--- old/src/share/classes/com/sun/xml/internal/ws/fault/SOAP11Fault.java	Tue Aug  4 10:01:51 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/fault/SOAP11Fault.java	Tue Aug  4 10:01:51 2009
@@ -30,11 +30,7 @@
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 
-import javax.xml.bind.annotation.XmlAccessType;
-import javax.xml.bind.annotation.XmlAccessorType;
-import javax.xml.bind.annotation.XmlElement;
-import javax.xml.bind.annotation.XmlRootElement;
-import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.annotation.*;
 import javax.xml.namespace.QName;
 import javax.xml.soap.Detail;
 import javax.xml.soap.SOAPException;
@@ -41,6 +37,7 @@
 import javax.xml.soap.SOAPFault;
 import javax.xml.ws.WebServiceException;
 import javax.xml.ws.soap.SOAPFaultException;
+import java.util.Iterator;
 
 /**
  * This class represents SOAP1.1 Fault. This class will be used to marshall/unmarshall a soap fault using JAXB.
@@ -121,7 +118,12 @@
         this.faultstring = fault.getFaultString();
         this.faultactor = fault.getFaultActor();
         if (fault.getDetail() != null) {
-            detail = new DetailType(fault.getDetail());
+            detail = new DetailType();
+            Iterator iter = fault.getDetail().getDetailEntries();
+            while(iter.hasNext()){
+                Element fd = (Element)iter.next();
+                detail.getDetails().add(fd);
+            }
         }
     }
 
@@ -165,10 +167,12 @@
     protected Throwable getProtocolException() {
         try {
             SOAPFault fault = SOAPVersion.SOAP_11.saajSoapFactory.createFault(faultstring, faultcode);
-            if(detail != null && detail.getDetail(0) != null) {
-                Node n = fault.getOwnerDocument().importNode(detail.getDetail(0), true);
+            if(detail != null){
                 Detail d = fault.addDetail();
-                d.appendChild(n);
+                for(Element det : detail.getDetails()){
+                    Node n = fault.getOwnerDocument().importNode(det, true);
+                    d.appendChild(n);
+                }
             }
             fault.setFaultActor(faultactor);
             return new SOAPFaultException(fault);
--- old/src/share/classes/com/sun/xml/internal/ws/fault/SOAP12Fault.java	Tue Aug  4 10:01:53 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/fault/SOAP12Fault.java	Tue Aug  4 10:01:53 2009
@@ -27,6 +27,7 @@
 
 
 import com.sun.xml.internal.ws.api.SOAPVersion;
+import com.sun.xml.internal.ws.util.DOMUtil;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 
@@ -111,6 +112,23 @@
         this.detail = detail;
     }
 
+    SOAP12Fault(CodeType code, ReasonType reason, String node, String role, Element detailObject) {
+        this.code = code;
+        this.reason = reason;
+        this.node = node;
+        this.role = role;
+        if (detailObject != null) {
+            if(detailObject.getNamespaceURI().equals(ns) && detailObject.getLocalName().equals("Detail")){
+                detail = new DetailType();
+                for(Element detailEntry : DOMUtil.getChildElements(detailObject)){
+                    detail.getDetails().add(detailEntry);
+                }
+            }else{
+                detail = new DetailType(detailObject);
+            }
+        }
+    }
+
     SOAP12Fault(SOAPFault fault) {
         code = new CodeType(fault.getFaultCodeAsQName());
         try {
@@ -121,14 +139,19 @@
 
         reason = new ReasonType(fault.getFaultString());
         role = fault.getFaultRole();
-        detail = new DetailType(fault.getDetail());
+        node = fault.getFaultNode();
+        if (fault.getDetail() != null) {
+            detail = new DetailType();
+            Iterator iter = fault.getDetail().getDetailEntries();
+            while(iter.hasNext()){
+                Element fd = (Element)iter.next();
+                detail.getDetails().add(fd);
+            }
+        }
     }
 
     SOAP12Fault(QName code, String reason, Element detailObject) {
-        this.code = new CodeType(code);
-        this.reason = new ReasonType(reason);
-        if(detailObject != null)
-            detail = new DetailType(detailObject);
+        this(new CodeType(code), new ReasonType(reason), null, null, detailObject);
     }
 
     CodeType getCode() {
@@ -164,7 +187,18 @@
 
      protected Throwable getProtocolException() {
         try {
-            SOAPFault fault = SOAPVersion.SOAP_12.saajSoapFactory.createFault(reason.texts().get(0).getText(), (code != null)? code.getValue():null);
+            SOAPFault fault = SOAPVersion.SOAP_12.saajSoapFactory.createFault();;
+            if(reason != null){
+                for(TextType tt : reason.texts()){
+                    fault.setFaultString(tt.getText());
+                }
+            }
+
+            if(code != null){
+                fault.setFaultCode(code.getValue());
+                fillFaultSubCodes(fault, code.getSubcode());
+            }
+
             if(detail != null && detail.getDetail(0) != null){
                 javax.xml.soap.Detail detail = fault.addDetail();
                 for(Node obj: this.detail.getDetails()){
@@ -172,8 +206,6 @@
                     detail.appendChild(n);
                 }
             }
-            if(code != null)
-                fillFaultSubCodes(fault, code.getSubcode());
 
             return new SOAPFaultException(fault);
         } catch (SOAPException e) {
--- old/src/share/classes/com/sun/xml/internal/ws/fault/SOAPFaultBuilder.java	Tue Aug  4 10:01:55 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/fault/SOAPFaultBuilder.java	Tue Aug  4 10:01:55 2009
@@ -37,6 +37,7 @@
 import com.sun.xml.internal.ws.encoding.soap.SOAPConstants;
 import com.sun.xml.internal.ws.encoding.soap.SerializationException;
 import com.sun.xml.internal.ws.message.jaxb.JAXBMessage;
+import com.sun.xml.internal.ws.message.FaultMessage;
 import com.sun.xml.internal.ws.model.CheckedExceptionImpl;
 import com.sun.xml.internal.ws.model.JavaMethodImpl;
 import com.sun.xml.internal.ws.util.DOMUtil;
@@ -49,6 +50,8 @@
 import javax.xml.bind.JAXBException;
 import javax.xml.namespace.QName;
 import javax.xml.soap.SOAPFault;
+import javax.xml.soap.Detail;
+import javax.xml.soap.DetailEntry;
 import javax.xml.transform.dom.DOMResult;
 import javax.xml.ws.ProtocolException;
 import javax.xml.ws.WebServiceException;
@@ -77,6 +80,17 @@
 
     abstract void setDetail(DetailType detailType);
 
+    public @Nullable QName getFirstDetailEntryName() {
+        DetailType dt = getDetail();
+        if (dt != null) {
+            Node entry = dt.getDetail(0);
+            if (entry != null) {
+                return new QName(entry.getNamespaceURI(), entry.getLocalName());
+            }
+        }
+        return null;
+    }
+
     /**
      * gives the fault string that can be used to create an {@link Exception}
      */
@@ -267,17 +281,18 @@
 
     private Exception createUserDefinedException(CheckedExceptionImpl ce) {
         Class exceptionClass = ce.getExceptionClass();
-        try {
-            Constructor constructor = exceptionClass.getConstructor(String.class);
-            Object exception = constructor.newInstance(getFaultString());
-            Node detail = getDetail().getDetails().get(0);
-            Object jaxbDetail = getJAXBObject(detail, ce);
-            Field[] fields = jaxbDetail.getClass().getFields();
-            for (Field f : fields) {
-                Method m = exceptionClass.getMethod(getWriteMethod(f));
-                m.invoke(exception, f.get(jaxbDetail));
+        Class detailBean = ce.getDetailBean();
+        try{
+            Node detailNode = getDetail().getDetails().get(0);
+            Object jaxbDetail = getJAXBObject(detailNode, ce);
+            Constructor exConstructor;
+            try{
+                exConstructor = exceptionClass.getConstructor(String.class, detailBean);
+                return (Exception) exConstructor.newInstance(getFaultString(), jaxbDetail);
+            }catch(NoSuchMethodException e){
+                exConstructor = exceptionClass.getConstructor(String.class);
+                return (Exception) exConstructor.newInstance(getFaultString());
             }
-            throw (Exception) exception;
         } catch (Exception e) {
             throw new WebServiceException(e);
         }
@@ -308,8 +323,14 @@
             Object detail = detailBean.newInstance();
             for (Field f : fields) {
                 Method em = exception.getClass().getMethod(getReadMethod(f));
-                Method sm = detailBean.getMethod(getWriteMethod(f), em.getReturnType());
-                sm.invoke(detail, em.invoke(exception));
+                try {
+                    Method sm = detailBean.getMethod(getWriteMethod(f), em.getReturnType());
+                    sm.invoke(detail, em.invoke(exception));
+                } catch(NoSuchMethodException ne) {
+                    // Try to use exception bean's public field to populate the value.
+                    Field sf = detailBean.getField(f.getName());
+                    sf.set(detail, em.invoke(exception));
+                }
             }
             return detail;
         } catch (Exception e) {
@@ -353,13 +374,16 @@
             }
         }
         Element detailNode = null;
+        QName firstEntry = null;
         if (detail == null && soapFaultException != null) {
             detailNode = soapFaultException.getFault().getDetail();
+            firstEntry = getFirstDetailEntryName((Detail)detailNode);
         } else if(ce != null){
             try {
                 DOMResult dr = new DOMResult();
                 ce.getBridge().marshal(detail,dr);
                 detailNode = (Element)dr.getNode().getFirstChild();
+                firstEntry = getFirstDetailEntryName(detailNode);
             } catch (JAXBException e1) {
                 //Should we throw Internal Server Error???
                 faultString = e.getMessage();
@@ -369,9 +393,25 @@
         SOAP11Fault soap11Fault = new SOAP11Fault(faultCode, faultString, faultActor, detailNode);
         soap11Fault.captureStackTrace(e);
 
-        return JAXBMessage.create(JAXB_CONTEXT, soap11Fault, soapVersion);
+        Message msg = JAXBMessage.create(JAXB_CONTEXT, soap11Fault, soapVersion);
+        return new FaultMessage(msg, firstEntry);
     }
 
+    private static @Nullable QName getFirstDetailEntryName(@Nullable Detail detail) {
+        if (detail != null) {
+            Iterator<DetailEntry> it = detail.getDetailEntries();
+            if (it.hasNext()) {
+                DetailEntry entry = it.next();
+                return getFirstDetailEntryName(entry);
+            }
+        }
+        return null;
+    }
+
+    private static @NotNull QName getFirstDetailEntryName(@NotNull Element entry) {
+        return new QName(entry.getNamespaceURI(), entry.getLocalName());
+    }
+
     private static Message createSOAP12Fault(SOAPVersion soapVersion, Throwable e, Object detail, CheckedExceptionImpl ce, QName faultCode) {
         SOAPFaultException soapFaultException = null;
         CodeType code = null;
@@ -424,13 +464,16 @@
 
         ReasonType reason = new ReasonType(faultString);
         Element detailNode = null;
+        QName firstEntry = null;
         if (detail == null && soapFaultException != null) {
             detailNode = soapFaultException.getFault().getDetail();
+            firstEntry = getFirstDetailEntryName((Detail)detailNode);
         } else if(detail != null){
             try {
                 DOMResult dr = new DOMResult();
                 ce.getBridge().marshal(detail, dr);
                 detailNode = (Element)dr.getNode().getFirstChild();
+                firstEntry = getFirstDetailEntryName(detailNode);
             } catch (JAXBException e1) {
                 //Should we throw Internal Server Error???
                 faultString = e.getMessage();
@@ -437,13 +480,12 @@
                 faultCode = getDefaultFaultCode(soapVersion);
             }
         }
-        DetailType detailType = null;
-        if(detailNode != null)
-            detailType = new DetailType(detailNode);
-        SOAP12Fault soap12Fault = new SOAP12Fault(code, reason, null, faultRole, detailType);
+
+        SOAP12Fault soap12Fault = new SOAP12Fault(code, reason, null, faultRole, detailNode);
         soap12Fault.captureStackTrace(e);
 
-        return JAXBMessage.create(JAXB_CONTEXT, soap12Fault, soapVersion);
+        Message msg = JAXBMessage.create(JAXB_CONTEXT, soap12Fault, soapVersion);
+        return new FaultMessage(msg, firstEntry);
     }
 
     private static SubcodeType fillSubcodes(SubcodeType parent, QName value){
--- old/src/share/classes/com/sun/xml/internal/ws/handler/ClientLogicalHandlerTube.java	Tue Aug  4 10:01:58 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/handler/ClientLogicalHandlerTube.java	Tue Aug  4 10:01:57 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 package com.sun.xml.internal.ws.handler;
 
 import com.sun.xml.internal.ws.api.WSBinding;
@@ -36,6 +35,7 @@
 
 import javax.xml.ws.handler.LogicalHandler;
 import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.Handler;
 import javax.xml.ws.WebServiceException;
 import java.util.List;
 import java.util.ArrayList;
@@ -47,7 +47,6 @@
 public class ClientLogicalHandlerTube extends HandlerTube {
 
     private WSBinding binding;
-    private List<LogicalHandler> logicalHandlers;
 
     /**
      * Creates a new instance of LogicalHandlerTube
@@ -78,57 +77,13 @@
         this.binding = that.binding;
     }
 
-    boolean isHandlerChainEmpty() {
-        return logicalHandlers.isEmpty();
+    //should be overridden by DriverHandlerTubes
+    @Override
+    protected void initiateClosing(MessageContext mc) {
+      close(mc);
+      super.initiateClosing(mc);
     }
 
-    /**
-     * Close SOAPHandlers first and then LogicalHandlers on Client
-     * Close LogicalHandlers first and then SOAPHandlers on Server
-     */
-    public void close(MessageContext msgContext) {
-        //assuming cousinTube is called if requestProcessingSucessful is true
-        if (requestProcessingSucessful) {
-            //cousinTube is null in XML/HTTP Binding
-            if (cousinTube != null) {
-                // Close SOAPHandlerTube
-                cousinTube.closeCall(msgContext);
-            }
-        }
-        if (processor != null)
-            closeLogicalHandlers(msgContext);
-
-    }
-
-    /**
-     * This is called from cousinTube.
-     * Close this Tubes's handlers.
-     */
-    public void closeCall(MessageContext msgContext) {
-        closeLogicalHandlers(msgContext);
-    }
-
-    //TODO:
-    private void closeLogicalHandlers(MessageContext msgContext) {
-        if (processor == null)
-            return;
-        if (remedyActionTaken) {
-            //Close only invoked handlers in the chain
-
-            //CLIENT-SIDE
-            processor.closeHandlers(msgContext, processor.getIndex(), 0);
-            processor.setIndex(-1);
-            //reset remedyActionTaken
-            remedyActionTaken = false;
-        } else {
-            //Close all handlers in the chain
-
-            //CLIENT-SIDE
-            processor.closeHandlers(msgContext, logicalHandlers.size() - 1, 0);
-
-        }
-    }
-
     public AbstractFilterTubeImpl copy(TubeCloner cloner) {
         return new ClientLogicalHandlerTube(this, cloner);
     }
@@ -136,16 +91,16 @@
     void setUpProcessor() {
         // Take a snapshot, User may change chain after invocation, Same chain
         // should be used for the entire MEP
-        logicalHandlers = new ArrayList<LogicalHandler>();
+        handlers = new ArrayList<Handler>();
         List<LogicalHandler> logicalSnapShot= ((BindingImpl) binding).getHandlerConfig().getLogicalHandlers();
         if (!logicalSnapShot.isEmpty()) {
-            logicalHandlers.addAll(logicalSnapShot);
+            handlers.addAll(logicalSnapShot);
             if (binding.getSOAPVersion() == null) {
                 processor = new XMLHandlerProcessor(this, binding,
-                        logicalHandlers);
+                        handlers);
             } else {
                 processor = new SOAPHandlerProcessor(true, this, binding,
-                        logicalHandlers);
+                        handlers);
             }
         }
     }
@@ -193,4 +148,8 @@
 
         }
     }
+    void closeHandlers(MessageContext mc) {
+        closeClientsideHandlers(mc);
+
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/handler/ClientSOAPHandlerTube.java	Tue Aug  4 10:02:00 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/handler/ClientSOAPHandlerTube.java	Tue Aug  4 10:01:59 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 package com.sun.xml.internal.ws.handler;
 
 import com.sun.xml.internal.ws.api.WSBinding;
@@ -40,6 +39,7 @@
 
 import javax.xml.ws.handler.soap.SOAPHandler;
 import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.Handler;
 import javax.xml.ws.WebServiceException;
 import javax.activation.DataHandler;
 import java.util.*;
@@ -51,7 +51,6 @@
 public class ClientSOAPHandlerTube extends HandlerTube {
 
     private WSBinding binding;
-    private List<SOAPHandler> soapHandlers;
     private Set<String> roles;
 
     /**
@@ -87,47 +86,7 @@
         this.binding = that.binding;
     }
 
-    boolean isHandlerChainEmpty() {
-        return soapHandlers.isEmpty();
-    }
-
-    /**
-     * Close SOAPHandlers first and then LogicalHandlers on Client
-     * Close LogicalHandlers first and then SOAPHandlers on Server
-     */
-    public void close(MessageContext msgContext) {
-
-    }
-
-    /**
-     * This is called from cousinTube.
-     * Close this Tube's handlers.
-     */
-    public void closeCall(MessageContext msgContext) {
-        closeSOAPHandlers(msgContext);
-    }
-
-    //TODO:
-    private void closeSOAPHandlers(MessageContext msgContext) {
-        if (processor == null)
-            return;
-        if (remedyActionTaken) {
-            //Close only invoked handlers in the chain
-
-            //CLIENT-SIDE
-            processor.closeHandlers(msgContext, processor.getIndex(), 0);
-            processor.setIndex(-1);
-            //reset remedyActionTaken
-            remedyActionTaken = false;
-        } else {
-            //Close all handlers in the chain
-
-            //CLIENT-SIDE
-            processor.closeHandlers(msgContext, soapHandlers.size() - 1, 0);
-        }
-    }
-
-    public AbstractFilterTubeImpl copy(TubeCloner cloner) {
+   public AbstractFilterTubeImpl copy(TubeCloner cloner) {
         return new ClientSOAPHandlerTube(this, cloner);
     }
 
@@ -134,20 +93,19 @@
     void setUpProcessor() {
         // Take a snapshot, User may change chain after invocation, Same chain
         // should be used for the entire MEP
-        soapHandlers = new ArrayList<SOAPHandler>();
+        handlers = new ArrayList<Handler>();
         HandlerConfiguration handlerConfig = ((BindingImpl) binding).getHandlerConfig();
         List<SOAPHandler> soapSnapShot= handlerConfig.getSoapHandlers();
         if (!soapSnapShot.isEmpty()) {
-            soapHandlers.addAll(soapSnapShot);
+            handlers.addAll(soapSnapShot);
             roles = new HashSet<String>();
             roles.addAll(handlerConfig.getRoles());
-            processor = new SOAPHandlerProcessor(true, this, binding, soapHandlers);
+            processor = new SOAPHandlerProcessor(true, this, binding, handlers);
         }
     }
 
     MessageUpdatableContext getContext(Packet packet) {
-        SOAPMessageContextImpl context = new SOAPMessageContextImpl(binding, packet);
-        context.setRoles(roles);
+        SOAPMessageContextImpl context = new SOAPMessageContextImpl(binding, packet,roles);
         return context;
     }
 
@@ -158,8 +116,10 @@
         Map<String, DataHandler> atts = (Map<String, DataHandler>) context.get(MessageContext.OUTBOUND_MESSAGE_ATTACHMENTS);
         AttachmentSet attSet = packet.getMessage().getAttachments();
         for(String cid : atts.keySet()){
-            Attachment att = new DataHandlerAttachment(cid, atts.get(cid));
-            attSet.add(att);
+            if (attSet.get(cid) == null) {  // Otherwise we would be adding attachments twice
+                Attachment att = new DataHandlerAttachment(cid, atts.get(cid));
+                attSet.add(att);
+            }
         }
 
         try {
@@ -194,4 +154,9 @@
             throw new WebServiceException(re);
         }
     }
+
+    void closeHandlers(MessageContext mc) {
+        closeClientsideHandlers(mc);
+
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/handler/HandlerTube.java	Tue Aug  4 10:02:02 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/handler/HandlerTube.java	Tue Aug  4 10:02:02 2009
@@ -32,6 +32,8 @@
 import com.sun.xml.internal.ws.api.pipe.helper.AbstractFilterTubeImpl;
 
 import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.Handler;
+import java.util.List;
 
 /**
  * @author WS Development team
@@ -38,14 +40,14 @@
  */
 
 public abstract class HandlerTube extends AbstractFilterTubeImpl {
-
     /**
      * handle hold reference to other Tube for inter-tube communication
      */
     HandlerTube cousinTube;
+    protected List<Handler> handlers;
     HandlerProcessor processor;
     boolean remedyActionTaken = false;
-    private final @Nullable WSDLPort port;
+    protected final @Nullable WSDLPort port;
     // flag used to decide whether to call close on cousinTube
     boolean requestProcessingSucessful = false;
 
@@ -123,7 +125,7 @@
                 throw re;
         } finally {
             if(!requestProcessingSucessful) {
-                cleanUpState(context.getMessageContext());
+                initiateClosing(context.getMessageContext());
             }
         }
 
@@ -147,7 +149,7 @@
                 callHandlersOnResponse(context, isFault);
             }
         } finally {
-            cleanUpState(context.getMessageContext());
+            initiateClosing(context.getMessageContext());
         }
         //Update Packet with user modifications
         context.updatePacket();
@@ -162,7 +164,7 @@
             return doThrow(t);
         } finally {
             MessageUpdatableContext context = getContext(packet);
-            cleanUpState(context.getMessageContext());
+            initiateClosing(context.getMessageContext());
             /* TODO revisit: commented this out as the modified packet is no longer used
                     In future if the message is propagated even when an exception
                     occurs, then uncomment context.updatePacket();
@@ -175,18 +177,100 @@
     }
 
     /**
+     * Must be overridden by HandlerTube that drives other handler tubes for processing a message.
+     * On Client-side: ClientLogicalHandlerTube drives the Handler Processing.
+     * On Server-side: In case SOAP Binding, ServerMessageHandlerTube drives the Handler Processing.
+     *                 In case XML/HTTP Binding, ServerLogicalHandlerTube drives the Handler Processing.
+     *
+     *
+     * If its a top HandlerTube, should override by calling #close(MessaggeContext);
+     *
+     */
+
+    protected void initiateClosing(MessageContext mc) {
+        // Do nothing
+
+    }
+
+    /**
      * Calls close on previously invoked handlers.
      * Also, Cleans up any state left over in the Tube instance from the current
      * invocation, as Tube instances can be reused after the completion of MEP.
      *
+     * On Client, SOAPHandlers are closed first and then LogicalHandlers
+     * On Server, LogicalHandlers are closed first and then SOAPHandlers
      */
-    private void cleanUpState(MessageContext mc) {
-        close(mc);
+    final public void close(MessageContext msgContext) {
+        //assuming cousinTube is called if requestProcessingSucessful is true
+        if (requestProcessingSucessful) {
+            if (cousinTube != null) {
+                cousinTube.close(msgContext);
+            }
+
+        }
+        if (processor != null)
+            closeHandlers(msgContext);
+
         // Clean up the exchange for next invocation.
         exchange = null;
         requestProcessingSucessful = false;
+
     }
 
+    /**
+     * On Client, Override by calling #closeClientHandlers(MessageContext mc)
+     * On Server, Override by calling #closeServerHandlers(MessageContext mc)
+     *      The difference is the order in which they are closed.
+     * @param mc
+     */
+    abstract void closeHandlers(MessageContext mc);
+
+    /**
+     * Called by close(MessageContext mc) in a Client Handlertube
+     */
+    protected void closeClientsideHandlers(MessageContext msgContext) {
+         if (processor == null)
+            return;
+        if (remedyActionTaken) {
+            //Close only invoked handlers in the chain
+
+            //CLIENT-SIDE
+            processor.closeHandlers(msgContext, processor.getIndex(), 0);
+            processor.setIndex(-1);
+            //reset remedyActionTaken
+            remedyActionTaken = false;
+        } else {
+            //Close all handlers in the chain
+
+            //CLIENT-SIDE
+            processor.closeHandlers(msgContext, handlers.size() - 1, 0);
+
+        }
+    }
+
+    /**
+     * Called by close(MessageContext mc) in a Server Handlertube
+     */
+    protected void closeServersideHandlers(MessageContext msgContext) {
+        if (processor == null)
+            return;
+        if (remedyActionTaken) {
+            //Close only invoked handlers in the chain
+
+            //SERVER-SIDE
+            processor.closeHandlers(msgContext, processor.getIndex(), handlers.size() - 1);
+            processor.setIndex(-1);
+            //reset remedyActionTaken
+            remedyActionTaken = false;
+        } else {
+            //Close all handlers in the chain
+
+            //SERVER-SIDE
+            processor.closeHandlers(msgContext, 0, handlers.size() - 1);
+
+        }
+    }
+
     abstract void callHandlersOnResponse(MessageUpdatableContext context, boolean handleFault);
 
     abstract boolean callHandlersOnRequest(MessageUpdatableContext context, boolean oneWay);
@@ -200,26 +284,16 @@
               otherwise use this value as an approximation, since this carries
               the appliation's intention --- whether it was invokeOneway vs invoke,etc.
              */
-            return (packet.expectReply != null && packet.expectReply);
+            return !(packet.expectReply != null && packet.expectReply);
         }
     }
 
     abstract void setUpProcessor();
-    abstract boolean isHandlerChainEmpty();
+    final public boolean isHandlerChainEmpty() {
+        return handlers.isEmpty();
+    }
     abstract MessageUpdatableContext getContext(Packet p);
 
-    /**
-     * Close SOAPHandlers first and then LogicalHandlers on Client
-     * Close LogicalHandlers first and then SOAPHandlers on Server
-     */
-    protected abstract void close(MessageContext msgContext);
-
-    /**
-     * This is called from cousinTube.
-     * Close this Tube's handlers.
-     */
-    protected abstract void closeCall(MessageContext msgContext);
-
     private boolean isHandleFault(Packet packet) {
         if (cousinTube != null) {
             return exchange.isHandleFault();
@@ -248,6 +322,11 @@
             if(cousinTube != null) {
                 cousinTube.exchange = exchange;
             }
+        } else {
+            if(cousinTube != null) {
+                cousinTube.exchange = exchange;
+            }
+
         }
     }
     private HandlerTubeExchange exchange;
--- old/src/share/classes/com/sun/xml/internal/ws/handler/SOAPMessageContextImpl.java	Tue Aug  4 10:02:04 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/handler/SOAPMessageContextImpl.java	Tue Aug  4 10:02:04 2009
@@ -56,9 +56,10 @@
     private SOAPMessage soapMsg = null;
     private WSBinding binding;
 
-    public SOAPMessageContextImpl(WSBinding binding, Packet packet) {
+    public SOAPMessageContextImpl(WSBinding binding, Packet packet,Set<String> roles) {
         super(packet);
         this.binding = binding;
+        this.roles = roles;
     }
 
     public SOAPMessage getMessage() {
@@ -125,8 +126,4 @@
     public Set<String> getRoles() {
         return roles;
     }
-
-    void setRoles(Set<String> roles) {
-        this.roles = roles;
-    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/handler/ServerLogicalHandlerTube.java	Tue Aug  4 10:02:06 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/handler/ServerLogicalHandlerTube.java	Tue Aug  4 10:02:06 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 package com.sun.xml.internal.ws.handler;
 
 import com.sun.xml.internal.ws.api.WSBinding;
@@ -39,6 +38,7 @@
 
 import javax.xml.ws.handler.LogicalHandler;
 import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.Handler;
 import javax.xml.ws.WebServiceException;
 import javax.activation.DataHandler;
 import java.util.List;
@@ -52,7 +52,6 @@
 public class ServerLogicalHandlerTube extends HandlerTube {
 
     private WSBinding binding;
-    private List<LogicalHandler> logicalHandlers;
 
     /**
      * Creates a new instance of LogicalHandlerTube
@@ -60,7 +59,7 @@
     public ServerLogicalHandlerTube(WSBinding binding, WSDLPort port, Tube next) {
         super(next, port);
         this.binding = binding;
-        setUpProcessorOnce();
+        setUpHandlersOnce();
     }
 
     /**
@@ -73,7 +72,7 @@
     public ServerLogicalHandlerTube(WSBinding binding, Tube next, HandlerTube cousinTube) {
         super(next, cousinTube);
         this.binding = binding;
-        setUpProcessorOnce();
+        setUpHandlersOnce();
     }
 
     /**
@@ -83,78 +82,43 @@
     private ServerLogicalHandlerTube(ServerLogicalHandlerTube that, TubeCloner cloner) {
         super(that, cloner);
         this.binding = that.binding;
-        setUpProcessorOnce();
+        this.handlers = that.handlers;
     }
 
-    boolean isHandlerChainEmpty() {
-        return logicalHandlers.isEmpty();
-    }
-
-    /**
-     * Close SOAPHandlers first and then LogicalHandlers on Client
-     * Close LogicalHandlers first and then SOAPHandlers on Server
-     */
-    public void close(MessageContext msgContext) {
-
-        if (binding.getSOAPVersion() != null) {
-            //SOAPHandlerTube will drive the closing of LogicalHandlerTube
+    //should be overridden by DriverHandlerTubes
+    @Override
+    protected void initiateClosing(MessageContext mc) {
+         if (binding.getSOAPVersion() != null) {
+            super.initiateClosing(mc);
         } else {
-            if (processor != null)
-                closeLogicalHandlers(msgContext);
+            close(mc);
+            super.initiateClosing(mc);
         }
-
     }
 
-    /**
-     * This is called from cousinTube.
-     * Close this Tube's handlers.
-     */
-    public void closeCall(MessageContext msgContext) {
-        closeLogicalHandlers(msgContext);
-    }
-
-    //TODO:
-    private void closeLogicalHandlers(MessageContext msgContext) {
-        if (processor == null)
-            return;
-        if (remedyActionTaken) {
-            //Close only invoked handlers in the chain
-            //SERVER-SIDE
-            processor.closeHandlers(msgContext, processor.getIndex(), logicalHandlers.size() - 1);
-            processor.setIndex(-1);
-            //reset remedyActionTaken
-            remedyActionTaken = false;
-        } else {
-            //Close all handlers in the chain
-            //SERVER-SIDE
-            processor.closeHandlers(msgContext, 0, logicalHandlers.size() - 1);
-
-        }
-    }
-
-    public AbstractFilterTubeImpl copy(TubeCloner cloner) {
+   public AbstractFilterTubeImpl copy(TubeCloner cloner) {
         return new ServerLogicalHandlerTube(this, cloner);
     }
 
-    private void setUpProcessorOnce() {
-        logicalHandlers = new ArrayList<LogicalHandler>();
+    private void setUpHandlersOnce() {
+        handlers = new ArrayList<Handler>();
         List<LogicalHandler> logicalSnapShot= ((BindingImpl) binding).getHandlerConfig().getLogicalHandlers();
         if (!logicalSnapShot.isEmpty()) {
-            logicalHandlers.addAll(logicalSnapShot);
+            handlers.addAll(logicalSnapShot);
+        }
+    }
+
+    void setUpProcessor() {
+        if (!handlers.isEmpty()) {
             if (binding.getSOAPVersion() == null) {
                 processor = new XMLHandlerProcessor(this, binding,
-                        logicalHandlers);
+                        handlers);
             } else {
-                processor = new SOAPHandlerProcessor(false, this, binding,
-                        logicalHandlers);
+                processor = new SOAPHandlerProcessor(false, this, binding, handlers);
             }
         }
     }
 
-    void setUpProcessor() {
-     // Do nothing, Processor is setup in the constructor.
-    }
-
     MessageUpdatableContext getContext(Packet packet) {
         return new LogicalMessageContextImpl(binding, packet);
     }
@@ -196,4 +160,9 @@
             throw re;
         }
     }
+
+    void closeHandlers(MessageContext mc) {
+        closeServersideHandlers(mc);
+
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/handler/ServerSOAPHandlerTube.java	Tue Aug  4 10:02:09 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/handler/ServerSOAPHandlerTube.java	Tue Aug  4 10:02:08 2009
@@ -23,7 +23,6 @@
  * have any questions.
  */
 
-
 package com.sun.xml.internal.ws.handler;
 
 import com.sun.xml.internal.ws.api.WSBinding;
@@ -40,6 +39,7 @@
 
 import javax.xml.ws.handler.soap.SOAPHandler;
 import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.Handler;
 import javax.xml.ws.WebServiceException;
 import javax.activation.DataHandler;
 import java.util.*;
@@ -51,7 +51,6 @@
 public class ServerSOAPHandlerTube extends HandlerTube {
 
     private WSBinding binding;
-    private List<SOAPHandler> soapHandlers;
     private Set<String> roles;
 
     /**
@@ -64,7 +63,7 @@
             // TODO: throw Exception
         }
         this.binding = binding;
-        setUpProcessorOnce();
+        setUpHandlersOnce();
     }
 
     // Handle to LogicalHandlerTube means its used on SERVER-SIDE
@@ -78,7 +77,7 @@
     public ServerSOAPHandlerTube(WSBinding binding, Tube next, HandlerTube cousinTube) {
         super(next, cousinTube);
         this.binding = binding;
-        setUpProcessorOnce();
+        setUpHandlersOnce();
     }
 
     /**
@@ -87,79 +86,32 @@
     private ServerSOAPHandlerTube(ServerSOAPHandlerTube that, TubeCloner cloner) {
         super(that, cloner);
         this.binding = that.binding;
-        setUpProcessorOnce();
+        this.handlers = that.handlers;
+        this.roles = that.roles;
     }
 
-    boolean isHandlerChainEmpty() {
-        return soapHandlers.isEmpty();
-    }
 
-    /**
-     * Close SOAPHandlers first and then LogicalHandlers on Client
-     * Close LogicalHandlers first and then SOAPHandlers on Server
-     */
-    public void close(MessageContext msgContext) {
-        //assuming cousinTube is called if requestProcessingSucessful is true
-        if (requestProcessingSucessful) {
-            if (cousinTube != null) {
-                // Close LogicalHandlerTube
-                cousinTube.closeCall(msgContext);
-            }
-        }
-        if (processor != null)
-            closeSOAPHandlers(msgContext);
-
-    }
-
-    /**
-     * This is called from cousinTube.
-     * Close this Tube's handlers.
-     */
-    public void closeCall(MessageContext msgContext) {
-        closeSOAPHandlers(msgContext);
-    }
-
-    //TODO:
-    private void closeSOAPHandlers(MessageContext msgContext) {
-        if (processor == null)
-            return;
-        if (remedyActionTaken) {
-            //Close only invoked handlers in the chain
-            //SERVER-SIDE
-            processor.closeHandlers(msgContext, processor.getIndex(), soapHandlers.size() - 1);
-            processor.setIndex(-1);
-            //reset remedyActionTaken
-            remedyActionTaken = false;
-        } else {
-            //Close all handlers in the chain
-            //SERVER-SIDE
-            processor.closeHandlers(msgContext, 0, soapHandlers.size() - 1);
-
-        }
-    }
-
     public AbstractFilterTubeImpl copy(TubeCloner cloner) {
         return new ServerSOAPHandlerTube(this, cloner);
     }
 
-    private void setUpProcessorOnce() {
-        soapHandlers = new ArrayList<SOAPHandler>();
+    private void setUpHandlersOnce() {
+        handlers = new ArrayList<Handler>();
         HandlerConfiguration handlerConfig = ((BindingImpl) binding).getHandlerConfig();
         List<SOAPHandler> soapSnapShot= handlerConfig.getSoapHandlers();
         if (!soapSnapShot.isEmpty()) {
-            soapHandlers.addAll(soapSnapShot);
+            handlers.addAll(soapSnapShot);
             roles = new HashSet<String>();
             roles.addAll(handlerConfig.getRoles());
-            processor = new SOAPHandlerProcessor(false, this, binding, soapHandlers);
         }
     }
 
     void setUpProcessor() {
-        // Do nothing, Processor is setup in the constructor.
+        if(!handlers.isEmpty())
+            processor = new SOAPHandlerProcessor(false, this, binding, handlers);
     }
     MessageUpdatableContext getContext(Packet packet) {
-        SOAPMessageContextImpl context = new SOAPMessageContextImpl(binding, packet);
-        context.setRoles(roles);
+        SOAPMessageContextImpl context = new SOAPMessageContextImpl(binding, packet,roles);
         return context;
     }
 
@@ -187,8 +139,10 @@
         Map<String, DataHandler> atts = (Map<String, DataHandler>) context.get(MessageContext.OUTBOUND_MESSAGE_ATTACHMENTS);
         AttachmentSet attSet = packet.getMessage().getAttachments();
         for(String cid : atts.keySet()){
-            Attachment att = new DataHandlerAttachment(cid, atts.get(cid));
-            attSet.add(att);
+            if (attSet.get(cid) == null) { // Otherwise we would be adding attachments twice
+                Attachment att = new DataHandlerAttachment(cid, atts.get(cid));
+                attSet.add(att);
+            }
         }
 
         try {
@@ -203,4 +157,9 @@
 
         }
     }
+
+    void closeHandlers(MessageContext mc) {
+        closeServersideHandlers(mc);
+
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/message/AttachmentUnmarshallerImpl.java	Tue Aug  4 10:02:11 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/AttachmentUnmarshallerImpl.java	Tue Aug  4 10:02:10 2009
@@ -74,9 +74,4 @@
         return cid;
     }
 
-    // TODO fix the hack
-    // So that SAAJ registers DCHs for MIME types
-    static {
-        new com.sun.xml.internal.messaging.saaj.soap.AttachmentPartImpl();
-    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/message/ByteArrayAttachment.java	Tue Aug  4 10:02:13 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/ByteArrayAttachment.java	Tue Aug  4 10:02:13 2009
@@ -28,6 +28,8 @@
 import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.ws.api.message.Attachment;
 import com.sun.xml.internal.ws.util.ByteArrayDataSource;
+import com.sun.xml.internal.ws.encoding.DataSourceStreamingDataHandler;
+
 import java.io.ByteArrayInputStream;
 
 import javax.activation.DataHandler;
@@ -36,8 +38,6 @@
 import javax.xml.soap.SOAPMessage;
 import javax.xml.transform.Source;
 import javax.xml.transform.stream.StreamSource;
-import javax.xml.ws.WebServiceException;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -85,7 +85,7 @@
     }
 
     public DataHandler asDataHandler() {
-        return new DataHandler(new ByteArrayDataSource(data,start,len,getContentType()));
+        return new DataSourceStreamingDataHandler(new ByteArrayDataSource(data,start,len,getContentType()));
     }
 
     public Source asSource() {
--- old/src/share/classes/com/sun/xml/internal/ws/message/DOMHeader.java	Tue Aug  4 10:02:16 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/DOMHeader.java	Tue Aug  4 10:02:16 2009
@@ -26,9 +26,7 @@
 package com.sun.xml.internal.ws.message;
 
 import com.sun.xml.internal.bind.api.Bridge;
-import com.sun.xml.internal.bind.api.BridgeContext;
 import com.sun.xml.internal.bind.unmarshaller.DOMScanner;
-import com.sun.xml.internal.messaging.saaj.packaging.mime.Header;
 import com.sun.xml.internal.ws.streaming.DOMStreamReader;
 import com.sun.xml.internal.ws.util.DOMUtil;
 import org.w3c.dom.Element;
@@ -47,7 +45,7 @@
 import javax.xml.stream.XMLStreamWriter;
 
 /**
- * {@link Header} implementation for a DOM.
+ * {@link com.sun.xml.internal.ws.api.message.Header} implementation for a DOM.
  *
  * @author Kohsuke Kawaguchi
  */
--- old/src/share/classes/com/sun/xml/internal/ws/message/DataHandlerAttachment.java	Tue Aug  4 10:02:19 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/DataHandlerAttachment.java	Tue Aug  4 10:02:18 2009
@@ -45,11 +45,6 @@
  * @author Jitendra Kotamraju
  */
 public final class DataHandlerAttachment implements Attachment {
-    // TODO fix the hack
-    // So that SAAJ registers DCHs for MIME types
-    static {
-        new com.sun.xml.internal.messaging.saaj.soap.AttachmentPartImpl();
-    }
 
     private final DataHandler dh;
     private final String contentId;
@@ -101,7 +96,7 @@
     }
 
     public void writeTo(OutputStream os) throws IOException {
-        os.write(asByteArray());
+        dh.writeTo(os);
     }
 
     public void writeTo(SOAPMessage saaj) throws SOAPException {
--- old/src/share/classes/com/sun/xml/internal/ws/message/JAXBAttachment.java	Tue Aug  4 10:02:21 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/JAXBAttachment.java	Tue Aug  4 10:02:20 2009
@@ -27,11 +27,10 @@
 
 import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.bind.api.Bridge;
-import com.sun.xml.internal.messaging.saaj.util.ByteOutputStream;
 import com.sun.xml.internal.ws.api.message.Attachment;
 import com.sun.xml.internal.ws.util.ASCIIUtility;
-import com.sun.xml.internal.ws.util.ByteArrayDataSource;
-import java.io.ByteArrayInputStream;
+import com.sun.xml.internal.ws.util.ByteArrayBuffer;
+import com.sun.xml.internal.ws.encoding.DataSourceStreamingDataHandler;
 
 import javax.activation.DataHandler;
 import javax.activation.DataSource;
@@ -41,10 +40,10 @@
 import javax.xml.soap.SOAPMessage;
 import javax.xml.transform.Source;
 import javax.xml.transform.stream.StreamSource;
+import javax.xml.ws.WebServiceException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import javax.xml.ws.WebServiceException;
 
 /**
  * @author Jitendra Kotamraju
@@ -80,7 +79,7 @@
     }
 
     public DataHandler asDataHandler() {
-        return new DataHandler(this);
+        return new DataSourceStreamingDataHandler(this);
     }
 
     public Source asSource() {
@@ -88,13 +87,13 @@
     }
 
     public InputStream asInputStream() {
-        ByteOutputStream bos = new ByteOutputStream();
+        ByteArrayBuffer bab = new ByteArrayBuffer();
         try {
-            writeTo(bos);
+            writeTo(bab);
         } catch (IOException e) {
             throw new WebServiceException(e);
         }
-        return bos.newInputStream();
+        return bab.newInputStream();
     }
 
     public void writeTo(OutputStream os) throws IOException {
--- old/src/share/classes/com/sun/xml/internal/ws/message/MimeAttachmentSet.java	Tue Aug  4 10:02:23 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/MimeAttachmentSet.java	Tue Aug  4 10:02:23 2009
@@ -24,13 +24,11 @@
  */
 
 
-
 package com.sun.xml.internal.ws.message;
 
 import com.sun.xml.internal.ws.api.message.AttachmentSet;
 import com.sun.xml.internal.ws.api.message.Attachment;
 import com.sun.xml.internal.ws.encoding.MimeMultipartParser;
-import com.sun.xml.internal.ws.message.stream.StreamAttachment;
 import com.sun.xml.internal.ws.resources.EncodingMessages;
 import com.sun.istack.internal.Nullable;
 
@@ -99,8 +97,8 @@
          * Browse thru all the attachments in the mpp, add them to #atts,
          * then return whether its empty.
          */
-        Map<String, StreamAttachment> attachments = mpp.getAttachmentParts();
-        for(Map.Entry<String, StreamAttachment> att : attachments.entrySet()) {
+        Map<String, Attachment> attachments = mpp.getAttachmentParts();
+        for(Map.Entry<String, Attachment> att : attachments.entrySet()) {
             if(atts.get(att.getKey()) == null){
                 atts.put(att.getKey(), att.getValue());
             }
--- old/src/share/classes/com/sun/xml/internal/ws/message/jaxb/JAXBHeader.java	Tue Aug  4 10:02:25 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/jaxb/JAXBHeader.java	Tue Aug  4 10:02:25 2009
@@ -51,7 +51,6 @@
 import javax.xml.stream.XMLStreamReader;
 import javax.xml.stream.XMLStreamWriter;
 import java.io.OutputStream;
-import java.util.Map;
 
 /**
  * {@link Header} whose physical data representation is a JAXB bean.
@@ -151,9 +150,16 @@
     }
 
     public <T> T readAsJAXB(Unmarshaller unmarshaller) throws JAXBException {
-        JAXBResult r = new JAXBResult(unmarshaller);
-        bridge.marshal(jaxbObject,r);
-        return (T)r.getResult();
+        try {
+            JAXBResult r = new JAXBResult(unmarshaller);
+            // bridge marshals a fragment, so we need to add start/endDocument by ourselves
+            r.getHandler().startDocument();
+            bridge.marshal(jaxbObject,r);
+            r.getHandler().endDocument();
+            return (T)r.getResult();
+        } catch (SAXException e) {
+            throw new JAXBException(e);
+        }
     }
 
     public <T> T readAsJAXB(Bridge<T> bridge) throws JAXBException {
--- old/src/share/classes/com/sun/xml/internal/ws/message/jaxb/JAXBMessage.java	Tue Aug  4 10:02:27 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/jaxb/JAXBMessage.java	Tue Aug  4 10:02:27 2009
@@ -40,6 +40,8 @@
 import com.sun.xml.internal.ws.message.RootElementSniffer;
 import com.sun.xml.internal.ws.message.stream.StreamMessage;
 import com.sun.xml.internal.ws.streaming.XMLStreamWriterUtil;
+import com.sun.xml.internal.ws.streaming.XMLStreamReaderUtil;
+import com.sun.xml.internal.ws.streaming.MtomStreamWriter;
 import org.xml.sax.ContentHandler;
 import org.xml.sax.ErrorHandler;
 import org.xml.sax.SAXException;
@@ -48,6 +50,7 @@
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Marshaller;
 import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.attachment.AttachmentMarshaller;
 import javax.xml.bind.annotation.XmlRootElement;
 import javax.xml.bind.util.JAXBResult;
 import javax.xml.namespace.QName;
@@ -54,6 +57,7 @@
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 import javax.xml.stream.XMLStreamWriter;
+import static javax.xml.stream.XMLStreamConstants.START_DOCUMENT;
 import javax.xml.transform.Source;
 import javax.xml.ws.WebServiceException;
 import java.io.OutputStream;
@@ -265,7 +269,10 @@
                 bridge.marshal(jaxbObject,sbr);
                 infoset = sbr.getXMLStreamBuffer();
             }
-            return infoset.readAsXMLStreamReader();
+            XMLStreamReader reader = infoset.readAsXMLStreamReader();
+            if(reader.getEventType()== START_DOCUMENT)
+                XMLStreamReaderUtil.nextElementContent(reader);
+            return reader;
         } catch (JAXBException e) {
            // bug 6449684, spec 4.3.4
            throw new WebServiceException(e);
@@ -292,7 +299,11 @@
 
     public void writePayloadTo(XMLStreamWriter sw) throws XMLStreamException {
         try {
-            AttachmentMarshallerImpl am = new AttachmentMarshallerImpl(attachmentSet);
+            // MtomCodec sets its own AttachmentMarshaller
+            AttachmentMarshaller am = (sw instanceof MtomStreamWriter)
+                    ? ((MtomStreamWriter)sw).getAttachmentMarshaller()
+                    : new AttachmentMarshallerImpl(attachmentSet);
+
             // Get output stream and use JAXB UTF-8 writer
             OutputStream os = XMLStreamWriterUtil.getOutputStream(sw);
             if (os != null) {
@@ -300,7 +311,8 @@
             } else {
                 bridge.marshal(jaxbObject,sw,am);
             }
-            am.cleanup();
+            //cleanup() is not needed since JAXB doesn't keep ref to AttachmentMarshaller
+            //am.cleanup();
         } catch (JAXBException e) {
             // bug 6449684, spec 4.3.4
             throw new WebServiceException(e);
--- old/src/share/classes/com/sun/xml/internal/ws/message/jaxb/MarshallerBridge.java	Tue Aug  4 10:02:30 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/jaxb/MarshallerBridge.java	Tue Aug  4 10:02:29 2009
@@ -26,8 +26,8 @@
 package com.sun.xml.internal.ws.message.jaxb;
 
 import com.sun.xml.internal.bind.api.Bridge;
-import com.sun.xml.internal.bind.api.TypeReference;
 import com.sun.xml.internal.bind.api.JAXBRIContext;
+import com.sun.xml.internal.bind.api.TypeReference;
 import com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl;
 import com.sun.xml.internal.bind.v2.runtime.MarshallerImpl;
 import org.w3c.dom.Node;
@@ -66,7 +66,7 @@
     public void marshal(Marshaller m, Object object, OutputStream output, NamespaceContext nsContext) throws JAXBException {
         m.setProperty(Marshaller.JAXB_FRAGMENT,true);
         try {
-            m.marshal(object,output);
+            ((MarshallerImpl)m).marshal(object,output,nsContext);
         } finally {
             m.setProperty(Marshaller.JAXB_FRAGMENT,false);
         }
--- old/src/share/classes/com/sun/xml/internal/ws/message/saaj/SAAJMessage.java	Tue Aug  4 10:02:32 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/saaj/SAAJMessage.java	Tue Aug  4 10:02:31 2009
@@ -26,15 +26,15 @@
 
 import com.sun.istack.internal.NotNull;
 import com.sun.istack.internal.XMLStreamException2;
+import com.sun.istack.internal.Nullable;
+import com.sun.istack.internal.FragmentContentHandler;
 import com.sun.xml.internal.bind.api.Bridge;
 import com.sun.xml.internal.bind.unmarshaller.DOMScanner;
 import com.sun.xml.internal.ws.api.SOAPVersion;
-import com.sun.xml.internal.ws.api.message.Attachment;
-import com.sun.xml.internal.ws.api.message.AttachmentSet;
-import com.sun.xml.internal.ws.api.message.HeaderList;
-import com.sun.xml.internal.ws.api.message.Message;
-import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.message.*;
 import com.sun.xml.internal.ws.message.AttachmentUnmarshallerImpl;
+import com.sun.xml.internal.ws.message.AbstractMessageImpl;
+import com.sun.xml.internal.ws.message.AttachmentSetImpl;
 import com.sun.xml.internal.ws.streaming.DOMStreamReader;
 import com.sun.xml.internal.ws.util.DOMUtil;
 import org.w3c.dom.Element;
@@ -42,6 +42,8 @@
 import org.xml.sax.ContentHandler;
 import org.xml.sax.ErrorHandler;
 import org.xml.sax.SAXException;
+import org.xml.sax.helpers.AttributesImpl;
+import org.xml.sax.helpers.LocatorImpl;
 
 import javax.activation.DataHandler;
 import javax.xml.bind.JAXBException;
@@ -60,6 +62,7 @@
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.ws.WebServiceException;
+import javax.xml.ws.soap.SOAPFaultException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -72,207 +75,218 @@
  * {@link Message} implementation backed by {@link SOAPMessage}.
  *
  * @author Vivek Pandey
+ * @author Rama Pulavarthi
  */
 public class SAAJMessage extends Message {
+    // flag to switch between representations
+    private boolean parsedMessage;
+    // flag to check if Message API is exercised;
+    private boolean accessedMessage;
     private final SOAPMessage sm;
+
     private HeaderList headers;
-    private String payloadLocalName;
-    private String payloadNamspace;
     private List<Element> bodyParts;
     private Element payload;
 
-    private boolean parsedHeader;
+    private String payloadLocalName;
+    private String payloadNamespace;
+    private SOAPVersion soapVersion;
 
     public SAAJMessage(SOAPMessage sm) {
         this.sm = sm;
-
-        try {
-            Node body = sm.getSOAPBody();
-            //cature all the body elements
-            bodyParts = DOMUtil.getChildElements(body);
-
-            //we treat payload as the first body part
-            payload = bodyParts.size() > 0? bodyParts.get(0):null;
-            // hope this is correct. Caching the localname and namespace of the payload should be fine
-            // but what about if a Handler replaces the payload with something else? Weel, may be it
-            // will be error condition anyway
-            if (payload != null) {
-                payloadLocalName = payload.getLocalName();
-                payloadNamspace = payload.getNamespaceURI();
-            }
-        } catch (SOAPException e) {
-            throw new WebServiceException(e);
-        }
     }
 
     /**
      * This constructor is a convenience and called by the {@link #copy}
+     *
      * @param headers
      * @param sm
      */
     private SAAJMessage(HeaderList headers, AttachmentSet as, SOAPMessage sm) {
-        this(sm);
+        this.sm = sm;
+        this.parse();
+        if(headers == null)
+            headers = new HeaderList();
         this.headers = headers;
         this.attachmentSet = as;
     }
 
-    public boolean hasHeaders() {
-        return getHeaders().size() > 0;
+    private void parse() {
+        if (!parsedMessage) {
+            try {
+                access();
+                if (headers == null)
+                    headers = new HeaderList();
+                SOAPHeader header = sm.getSOAPHeader();
+                if (header != null) {
+                    Iterator iter = header.examineAllHeaderElements();
+                    while (iter.hasNext()) {
+                        headers.add(new SAAJHeader((SOAPHeaderElement) iter.next()));
+                    }
+                }
+                attachmentSet = new SAAJAttachmentSet(sm);
+
+                parsedMessage = true;
+            } catch (SOAPException e) {
+                throw new WebServiceException(e);
+            }
+        }
     }
 
-    /**
-     * Gets all the headers of this message.
-     *
-     * @return always return the same non-null object.
-     */
-    public HeaderList getHeaders() {
-        if (parsedHeader)
-            return headers;
-
-        if (headers == null)
-            headers = new HeaderList();
-
-        try {
-            SOAPHeader header = sm.getSOAPHeader();
-            if(header!=null) {
-                Iterator iter = header.examineAllHeaderElements();
-                while (iter.hasNext()) {
-                    headers.add(new SAAJHeader((SOAPHeaderElement) iter.next()));
+    private void access() {
+        if (!accessedMessage) {
+            try {
+                Node body = sm.getSOAPBody();
+                soapVersion = SOAPVersion.fromNsUri(body.getNamespaceURI());
+                //cature all the body elements
+                bodyParts = DOMUtil.getChildElements(body);
+                //we treat payload as the first body part
+                payload = bodyParts.size() > 0 ? bodyParts.get(0) : null;
+                // hope this is correct. Caching the localname and namespace of the payload should be fine
+                // but what about if a Handler replaces the payload with something else? Weel, may be it
+                // will be error condition anyway
+                if (payload != null) {
+                    payloadLocalName = payload.getLocalName();
+                    payloadNamespace = payload.getNamespaceURI();
                 }
+                accessedMessage = true;
+            } catch (SOAPException e) {
+                throw new WebServiceException(e);
             }
-            parsedHeader = true;
-        } catch (SOAPException e) {
-            e.printStackTrace();
         }
-        return headers;
     }
 
+    public boolean hasHeaders() {
+        parse();
+        return headers.size() > 0;
+    }
+
+    public @NotNull HeaderList getHeaders() {
+        parse();
+        return headers;
+    }
     /**
      * Gets the attachments of this message
      * (attachments live outside a message.)
      */
     @Override
-    @NotNull
-    public AttachmentSet getAttachments() {
-        if (attachmentSet == null)
-            attachmentSet = new SAAJAttachmentSet(sm);
+    public @NotNull AttachmentSet getAttachments() {
+        parse();
         return attachmentSet;
     }
 
+    /**
+     * Optimization hint for the derived class to check
+     * if we may have some attachments.
+     */
+    @Override
     protected boolean hasAttachments() {
-        return !getAttachments().isEmpty();
+        parse();
+        return attachmentSet!=null;
     }
 
-    /**
-     * Gets the local name of the payload element.
-     */
-    public String getPayloadLocalPart() {
+    public @Nullable String getPayloadLocalPart() {
+        access();
         return payloadLocalName;
     }
 
-    /**
-     * Gets the namespace URI of the payload element.
-     */
     public String getPayloadNamespaceURI() {
-        return payloadNamspace;
+        access();
+        return payloadNamespace;
     }
 
     public boolean hasPayload() {
-        return payloadNamspace!=null;
+        access();
+        return payloadNamespace != null;
     }
 
-    /**
-     * Consumes this message including the envelope.
-     * returns it as a {@link javax.xml.transform.Source} object.
-     */
     public Source readEnvelopeAsSource() {
         try {
-            SOAPEnvelope se = sm .getSOAPPart().getEnvelope();
-            return new DOMSource(se);
+            if (!parsedMessage) {
+                SOAPEnvelope se = sm.getSOAPPart().getEnvelope();
+                return new DOMSource(se);
+
+            } else {
+                SOAPMessage msg = soapVersion.saajMessageFactory.createMessage();
+                SOAPBody newBody = msg.getSOAPPart().getEnvelope().getBody();
+                for (Element part : bodyParts) {
+                    Node n = newBody.getOwnerDocument().importNode(part, true);
+                    newBody.appendChild(n);
+                }
+                for (Header header : headers) {
+                    header.writeTo(msg);
+                }
+                SOAPEnvelope se = msg.getSOAPPart().getEnvelope();
+                return new DOMSource(se);
+            }
         } catch (SOAPException e) {
             throw new WebServiceException(e);
         }
     }
 
-    /**
-     * Returns the payload as a {@link javax.xml.transform.Source} object.
-     *
-     * Can't really give all the body parts inside soapenv:Body as Source
-     * cant take only one part.
-     *
-     * <p/>
-     * This consumes the message.
-     */
+    public SOAPMessage readAsSOAPMessage() throws SOAPException {
+        if (!parsedMessage) {
+            return sm;
+        } else {
+            SOAPMessage msg = soapVersion.saajMessageFactory.createMessage();
+            SOAPBody newBody = msg.getSOAPPart().getEnvelope().getBody();
+            for (Element part : bodyParts) {
+                Node n = newBody.getOwnerDocument().importNode(part, true);
+                newBody.appendChild(n);
+            }
+            for (Header header : headers) {
+                header.writeTo(msg);
+            }
+            for (Attachment att : getAttachments()) {
+                AttachmentPart part = msg.createAttachmentPart();
+                part.setDataHandler(att.asDataHandler());
+                part.setContentId('<' + att.getContentId() + '>');
+                msg.addAttachmentPart(part);
+            }
+            msg.saveChanges();
+            return msg;
+        }
+    }
+
     public Source readPayloadAsSource() {
+        access();
         return (payload != null) ? new DOMSource(payload) : null;
     }
 
-    /**
-     * Creates the equivalent {@link javax.xml.soap.SOAPMessage} from this message.
-     * <p/>
-     * This consumes the message.
-     */
-    public SOAPMessage readAsSOAPMessage() {
-        return sm;
-    }
-
-    public SOAPMessage readAsSOAPMessage(Packet packet, boolean inbound) throws SOAPException {
-        return sm;
-    }
-
-    /**
-     * Reads the payload as a JAXB object by using the given unmarshaller.
-     * <p/>
-     * This consumes the message.
-     */
     public <T> T readPayloadAsJAXB(Unmarshaller unmarshaller) throws JAXBException {
-        try {
-            Node pn = sm.getSOAPBody().getFirstChild();
-            if (pn != null)
-                return (T) unmarshaller.unmarshal(pn);
-            return null;
-        } catch (SOAPException e) {
-            throw new WebServiceException(e);
+        access();
+        if (payload != null) {
+            if(hasAttachments())
+                unmarshaller.setAttachmentUnmarshaller(new AttachmentUnmarshallerImpl(getAttachments()));
+            return (T) unmarshaller.unmarshal(payload);
+
         }
+        return null;
     }
 
     public <T> T readPayloadAsJAXB(Bridge<T> bridge) throws JAXBException {
-        try {
-            Node pn = sm.getSOAPBody().getFirstChild();
-            if (pn != null)
-                return bridge.unmarshal(pn,
-                    new AttachmentUnmarshallerImpl(getAttachments()));
-            return null;
-        } catch (SOAPException e) {
-            throw new WebServiceException(e);
-        }
+        access();
+        if (payload != null)
+            return bridge.unmarshal(payload,hasAttachments()? new AttachmentUnmarshallerImpl(getAttachments()) : null);
+        return null;
     }
 
-    /**
-     * Reads the payload as a {@link javax.xml.stream.XMLStreamReader}
-     * <p/>
-     * This consumes the message.
-     */
     public XMLStreamReader readPayload() throws XMLStreamException {
-        if(payload==null)
-            return null;
-
-        DOMStreamReader dss = new DOMStreamReader();
-        dss.setCurrentNode(payload);
-        dss.nextTag();
-        assert dss.getEventType()==XMLStreamReader.START_ELEMENT;
-        return dss;
+        access();
+        if (payload != null) {
+            DOMStreamReader dss = new DOMStreamReader();
+            dss.setCurrentNode(payload);
+            dss.nextTag();
+            assert dss.getEventType() == XMLStreamReader.START_ELEMENT;
+            return dss;
+        }
+        return null;
     }
 
-    /**
-     * Writes the payload to StAX.
-     * <p/>
-     * This method writes just the payload of the message to the writer.
-     * This consumes the message.
-     */
-    public void writePayloadTo(XMLStreamWriter sw) {
+    public void writePayloadTo(XMLStreamWriter sw) throws XMLStreamException {
+        access();
         try {
-            for(Element part: bodyParts)
+            for (Element part : bodyParts)
                 DOMUtil.serializeNode(part, sw);
         } catch (XMLStreamException e) {
             throw new WebServiceException(e);
@@ -279,10 +293,69 @@
         }
     }
 
+    public void writeTo(XMLStreamWriter writer) throws XMLStreamException {
+        try {
+            writer.writeStartDocument();
+            if (!parsedMessage) {
+                DOMUtil.serializeNode(sm.getSOAPPart().getEnvelope(), writer);
+            } else {
+                SOAPEnvelope env = sm.getSOAPPart().getEnvelope();
+                DOMUtil.writeTagWithAttributes(env, writer);
+                if (hasHeaders()) {
+                    writer.writeStartElement(env.getPrefix(), "Header", env.getNamespaceURI());
+                    int len = headers.size();
+                    for (int i = 0; i < len; i++) {
+                        headers.get(i).writeTo(writer);
+                    }
+                    writer.writeEndElement();
+                }
+
+                DOMUtil.serializeNode(sm.getSOAPBody(), writer);
+                writer.writeEndElement();
+            }
+            writer.writeEndDocument();
+            writer.flush();
+        } catch (SOAPException ex) {
+            throw new XMLStreamException2(ex);
+            //for now. ask jaxws team what to do.
+        }
+    }
+
     public void writeTo(ContentHandler contentHandler, ErrorHandler errorHandler) throws SAXException {
+        String soapNsUri = soapVersion.nsUri;
+        if (!parsedMessage) {
+            DOMScanner ds = new DOMScanner();
+            ds.setContentHandler(contentHandler);
+            ds.scan(sm.getSOAPPart());
+        } else {
+            contentHandler.setDocumentLocator(NULL_LOCATOR);
+            contentHandler.startDocument();
+            contentHandler.startPrefixMapping("S", soapNsUri);
+            contentHandler.startElement(soapNsUri, "Envelope", "S:Envelope", EMPTY_ATTS);
+            if (hasHeaders()) {
+                contentHandler.startElement(soapNsUri, "Header", "S:Header", EMPTY_ATTS);
+                HeaderList headers = getHeaders();
+                int len = headers.size();
+                for (int i = 0; i < len; i++) {
+                    // shouldn't JDK be smart enough to use array-style indexing for this foreach!?
+                    headers.get(i).writeTo(contentHandler, errorHandler);
+                }
+                contentHandler.endElement(soapNsUri, "Header", "S:Header");
+            }
+            // write the body
+            contentHandler.startElement(soapNsUri, "Body", "S:Body", EMPTY_ATTS);
+            writePayloadTo(contentHandler, errorHandler, true);
+            contentHandler.endElement(soapNsUri, "Body", "S:Body");
+            contentHandler.endElement(soapNsUri, "Envelope", "S:Envelope");
+        }
+    }
+
+    private void writePayloadTo(ContentHandler contentHandler, ErrorHandler errorHandler, boolean fragment) throws SAXException {
+        if(fragment)
+            contentHandler = new FragmentContentHandler(contentHandler);
         DOMScanner ds = new DOMScanner();
         ds.setContentHandler(contentHandler);
-        ds.scan(sm.getSOAPPart());
+        ds.scan(payload);
     }
 
     /**
@@ -308,23 +381,27 @@
      */
     public Message copy() {
         try {
-            SOAPBody sb = sm.getSOAPPart().getEnvelope().getBody();
-            SOAPMessage msg = SOAPVersion.fromNsUri(sb.getNamespaceURI()).saajMessageFactory.createMessage();
-            SOAPBody newBody = msg.getSOAPPart().getEnvelope().getBody();
-            for(Element part: bodyParts){
-                Node n = newBody.getOwnerDocument().importNode(part, true);
-                newBody.appendChild(n);
+            if (!parsedMessage) {
+                return new SAAJMessage(readAsSOAPMessage());
+            } else {
+                SOAPMessage msg = soapVersion.saajMessageFactory.createMessage();
+                SOAPBody newBody = msg.getSOAPPart().getEnvelope().getBody();
+                for (Element part : bodyParts) {
+                    Node n = newBody.getOwnerDocument().importNode(part, true);
+                    newBody.appendChild(n);
+                }
+                return new SAAJMessage(getHeaders(), getAttachments(), msg);
             }
-            return new SAAJMessage(getHeaders(), getAttachments(), msg);
         } catch (SOAPException e) {
             throw new WebServiceException(e);
         }
     }
+    private static final AttributesImpl EMPTY_ATTS = new AttributesImpl();
+    private static final LocatorImpl NULL_LOCATOR = new LocatorImpl();
 
-
     private class SAAJAttachment implements Attachment {
 
-        AttachmentPart ap;
+        final AttachmentPart ap;
 
         public SAAJAttachment(AttachmentPart part) {
             this.ap = part;
@@ -475,30 +552,4 @@
         }
     }
 
-
-    public void writeTo( XMLStreamWriter writer ) throws XMLStreamException {
-        try {
-            writer.writeStartDocument();
-            SOAPEnvelope env = sm.getSOAPPart().getEnvelope();
-            DOMUtil.writeTagWithAttributes(env, writer);
-            if(hasHeaders()) {
-                writer.writeStartElement(env.getPrefix(),"Header",env.getNamespaceURI());
-                int len = headers.size();
-                for( int i=0; i<len; i++ ) {
-                    headers.get(i).writeTo(writer);
-                }
-                writer.writeEndElement();
-            }
-
-            DOMUtil.serializeNode(sm.getSOAPBody(),writer);
-            writer.writeEndElement();
-            writer.writeEndDocument();
-            writer.flush();
-        } catch (SOAPException ex) {
-            throw new XMLStreamException2(ex);
-            //for now. ask jaxws team what to do.
-        }
-
-    }
-
 }
--- old/src/share/classes/com/sun/xml/internal/ws/message/stream/StreamAttachment.java	Tue Aug  4 10:02:34 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/stream/StreamAttachment.java	Tue Aug  4 10:02:34 2009
@@ -28,6 +28,7 @@
 import com.sun.xml.internal.ws.api.message.Attachment;
 import com.sun.xml.internal.ws.util.ByteArrayDataSource;
 import com.sun.xml.internal.ws.util.ByteArrayBuffer;
+import com.sun.xml.internal.ws.encoding.DataSourceStreamingDataHandler;
 
 import javax.activation.DataHandler;
 import javax.xml.transform.Source;
@@ -77,7 +78,7 @@
     }
 
     public DataHandler asDataHandler() {
-        return new DataHandler(new ByteArrayDataSource(data,0,len,getContentType()));
+        return new DataSourceStreamingDataHandler(new ByteArrayDataSource(data,0,len,getContentType()));
     }
 
     public Source asSource() {
--- old/src/share/classes/com/sun/xml/internal/ws/message/stream/StreamHeader.java	Tue Aug  4 10:02:36 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/stream/StreamHeader.java	Tue Aug  4 10:02:36 2009
@@ -181,8 +181,10 @@
     }
 
     public void writeTo(XMLStreamWriter w) throws XMLStreamException {
-        // TODO what about in-scope namespaces
-        _mark.writeToXMLStreamWriter(w);
+        if(_mark.getInscopeNamespaces().size() > 0)
+            _mark.writeToXMLStreamWriter(w,true);
+        else
+            _mark.writeToXMLStreamWriter(w);
     }
 
     public void writeTo(SOAPMessage saaj) throws SOAPException {
--- old/src/share/classes/com/sun/xml/internal/ws/message/stream/StreamHeader11.java	Tue Aug  4 10:02:39 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/stream/StreamHeader11.java	Tue Aug  4 10:02:38 2009
@@ -61,10 +61,10 @@
             final String namespaceURI = reader.getAttributeNamespace(i);
             final String value = reader.getAttributeValue(i);
 
-            if (namespaceURI == SOAPConstants.URI_NS_SOAP_1_1_ENVELOPE) {
-                if (localName == SOAP_1_1_MUST_UNDERSTAND) {
+            if (SOAPConstants.URI_NS_SOAP_1_1_ENVELOPE.equals(namespaceURI)) {
+                if (SOAP_1_1_MUST_UNDERSTAND.equals(localName)) {
                     _isMustUnderstand = Util.parseBool(value);
-                } else if (localName == SOAP_1_1_ROLE) {
+                } else if (SOAP_1_1_ROLE.equals(localName)) {
                     if (value != null && value.length() > 0) {
                         _role = value;
                     }
--- old/src/share/classes/com/sun/xml/internal/ws/message/stream/StreamHeader12.java	Tue Aug  4 10:02:41 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/stream/StreamHeader12.java	Tue Aug  4 10:02:40 2009
@@ -63,14 +63,14 @@
             final String namespaceURI = reader.getAttributeNamespace(i);
             final String value = reader.getAttributeValue(i);
 
-            if (namespaceURI == SOAPConstants.URI_NS_SOAP_1_2_ENVELOPE) {
-                if (localName == SOAP_1_2_MUST_UNDERSTAND) {
+            if (SOAPConstants.URI_NS_SOAP_1_2_ENVELOPE.equals(namespaceURI)) {
+                if (SOAP_1_2_MUST_UNDERSTAND.equals(localName)) {
                     _isMustUnderstand = Util.parseBool(value);
-                } else if (localName == SOAP_1_2_ROLE) {
+                } else if (SOAP_1_2_ROLE.equals(localName)) {
                     if (value != null && value.length() > 0) {
                         _role = value;
                     }
-                } else if (localName == SOAP_1_2_RELAY) {
+                } else if (SOAP_1_2_RELAY.equals(localName)) {
                     _isRelay = Util.parseBool(value);
                 }
             }
--- old/src/share/classes/com/sun/xml/internal/ws/message/stream/StreamMessage.java	Tue Aug  4 10:02:43 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/stream/StreamMessage.java	Tue Aug  4 10:02:43 2009
@@ -47,18 +47,19 @@
 import org.xml.sax.ErrorHandler;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXParseException;
+import org.xml.sax.helpers.NamespaceSupport;
 
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Unmarshaller;
-import javax.xml.stream.Location;
-import javax.xml.stream.XMLStreamConstants;
+import javax.xml.stream.*;
 import static javax.xml.stream.XMLStreamConstants.START_DOCUMENT;
 import static javax.xml.stream.XMLStreamConstants.START_ELEMENT;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.stream.XMLStreamWriter;
 import javax.xml.transform.Source;
 import javax.xml.ws.WebServiceException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.List;
 
 /**
  * {@link Message} implementation backed by {@link XMLStreamReader}.
@@ -190,11 +191,40 @@
     public Source readPayloadAsSource() {
         if(hasPayload()) {
             assert unconsumed();
-            return new StAXSource(reader, true);
+            return new StAXSource(reader, true, getInscopeNamespaces());
         } else
             return null;
     }
 
+    /**
+     * There is no way to enumerate inscope namespaces for XMLStreamReader. That means
+     * namespaces declared in envelope, and body tags need to be computed using their
+     * {@link TagInfoset}s.
+     *
+     * @return array of the even length of the form { prefix0, uri0, prefix1, uri1, ... }
+     */
+    private String[] getInscopeNamespaces() {
+        NamespaceSupport nss = new NamespaceSupport();
+
+        nss.pushContext();
+        for(int i=0; i < envelopeTag.ns.length; i+=2) {
+            nss.declarePrefix(envelopeTag.ns[i], envelopeTag.ns[i+1]);
+        }
+
+        nss.pushContext();
+        for(int i=0; i < bodyTag.ns.length; i+=2) {
+            nss.declarePrefix(bodyTag.ns[i], bodyTag.ns[i+1]);
+        }
+
+        List<String> inscope = new ArrayList<String>();
+        for( Enumeration en = nss.getPrefixes(); en.hasMoreElements(); ) {
+            String prefix = (String)en.nextElement();
+            inscope.add(prefix);
+            inscope.add(nss.getURI(prefix));
+        }
+        return inscope.toArray(new String[inscope.size()]);
+    }
+
     public Object readPayloadAsJAXB(Unmarshaller unmarshaller) throws JAXBException {
         if(!hasPayload())
             return null;
@@ -206,6 +236,7 @@
             return unmarshaller.unmarshal(reader);
         } finally{
             unmarshaller.setAttachmentUnmarshaller(null);
+            XMLStreamReaderUtil.readRest(reader);
             XMLStreamReaderUtil.close(reader);
             XMLStreamReaderFactory.recycle(reader);
         }
@@ -217,6 +248,7 @@
         assert unconsumed();
         T r = bridge.unmarshal(reader,
             hasAttachments() ? new AttachmentUnmarshallerImpl(getAttachments()) : null);
+        XMLStreamReaderUtil.readRest(reader);
         XMLStreamReaderUtil.close(reader);
         XMLStreamReaderFactory.recycle(reader);
         return r;
@@ -225,6 +257,8 @@
     @Override
     public void consume() {
         assert unconsumed();
+        XMLStreamReaderUtil.readRest(reader);
+        XMLStreamReaderUtil.close(reader);
         XMLStreamReaderFactory.recycle(reader);
     }
 
@@ -259,7 +293,8 @@
                 break;
             conv.bridge(reader,writer);
         }
-        reader.close();
+        XMLStreamReaderUtil.readRest(reader);
+        XMLStreamReaderUtil.close(reader);
         XMLStreamReaderFactory.recycle(reader);
     }
 
@@ -322,7 +357,8 @@
 
                 conv.bridge();
             }
-            reader.close();
+            XMLStreamReaderUtil.readRest(reader);
+            XMLStreamReaderUtil.close(reader);
             XMLStreamReaderFactory.recycle(reader);
         } catch (XMLStreamException e) {
             Location loc = e.getLocation();
@@ -346,6 +382,13 @@
                 //the boolean value tells the first body part is written.
                 //based on this we do the right thing
                 StreamReaderBufferCreator c = new StreamReaderBufferCreator(xsb);
+
+                // preserving inscope namespaces from envelope, and body. Other option
+                // would be to create a filtering XMLStreamReader from reader+envelopeTag+bodyTag
+                c.storeElement(envelopeTag.nsUri, envelopeTag.localName, envelopeTag.prefix, envelopeTag.ns);
+                c.storeElement(bodyTag.nsUri, bodyTag.localName, bodyTag.prefix, bodyTag.ns);
+
+                // Loop all the way for multi payload case
                 while(reader.getEventType() != XMLStreamConstants.END_DOCUMENT){
                     String name = reader.getLocalName();
                     String nsUri = reader.getNamespaceURI();
@@ -352,11 +395,18 @@
                     if(name.equals("Body") && nsUri.equals(soapVersion.nsUri) || (reader.getEventType() == XMLStreamConstants.END_DOCUMENT))
                         break;
                     c.create(reader);
+                    // Skip whitespaces in between payload and </Body> or between elements
+                    if (reader.isWhiteSpace()) {
+                        XMLStreamReaderUtil.nextElementContent(reader);
+                    }
                 }
+                XMLStreamReaderUtil.readRest(reader);
+                XMLStreamReaderUtil.close(reader);
                 XMLStreamReaderFactory.recycle(reader);
 
                 reader = xsb.readAsXMLStreamReader();
                 clone = xsb.readAsXMLStreamReader();
+
                 // advance to the start tag of the first element
                 proceedToRootElement(reader);
                 proceedToRootElement(clone);
@@ -375,6 +425,8 @@
     private void proceedToRootElement(XMLStreamReader xsr) throws XMLStreamException {
         assert xsr.getEventType()==START_DOCUMENT;
         xsr.nextTag();
+        xsr.nextTag();
+        xsr.nextTag();
         assert xsr.getEventType()==START_ELEMENT;
     }
 
--- old/src/share/classes/com/sun/xml/internal/ws/model/AbstractSEIModelImpl.java	Tue Aug  4 10:02:45 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/AbstractSEIModelImpl.java	Tue Aug  4 10:02:45 2009
@@ -28,6 +28,7 @@
 import com.sun.xml.internal.bind.api.Bridge;
 import com.sun.xml.internal.bind.api.JAXBRIContext;
 import com.sun.xml.internal.bind.api.TypeReference;
+import com.sun.xml.internal.ws.api.model.JavaMethod;
 import com.sun.xml.internal.ws.api.model.ParameterBinding;
 import com.sun.xml.internal.ws.api.model.SEIModel;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLModel;
@@ -40,24 +41,40 @@
 import com.sun.xml.internal.ws.model.wsdl.WSDLPortImpl;
 import com.sun.xml.internal.ws.resources.ModelerMessages;
 import com.sun.xml.internal.ws.util.Pool;
+import com.sun.xml.internal.ws.developer.UsesJAXBContextFeature;
+import com.sun.xml.internal.ws.developer.JAXBContextFactory;
+import com.sun.xml.internal.ws.binding.WebServiceFeatureList;
 
 import javax.jws.WebParam.Mode;
+import javax.xml.bind.annotation.XmlSeeAlso;
 import javax.xml.namespace.QName;
 import javax.xml.ws.WebServiceException;
+import javax.xml.ws.WebServiceFeature;
 import java.lang.reflect.Method;
 import java.security.AccessController;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * model of the web service.  Used by the runtime marshall/unmarshall
  * web service invocations
  *
- * $author: JAXWS Development Team
+ * @author JAXWS Development Team
  */
 public abstract class AbstractSEIModelImpl implements SEIModel {
 
+    protected AbstractSEIModelImpl(WebServiceFeature[] features) {
+        this.features = features;
+    }
+
     void postProcess() {
         // should be called only once.
         if (jaxbContext != null)
@@ -111,15 +128,11 @@
 
     private JAXBRIContext createJAXBContext() {
         final List<TypeReference> types = getAllTypeReferences();
-        final Class[] cls = new Class[types.size() + additionalClasses.size()];
-        int i = 0;
-        for(Class additionalClass:additionalClasses){
-            cls[i++] = additionalClass;
-        }
+        final List<Class> cls = new ArrayList<Class>(types.size() + additionalClasses.size());
 
-        for (TypeReference type : types) {
-            cls[i++] = (Class) type.type;
-        }
+        cls.addAll(additionalClasses);
+        for (TypeReference type : types)
+            cls.add((Class) type.type);
 
         try {
             //jaxbContext = JAXBRIContext.newInstance(cls, types, targetNamespace, false);
@@ -126,7 +139,13 @@
             // Need to avoid doPriv block once JAXB is fixed. Afterwards, use the above
             jaxbContext = AccessController.doPrivileged(new PrivilegedExceptionAction<JAXBRIContext>() {
                 public JAXBRIContext run() throws Exception {
-                    return JAXBRIContext.newInstance(cls, types, null, targetNamespace, false, null);
+                    if(LOGGER.isLoggable(Level.FINE)) {
+                        LOGGER.log(Level.FINE,"Creating JAXBContext with classes="+cls+" and types="+types);
+                    }
+                    UsesJAXBContextFeature f = WebServiceFeatureList.getFeature(features, UsesJAXBContextFeature.class);
+                    JAXBContextFactory factory = f!=null ? f.getFactory() : null;
+                    if(factory==null)   factory=JAXBContextFactory.DEFAULT;
+                    return factory.createJAXBContext(AbstractSEIModelImpl.this,cls,types);
                 }
             });
             createBridgeMap(types);
@@ -222,7 +241,10 @@
 
     /**
      * @return the <code>QName</code> associated with the
-     * JavaMethod jm
+     * JavaMethod jm.
+     *
+     * @deprecated
+     *      Use {@link JavaMethod#getOperationName()}.
      */
     public QName getQNameForJM(JavaMethodImpl jm) {
         for (QName key : nameToJM.keySet()) {
@@ -462,13 +484,12 @@
     }
 
     /**
-     * Sets additional classes obtained from {@link javax.xml.bind.annotation.XmlSeeAlso} annotation. In starting
+     * Adds additional classes obtained from {@link XmlSeeAlso} annotation. In starting
      * from wsdl case these classes would most likely be JAXB ObjectFactory that references other classes.
      */
-    public void setAdditionalClasses(Class[] additionalClasses) {
-        for(Class cls:additionalClasses){
+    public void addAdditionalClasses(Class... additionalClasses) {
+        for(Class cls : additionalClasses)
             this.additionalClasses.add(cls);
-        }
     }
 
     private List<Class> additionalClasses = new ArrayList<Class>();
@@ -480,6 +501,9 @@
     private QName portName;
     private QName portTypeName;
     private Map<Method,JavaMethodImpl> methodToJM = new HashMap<Method, JavaMethodImpl>();
+    /**
+     * Payload QName to the method that handles it.
+     */
     private Map<QName,JavaMethodImpl> nameToJM = new HashMap<QName, JavaMethodImpl>();
     private List<JavaMethodImpl> javaMethods = new ArrayList<JavaMethodImpl>();
     private final Map<TypeReference, Bridge> bridgeMap = new HashMap<TypeReference, Bridge>();
@@ -487,4 +511,7 @@
     private String targetNamespace = "";
     private List<String> knownNamespaceURIs = null;
     private WSDLPortImpl port;
+    private final WebServiceFeature[] features;
+
+    private static final Logger LOGGER = Logger.getLogger(AbstractSEIModelImpl.class.getName());
 }
--- old/src/share/classes/com/sun/xml/internal/ws/model/JavaMethodImpl.java	Tue Aug  4 10:02:47 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/JavaMethodImpl.java	Tue Aug  4 10:02:47 2009
@@ -24,6 +24,7 @@
  */
 package com.sun.xml.internal.ws.model;
 
+import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.bind.api.TypeReference;
 import com.sun.xml.internal.ws.api.model.JavaMethod;
 import com.sun.xml.internal.ws.api.model.MEP;
@@ -32,7 +33,7 @@
 import com.sun.xml.internal.ws.model.soap.SOAPBindingImpl;
 import com.sun.xml.internal.ws.model.wsdl.WSDLBoundOperationImpl;
 import com.sun.xml.internal.ws.model.wsdl.WSDLPortImpl;
-import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
 
 import javax.xml.namespace.QName;
 import javax.xml.ws.Action;
@@ -47,6 +48,7 @@
  * @author Vivek Pandey
  */
 public final class JavaMethodImpl implements JavaMethod {
+
     private String inputAction;
     private String outputAction;
     private final List<CheckedExceptionImpl> exceptions = new ArrayList<CheckedExceptionImpl>();
@@ -162,6 +164,20 @@
     }
 
     /**
+     * @return soap:Body's first child name for request message.
+     */
+    public @Nullable QName getRequestPayloadName() {
+        return wsdlOperation.getReqPayloadName();
+    }
+
+    /**
+     * @return soap:Body's first child name for response message.
+     */
+    public @Nullable QName getResponsePayloadName() {
+        return (mep == MEP.ONE_WAY) ? null : wsdlOperation.getResPayloadName();
+    }
+
+    /**
      * @return returns unmodifiable list of request parameters
      */
     public List<ParameterImpl> getRequestParameters() {
@@ -252,15 +268,7 @@
         return null;
     }
 
-    public QName getPayloadName(){
-        if(payloadName != null)
-            return payloadName;
-        payloadName = wsdlOperation.getPayloadName();
-        return payloadName;
-    }
 
-    private QName payloadName;
-
     /**
      * @return a list of checked Exceptions thrown by this method
      */
--- old/src/share/classes/com/sun/xml/internal/ws/model/RuntimeModeler.java	Tue Aug  4 10:02:50 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/RuntimeModeler.java	Tue Aug  4 10:02:49 2009
@@ -35,10 +35,12 @@
 import com.sun.xml.internal.ws.api.model.Parameter;
 import com.sun.xml.internal.ws.api.model.ParameterBinding;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLPart;
+import com.sun.xml.internal.ws.model.soap.SOAPBindingImpl;
 import com.sun.xml.internal.ws.model.wsdl.WSDLBoundOperationImpl;
-import com.sun.xml.internal.ws.model.wsdl.WSDLPortImpl;
 import com.sun.xml.internal.ws.model.wsdl.WSDLInputImpl;
+import com.sun.xml.internal.ws.model.wsdl.WSDLPortImpl;
 import com.sun.xml.internal.ws.resources.ModelerMessages;
+import com.sun.xml.internal.ws.resources.ServerMessages;
 import com.sun.xml.internal.ws.util.localization.Localizable;
 
 import javax.jws.Oneway;
@@ -48,17 +50,11 @@
 import javax.jws.WebResult;
 import javax.jws.WebService;
 import javax.jws.soap.SOAPBinding;
+import static javax.jws.soap.SOAPBinding.ParameterStyle.WRAPPED;
 import javax.jws.soap.SOAPBinding.Style;
 import javax.xml.bind.annotation.XmlSeeAlso;
 import javax.xml.namespace.QName;
-import javax.xml.ws.Action;
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.FaultAction;
-import javax.xml.ws.Holder;
-import javax.xml.ws.RequestWrapper;
-import javax.xml.ws.Response;
-import javax.xml.ws.ResponseWrapper;
-import javax.xml.ws.WebFault;
+import javax.xml.ws.*;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
@@ -72,6 +68,7 @@
 import java.util.StringTokenizer;
 import java.util.TreeMap;
 import java.util.concurrent.Future;
+import java.util.logging.Logger;
 
 /**
  * Creates a runtime model of a SEI (portClass).
@@ -79,10 +76,11 @@
  * @author WS Developement Team
  */
 public class RuntimeModeler {
+    private final WebServiceFeature[] features;
     private BindingID bindingId;
     private Class portClass;
     private AbstractSEIModelImpl model;
-    private com.sun.xml.internal.ws.model.soap.SOAPBindingImpl defaultBinding;
+    private SOAPBindingImpl defaultBinding;
     // can be empty but never null
     private String packageName;
     private String targetNamespace;
@@ -118,10 +116,15 @@
      * @param bindingId The binding identifier to be used when modeling the <code>portClass</code>.
      */
     public RuntimeModeler(@NotNull Class portClass, @NotNull QName serviceName, @NotNull BindingID bindingId) {
+        this(portClass, serviceName, bindingId, new WebServiceFeature[0]);
+    }
+
+    public RuntimeModeler(@NotNull Class portClass, @NotNull QName serviceName, @NotNull BindingID bindingId, @NotNull WebServiceFeature... features) {
         this.portClass = portClass;
         this.serviceName = serviceName;
         this.binding = null;
         this.bindingId = bindingId;
+        this.features = features;
     }
 
     /**
@@ -131,18 +134,12 @@
      * @param serviceName The ServiceName to use instead of one calculated from the implementation class
      * @param wsdlPort {@link com.sun.xml.internal.ws.api.model.wsdl.WSDLPort}
      */
-    public RuntimeModeler(@NotNull Class sei, @NotNull QName serviceName, @NotNull WSDLPortImpl wsdlPort){
+    public RuntimeModeler(@NotNull Class sei, @NotNull QName serviceName, @NotNull WSDLPortImpl wsdlPort, @NotNull WebServiceFeature... features){
         this.portClass = sei;
         this.serviceName = serviceName;
         this.bindingId = wsdlPort.getBinding().getBindingId();
-
-        //If the bindingId is null lets default to SOAP 1.1 binding id. As it looks like this bindingId
-        //is used latter on from model to generate binding on the WSDL. So defaulting to SOAP 1.1 maybe
-        // safe to do.
-        if(this.bindingId == null)
-            this.bindingId = BindingID.SOAP11_HTTP;
-
         this.binding = wsdlPort;
+        this.features = features;
     }
 
     /**
@@ -186,6 +183,10 @@
         });
     }
 
+    private static final Logger logger =
+        Logger.getLogger(
+            com.sun.xml.internal.ws.util.Constants.LoggingDomain + ".server");
+
     //currently has many local vars which will be eliminated after debugging issues
     //first draft
     /**
@@ -193,7 +194,7 @@
      * @return the runtime model for the <code>portClass</code>.
      */
     public AbstractSEIModelImpl buildRuntimeModel() {
-        model = new SOAPSEIModel();
+        model = new SOAPSEIModel(features);
         Class clazz = portClass;
         WebService webService = getPrivClassAnnotation(portClass, WebService.class);
         if (webService == null) {
@@ -207,6 +208,15 @@
                 throw new RuntimeModelerException("runtime.modeler.endpoint.interface.no.webservice",
                     webService.endpointInterface());
             }
+
+            //check if @SOAPBinding is defined on the impl class
+            SOAPBinding sbPortClass = getPrivClassAnnotation(portClass, SOAPBinding.class);
+            SOAPBinding sbSei = getPrivClassAnnotation(clazz, SOAPBinding.class);
+            if(sbPortClass != null){
+                if(sbSei == null || sbSei.style() != sbPortClass.style()|| sbSei.use() != sbPortClass.use()){
+                    logger.warning(ServerMessages.RUNTIMEMODELER_INVALIDANNOTATION_ON_IMPL("@SOAPBinding", portClass.getName(), clazz.getName()));
+                }
+            }
         }
         if (serviceName == null)
             serviceName = getServiceName(portClass);
@@ -260,6 +270,46 @@
         }
     }
 
+    private Class getRequestWrapperClass(String className, Method method, QName reqElemName) {
+        ClassLoader loader =  (classLoader == null) ? Thread.currentThread().getContextClassLoader() : classLoader;
+        try {
+            return loader.loadClass(className);
+        } catch (ClassNotFoundException e) {
+            if (generateWrapperBeans) {
+                logger.info("Dynamically creating request wrapper Class " + className);
+                return WrapperBeanGenerator.createRequestWrapperBean(className, method, reqElemName, loader);
+            }
+            throw new RuntimeModelerException(e);
+        }
+    }
+
+    private Class getResponseWrapperClass(String className, Method method, QName resElemName) {
+        ClassLoader loader =  (classLoader == null) ? Thread.currentThread().getContextClassLoader() : classLoader;
+        try {
+            return loader.loadClass(className);
+        } catch (ClassNotFoundException e) {
+            if (generateWrapperBeans) {
+                logger.info("Dynamically creating response wrapper bean Class " + className);
+                return WrapperBeanGenerator.createResponseWrapperBean(className, method, resElemName, loader);
+            }
+            throw new RuntimeModelerException(e);
+        }
+    }
+
+
+    private Class getExceptionBeanClass(String className, Class exception, String name, String namespace) {
+        ClassLoader loader =  (classLoader == null) ? Thread.currentThread().getContextClassLoader() : classLoader;
+        try {
+            return loader.loadClass(className);
+        } catch (ClassNotFoundException e) {
+            if (generateWrapperBeans) {
+                logger.info("Dynamically creating exception bean Class " + className);
+                return WrapperBeanGenerator.createExceptionBean(className, exception, targetNamespace, name, namespace, loader);
+            }
+            throw new RuntimeModelerException(e);
+        }
+    }
+
     protected void setUsesWebMethod(Class clazz, Boolean usesWebMethod) {
 //        System.out.println("class: "+clazz.getName()+" uses WebMethod: "+usesWebMethod);
         classUsesWebMethod.put(clazz, usesWebMethod);
@@ -309,10 +359,9 @@
         model.setPortTypeName(portTypeName);
         model.setWSDLLocation(webService.wsdlLocation());
 
-        javax.jws.soap.SOAPBinding soapBinding = getPrivClassAnnotation(clazz, javax.jws.soap.SOAPBinding.class);
+        SOAPBinding soapBinding = getPrivClassAnnotation(clazz, SOAPBinding.class);
         if (soapBinding != null) {
-            isWrapped = soapBinding.parameterStyle().equals(
-                javax.jws.soap.SOAPBinding.ParameterStyle.WRAPPED);
+            isWrapped = soapBinding.parameterStyle()== WRAPPED;
         }
         defaultBinding = createBinding(soapBinding);
         /*
@@ -335,9 +384,17 @@
         }*/
 
         for (Method method : clazz.getMethods()) {
-            if (method.getDeclaringClass()==Object.class ||
-                !isWebMethod(method, clazz)) {
-                continue;
+            if (!clazz.isInterface()) {     // if clazz is SEI, then all methods are web methods
+                if (!legacyWebMethod) {
+                    if (!isWebMethodBySpec(method, clazz)) {
+                        continue;
+                    }
+                } else {
+                    if (method.getDeclaringClass()==Object.class ||
+                        !isWebMethod(method, clazz)) {
+                        continue;
+                    }
+                }
             }
             // TODO: binding can be null. We need to figure out how to post-process
             // RuntimeModel to link to WSDLModel
@@ -346,9 +403,48 @@
         //Add additional jaxb classes referenced by {@link XmlSeeAlso}
         XmlSeeAlso xmlSeeAlso = getPrivClassAnnotation(clazz, XmlSeeAlso.class);
         if(xmlSeeAlso != null)
-            model.setAdditionalClasses(xmlSeeAlso.value());
+            model.addAdditionalClasses(xmlSeeAlso.value());
     }
 
+    /*
+     * Section 3.3 of spec
+     * Otherwise, the class implicitly defines a service endpoint interface (SEI) which
+     * comprises all of the public methods that satisfy one of the following conditions:
+     *  1. They are annotated with the javax.jws.WebMethod annotation with the exclude element set to
+     *     false or missing (since false is the default for this annotation element).
+     *  2. They are not annotated with the javax.jws.WebMethod annotation but their declaring class has a
+     *     javax.jws.WebService annotation.
+     *
+     * also the method should non-static or non-final
+     */
+    private boolean isWebMethodBySpec(Method method, Class clazz) {
+
+        int modifiers = method.getModifiers();
+        boolean staticFinal = Modifier.isStatic(modifiers) || Modifier.isFinal(modifiers);
+
+        assert Modifier.isPublic(modifiers);
+        assert !clazz.isInterface();
+
+        WebMethod webMethod = getPrivMethodAnnotation(method, WebMethod.class);
+        if (webMethod != null) {
+            if (webMethod.exclude()) {
+                return false;       // @WebMethod(exclude="true")
+            }
+            if (staticFinal) {
+                throw new RuntimeModelerException(ModelerMessages.localizableRUNTIME_MODELER_WEBMETHOD_MUST_BE_NONSTATICFINAL(method));
+            }
+            return true;            // @WebMethod
+        }
+
+        if (staticFinal) {
+            return false;
+        }
+
+        Class declClass = method.getDeclaringClass();
+        return getPrivClassAnnotation(declClass, WebService.class) != null;
+    }
+
+
     protected boolean isWebMethod(Method method, Class clazz) {
         if (clazz.isInterface()) {
             return true;
@@ -369,9 +465,8 @@
      * @param soapBinding the <code>javax.jws.soap.SOAPBinding</code> to model
      * @return returns the runtime model SOAPBinding corresponding to <code>soapBinding</code>
      */
-    protected com.sun.xml.internal.ws.model.soap.SOAPBindingImpl createBinding(javax.jws.soap.SOAPBinding soapBinding) {
-        com.sun.xml.internal.ws.model.soap.SOAPBindingImpl rtSOAPBinding =
-            new com.sun.xml.internal.ws.model.soap.SOAPBindingImpl();
+    protected SOAPBindingImpl createBinding(SOAPBinding soapBinding) {
+        SOAPBindingImpl rtSOAPBinding = new SOAPBindingImpl();
         Style style = soapBinding!=null ? soapBinding.style() : Style.DOCUMENT;
         rtSOAPBinding.setStyle(style);
         assert bindingId != null;
@@ -500,7 +595,7 @@
             if (action != null)
                 mySOAPBinding.setSOAPAction(action);
             methodIsWrapped = methodBinding.parameterStyle().equals(
-                javax.jws.soap.SOAPBinding.ParameterStyle.WRAPPED);
+                WRAPPED);
             javaMethod.setBinding(mySOAPBinding);
         } else {
             com.sun.xml.internal.ws.model.soap.SOAPBindingImpl sb = new com.sun.xml.internal.ws.model.soap.SOAPBindingImpl(defaultBinding);
@@ -567,8 +662,6 @@
             responseClassName = beanPackage + capitalize(method.getName()) + RESPONSE;
         }
 
-        Class requestClass = getClass(requestClassName, ModelerMessages.localizableRUNTIME_MODELER_WRAPPER_NOT_FOUND(requestClassName));
-
         String reqName = operationName;
         String reqNamespace = targetNamespace;
         if (reqWrapper != null) {
@@ -578,12 +671,13 @@
                 reqName = reqWrapper.localName();
         }
         QName reqElementName = new QName(reqNamespace, reqName);
+        Class requestClass = getRequestWrapperClass(requestClassName, method, reqElementName);
 
         Class responseClass = null;
         String resName = operationName+"Response";
         String resNamespace = targetNamespace;
+        QName resElementName = null;
         if (!isOneway) {
-            responseClass = getClass(responseClassName, ModelerMessages.localizableRUNTIME_MODELER_WRAPPER_NOT_FOUND(responseClassName));
             if (resWrapper != null) {
                 if (resWrapper.targetNamespace().length() > 0)
                     resNamespace = resWrapper.targetNamespace();
@@ -590,8 +684,9 @@
                 if (resWrapper.localName().length() > 0)
                     resName = resWrapper.localName();
             }
+            resElementName = new QName(resNamespace, resName);
+            responseClass = getResponseWrapperClass(responseClassName, method, resElementName);
         }
-        QName resElementName = new QName(resNamespace, resName);
 
         TypeReference typeRef =
                 new TypeReference(reqElementName, requestClass);
@@ -977,7 +1072,7 @@
                     namespace = webFault.targetNamespace();
             }
             if (faultInfoMethod == null)  {
-                exceptionBean = getClass(className, ModelerMessages.localizableRUNTIME_MODELER_WRAPPER_NOT_FOUND(className));
+                exceptionBean = getExceptionBeanClass(className, exception, name, namespace);
                 exceptionType = ExceptionType.UserDefined;
                 anns = exceptionBean.getAnnotations();
             } else {
@@ -1096,6 +1191,9 @@
             for (Annotation annotation : pannotations[pos]) {
                 if (annotation.annotationType() == javax.jws.WebParam.class) {
                     javax.jws.WebParam webParam = (javax.jws.WebParam) annotation;
+                    isHeader = webParam.header();
+                    if(isHeader)
+                        paramName = "arg"+pos;
                     if (webParam.name().length() > 0)
                         paramName = webParam.name();
                     partName = webParam.partName();
@@ -1102,7 +1200,6 @@
                     if (!webParam.targetNamespace().equals("")) {
                         requestNamespace = webParam.targetNamespace();
                     }
-                    isHeader = webParam.header();
                     paramMode = webParam.mode();
                     if (isHolder && paramMode == Mode.IN)
                         paramMode = Mode.INOUT;
@@ -1327,4 +1424,40 @@
         }
         return null;
     }
+
+    private static Boolean getProperty(final String prop) {
+        Boolean b = AccessController.doPrivileged(
+            new java.security.PrivilegedAction<Boolean>() {
+                public Boolean run() {
+                    String value = System.getProperty(prop);
+                    return value != null ? Boolean.valueOf(value) : Boolean.FALSE;
+                }
+            }
+        );
+        return Boolean.FALSE;
+    }
+
+    /**
+     * Support for legacy WebMethod computation.
+     */
+    public static final boolean legacyWebMethod = getProperty(RuntimeModeler.class.getName()+".legacyWebMethod");
+
+
+    /**
+     * Controls whether wrapper beans should be generated dynamically.
+     *
+     * By default in JDK, they are not generated.
+     */
+    public static final boolean generateWrapperBeans;
+    static {
+        boolean wrapperGeneratorExists = false;
+        try {
+            Class.forName("com.sun.xml.internal." + "ws.model.WrapperBeanGenerator");
+            wrapperGeneratorExists = true;
+        } catch (ClassNotFoundException cnfe) {
+            wrapperGeneratorExists = getProperty(RuntimeModeler.class.getName()+".generateWrappers");
+        }
+        generateWrapperBeans = wrapperGeneratorExists;
+    }
+
 }
--- old/src/share/classes/com/sun/xml/internal/ws/model/SOAPSEIModel.java	Tue Aug  4 10:02:52 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/SOAPSEIModel.java	Tue Aug  4 10:02:52 2009
@@ -28,6 +28,7 @@
 
 import javax.jws.WebParam.Mode;
 import javax.xml.namespace.QName;
+import javax.xml.ws.WebServiceFeature;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
@@ -39,6 +40,10 @@
  */
 public class SOAPSEIModel extends AbstractSEIModelImpl {
 
+    public SOAPSEIModel(WebServiceFeature[] features) {
+        super(features);
+    }
+
     @Override
     protected void populateMaps() {
         int emptyBodyCount = 0;
--- old/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLBoundOperationImpl.java	Tue Aug  4 10:02:54 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLBoundOperationImpl.java	Tue Aug  4 10:02:54 2009
@@ -25,16 +25,15 @@
 package com.sun.xml.internal.ws.model.wsdl;
 
 import com.sun.istack.internal.Nullable;
+import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.ws.api.model.ParameterBinding;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundOperation;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLOperation;
+import com.sun.xml.internal.ws.api.model.wsdl.*;
 
 import javax.jws.WebParam.Mode;
 import javax.jws.soap.SOAPBinding.Style;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLStreamReader;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.*;
 
 /**
  * Implementation of {@link WSDLBoundOperation}
@@ -63,6 +62,7 @@
     private final Map<String, WSDLPartImpl> inParts;
     private final Map<String, WSDLPartImpl> outParts;
     private final Map<String, WSDLPartImpl> fltParts;
+    private final List<WSDLBoundFaultImpl> wsdlBoundFaults;
     private WSDLOperationImpl operation;
     private String soapAction;
     private ANONYMOUS anonymous;
@@ -85,6 +85,7 @@
         inParts = new HashMap<String, WSDLPartImpl>();
         outParts = new HashMap<String, WSDLPartImpl>();
         fltParts = new HashMap<String, WSDLPartImpl>();
+        wsdlBoundFaults = new ArrayList<WSDLBoundFaultImpl>();
         this.owner = owner;
     }
 
@@ -100,14 +101,7 @@
         this.soapAction = soapAction!=null?soapAction:"";
     }
 
-    /**
-     * Gets {@link com.sun.xml.internal.ws.api.model.wsdl.WSDLPart} for the given wsdl:input or wsdl:output part
-     *
-     * @param partName must be non-null
-     * @param mode     must be non-null
-     * @return null if no part is found
-     */
-    public WSDLPartImpl getPart(String partName, Mode mode){
+    public WSDLPartImpl getPart(String partName, Mode mode) {
         if(mode==Mode.IN){
             return inParts.get(partName);
         }else if(mode==Mode.OUT){
@@ -150,6 +144,25 @@
         return faultParts;
     }
 
+    // TODO: what's the difference between this and inputParts/outputParts?
+    public Map<String,WSDLPart> getInParts() {
+        return Collections.<String,WSDLPart>unmodifiableMap(inParts);
+    }
+
+    public Map<String,WSDLPart> getOutParts() {
+        return Collections.<String,WSDLPart>unmodifiableMap(outParts);
+    }
+
+    @NotNull
+    public List<WSDLBoundFaultImpl> getFaults() {
+        return wsdlBoundFaults;
+    }
+
+    public void addFault(@NotNull WSDLBoundFaultImpl fault){
+        wsdlBoundFaults.add(fault);
+    }
+
+
     /**
      * Map of mime:content@part and the mime type from mime:content@type for wsdl:output
      *
@@ -280,6 +293,11 @@
         return operation;
     }
 
+
+    public WSDLBoundPortType getBoundPortType() {
+        return owner;
+    }
+
     public void setInputExplicitBodyParts(boolean b) {
         explicitInputSOAPBodyParts = b;
     }
@@ -297,33 +315,65 @@
         this.style = style;
     }
 
-    public @Nullable QName getPayloadName() {
-        if(style.equals(Style.RPC)){
-            return name;
-        }else{
-            if(emptyPayload)
-                return null;
+    public @Nullable QName getReqPayloadName() {
+        if (emptyRequestPayload)
+            return null;
 
-            if(payloadName != null)
-                return payloadName;
+        if (requestPayloadName != null)
+            return requestPayloadName;
 
+        if(style.equals(Style.RPC)){
+            String ns = getRequestNamespace() != null ? getRequestNamespace() : name.getNamespaceURI();
+            requestPayloadName = new QName(ns, name.getLocalPart());
+            return requestPayloadName;
+        }else{
             QName inMsgName = operation.getInput().getMessage().getName();
             WSDLMessageImpl message = messages.get(inMsgName);
             for(WSDLPartImpl part:message.parts()){
                 ParameterBinding binding = getInputBinding(part.getName());
                 if(binding.isBody()){
-                    payloadName = part.getDescriptor().name();
-                    return payloadName;
+                    requestPayloadName = part.getDescriptor().name();
+                    return requestPayloadName;
                 }
             }
 
             //Its empty payload
-            emptyPayload = true;
+            emptyRequestPayload = true;
         }
         //empty body
         return null;
     }
 
+    public @Nullable QName getResPayloadName() {
+        if (emptyResponsePayload)
+            return null;
+
+        if (responsePayloadName != null)
+            return responsePayloadName;
+
+        if(style.equals(Style.RPC)){
+            String ns = getResponseNamespace() != null ? getResponseNamespace() : name.getNamespaceURI();
+            responsePayloadName = new QName(ns, name.getLocalPart()+"Response");
+            return responsePayloadName;
+        }else{
+            QName outMsgName = operation.getOutput().getMessage().getName();
+            WSDLMessageImpl message = messages.get(outMsgName);
+            for(WSDLPartImpl part:message.parts()){
+                ParameterBinding binding = getOutputBinding(part.getName());
+                if(binding.isBody()){
+                    responsePayloadName = part.getDescriptor().name();
+                    return responsePayloadName;
+                }
+            }
+
+            //Its empty payload
+            emptyResponsePayload = true;
+        }
+        //empty body
+        return null;
+    }
+
+
     private String reqNamespace;
     private String respNamespace;
 
@@ -334,7 +384,7 @@
      * @see com.sun.xml.internal.ws.model.RuntimeModeler#processRpcMethod(com.sun.xml.internal.ws.model.JavaMethodImpl, String, javax.jws.WebMethod, String, java.lang.reflect.Method, javax.jws.WebService)
      */
     public String getRequestNamespace(){
-        return reqNamespace;
+        return (reqNamespace != null)?reqNamespace:name.getNamespaceURI();
     }
 
     public void setRequestNamespace(String ns){
@@ -349,7 +399,7 @@
      *      * @see com.sun.xml.internal.ws.modeler.RuntimeModeler#processRpcMethod(com.sun.xml.internal.ws.model.JavaMethod, String, javax.jws.WebMethod, String, java.lang.reflect.Method, javax.jws.WebService)
      */
     public String getResponseNamespace(){
-        return respNamespace;
+        return (respNamespace!=null)?respNamespace:name.getNamespaceURI();
     }
 
     public void setResponseNamespace(String ns){
@@ -360,13 +410,18 @@
         return owner;
     }
 
-    private QName payloadName;
-    private boolean emptyPayload;
+    private QName requestPayloadName;
+    private QName responsePayloadName;
+    private boolean emptyRequestPayload;
+    private boolean emptyResponsePayload;
     private Map<QName, WSDLMessageImpl> messages;
 
     void freeze(WSDLModelImpl parent) {
         messages = parent.getMessages();
         operation = owner.getPortType().get(name.getLocalPart());
+        for(WSDLBoundFaultImpl bf : wsdlBoundFaults){
+            bf.freeze(this);
+        }
     }
 
     public void setAnonymous(ANONYMOUS anonymous) {
--- old/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLBoundPortTypeImpl.java	Tue Aug  4 10:02:57 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLBoundPortTypeImpl.java	Tue Aug  4 10:02:56 2009
@@ -30,9 +30,9 @@
 import com.sun.xml.internal.ws.api.model.ParameterBinding;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundOperation;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundPortType;
+import com.sun.xml.internal.ws.resources.ClientMessages;
 import com.sun.xml.internal.ws.util.QNameMap;
 import com.sun.xml.internal.ws.util.exception.LocatableWebServiceException;
-import com.sun.xml.internal.ws.resources.ClientMessages;
 
 import javax.jws.WebParam.Mode;
 import javax.jws.soap.SOAPBinding;
@@ -52,7 +52,6 @@
     private WSDLPortTypeImpl portType;
     private BindingID bindingId;
     private final @NotNull WSDLModelImpl owner;
-    private boolean finalized = false;
     private final QNameMap<WSDLBoundOperationImpl> bindingOperations = new QNameMap<WSDLBoundOperationImpl>();
 
     /**
@@ -209,21 +208,20 @@
         }
 
         freezePayloadMap();
-        if(style == Style.RPC){
-            owner.finalizeRpcLitBinding(this);
-        }
+        owner.finalizeRpcLitBinding(this);
     }
 
     private void freezePayloadMap() {
         if(style== Style.RPC) {
-            // If the style is rpc then the tag name should be
-            // same as operation name so return the operation that matches the tag name.
-            payloadMap = bindingOperations;
+            payloadMap = new QNameMap<WSDLBoundOperationImpl>();
+            for(WSDLBoundOperationImpl op : bindingOperations.values()){
+                payloadMap.put(op.getReqPayloadName(), op);
+            }
         } else {
             payloadMap = new QNameMap<WSDLBoundOperationImpl>();
             // For doclit The tag will be the operation that has the same input part descriptor value
             for(WSDLBoundOperationImpl op : bindingOperations.values()){
-                QName name = op.getPayloadName();
+                QName name = op.getReqPayloadName();
                 if(name == null){
                     //empty payload
                     emptyPayloadOperation = op;
--- old/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLFaultImpl.java	Tue Aug  4 10:02:59 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLFaultImpl.java	Tue Aug  4 10:02:58 2009
@@ -26,6 +26,8 @@
 package com.sun.xml.internal.ws.model.wsdl;
 
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLFault;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLOperation;
+import com.sun.istack.internal.NotNull;
 
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLStreamReader;
@@ -37,11 +39,13 @@
     private final String name;
     private final QName messageName;
     private WSDLMessageImpl message;
+    private WSDLOperationImpl operation;
 
-    public WSDLFaultImpl(XMLStreamReader xsr,String name, QName messageName) {
+    public WSDLFaultImpl(XMLStreamReader xsr, String name, QName messageName, WSDLOperationImpl operation) {
         super(xsr);
         this.name = name;
         this.messageName = messageName;
+        this.operation = operation;
     }
 
     public String getName() {
@@ -52,6 +56,16 @@
         return message;
     }
 
+    @NotNull
+    public WSDLOperation getOperation() {
+        return operation;
+    }
+
+    @NotNull
+    public QName getQName() {
+        return new QName(operation.getName().getNamespaceURI(), name);
+    }
+
     void freeze(WSDLModelImpl root){
         message = root.getMessage(messageName);
     }
--- old/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLInputImpl.java	Tue Aug  4 10:03:01 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLInputImpl.java	Tue Aug  4 10:03:01 2009
@@ -27,6 +27,9 @@
 
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLInput;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLMessage;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLOperation;
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
 
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLStreamReader;
@@ -64,6 +67,15 @@
         return action;
     }
 
+    @NotNull
+    public WSDLOperation getOperation() {
+        return operation;
+    }
+
+    public QName getQName() {
+        return new QName(operation.getName().getNamespaceURI(), getName());
+    }
+
     public void setAction(String action) {
         this.action = action;
     }
--- old/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLMessageImpl.java	Tue Aug  4 10:03:03 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLMessageImpl.java	Tue Aug  4 10:03:03 2009
@@ -55,7 +55,7 @@
         parts.add(part);
     }
 
-    Iterable<WSDLPartImpl> parts(){
+    public Iterable<WSDLPartImpl> parts(){
         return parts;
     }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLOutputImpl.java	Tue Aug  4 10:03:05 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLOutputImpl.java	Tue Aug  4 10:03:05 2009
@@ -27,6 +27,8 @@
 
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLMessage;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLOperation;
+import com.sun.istack.internal.NotNull;
 
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLStreamReader;
@@ -60,6 +62,16 @@
         return action;
     }
 
+    @NotNull
+    public WSDLOperation getOperation() {
+        return operation;
+    }
+
+    @NotNull
+    public QName getQName() {
+        return new QName(operation.getName().getNamespaceURI(), getName());
+    }
+
     public void setAction(String action) {
         this.action = action;
     }
--- old/src/share/classes/com/sun/xml/internal/ws/protocol/soap/MUTube.java	Tue Aug  4 10:03:08 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/protocol/soap/MUTube.java	Tue Aug  4 10:03:07 2009
@@ -103,7 +103,7 @@
                 if (!header.isIgnorable(soapVersion, roles)) {
                     QName qName = new QName(header.getNamespaceURI(), header.getLocalPart());
                     if (! knownHeaders.contains(qName)) {
-                        logger.finest("Element not understood=" + qName);
+                        logger.info("Element not understood=" + qName);
                         if (notUnderstoodHeaders == null)
                             notUnderstoodHeaders = new HashSet<QName>();
                         notUnderstoodHeaders.add(qName);
--- old/src/share/classes/com/sun/xml/internal/ws/resources/AddressingMessages.java	Tue Aug  4 10:03:10 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/AddressingMessages.java	Tue Aug  4 10:03:09 2009
@@ -182,6 +182,18 @@
         return localizer.localize(localizableNULL_MESSAGE());
     }
 
+    public static Localizable localizableACTION_NOT_SUPPORTED_EXCEPTION(Object arg0) {
+        return messageFactory.getMessage("action.not.supported.exception", arg0);
+    }
+
+    /**
+     * Action: "{0}" not supported
+     *
+     */
+    public static String ACTION_NOT_SUPPORTED_EXCEPTION(Object arg0) {
+        return localizer.localize(localizableACTION_NOT_SUPPORTED_EXCEPTION(arg0));
+    }
+
     public static Localizable localizableNON_ANONYMOUS_RESPONSE_NULL_HEADERS(Object arg0) {
         return messageFactory.getMessage("nonAnonymous.response.nullHeaders", arg0);
     }
@@ -218,6 +230,18 @@
         return localizer.localize(localizableREPLY_TO_CANNOT_PARSE());
     }
 
+    public static Localizable localizableINVALID_ADDRESSING_HEADER_EXCEPTION(Object arg0, Object arg1) {
+        return messageFactory.getMessage("invalid.addressing.header.exception", arg0, arg1);
+    }
+
+    /**
+     * Invalid WS-Addressing header: "{0}",Reason: "{1}"
+     *
+     */
+    public static String INVALID_ADDRESSING_HEADER_EXCEPTION(Object arg0, Object arg1) {
+        return localizer.localize(localizableINVALID_ADDRESSING_HEADER_EXCEPTION(arg0, arg1));
+    }
+
     public static Localizable localizableWSAW_ANONYMOUS_PROHIBITED() {
         return messageFactory.getMessage("wsaw.anonymousProhibited");
     }
@@ -242,6 +266,18 @@
         return localizer.localize(localizableNULL_WSDL_PORT());
     }
 
+    public static Localizable localizableADDRESSING_SHOULD_BE_ENABLED() {
+        return messageFactory.getMessage("addressing.should.be.enabled.");
+    }
+
+    /**
+     * Addressing is not enabled
+     *
+     */
+    public static String ADDRESSING_SHOULD_BE_ENABLED() {
+        return localizer.localize(localizableADDRESSING_SHOULD_BE_ENABLED());
+    }
+
     public static Localizable localizableNULL_ADDRESSING_VERSION() {
         return messageFactory.getMessage("null.addressing.version");
     }
@@ -254,6 +290,18 @@
         return localizer.localize(localizableNULL_ADDRESSING_VERSION());
     }
 
+    public static Localizable localizableMISSING_HEADER_EXCEPTION(Object arg0) {
+        return messageFactory.getMessage("missing.header.exception", arg0);
+    }
+
+    /**
+     * Missing WS-Addressing header: "{0}"
+     *
+     */
+    public static String MISSING_HEADER_EXCEPTION(Object arg0) {
+        return localizer.localize(localizableMISSING_HEADER_EXCEPTION(arg0));
+    }
+
     public static Localizable localizableNULL_PACKET() {
         return messageFactory.getMessage("null.packet");
     }
--- old/src/share/classes/com/sun/xml/internal/ws/resources/ClientMessages.java	Tue Aug  4 10:03:12 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/ClientMessages.java	Tue Aug  4 10:03:12 2009
@@ -198,6 +198,18 @@
         return localizer.localize(localizableUNDEFINED_PORT_TYPE(arg0));
     }
 
+    public static Localizable localizableWSDL_CONTAINS_NO_SERVICE(Object arg0) {
+        return messageFactory.getMessage("wsdl.contains.no.service", arg0);
+    }
+
+    /**
+     * WSDL {0} contains no service definition.
+     *
+     */
+    public static String WSDL_CONTAINS_NO_SERVICE(Object arg0) {
+        return localizer.localize(localizableWSDL_CONTAINS_NO_SERVICE(arg0));
+    }
+
     public static Localizable localizableINVALID_SOAP_ACTION() {
         return messageFactory.getMessage("invalid.soap.action");
     }
--- old/src/share/classes/com/sun/xml/internal/ws/resources/ModelerMessages.java	Tue Aug  4 10:03:14 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/ModelerMessages.java	Tue Aug  4 10:03:14 2009
@@ -175,7 +175,7 @@
     }
 
     /**
-     * Unable to create JAXBContext due to the security restriction
+     * Unable to create JAXBContext
      *
      */
     public static String UNABLE_TO_CREATE_JAXB_CONTEXT() {
@@ -278,4 +278,16 @@
         return localizer.localize(localizableRUNTIME_MODELER_WSFEATURE_ILLEGAL_FTRCONSTRUCTOR(arg0, arg1));
     }
 
+    public static Localizable localizableRUNTIME_MODELER_WEBMETHOD_MUST_BE_NONSTATICFINAL(Object arg0) {
+        return messageFactory.getMessage("runtime.modeler.webmethod.must.be.nonstaticfinal", arg0);
+    }
+
+    /**
+     * @WebMethod is not allowed on a static or final method {0}
+     *
+     */
+    public static String RUNTIME_MODELER_WEBMETHOD_MUST_BE_NONSTATICFINAL(Object arg0) {
+        return localizer.localize(localizableRUNTIME_MODELER_WEBMETHOD_MUST_BE_NONSTATICFINAL(arg0));
+    }
+
 }
--- old/src/share/classes/com/sun/xml/internal/ws/resources/ProviderApiMessages.java	Tue Aug  4 10:03:17 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/ProviderApiMessages.java	Tue Aug  4 10:03:16 2009
@@ -50,6 +50,18 @@
         return localizer.localize(localizableNULL_ADDRESS_SERVICE_ENDPOINT());
     }
 
+    public static Localizable localizableNO_WSDL_NO_PORT(Object arg0) {
+        return messageFactory.getMessage("no.wsdl.no.port", arg0);
+    }
+
+    /**
+     * WSDL Metadata not available to create the proxy, either Service instance or ServiceEndpointInterface {0} should have WSDL information
+     *
+     */
+    public static String NO_WSDL_NO_PORT(Object arg0) {
+        return localizer.localize(localizableNO_WSDL_NO_PORT(arg0));
+    }
+
     public static Localizable localizableNULL_SERVICE() {
         return messageFactory.getMessage("null.service");
     }
--- old/src/share/classes/com/sun/xml/internal/ws/resources/ServerMessages.java	Tue Aug  4 10:03:19 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/ServerMessages.java	Tue Aug  4 10:03:18 2009
@@ -38,6 +38,27 @@
     private final static LocalizableMessageFactory messageFactory = new LocalizableMessageFactory("com.sun.xml.internal.ws.resources.server");
     private final static Localizer localizer = new Localizer();
 
+    public static Localizable localizableRUNTIME_PARSER_WSDL_INCORRECTSERVICE(Object arg0, Object arg1) {
+        return messageFactory.getMessage("runtime.parser.wsdl.incorrectservice", arg0, arg1);
+    }
+
+    /**
+     * could not get binding from WSDL! service: {0} not found in the WSDL {1}.
+     * It could be because service name does not match WSDL''s wsdl:service name:
+     *  1. service name is not there in deployment descriptor OR
+     *  2. Either there is a typo in deployment descriptor''s service name OR
+     *  3. The computed names from @WebService do not match wsdl:service name
+     * OR
+     *  1. There is an error while parsing the wsdl and Service with name {0} is not found in the WSDLModel.
+     * Suggest doing the following:
+     *  1. Add/Correct entries for service name in deployment descriptor OR
+     *  2. Specify targetNamespace, serviceName in @WebService on the endpoint class
+     *
+     */
+    public static String RUNTIME_PARSER_WSDL_INCORRECTSERVICE(Object arg0, Object arg1) {
+        return localizer.localize(localizableRUNTIME_PARSER_WSDL_INCORRECTSERVICE(arg0, arg1));
+    }
+
     public static Localizable localizableRUNTIME_PARSER_MISSING_ATTRIBUTE_NO_LINE() {
         return messageFactory.getMessage("runtime.parser.missing.attribute.no.line");
     }
@@ -122,16 +143,16 @@
         return localizer.localize(localizableGENERATE_NON_STANDARD_WSDL());
     }
 
-    public static Localizable localizableDISPATCH_CANNOT_FIND_METHOD(Object arg0, Object arg1) {
-        return messageFactory.getMessage("dispatch.cannotFindMethod", arg0, arg1);
+    public static Localizable localizableDISPATCH_CANNOT_FIND_METHOD(Object arg0) {
+        return messageFactory.getMessage("dispatch.cannotFindMethod", arg0);
     }
 
     /**
-     * Cannot find dispatch method for {0} using "{1}"
+     * Cannot find dispatch method for {0}
      *
      */
-    public static String DISPATCH_CANNOT_FIND_METHOD(Object arg0, Object arg1) {
-        return localizer.localize(localizableDISPATCH_CANNOT_FIND_METHOD(arg0, arg1));
+    public static String DISPATCH_CANNOT_FIND_METHOD(Object arg0) {
+        return localizer.localize(localizableDISPATCH_CANNOT_FIND_METHOD(arg0));
     }
 
     public static Localizable localizableNO_CONTENT_TYPE() {
@@ -357,6 +378,18 @@
         return localizer.localize(localizableNOT_HTTP_CONTEXT_TYPE(arg0));
     }
 
+    public static Localizable localizableRUNTIME_PARSER_WSDL_NOSERVICE_IN_WSDLMODEL(Object arg0) {
+        return messageFactory.getMessage("runtime.parser.wsdl.noservice.in.wsdlmodel", arg0);
+    }
+
+    /**
+     * There is an error in processing the WSDL {0} and no valid services are found.
+     *
+     */
+    public static String RUNTIME_PARSER_WSDL_NOSERVICE_IN_WSDLMODEL(Object arg0) {
+        return localizer.localize(localizableRUNTIME_PARSER_WSDL_NOSERVICE_IN_WSDLMODEL(arg0));
+    }
+
     public static Localizable localizablePORT_NAME_REQUIRED() {
         return messageFactory.getMessage("port.name.required");
     }
@@ -393,6 +426,18 @@
         return localizer.localize(localizableRUNTIME_PARSER_WSDL_MULTIPLEBINDING(arg0, arg1, arg2));
     }
 
+    public static Localizable localizableNON_UNIQUE_DISPATCH_QNAME(Object arg0, Object arg1) {
+        return messageFactory.getMessage("non.unique.dispatch.qname", arg0, arg1);
+    }
+
+    /**
+     * Non unique body parts! In a port, as per BP 1.1 R2710 operations must have unique operation signature on the wire for successful dispatch. Methods {0} have the same request body block {1}. Method dispatching may fail, runtime will try to dispatch using SOAPAction.
+     *
+     */
+    public static String NON_UNIQUE_DISPATCH_QNAME(Object arg0, Object arg1) {
+        return localizer.localize(localizableNON_UNIQUE_DISPATCH_QNAME(arg0, arg1));
+    }
+
     public static Localizable localizableALREADY_HTTP_SERVER(Object arg0) {
         return messageFactory.getMessage("already.http.server", arg0);
     }
@@ -441,6 +486,18 @@
         return localizer.localize(localizableRUNTIME_PARSER_WRONG_ELEMENT(arg0, arg1, arg2));
     }
 
+    public static Localizable localizableRUNTIMEMODELER_INVALIDANNOTATION_ON_IMPL(Object arg0, Object arg1, Object arg2) {
+        return messageFactory.getMessage("runtimemodeler.invalidannotationOnImpl", arg0, arg1, arg2);
+    }
+
+    /**
+     * Invalid annotation: {0} on endpoint implementation class "{1}" - will be ignored. "{1}" is annotated with @WebService(endpointInterface="{2}"}, it MUST NOT be annotated with {0}, to fix it - put this annotation on the SEI {2}.
+     *
+     */
+    public static String RUNTIMEMODELER_INVALIDANNOTATION_ON_IMPL(Object arg0, Object arg1, Object arg2) {
+        return localizer.localize(localizableRUNTIMEMODELER_INVALIDANNOTATION_ON_IMPL(arg0, arg1, arg2));
+    }
+
     public static Localizable localizableRUNTIME_PARSER_WSDL_NOSERVICE() {
         return messageFactory.getMessage("runtime.parser.wsdl.noservice");
     }
@@ -538,6 +595,18 @@
         return localizer.localize(localizableRUNTIME_PARSER_CLASS_NOT_FOUND(arg0));
     }
 
+    public static Localizable localizableUNSUPPORTED_CHARSET(Object arg0) {
+        return messageFactory.getMessage("unsupported.charset", arg0);
+    }
+
+    /**
+     * Unsupported charset "{0}" in the received message''s Content-Type
+     *
+     */
+    public static String UNSUPPORTED_CHARSET(Object arg0) {
+        return localizer.localize(localizableUNSUPPORTED_CHARSET(arg0));
+    }
+
     public static Localizable localizableSTATIC_RESOURCE_INJECTION_ONLY(Object arg0, Object arg1) {
         return messageFactory.getMessage("static.resource.injection.only", arg0, arg1);
     }
--- old/src/share/classes/com/sun/xml/internal/ws/resources/WsservletMessages.java	Tue Aug  4 10:03:21 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/WsservletMessages.java	Tue Aug  4 10:03:21 2009
@@ -542,16 +542,16 @@
         return localizer.localize(localizableSERVLET_HTML_NO_INFO_AVAILABLE());
     }
 
-    public static Localizable localizableSERVLET_HTML_INFORMATION_TABLE(Object arg0, Object arg1, Object arg2) {
-        return messageFactory.getMessage("servlet.html.information.table", arg0, arg1, arg2);
+    public static Localizable localizableSERVLET_HTML_INFORMATION_TABLE(Object arg0, Object arg1) {
+        return messageFactory.getMessage("servlet.html.information.table", arg0, arg1);
     }
 
     /**
-     * <table border="0"><tr><td>Address:</td><td>{0}</td></tr><tr><td>WSDL:</td><td><a href="{0}?wsdl">{0}?wsdl</a></td></tr><tr><td>Port QName:</td><td>{1}</td></tr><tr><td>Implementation class:</td><td>{2}</td></tr></table>
+     * <table border="0"><tr><td>Address:</td><td>{0}</td></tr><tr><td>WSDL:</td><td><a href="{0}?wsdl">{0}?wsdl</a></td></tr><tr><td>Implementation class:</td><td>{1}</td></tr></table>
      *
      */
-    public static String SERVLET_HTML_INFORMATION_TABLE(Object arg0, Object arg1, Object arg2) {
-        return localizer.localize(localizableSERVLET_HTML_INFORMATION_TABLE(arg0, arg1, arg2));
+    public static String SERVLET_HTML_INFORMATION_TABLE(Object arg0, Object arg1) {
+        return localizer.localize(localizableSERVLET_HTML_INFORMATION_TABLE(arg0, arg1));
     }
 
     public static Localizable localizableSERVLET_TRACE_WRITING_FAULT_RESPONSE() {
@@ -698,6 +698,18 @@
         return localizer.localize(localizableERROR_SERVLET_CAUGHT_THROWABLE_IN_INIT(arg0));
     }
 
+    public static Localizable localizableSERVLET_HTML_ENDPOINT_TABLE(Object arg0, Object arg1) {
+        return messageFactory.getMessage("servlet.html.endpoint.table", arg0, arg1);
+    }
+
+    /**
+     * <table border="0"><tr><td>Service Name:</td><td>{0}</td></tr><tr><td>Port Name:</td><td>{1}</td></tr></table>
+     *
+     */
+    public static String SERVLET_HTML_ENDPOINT_TABLE(Object arg0, Object arg1) {
+        return localizer.localize(localizableSERVLET_HTML_ENDPOINT_TABLE(arg0, arg1));
+    }
+
     public static Localizable localizableERROR_SERVLET_CAUGHT_THROWABLE_WHILE_RECOVERING(Object arg0) {
         return messageFactory.getMessage("error.servlet.caughtThrowableWhileRecovering", arg0);
     }
@@ -1099,7 +1111,7 @@
     }
 
     /**
-     * Port Name
+     * Endpoint
      *
      */
     public static String SERVLET_HTML_COLUMN_HEADER_PORT_NAME() {
--- old/src/share/classes/com/sun/xml/internal/ws/resources/addressing.properties	Tue Aug  4 10:03:23 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/addressing.properties	Tue Aug  4 10:03:23 2009
@@ -41,6 +41,7 @@
 null.headers=No headers found when processing the server inbound request and WS-Addressing is required
 null.wsa.headers=No WS-Addressing headers found processing the server inbound request
 addressing.notEnabled=Addressing is not enabled, {0} should not be included in the pipeline"
+addressing.should.be.enabled.=Addressing is not enabled
 validation.client.nullAction=Validating inbound Addressing headers on client and found null Action
 validation.server.nullAction=Validating inbound Addressing headers on server and found null Action
 
@@ -50,4 +51,7 @@
 nonAnonymous.response.nullHeaders=No response headers found in non-anonymous response from "{0}"
 nonAnonymous.response.nullMessage=No message for non-anonymous response from "{0}"
 nonAnonymous.response.oneway=Ignoring non-anonymous response for one-way message
- 
+
+invalid.addressing.header.exception=Invalid WS-Addressing header: "{0}",Reason: "{1}"
+action.not.supported.exception=Action: "{0}" not supported
+missing.header.exception=Missing WS-Addressing header: "{0}"
--- old/src/share/classes/com/sun/xml/internal/ws/resources/client.properties	Tue Aug  4 10:03:26 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/client.properties	Tue Aug  4 10:03:25 2009
@@ -51,4 +51,4 @@
   Use BindingProvider.SOAPACTION_URI_PROPERTY to set it.
 failed.to.parseWithMEX=Failed to access the WSDL at: {0}. It failed with: \n\t{1}.\nRetrying with MEX gave: \n\t{2}
 failed.to.parse=Failed to access the WSDL at: {0}. It failed with: \n\t{1}.
- 
+wsdl.contains.no.service=WSDL {0} contains no service definition.
--- old/src/share/classes/com/sun/xml/internal/ws/resources/dispatch.properties	Tue Aug  4 10:03:28 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/dispatch.properties	Tue Aug  4 10:03:27 2009
@@ -39,4 +39,3 @@
 duplicate.port=WSDLPort {0} already exists. Can not create a port of the same QName.
 invalid.query.leading.char=Leading '?' of MessageContext.QUERY_STRING: {0} is not valid. Remove '?' and run again.
 duplicate.port=WSDLPort {0} already exists. Can not create a port of the same QName.
- 
--- old/src/share/classes/com/sun/xml/internal/ws/resources/encoding.properties	Tue Aug  4 10:03:30 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/encoding.properties	Tue Aug  4 10:03:30 2009
@@ -39,4 +39,3 @@
 xsd.unexpectedElementName=unexpected element name: expected={0}, actual: {1}
 
 failed.to.read.response=Failed to read a response: {0}
- 
--- old/src/share/classes/com/sun/xml/internal/ws/resources/handler.properties	Tue Aug  4 10:03:32 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/handler.properties	Tue Aug  4 10:03:32 2009
@@ -30,4 +30,3 @@
 handler.not.valid.type= {0} does not implement one of the handler interfaces.
 handler.messageContext.invalid.class= \"{0}\" is not an allowed value for the property \"{1}\"
 handler.predestroy.ignore=Exception ignored from invoking handler @PreDestroy method: {0}
- 
--- old/src/share/classes/com/sun/xml/internal/ws/resources/httpserver.properties	Tue Aug  4 10:03:34 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/httpserver.properties	Tue Aug  4 10:03:34 2009
@@ -24,4 +24,3 @@
 #
 
 unexpected.http.method=Cannot handle HTTP method: {0}
- 
--- old/src/share/classes/com/sun/xml/internal/ws/resources/modeler.properties	Tue Aug  4 10:03:37 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/modeler.properties	Tue Aug  4 10:03:36 2009
@@ -31,7 +31,8 @@
 runtime.modeler.wrapper.not.found=Wrapper class {0} is not found. Have you run APT to generate them?
 runtime.modeler.method.not.found=method: {0} could not be found on class: {1}
 runtime.modeler.webmethod.must.be.public=@WebMethod is not allowed on a non-public method {0}
-runtime.modeler.webmethod.must.be.nonstatic=@WebMethod is not allowed on a static method {0}  
+runtime.modeler.webmethod.must.be.nonstatic=@WebMethod is not allowed on a static method {0}
+runtime.modeler.webmethod.must.be.nonstaticfinal=@WebMethod is not allowed on a static or final method {0}
 runtime.modeler.oneway.operation.no.out.parameters=oneway operation should not have out parameters class: {0} method: {1}
 runtime.modeler.cannot.get.serviceName.from.interface=The serviceName cannot be retrieved from an interface.  class {0}
 runtime.modeler.portname.servicename.namespace.mismatch=The namespace of the serviceName \"{0}\" and the namespace of the portName \"{1}\" must match
@@ -38,12 +39,11 @@
 runtime.modeler.no.package=A @WebService.targetNamespace must be specified on classes with no package.  Class: {0}
 runtime.modeler.no.operations=The web service defined by the class {0} does not contain any valid WebMethods.
 runtime.modeler.mtom.conflict = Error in  @BindingType: MTOM Configuration in binding identifier {0} conflicts with feature @MTOM {1}
-runtime.modeler.feature.conflict= Feature {0} in implementation conflicts with {1} in WSDL configuration 
+runtime.modeler.feature.conflict= Feature {0} in implementation conflicts with {1} in WSDL configuration
 
 runtime.modeler.wsfeature.no.ftrconstructor=Annotation {0} is not recognizable, atleast one constructor of {1} should be marked with @FeatureConstructor
 runtime.modeler.wsfeature.morethanone.ftrconstructor=Annotation {0} is illegal, Only one constructor of {1} can be marked as @FeatureConstructor
 runtime.modeler.wsfeature.illegal.ftrconstructor=Annotation {0} is illegal, In {1} @FeatureConstructor value does n't match the constructor parameters
 
-unable.to.create.JAXBContext=Unable to create JAXBContext due to the security restriction
+unable.to.create.JAXBContext=Unable to create JAXBContext
 not.a.valid.bare.method=SEI {0} has method {1} annotated as BARE but it has more than one parameter bound to body. This is invalid. Please annotate the method with annotation: @SOAPBinding(parameterStyle=SOAPBinding.ParameterStyle.WRAPPED)
- 
--- old/src/share/classes/com/sun/xml/internal/ws/resources/providerApi.properties	Tue Aug  4 10:03:39 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/providerApi.properties	Tue Aug  4 10:03:38 2009
@@ -29,7 +29,8 @@
 null.portname=EPR does n't have EndpointName in the Metadata
 null.wsdl= EPR does n't have WSDL Metadata which is needed for the current operation
 notfound.service.in.wsdl= Service: {0} not found in WSDL: {1}
+no.wsdl.no.port = WSDL Metadata not available to create the proxy, either Service instance or \
+  ServiceEndpointInterface {0} should have WSDL information
 notfound.port.in.wsdl=Port: {0} not a valid port in Service: {1} in WSDL: {2}
 error.wsdl= Error in parsing WSDL: {0}
 null.epr= EndpointReference is null
- 
--- old/src/share/classes/com/sun/xml/internal/ws/resources/sender.properties	Tue Aug  4 10:03:41 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/sender.properties	Tue Aug  4 10:03:41 2009
@@ -27,4 +27,3 @@
 sender.request.messageNotReady=message not ready to be sent
 sender.response.cannotDecodeFaultDetail=fault detail cannot be decoded
 sender.request.illegalValueForContentNegotiation=illegal value for content negotiation property \"{0}\"
- 
--- old/src/share/classes/com/sun/xml/internal/ws/resources/server.properties	Tue Aug  4 10:03:43 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/server.properties	Tue Aug  4 10:03:43 2009
@@ -49,7 +49,7 @@
 port.name.required=Port QName is not found
 wrong.tns.for.port=Port namespace {0} doesn't match Service namespace {1}
 
-already.http.server=There is already a HTTP server at : {0} 
+already.http.server=There is already a HTTP server at : {0}
 already.https.server=There is already a HTTPS server at : {0}
 not.HttpContext.type=Required com.sun.net.httpserver.HttpContext. Got : {0}
 
@@ -73,6 +73,18 @@
 runtime.parser.wsdl.noservice=can\'t apply binding! service {0} not found in the WSDL {1}
 runtime.parser.wsdl.nobinding=can\'t apply binding! no binding found for binding ID {0] for service {1} in WSDL {2}
 runtime.parser.wsdl.multiplebinding=multiple bindings found for binding ID {0} for service {1} in WSDL {2}
+runtime.parser.wsdl.noservice.in.wsdlmodel=There is an error in processing the WSDL {0} and no valid services are found.
+runtime.parser.wsdl.incorrectservice=could not get binding from WSDL! service: {0} not found in the WSDL {1}.\n\
+  It could be because service name does not match WSDL''s wsdl:service name:\n\
+    1. service name is not there in deployment descriptor OR\n\
+    2. Either there is a typo in deployment descriptor''s service name OR\n\
+    3. The computed names from @WebService do not match wsdl:service name\n\
+  OR\n\
+    1. There is an error while parsing the wsdl and Service with name {0} is not found in the WSDLModel.\n\
+  Suggest doing the following:\n\
+    1. Add/Correct entries for service name in deployment descriptor OR \n\
+    2. Specify targetNamespace, serviceName in @WebService on the endpoint class
+
 runtime.parser.wsdl.incorrectserviceport=could not get binding from WSDL! service: {0} or port {1} not found in the WSDL {2}.\n\
   It could be because service and port names do not match WSDL''s wsdl:service and wsdl:port names:\n\
     1. service and port names are not there in deployment descriptor OR\n\
@@ -95,8 +107,16 @@
 
 dd.mtom.conflict = Error in Deployment Descriptor : MTOM Configuration in binding {0} conflicts with enable-mtom attribute value {1}
 
-dispatch.cannotFindMethod=Cannot find dispatch method for {0} using "{1}"
+dispatch.cannotFindMethod=Cannot find dispatch method for {0}
+non.unique.dispatch.qname=Non unique body parts! In a port, as per BP 1.1 R2710 operations must have unique \
+  operation signature on the wire for successful dispatch. Methods {0} have the \
+  same request body block {1}. Method dispatching may fail, runtime will try to \
+  dispatch using SOAPAction.
+
+
 unsupported.contentType=Unsupported Content-Type: {0} Supported ones are: {1}
 no.contentType=Request doesn't have a Content-Type
+unsupported.charset=Unsupported charset "{0}" in the received message''s Content-Type
 duplicate.portKnownHeader=Received SOAP message contains duplicate header: {0} for a bound parameter
- 
+
+runtimemodeler.invalidannotationOnImpl=Invalid annotation: {0} on endpoint implementation class \"{1}\" - will be ignored. \"{1}\" is annotated with @WebService(endpointInterface=\"{2}\"}, it MUST NOT be annotated with {0}, to fix it - put this annotation on the SEI {2}.
--- old/src/share/classes/com/sun/xml/internal/ws/resources/soap.properties	Tue Aug  4 10:03:45 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/soap.properties	Tue Aug  4 10:03:45 2009
@@ -28,5 +28,4 @@
 soap.protocol.invalidFaultCode=Invalid fault code: {0}
 soap.factory.create.err=Couldn''t create SOAP factory due to exception: {0}
 soap.fault.create.err=Couldn''t create SOAP Fault due to exception: {0}
-soap.version.mismatch.err=Couldn''t create SOAP message. Expecting Envelope in namespace {0}, but got {1} 
- 
+soap.version.mismatch.err=Couldn''t create SOAP message. Expecting Envelope in namespace {0}, but got {1}
--- old/src/share/classes/com/sun/xml/internal/ws/resources/streaming.properties	Tue Aug  4 10:03:48 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/streaming.properties	Tue Aug  4 10:03:47 2009
@@ -48,4 +48,3 @@
 fastinfoset.noImplementation=Unable to locate compatible implementation of Fast Infoset in classpath
 
 sourcereader.invalidSource=Unable to create reader from source \"{0}\"
- 
--- old/src/share/classes/com/sun/xml/internal/ws/resources/util.properties	Tue Aug  4 10:03:50 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/util.properties	Tue Aug  4 10:03:49 2009
@@ -31,4 +31,3 @@
 util.failed.to.find.handlerchain.file=Could not find handler chain file {1} for class {0}
 util.failed.to.parse.handlerchain.file=Could not parse handler chain file {1} for class {0}
 util.location=at line {0} of {1}
- 
--- old/src/share/classes/com/sun/xml/internal/ws/resources/wsdlmodel.properties	Tue Aug  4 10:03:52 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/wsdlmodel.properties	Tue Aug  4 10:03:51 2009
@@ -28,4 +28,3 @@
   R2001 A DESCRIPTION MUST only use the WSDL \"import\" statement to import another WSDL description.
 wsdl.portaddress.epraddress.not.match= For Port: {0}, service location {1} does not match address {2} \
   in the EndpointReference
- 
--- old/src/share/classes/com/sun/xml/internal/ws/resources/wsservlet.properties	Tue Aug  4 10:03:54 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/wsservlet.properties	Tue Aug  4 10:03:54 2009
@@ -81,7 +81,6 @@
 servlet.error.noResponseMessage=WSSERVLET23: no response message
 WSSERVLET23.diag.cause.1=The request generated no response from the service
 WSSERVLET23.diag.check.1=If a response was expected, check that a request message was actually sent
-WSSERVLET23.diag.cause.1=The request generated no response from the service
 WSSERVLET23.diag.check.2=The request may be malformed and be accepted by the service, yet did not generate a response
 
 servlet.trace.writingFaultResponse=WSSERVLET24: writing fault response
@@ -178,12 +177,13 @@
 servlet.html.title= Web Services
 servlet.html.title2=<h1>Web Services</h1>
 servlet.html.noInfoAvailable=<p>No JAX-WS context information available.</p>
-servlet.html.columnHeader.portName=Port Name
+servlet.html.columnHeader.portName=Endpoint
 servlet.html.columnHeader.status=Status
 servlet.html.columnHeader.information=Information
 servlet.html.status.active=ACTIVE
 servlet.html.status.error=ERROR
-servlet.html.information.table=<table border=\"0\"><tr><td>Address\:</td><td>{0}</td></tr><tr><td>WSDL\:</td><td><a href\="{0}?wsdl">{0}?wsdl</a></td></tr><tr><td>Port QName\:</td><td>{1}</td></tr><tr><td>Implementation class\:</td><td>{2}</td></tr></table>
+servlet.html.endpoint.table=<table border=\"0\"><tr><td>Service Name\:</td><td>{0}</td></tr><tr><td>Port Name\:</td><td>{1}</td></tr></table>
+servlet.html.information.table=<table border=\"0\"><tr><td>Address\:</td><td>{0}</td></tr><tr><td>WSDL\:</td><td><a href\="{0}?wsdl">{0}?wsdl</a></td></tr><tr><td>Implementation class\:</td><td>{1}</td></tr></table>
 servlet.html.notFound=<h1>404 Not Found: {0}</h1>
 
 
@@ -234,4 +234,3 @@
 html.rootPage.body3a=<p>A WSDL description of these ports is available <a href='
 html.rootPage.body3b='>here.</a></p>
 html.rootPage.body4=<p>This endpoint is incorrectly configured. Please check the location and contents of the configuration file.</p>
- 
--- old/src/share/classes/com/sun/xml/internal/ws/resources/xmlmessage.properties	Tue Aug  4 10:03:56 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/resources/xmlmessage.properties	Tue Aug  4 10:03:56 2009
@@ -34,4 +34,3 @@
 xml.content-type.mustbe.multipart=Content-Type needs to be Multipart/Related and with type=text/xml
 xml.invalid.content-type=Invalid Content-Type: {0}
 xml.Content-Type.parse.err=Error while parsing MimeHeaders for Content-Type
- 
--- old/src/share/classes/com/sun/xml/internal/ws/server/AbstractInstanceResolver.java	Tue Aug  4 10:03:58 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/AbstractInstanceResolver.java	Tue Aug  4 10:03:58 2009
@@ -199,35 +199,43 @@
     InjectionPlan<T,R> buildInjectionPlan(Class<? extends T> clazz, Class<R> resourceType, boolean isStatic) {
         List<InjectionPlan<T,R>> plan = new ArrayList<InjectionPlan<T,R>>();
 
-        for(Field field: clazz.getDeclaredFields()) {
-            Resource resource = field.getAnnotation(Resource.class);
-            if (resource != null) {
-                if(isInjectionPoint(resource, field.getType(),
-                    ServerMessages.localizableWRONG_FIELD_TYPE(field.getName()),resourceType)) {
+        Class<?> cl = clazz;
+        while(cl != Object.class) {
+            for(Field field: cl.getDeclaredFields()) {
+                Resource resource = field.getAnnotation(Resource.class);
+                if (resource != null) {
+                    if(isInjectionPoint(resource, field.getType(),
+                        ServerMessages.localizableWRONG_FIELD_TYPE(field.getName()),resourceType)) {
 
-                    if(isStatic && !Modifier.isStatic(field.getModifiers()))
-                        throw new WebServiceException(ServerMessages.STATIC_RESOURCE_INJECTION_ONLY(resourceType,field));
+                        if(isStatic && !Modifier.isStatic(field.getModifiers()))
+                            throw new WebServiceException(ServerMessages.STATIC_RESOURCE_INJECTION_ONLY(resourceType,field));
 
-                    plan.add(new FieldInjectionPlan<T,R>(field));
+                        plan.add(new FieldInjectionPlan<T,R>(field));
+                    }
                 }
             }
+            cl = cl.getSuperclass();
         }
 
-        for(Method method : clazz.getDeclaredMethods()) {
-            Resource resource = method.getAnnotation(Resource.class);
-            if (resource != null) {
-                Class[] paramTypes = method.getParameterTypes();
-                if (paramTypes.length != 1)
-                    throw new ServerRtException(ServerMessages.WRONG_NO_PARAMETERS(method));
-                if(isInjectionPoint(resource,paramTypes[0],
-                    ServerMessages.localizableWRONG_PARAMETER_TYPE(method.getName()),resourceType)) {
+        cl = clazz;
+        while(cl != Object.class) {
+            for(Method method : cl.getDeclaredMethods()) {
+                Resource resource = method.getAnnotation(Resource.class);
+                if (resource != null) {
+                    Class[] paramTypes = method.getParameterTypes();
+                    if (paramTypes.length != 1)
+                        throw new ServerRtException(ServerMessages.WRONG_NO_PARAMETERS(method));
+                    if(isInjectionPoint(resource,paramTypes[0],
+                        ServerMessages.localizableWRONG_PARAMETER_TYPE(method.getName()),resourceType)) {
 
-                    if(isStatic && !Modifier.isStatic(method.getModifiers()))
-                        throw new WebServiceException(ServerMessages.STATIC_RESOURCE_INJECTION_ONLY(resourceType,method));
+                        if(isStatic && !Modifier.isStatic(method.getModifiers()))
+                            throw new WebServiceException(ServerMessages.STATIC_RESOURCE_INJECTION_ONLY(resourceType,method));
 
-                    plan.add(new MethodInjectionPlan<T,R>(method));
+                        plan.add(new MethodInjectionPlan<T,R>(method));
+                    }
                 }
             }
+            cl = cl.getSuperclass();
         }
 
         return new Compositor<T,R>(plan);
--- old/src/share/classes/com/sun/xml/internal/ws/server/EndpointFactory.java	Tue Aug  4 10:04:01 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/EndpointFactory.java	Tue Aug  4 10:04:00 2009
@@ -50,6 +50,7 @@
 import com.sun.xml.internal.ws.model.SOAPSEIModel;
 import com.sun.xml.internal.ws.model.wsdl.WSDLModelImpl;
 import com.sun.xml.internal.ws.model.wsdl.WSDLPortImpl;
+import com.sun.xml.internal.ws.model.wsdl.WSDLServiceImpl;
 import com.sun.xml.internal.ws.resources.ServerMessages;
 import com.sun.xml.internal.ws.server.provider.ProviderInvokerTube;
 import com.sun.xml.internal.ws.server.sei.SEIInvokerTube;
@@ -160,7 +161,7 @@
         AbstractSEIModelImpl seiModel = null;
         // create WSDL model
         if (primaryDoc != null) {
-            wsdlPort = getWSDLPort(primaryDoc, docList, serviceName, portName);
+            wsdlPort = getWSDLPort(primaryDoc, docList, serviceName, portName, container);
         }
 
         WebServiceFeatureList features=((BindingImpl)binding).getFeatures();
@@ -184,7 +185,7 @@
             if (primaryDoc == null) {
                 primaryDoc = generateWSDL(binding, seiModel, docList, container, implType);
                 // create WSDL model
-                wsdlPort = getWSDLPort(primaryDoc, docList, serviceName, portName);
+                wsdlPort = getWSDLPort(primaryDoc, docList, serviceName, portName, container);
                 seiModel.freeze(wsdlPort);
             }
             // New Features might have been added in WSDL through Policy.
@@ -297,7 +298,7 @@
         // wsdlPort will be null, means we will generate WSDL. Hence no need to apply
         // bindings or need to look in the WSDL
         if(wsdlPort == null){
-            rap = new RuntimeModeler(implType,serviceName, binding.getBindingId());
+            rap = new RuntimeModeler(implType,serviceName, binding.getBindingId(), binding.getFeatures().toArray());
         } else {
             /*
             This not needed anymore as wsdlFeatures are merged later anyway
@@ -305,7 +306,7 @@
             applyEffectiveMtomSetting(wsdlPort.getBinding(), binding);
             */
             //now we got the Binding so lets build the model
-            rap = new RuntimeModeler(implType, serviceName, (WSDLPortImpl)wsdlPort);
+            rap = new RuntimeModeler(implType, serviceName, (WSDLPortImpl)wsdlPort, binding.getFeatures().toArray());
         }
         rap.setPortName(portName);
         return rap.buildRuntimeModel();
@@ -441,8 +442,11 @@
         }
         SDDocument.WSDL wsdlDoc = (SDDocument.WSDL)primaryDoc;
         if (!wsdlDoc.hasService()) {
-            throw new WebServiceException("Not a primary WSDL="+primaryWsdl.getSystemId()+
-                    " since it doesn't have Service "+serviceName);
+            if(wsdlDoc.getAllServices().isEmpty())
+                throw new WebServiceException("Not a primary WSDL="+primaryWsdl.getSystemId()+
+                        " since it doesn't have Service "+serviceName);
+            else
+                throw new WebServiceException("WSDL "+primaryDoc.getSystemId()+" has the following services "+wsdlDoc.getAllServices()+" but not "+serviceName+". Maybe you forgot to specify a service name in @WebService/@WebServiceProvider?");
         }
     }
 
@@ -487,17 +491,25 @@
      * @param metadata it may contain imported WSDL and schema documents
      * @param serviceName service name in wsdl
      * @param portName port name in WSDL
+     * @param container container in which this service is running
      * @return non-null wsdl port object
      */
     private static @NotNull WSDLPortImpl getWSDLPort(SDDocumentSource primaryWsdl, List<? extends SDDocumentSource> metadata,
-                                                     @NotNull QName serviceName, @NotNull QName portName) {
+                                                     @NotNull QName serviceName, @NotNull QName portName, Container container) {
         URL wsdlUrl = primaryWsdl.getSystemId();
         try {
             // TODO: delegate to another entity resolver
             WSDLModelImpl wsdlDoc = RuntimeWSDLParser.parse(
                 new Parser(primaryWsdl), new EntityResolverImpl(metadata),
-                    false, ServiceFinder.find(WSDLParserExtension.class).toArray());
-            WSDLPortImpl wsdlPort = wsdlDoc.getService(serviceName).get(portName);
+                    false, container, ServiceFinder.find(WSDLParserExtension.class).toArray());
+            if(wsdlDoc.getServices().size() == 0) {
+                throw new ServerRtException(ServerMessages.localizableRUNTIME_PARSER_WSDL_NOSERVICE_IN_WSDLMODEL(wsdlUrl));
+            }
+            WSDLServiceImpl wsdlService = wsdlDoc.getService(serviceName);
+            if (wsdlService == null) {
+                throw new ServerRtException(ServerMessages.localizableRUNTIME_PARSER_WSDL_INCORRECTSERVICE(serviceName,wsdlUrl));
+            }
+            WSDLPortImpl wsdlPort = wsdlService.get(portName);
             if (wsdlPort == null) {
                 throw new ServerRtException(ServerMessages.localizableRUNTIME_PARSER_WSDL_INCORRECTSERVICEPORT(serviceName, portName, wsdlUrl));
             }
--- old/src/share/classes/com/sun/xml/internal/ws/server/SDDocumentImpl.java	Tue Aug  4 10:04:03 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/SDDocumentImpl.java	Tue Aug  4 10:04:03 2009
@@ -25,24 +25,16 @@
 
 package com.sun.xml.internal.ws.server;
 
-import com.sun.xml.internal.ws.api.server.DocumentAddressResolver;
-import com.sun.xml.internal.ws.api.server.PortAddressResolver;
-import com.sun.xml.internal.ws.api.server.SDDocument;
-import com.sun.xml.internal.ws.api.server.SDDocumentFilter;
-import com.sun.xml.internal.ws.api.server.SDDocumentSource;
-import com.sun.xml.internal.ws.api.server.WSEndpoint;
+import com.sun.xml.internal.ws.api.server.*;
 import com.sun.xml.internal.ws.api.streaming.XMLStreamWriterFactory;
 import com.sun.xml.internal.ws.streaming.XMLStreamReaderUtil;
+import com.sun.xml.internal.ws.util.RuntimeVersion;
+import com.sun.xml.internal.ws.util.xml.XMLStreamReaderToXMLStreamWriter;
 import com.sun.xml.internal.ws.wsdl.parser.ParserUtil;
 import com.sun.xml.internal.ws.wsdl.parser.WSDLConstants;
-import com.sun.xml.internal.ws.util.RuntimeVersion;
 
 import javax.xml.namespace.QName;
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamConstants;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.stream.XMLStreamWriter;
+import javax.xml.stream.*;
 import javax.xml.ws.WebServiceException;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -61,11 +53,12 @@
  * @author Kohsuke Kawaguchi
  * @author Jitendra Kotamraju
  */
-class SDDocumentImpl extends SDDocumentSource implements SDDocument {
+public class SDDocumentImpl extends SDDocumentSource implements SDDocument {
 
     private static final String NS_XSD = "http://www.w3.org/2001/XMLSchema";
     private static final QName SCHEMA_INCLUDE_QNAME = new QName(NS_XSD, "include");
     private static final QName SCHEMA_IMPORT_QNAME = new QName(NS_XSD, "import");
+    private static final QName SCHEMA_REDEFINE_QNAME = new QName(NS_XSD, "redefine");
     private static final String VERSION_COMMENT =
         " Published by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is "+RuntimeVersion.VERSION+". ";
 
@@ -98,7 +91,8 @@
                          if (reader.getEventType() != XMLStreamConstants.START_ELEMENT)
                             continue;
                         QName name = reader.getName();
-                        if (SCHEMA_INCLUDE_QNAME.equals(name) || SCHEMA_IMPORT_QNAME.equals(name)) {
+                        if (SCHEMA_INCLUDE_QNAME.equals(name) || SCHEMA_IMPORT_QNAME.equals(name) ||
+                                SCHEMA_REDEFINE_QNAME.equals(name)) {
                             String importedDoc = reader.getAttributeValue(null, "schemaLocation");
                             if (importedDoc != null) {
                                 importedDocs.add(new URL(src.getSystemId(), importedDoc).toString());
@@ -112,6 +106,7 @@
                     boolean hasPortType = false;
                     boolean hasService = false;
                     Set<String> importedDocs = new HashSet<String>();
+                    Set<QName> allServices = new HashSet<QName>();
 
                     // if WSDL, parse more
                     while (XMLStreamReaderUtil.nextContent(reader) != XMLStreamConstants.END_DOCUMENT) {
@@ -129,6 +124,7 @@
                         } else if (WSDLConstants.QNAME_SERVICE.equals(name)) {
                             String sn = ParserUtil.getMandatoryNonEmptyAttribute(reader, WSDLConstants.ATTR_NAME);
                             QName sqn = new QName(tns,sn);
+                            allServices.add(sqn);
                             if(serviceName.equals(sqn)) {
                                 hasService = true;
                             }
@@ -137,7 +133,8 @@
                             if (importedDoc != null) {
                                 importedDocs.add(new URL(src.getSystemId(), importedDoc).toString());
                             }
-                        } else if (SCHEMA_INCLUDE_QNAME.equals(name) || SCHEMA_IMPORT_QNAME.equals(name)) {
+                        } else if (SCHEMA_INCLUDE_QNAME.equals(name) || SCHEMA_IMPORT_QNAME.equals(name) ||
+                                SCHEMA_REDEFINE_QNAME.equals(name)) {
                             String importedDoc = reader.getAttributeValue(null, "schemaLocation");
                             if (importedDoc != null) {
                                 importedDocs.add(new URL(src.getSystemId(), importedDoc).toString());
@@ -145,7 +142,7 @@
                         }
                     }
                     return new WSDLImpl(
-                        rootName,systemId,src,tns,hasPortType,hasService,importedDocs);
+                        rootName,systemId,src,tns,hasPortType,hasService,importedDocs,allServices);
                 } else {
                     return new SDDocumentImpl(rootName,systemId,src);
                 }
@@ -225,6 +222,31 @@
         return imports;
     }
 
+    public void writeTo(OutputStream os) throws IOException {
+        XMLStreamWriter w = null;
+        try {
+            //generate the WSDL with utf-8 encoding and XML version 1.0
+            w = XMLStreamWriterFactory.create(os, "UTF-8");
+            w.writeStartDocument("UTF-8", "1.0");
+            new XMLStreamReaderToXMLStreamWriter().bridge(source.read(), w);
+            w.writeEndDocument();
+        } catch (XMLStreamException e) {
+            IOException ioe = new IOException(e.getMessage());
+            ioe.initCause(e);
+            throw ioe;
+        } finally {
+            try {
+                if (w != null)
+                    w.close();
+            } catch (XMLStreamException e) {
+                IOException ioe = new IOException(e.getMessage());
+                ioe.initCause(e);
+                throw ioe;
+            }
+        }
+    }
+
+
     public void writeTo(PortAddressResolver portAddressResolver, DocumentAddressResolver resolver, OutputStream os) throws IOException {
         XMLStreamWriter w = null;
         try {
@@ -292,13 +314,15 @@
         private final String targetNamespace;
         private final boolean hasPortType;
         private final boolean hasService;
+        private final Set<QName> allServices;
 
         public WSDLImpl(QName rootName, URL url, SDDocumentSource source, String targetNamespace, boolean hasPortType,
-                        boolean hasService, Set<String> imports) {
+                        boolean hasService, Set<String> imports,Set<QName> allServices) {
             super(rootName, url, source, imports);
             this.targetNamespace = targetNamespace;
             this.hasPortType = hasPortType;
             this.hasService = hasService;
+            this.allServices = allServices;
         }
 
         public String getTargetNamespace() {
@@ -313,6 +337,10 @@
             return hasService;
         }
 
+        public Set<QName> getAllServices() {
+            return allServices;
+        }
+
         public boolean isWSDL() {
             return true;
         }
--- old/src/share/classes/com/sun/xml/internal/ws/server/StatefulInstanceResolver.java	Tue Aug  4 10:04:05 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/StatefulInstanceResolver.java	Tue Aug  4 10:04:05 2009
@@ -352,6 +352,7 @@
         String key = reverseInstances.get(o);
         if(key==null)   return; // already unexported
         instances.remove(key);
+        reverseInstances.remove(o);
     }
 
     public T resolve(EndpointReference epr) {
@@ -405,9 +406,9 @@
     /**
      * Timer that controls the instance time out. Lazily created.
      */
-    private static volatile Timer timer;
+    private volatile Timer timer;
 
-    private static synchronized void startTimer() {
+    private synchronized void startTimer() {
         if(timer==null)
             timer = new Timer("JAX-WS stateful web service timeout timer");
     }
--- old/src/share/classes/com/sun/xml/internal/ws/server/UnsupportedMediaException.java	Tue Aug  4 10:04:08 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/UnsupportedMediaException.java	Tue Aug  4 10:04:07 2009
@@ -47,6 +47,10 @@
         super(ServerMessages.localizableNO_CONTENT_TYPE());
     }
 
+    public UnsupportedMediaException(String charset) {
+        super(ServerMessages.localizableUNSUPPORTED_CHARSET(charset));
+    }
+
     public String getDefaultResourceBundleName() {
         return "com.sun.xml.internal.ws.resources.server";
     }
--- old/src/share/classes/com/sun/xml/internal/ws/server/WSDLPatcher.java	Tue Aug  4 10:04:10 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/WSDLPatcher.java	Tue Aug  4 10:04:09 2009
@@ -26,7 +26,6 @@
 
 import com.sun.xml.internal.ws.api.server.PortAddressResolver;
 import com.sun.xml.internal.ws.api.server.WSEndpoint;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
 import com.sun.xml.internal.ws.api.server.DocumentAddressResolver;
 import com.sun.xml.internal.ws.api.server.SDDocument;
 import com.sun.xml.internal.ws.util.xml.XMLStreamReaderToXMLStreamWriter;
@@ -52,6 +51,7 @@
     private static final String NS_XSD = "http://www.w3.org/2001/XMLSchema";
     private static final QName SCHEMA_INCLUDE_QNAME = new QName(NS_XSD, "include");
     private static final QName SCHEMA_IMPORT_QNAME = new QName(NS_XSD, "import");
+    private static final QName SCHEMA_REDEFINE_QNAME = new QName(NS_XSD, "redefine");
 
     private static final Logger logger = Logger.getLogger(
             com.sun.xml.internal.ws.util.Constants.LoggingDomain + ".wsdl.patcher");
@@ -76,6 +76,7 @@
     private String targetNamespace;
     private QName serviceName;
     private QName portName;
+    private String portAddress;
 
     private enum EPR_ADDRESS_STATE {IN, OUT, DONE}
     private EPR_ADDRESS_STATE eprAddressState = EPR_ADDRESS_STATE.OUT;
@@ -109,6 +110,7 @@
 
         if((name.equals(SCHEMA_INCLUDE_QNAME) && attLocalName.equals("schemaLocation"))
         || (name.equals(SCHEMA_IMPORT_QNAME)  && attLocalName.equals("schemaLocation"))
+        || (name.equals(SCHEMA_REDEFINE_QNAME)  && attLocalName.equals("schemaLocation"))
         || (name.equals(WSDLConstants.QNAME_IMPORT)  && attLocalName.equals("location"))) {
             // patch this attribute value.
 
@@ -128,10 +130,11 @@
             name.equals(WSDLConstants.NS_SOAP12_BINDING_ADDRESS)) {
 
             if(attLocalName.equals("location")) {
+                portAddress = in.getAttributeValue(i);
                 String value = getAddressLocation();
                 if (value != null) {
-                    logger.fine("Fixing service:"+serviceName+ " port:"+portName
-                            + " address with "+value);
+                    logger.fine("Service:"+serviceName+ " port:"+portName
+                            + " current address "+portAddress+" Patching it with "+value);
                     writeAttribute(i, value);
                     return;
                 }
@@ -241,6 +244,6 @@
      */
     private String getAddressLocation() {
         return (portAddressResolver == null || portName == null)
-                ? null : portAddressResolver.getAddressFor(serviceName, portName.getLocalPart());
+                ? null : portAddressResolver.getAddressFor(serviceName, portName.getLocalPart(), portAddress);
     }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/server/WSEndpointImpl.java	Tue Aug  4 10:04:12 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/WSEndpointImpl.java	Tue Aug  4 10:04:11 2009
@@ -47,6 +47,7 @@
 import com.sun.xml.internal.ws.api.pipe.TubelineAssemblerFactory;
 import com.sun.xml.internal.ws.api.server.Container;
 import com.sun.xml.internal.ws.api.server.EndpointAwareCodec;
+import com.sun.xml.internal.ws.api.server.EndpointComponent;
 import com.sun.xml.internal.ws.api.server.TransportBackChannel;
 import com.sun.xml.internal.ws.api.server.WSEndpoint;
 import com.sun.xml.internal.ws.api.server.WebServiceContextDelegate;
@@ -63,7 +64,9 @@
 import javax.xml.ws.handler.Handler;
 import java.lang.reflect.Method;
 import java.util.Arrays;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -75,6 +78,16 @@
  * @author Jitendra Kotamraju
  */
 public final class WSEndpointImpl<T> extends WSEndpoint<T> {
+    // Register JAX-WS JMX MBeans
+    static {
+        try {
+            JMXAgent.getDefault();
+        } catch (Throwable t) {
+            // Ignore for now by logging the stack trace
+            t.printStackTrace();
+        }
+    }
+
     private final @NotNull QName serviceName;
     private final @NotNull QName portName;
     private final WSBinding binding;
@@ -100,6 +113,7 @@
 
     private final Class<T> implementationClass;
     private final @Nullable WSDLProperties wsdlProperties;
+    private final Set<EndpointComponent> componentRegistry = new LinkedHashSet<EndpointComponent>();
 
     WSEndpointImpl(@NotNull QName serviceName, @NotNull QName portName, WSBinding binding,
                    Container container, SEIModel seiModel, WSDLPort port,
@@ -156,18 +170,7 @@
         return port;
     }
 
-    /**
-     * Gets the {@link SEIModel} that represents the relationship
-     * between WSDL and Java SEI.
-     *
-     * <p>
-     * This method returns a non-null value if and only if this
-     * endpoint is ultimately serving an application through an SEI.
-     *
-     * @return
-     *      maybe null. See above for more discussion.
-     *      Always the same value.
-     */
+    @Override
     public @Nullable SEIModel getSEIModel() {
         return seiModel;
     }
@@ -267,6 +270,10 @@
         return serviceDef;
     }
 
+    public Set<EndpointComponent> getComponentRegistry() {
+        return componentRegistry;
+    }
+
     private static final Logger logger = Logger.getLogger(
         com.sun.xml.internal.ws.util.Constants.LoggingDomain + ".server.endpoint");
 
--- old/src/share/classes/com/sun/xml/internal/ws/server/provider/ProviderArgumentsBuilder.java	Tue Aug  4 10:04:14 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/provider/ProviderArgumentsBuilder.java	Tue Aug  4 10:04:14 2009
@@ -74,7 +74,7 @@
 
     public static ProviderArgumentsBuilder<?> create(ProviderEndpointModel model, WSBinding binding) {
         return (binding instanceof SOAPBinding) ? SOAPProviderArgumentBuilder.create(model, binding.getSOAPVersion())
-                : XMLProviderArgumentBuilder.create(model);
+                : XMLProviderArgumentBuilder.createBuilder(model, binding);
     }
 
 }
--- old/src/share/classes/com/sun/xml/internal/ws/server/provider/XMLProviderArgumentBuilder.java	Tue Aug  4 10:04:16 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/provider/XMLProviderArgumentBuilder.java	Tue Aug  4 10:04:16 2009
@@ -56,7 +56,7 @@
         return response;
     }
 
-    static XMLProviderArgumentBuilder create(ProviderEndpointModel model) {
+    static XMLProviderArgumentBuilder createBuilder(ProviderEndpointModel model, WSBinding binding) {
         if (model.mode == Service.Mode.PAYLOAD) {
             return new PayloadSource();
         } else {
@@ -63,7 +63,7 @@
             if(model.datatype==Source.class)
                 return new PayloadSource();
             if(model.datatype== DataSource.class)
-                return new DataSourceParameter();
+                return new DataSourceParameter(binding);
             throw new WebServiceException(ServerMessages.PROVIDER_INVALID_PARAMETER_TYPE(model.implClass,model.datatype));
         }
     }
@@ -83,15 +83,20 @@
     }
 
     private static final class DataSourceParameter extends XMLProviderArgumentBuilder<DataSource> {
+        private final WSBinding binding;
+
+        DataSourceParameter(WSBinding binding) {
+            this.binding = binding;
+        }
         public DataSource getParameter(Packet packet) {
             Message msg = packet.getMessage();
             return (msg instanceof XMLMessage.MessageDataSource)
                     ? ((XMLMessage.MessageDataSource) msg).getDataSource()
-                    : XMLMessage.getDataSource(msg);
+                    : XMLMessage.getDataSource(msg, binding);
         }
 
         public Message getResponseMessage(DataSource ds) {
-            return XMLMessage.create(ds);
+            return XMLMessage.create(ds, binding);
         }
 
         protected Message getResponseMessage(Exception e) {
--- old/src/share/classes/com/sun/xml/internal/ws/server/sei/EndpointArgumentsBuilder.java	Tue Aug  4 10:04:19 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/sei/EndpointArgumentsBuilder.java	Tue Aug  4 10:04:18 2009
@@ -49,6 +49,7 @@
 import javax.xml.soap.SOAPFault;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.XMLStreamConstants;
 import javax.xml.transform.Source;
 import javax.xml.ws.Holder;
 import javax.xml.ws.WebServiceException;
@@ -219,11 +220,12 @@
             } else if(isXMLMimeType(param.getBinding().getMimeType())) {
                 return new JAXBBuilder(param, setter);
             } else {
-                throw new UnsupportedOperationException("Attachment is not mapped");
+                throw new UnsupportedOperationException("Unknown Type="+type+" Attachment is not mapped.");
             }
         }
 
         public void readRequest(Message msg, Object[] args) throws JAXBException, XMLStreamException {
+            boolean foundAttachment = false;
             // TODO not to loop
             for (Attachment att : msg.getAttachments()) {
                 String part = getWSDLPartName(att);
@@ -231,10 +233,14 @@
                     continue;
                 }
                 if(part.equals(pname) || part.equals(pname1)){
+                    foundAttachment = true;
                     mapAttachment(att, args);
                     break;
                 }
             }
+            if (!foundAttachment) {
+                throw new WebServiceException("Missing Attachment for "+pname);
+            }
         }
 
         abstract void mapAttachment(Attachment att, Object[] args) throws JAXBException;
@@ -277,10 +283,20 @@
 
         void mapAttachment(Attachment att, Object[] args) {
             Image image;
+            InputStream is = null;
             try {
-                image = ImageIO.read(att.asInputStream());
+                is = att.asInputStream();
+                image = ImageIO.read(is);
             } catch(IOException ioe) {
                 throw new WebServiceException(ioe);
+            } finally {
+                if (is != null) {
+                    try {
+                        is.close();
+                    } catch(IOException ioe) {
+                        throw new WebServiceException(ioe);
+                    }
+                }
             }
             setter.put(image, args);
         }
@@ -489,30 +505,27 @@
         }
 
         public void readRequest(Message msg, Object[] args) throws JAXBException, XMLStreamException {
-            Object retVal = null;
 
-            XMLStreamReader reader = msg.readPayload();
-            Object wrapperBean = wrapper.unmarshal(reader, (msg.getAttachments() != null) ?
-                    new AttachmentUnmarshallerImpl(msg.getAttachments()): null);
+            if (parts.length>0) {
+                XMLStreamReader reader = msg.readPayload();
+                Object wrapperBean = wrapper.unmarshal(reader, (msg.getAttachments() != null) ?
+                        new AttachmentUnmarshallerImpl(msg.getAttachments()): null);
 
-            try {
-                for (PartBuilder part : parts) {
-                    Object o = part.readResponse(args,wrapperBean);
-                    // there's only at most one EndpointArgumentsBuilder that returns a value.
-                    // TODO: reorder parts so that the return value comes at the end.
-                    if(o!=null) {
-                        assert retVal==null;
-                        retVal = o;
+                try {
+                    for (PartBuilder part : parts) {
+                        part.readRequest(args,wrapperBean);
                     }
+                } catch (AccessorException e) {
+                    // this can happen when the set method throw a checked exception or something like that
+                    throw new WebServiceException(e);    // TODO:i18n
                 }
-            } catch (AccessorException e) {
-                // this can happen when the set method throw a checked exception or something like that
-                throw new WebServiceException(e);    // TODO:i18n
-            }
 
-            // we are done with the body
-            reader.close();
-            XMLStreamReaderFactory.recycle(reader);
+                // we are done with the body
+                reader.close();
+                XMLStreamReaderFactory.recycle(reader);
+            } else {
+                msg.consume();
+            }
         }
 
         /**
@@ -535,10 +548,9 @@
                 assert accessor!=null && setter!=null;
             }
 
-            final Object readResponse( Object[] args, Object wrapperBean ) throws AccessorException {
+            final void readRequest( Object[] args, Object wrapperBean ) throws AccessorException {
                 Object obj = accessor.get(wrapperBean);
                 setter.put(obj,args);
-                return null;
             }
 
 
@@ -576,7 +588,7 @@
             XMLStreamReader reader = msg.readPayload();
             if (!reader.getName().equals(wrapperName))
                 throw new WebServiceException( // TODO: i18n
-                    "Unexpected response element "+reader.getName()+" expected: "+wrapperName);
+                    "Unexpected request element "+reader.getName()+" expected: "+wrapperName);
             reader.nextTag();
 
             while(reader.getEventType()==XMLStreamReader.START_ELEMENT) {
@@ -589,6 +601,11 @@
                 } else {
                     part.readRequest(args,reader, msg.getAttachments());
                 }
+                // skip any whitespace
+                if (reader.getEventType() != XMLStreamConstants.START_ELEMENT &&
+                        reader.getEventType() != XMLStreamConstants.END_ELEMENT) {
+                    XMLStreamReaderUtil.nextElementContent(reader);
+                }
             }
 
             // we are done with the body
@@ -623,6 +640,6 @@
     }
 
     private static boolean isXMLMimeType(String mimeType){
-        return (mimeType.equals("text/xml") || mimeType.equals("application/xml")) ? true : false;
+        return mimeType.equals("text/xml") || mimeType.equals("application/xml");
     }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/server/sei/EndpointMethodDispatcher.java	Tue Aug  4 10:04:21 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/sei/EndpointMethodDispatcher.java	Tue Aug  4 10:04:21 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: EndpointMethodDispatcher.java,v 1.1.2.5 2006/11/10 00:55:03 kohsuke Exp $
- */
 
 package com.sun.xml.internal.ws.server.sei;
 
--- old/src/share/classes/com/sun/xml/internal/ws/server/sei/EndpointMethodDispatcherGetter.java	Tue Aug  4 10:04:23 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/sei/EndpointMethodDispatcherGetter.java	Tue Aug  4 10:04:23 2009
@@ -59,6 +59,7 @@
         // even when action based dispatching is in place,
         // we still need this because clients are alowed not to use addressing headers
         dispatcherList.add(new PayloadQNameBasedDispatcher(model, binding, invokerTube));
+        dispatcherList.add(new SOAPActionBasedDispatcher(model, binding, invokerTube));
     }
 
     List<EndpointMethodDispatcher> getDispatcherList() {
--- old/src/share/classes/com/sun/xml/internal/ws/server/sei/EndpointMethodHandler.java	Tue Aug  4 10:04:25 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/sei/EndpointMethodHandler.java	Tue Aug  4 10:04:25 2009
@@ -29,8 +29,6 @@
 import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.message.Message;
 import com.sun.xml.internal.ws.api.message.Packet;
-import com.sun.xml.internal.ws.api.model.SEIModel;
-import com.sun.xml.internal.ws.encoding.soap.DeserializationException;
 import com.sun.xml.internal.ws.fault.SOAPFaultBuilder;
 import com.sun.xml.internal.ws.message.jaxb.JAXBMessage;
 import com.sun.xml.internal.ws.model.JavaMethodImpl;
@@ -41,6 +39,8 @@
 import javax.xml.bind.JAXBException;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.ws.Holder;
+import javax.xml.ws.ProtocolException;
+import javax.xml.ws.WebServiceException;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
@@ -226,19 +226,21 @@
 
 
     public Packet invoke(Packet req) {
-        // Some transports(like HTTP) may want to send response before envoking endpoint method
-        if (isOneWay && req.transportBackChannel != null) {
-            req.transportBackChannel.close();
-        }
         Message reqMsg = req.getMessage();
         Object[] args = new Object[noOfArgs];
         try {
             argumentsBuilder.readRequest(reqMsg,args);
         } catch (JAXBException e) {
-            throw new DeserializationException("failed.to.read.response",e);
+            throw new WebServiceException(e);
         } catch (XMLStreamException e) {
-            throw new DeserializationException("failed.to.read.response",e);
+            throw new WebServiceException(e);
         }
+        // Some transports(like HTTP) may want to send response before envoking endpoint method
+        // Doing this here so that after closing the response stream, cannot read
+        // request from some transports(light weight http server)
+        if (isOneWay && req.transportBackChannel != null) {
+            req.transportBackChannel.close();
+        }
         Message responseMessage;
         try {
             Object ret = owner.getInvoker(req).invoke(req, method, args);
@@ -248,11 +250,17 @@
 
             if (!(cause instanceof RuntimeException) && cause instanceof Exception) {
                 // Service specific exception
-                LOGGER.log(Level.INFO, cause.getMessage(), cause);
+                LOGGER.log(Level.FINE, cause.getMessage(), cause);
                 responseMessage = SOAPFaultBuilder.createSOAPFaultMessage(soapVersion,
                         javaMethodModel.getCheckedException(cause.getClass()), cause);
             } else {
-                LOGGER.log(Level.SEVERE, cause.getMessage(), cause);
+                if (cause instanceof ProtocolException) {
+                    // Application code may be throwing it intentionally
+                    LOGGER.log(Level.FINE, cause.getMessage(), cause);
+                } else {
+                    // Probably some bug in application code
+                    LOGGER.log(Level.SEVERE, cause.getMessage(), cause);
+                }
                 responseMessage = SOAPFaultBuilder.createSOAPFaultMessage(soapVersion, null, cause);
             }
         } catch (Exception e) {
--- old/src/share/classes/com/sun/xml/internal/ws/server/sei/PayloadQNameBasedDispatcher.java	Tue Aug  4 10:04:28 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/sei/PayloadQNameBasedDispatcher.java	Tue Aug  4 10:04:27 2009
@@ -25,7 +25,7 @@
 
 package com.sun.xml.internal.ws.server.sei;
 
-import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
 import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.message.Message;
 import com.sun.xml.internal.ws.api.message.Packet;
@@ -36,6 +36,9 @@
 import com.sun.xml.internal.ws.util.QNameMap;
 
 import javax.xml.namespace.QName;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Logger;
 
 /**
  * An {@link com.sun.xml.internal.ws.server.sei.EndpointMethodDispatcher} that uses
@@ -47,28 +50,60 @@
  * handler.
  *
  * @author Arun Gupta
+ * @author Jitendra Kotamraju
  */
 final class PayloadQNameBasedDispatcher implements EndpointMethodDispatcher {
-    private final QNameMap<EndpointMethodHandler> methodHandlers;
+    private static final Logger LOGGER = Logger.getLogger(PayloadQNameBasedDispatcher.class.getName());
+
     private static final String EMPTY_PAYLOAD_LOCAL = "";
     private static final String EMPTY_PAYLOAD_NSURI = "";
-    private WSBinding binding;
+    private static final QName EMPTY_PAYLOAD = new QName(EMPTY_PAYLOAD_NSURI, EMPTY_PAYLOAD_LOCAL);
 
+    private final QNameMap<EndpointMethodHandler> methodHandlers = new QNameMap<EndpointMethodHandler>();
+    private final QNameMap<List<String>> unique = new QNameMap<List<String>>();
+    private final WSBinding binding;
+
     public PayloadQNameBasedDispatcher(AbstractSEIModelImpl model, WSBinding binding, SEIInvokerTube invokerTube) {
         this.binding = binding;
-        methodHandlers = new QNameMap<EndpointMethodHandler>();
-        for( JavaMethodImpl m : model.getJavaMethods() ) {
-            EndpointMethodHandler handler = new EndpointMethodHandler(invokerTube,m,binding);
-            QName payloadName = model.getQNameForJM(m);     // TODO need a new method on JavaMethodImpl
-            methodHandlers.put(payloadName.getNamespaceURI(), payloadName.getLocalPart(), handler);
+        // Find if any payload QNames repeat for operations
+        for(JavaMethodImpl m : model.getJavaMethods()) {
+            QName name = m.getRequestPayloadName();
+            if (name == null)
+                name = EMPTY_PAYLOAD;
+            List<String> methods = unique.get(name);
+            if (methods == null) {
+                methods = new ArrayList<String>();
+                unique.put(name, methods);
+            }
+            methods.add(m.getMethod().getName());
         }
+
+        // Log warnings about non unique payload QNames
+        for(QNameMap.Entry<List<String>> e : unique.entrySet()) {
+            if (e.getValue().size() > 1) {
+                LOGGER.warning(ServerMessages.NON_UNIQUE_DISPATCH_QNAME(e.getValue(), e.createQName()));
+            }
+        }
+
+        for( JavaMethodImpl m : model.getJavaMethods()) {
+            QName name = m.getRequestPayloadName();
+            if (name == null)
+                name = EMPTY_PAYLOAD;
+            // Set up method handlers only for unique QNames. So that dispatching
+            // happens consistently for a method
+            if (unique.get(name).size() == 1) {
+                methodHandlers.put(name, new EndpointMethodHandler(invokerTube,m,binding));
+            }
+        }
     }
 
     /**
-     * {@link PayloadQNameBasedDispatcher} never returns null because this is always
-     * the last {@link EndpointMethodHandler} to kick in.
+     *
+     * @return not null if it finds a unique handler for the request
+     *         null otherwise
+     * @throws DispatchException if the payload itself is incorrect
      */
-    public @NotNull EndpointMethodHandler getEndpointMethodHandler(Packet request) throws DispatchException {
+    public @Nullable EndpointMethodHandler getEndpointMethodHandler(Packet request) throws DispatchException {
         Message message = request.getMessage();
         String localPart = message.getPayloadLocalPart();
         String nsUri;
@@ -77,18 +112,19 @@
             nsUri = EMPTY_PAYLOAD_NSURI;
         } else {
             nsUri = message.getPayloadNamespaceURI();
+            if(nsUri == null)
+                nsUri = EMPTY_PAYLOAD_NSURI;
         }
+        EndpointMethodHandler mh = methodHandlers.get(nsUri, localPart);
 
-        EndpointMethodHandler h = methodHandlers.get(nsUri, localPart);
-
-        if (h==null) {
+        // Check if payload itself is correct. Usually it is, so let us check last
+        if (mh == null && !unique.containsKey(nsUri,localPart)) {
             String dispatchKey = "{" + nsUri + "}" + localPart;
-            String faultString = ServerMessages.DISPATCH_CANNOT_FIND_METHOD(dispatchKey, "Payload QName-based Dispatcher");
+            String faultString = ServerMessages.DISPATCH_CANNOT_FIND_METHOD(dispatchKey);
             throw new DispatchException(SOAPFaultBuilder.createSOAPFaultMessage(
-                binding.getSOAPVersion(), faultString, binding.getSOAPVersion().faultCodeClient));
+                 binding.getSOAPVersion(), faultString, binding.getSOAPVersion().faultCodeClient));
         }
-
-        return h;
+        return mh;
     }
 
 }
--- old/src/share/classes/com/sun/xml/internal/ws/server/sei/SEIInvokerTube.java	Tue Aug  4 10:04:30 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/sei/SEIInvokerTube.java	Tue Aug  4 10:04:29 2009
@@ -34,8 +34,11 @@
 import com.sun.xml.internal.ws.client.sei.MethodHandler;
 import com.sun.xml.internal.ws.model.AbstractSEIModelImpl;
 import com.sun.xml.internal.ws.server.InvokerTube;
+import com.sun.xml.internal.ws.resources.ServerMessages;
+import com.sun.xml.internal.ws.fault.SOAPFaultBuilder;
 
 import java.util.List;
+import java.text.MessageFormat;
 
 /**
  * This pipe is used to invoke SEI based endpoints.
@@ -68,24 +71,26 @@
      * that traverses through the Pipeline to transport.
      */
     public @NotNull NextAction processRequest(@NotNull Packet req) {
-        Packet res = null;
-
-        try {
-            for (EndpointMethodDispatcher dispatcher : dispatcherList) {
-                EndpointMethodHandler handler = dispatcher.getEndpointMethodHandler(req);
-                if (handler != null) {
-                    res = handler.invoke(req);
-                    break;
-                }
+        for (EndpointMethodDispatcher dispatcher : dispatcherList) {
+            EndpointMethodHandler handler;
+            try {
+                handler = dispatcher.getEndpointMethodHandler(req);
+            } catch(DispatchException e) {
+                return doReturnWith(req.createServerResponse(e.fault, model.getPort(), null, binding));
             }
-        } catch (DispatchException e) {
-            return doReturnWith(req.createServerResponse(e.fault, model.getPort(), null, binding));
+            if (handler != null) {
+                Packet res = handler.invoke(req);
+                assert res!=null;
+                return doReturnWith(res);
+            }
         }
-
-        // PayloadQNameBasedDispatcher should throw DispatchException
-        assert res!=null;
-
-        return doReturnWith(res);
+        String err = MessageFormat.format("Request=[SOAPAction={0},Payload='{'{1}'}'{2}]",
+                req.soapAction,req.getMessage().getPayloadNamespaceURI(),
+                req.getMessage().getPayloadLocalPart());
+        String faultString = ServerMessages.DISPATCH_CANNOT_FIND_METHOD(err);
+        Message faultMsg = SOAPFaultBuilder.createSOAPFaultMessage(
+            binding.getSOAPVersion(), faultString, binding.getSOAPVersion().faultCodeClient);
+        return doReturnWith(req.createServerResponse(faultMsg, model.getPort(), null, binding));
     }
 
     public @NotNull NextAction processResponse(@NotNull Packet response) {
--- old/src/share/classes/com/sun/xml/internal/ws/spi/ProviderImpl.java	Tue Aug  4 10:04:32 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/spi/ProviderImpl.java	Tue Aug  4 10:04:32 2009
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,12 +27,15 @@
 
 import com.sun.xml.internal.ws.api.BindingID;
 import com.sun.xml.internal.ws.api.WSService;
-import com.sun.xml.internal.ws.api.server.*;
-import com.sun.xml.internal.ws.api.server.Container;
 import com.sun.xml.internal.ws.api.addressing.AddressingVersion;
 import com.sun.xml.internal.ws.api.addressing.WSEndpointReference;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLService;
+import com.sun.xml.internal.ws.api.server.BoundEndpoint;
+import com.sun.xml.internal.ws.api.server.Container;
+import com.sun.xml.internal.ws.api.server.ContainerResolver;
+import com.sun.xml.internal.ws.api.server.Module;
+import com.sun.xml.internal.ws.api.server.WSEndpoint;
 import com.sun.xml.internal.ws.api.wsdl.parser.WSDLParserExtension;
 import com.sun.xml.internal.ws.client.WSServiceDelegate;
 import com.sun.xml.internal.ws.developer.MemberSubmissionEndpointReference;
@@ -51,7 +54,11 @@
 import javax.xml.namespace.QName;
 import javax.xml.transform.Source;
 import javax.xml.transform.stream.StreamSource;
-import javax.xml.ws.*;
+import javax.xml.ws.Endpoint;
+import javax.xml.ws.EndpointReference;
+import javax.xml.ws.Service;
+import javax.xml.ws.WebServiceException;
+import javax.xml.ws.WebServiceFeature;
 import javax.xml.ws.spi.Provider;
 import javax.xml.ws.spi.ServiceDelegate;
 import javax.xml.ws.wsaddressing.W3CEndpointReference;
@@ -131,12 +138,12 @@
     }
 
     public W3CEndpointReference createW3CEndpointReference(String address, QName serviceName, QName portName, List<Element> metadata, String wsdlDocumentLocation, List<Element> referenceParameters) {
+        Container container = ContainerResolver.getInstance().getContainer();
         if (address == null) {
             if (serviceName == null || portName == null) {
                 throw new IllegalStateException(ProviderApiMessages.NULL_ADDRESS_SERVICE_ENDPOINT());
             } else {
                 //check if it is run in a Java EE Container and if so, get address using serviceName and portName
-                Container container = ContainerResolver.getInstance().getContainer();
                 Module module = container.getSPI(Module.class);
                 if (module != null) {
                     List<BoundEndpoint> beList = module.getBoundEndpoints();
@@ -168,7 +175,7 @@
 
                 URL wsdlLoc = new URL(wsdlDocumentLocation);
                 WSDLModelImpl wsdlDoc = RuntimeWSDLParser.parse(wsdlLoc, new StreamSource(wsdlLoc.toExternalForm()), er,
-                        false, ServiceFinder.find(WSDLParserExtension.class).toArray());
+                        false, container, ServiceFinder.find(WSDLParserExtension.class).toArray());
                 if (serviceName != null) {
                     WSDLService wsdlService = wsdlDoc.getService(serviceName);
                     if (wsdlService == null)
--- old/src/share/classes/com/sun/xml/internal/ws/streaming/DOMStreamReader.java	Tue Aug  4 10:04:34 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/streaming/DOMStreamReader.java	Tue Aug  4 10:04:34 2009
@@ -115,12 +115,6 @@
     private int depth = 0;
 
     /**
-     * Flag indicating if {@link #_namedNodeMap} is already split into
-     * {@link #_currentAttributes} and {@link Scope#currentNamespaces}.
-     */
-    boolean _needAttributesSplit;
-
-    /**
      * State of this reader. Any of the valid states defined in StAX'
      * XMLStreamConstants class.
      */
@@ -254,9 +248,6 @@
      * to attributes-proper and namespace decls.
      */
     private void splitAttributes() {
-        if (!_needAttributesSplit) return;
-        _needAttributesSplit = false;
-
         // Clear attribute and namespace lists
         _currentAttributes.clear();
 
@@ -281,7 +272,8 @@
         ensureNs(_current);
         for( int i=_currentAttributes.size()-1; i>=0; i-- ) {
             Attr a = _currentAttributes.get(i);
-            ensureNs(a);
+            if(fixNull(a.getNamespaceURI()).length()>0)
+                ensureNs(a);    // no need to declare "" for attributes in the default namespace
         }
     }
 
@@ -312,8 +304,10 @@
                 return; // declared correctly
         }
 
-        // needs to be declared
+        if(prefix.equals("xml") || prefix.equals("xmlns"))
+            return; // implicitly declared namespaces
 
+        // needs to be declared
         scope.additionalNamespaces.add(prefix);
         scope.additionalNamespaces.add(uri);
     }
@@ -322,7 +316,7 @@
      * Allocate new {@link Scope} for {@link #splitAttributes()}.
      */
     private Scope allocateScope() {
-        if(scopes.length==depth) {
+        if(scopes.length==++depth) {
             Scope[] newBuf = new Scope[scopes.length*2];
             System.arraycopy(scopes,0,newBuf,0,scopes.length);
             scopes = newBuf;
@@ -337,10 +331,8 @@
     }
 
     public int getAttributeCount() {
-        if (_state == START_ELEMENT) {
-            splitAttributes();
+        if (_state == START_ELEMENT)
             return _currentAttributes.size();
-        }
         throw new IllegalStateException("DOMStreamReader: getAttributeCount() called in illegal state");
     }
 
@@ -349,8 +341,6 @@
      */
     public String getAttributeLocalName(int index) {
         if (_state == START_ELEMENT) {
-            splitAttributes();
-
             String localName = _currentAttributes.get(index).getLocalName();
             return (localName != null) ? localName :
                 QName.valueOf(_currentAttributes.get(index).getNodeName()).getLocalPart();
@@ -363,8 +353,6 @@
      */
     public QName getAttributeName(int index) {
         if (_state == START_ELEMENT) {
-            splitAttributes();
-
             Node attr = _currentAttributes.get(index);
             String localName = attr.getLocalName();
             if (localName != null) {
@@ -381,7 +369,6 @@
 
     public String getAttributeNamespace(int index) {
         if (_state == START_ELEMENT) {
-            splitAttributes();
             String uri = _currentAttributes.get(index).getNamespaceURI();
             return fixNull(uri);
         }
@@ -390,7 +377,6 @@
 
     public String getAttributePrefix(int index) {
         if (_state == START_ELEMENT) {
-            splitAttributes();
             String prefix = _currentAttributes.get(index).getPrefix();
             return fixNull(prefix);
         }
@@ -406,7 +392,6 @@
 
     public String getAttributeValue(int index) {
         if (_state == START_ELEMENT) {
-            splitAttributes();
             return _currentAttributes.get(index).getNodeValue();
         }
         throw new IllegalStateException("DOMStreamReader: getAttributeValue() called in illegal state");
@@ -414,7 +399,6 @@
 
     public String getAttributeValue(String namespaceURI, String localName) {
         if (_state == START_ELEMENT) {
-            splitAttributes();
             if (_namedNodeMap != null) {
                 Node attr = _namedNodeMap.getNamedItemNS(namespaceURI, localName);
                 return attr != null ? attr.getNodeValue() : null;
@@ -489,7 +473,6 @@
      */
     private Scope getCheckedScope() {
         if (_state == START_ELEMENT || _state == END_ELEMENT) {
-            splitAttributes();
             return scopes[depth];
         }
         throw new IllegalStateException("DOMStreamReader: neither on START_ELEMENT nor END_ELEMENT");
@@ -532,7 +515,6 @@
         }
 
         // check scopes
-        splitAttributes();
         String nsUri = scopes[depth].getNamespaceURI(prefix);
         if(nsUri!=null)    return nsUri;
 
@@ -562,7 +544,6 @@
         }
 
         // check scopes
-        splitAttributes();
         String prefix = scopes[depth].getPrefix(nsUri);
         if(prefix!=null)    return prefix;
 
@@ -754,18 +735,24 @@
     public int next() throws XMLStreamException {
         while(true) {
             int r = _next();
-            if(r!=CHARACTERS)   return r;
+            switch (r) {
+            case CHARACTERS:
+                // if we are currently at text node, make sure that this is a meaningful text node.
+                Node prev = _current.getPreviousSibling();
+                if(prev!=null && prev.getNodeType()==Node.TEXT_NODE)
+                    continue;   // nope. this is just a continuation of previous text that should be invisible
 
-            // if we are currently at text node, make sure that this is a meaningful text node.
-            Node prev = _current.getPreviousSibling();
-            if(prev!=null && prev.getNodeType()==Node.TEXT_NODE)
-                continue;   // nope. this is just a continuation of previous text that should be invisible
-
-            Text t = (Text)_current;
-            wholeText = t.getWholeText();
-            if(wholeText.length()==0)
-                continue;   // nope. this is empty text.
-            return CHARACTERS;
+                Text t = (Text)_current;
+                wholeText = t.getWholeText();
+                if(wholeText.length()==0)
+                    continue;   // nope. this is empty text.
+                return CHARACTERS;
+            case START_ELEMENT:
+                splitAttributes();
+                return START_ELEMENT;
+            default:
+                return r;
+            }
         }
     }
 
@@ -772,9 +759,6 @@
     private int _next() throws XMLStreamException {
         Node child;
 
-        // Indicate that attributes still need processing
-        _needAttributesSplit = true;
-
         switch (_state) {
             case END_DOCUMENT:
                 throw new IllegalStateException("DOMStreamReader: Calling next() at END_DOCUMENT");
@@ -793,8 +777,6 @@
                     return (_state = mapNodeTypeToState(_current.getNodeType()));
                 }
             case START_ELEMENT:
-                depth++;
-
                 child = _current.getFirstChild();
                 if (child == null) {
                     return (_state = END_ELEMENT);
--- old/src/share/classes/com/sun/xml/internal/ws/streaming/XMLReaderException.java	Tue Aug  4 10:04:37 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/streaming/XMLReaderException.java	Tue Aug  4 10:04:36 2009
@@ -32,7 +32,6 @@
  * <p> XMLReaderException represents an exception that occurred while reading an
  * XML document. </p>
  *
- * @see XMLReader
  * @see JAXWSExceptionBase
  *
  * @author WS Development Team
--- old/src/share/classes/com/sun/xml/internal/ws/streaming/XMLStreamReaderUtil.java	Tue Aug  4 10:04:39 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/streaming/XMLStreamReaderUtil.java	Tue Aug  4 10:04:38 2009
@@ -29,6 +29,7 @@
 import static javax.xml.stream.XMLStreamConstants.*;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.XMLStreamConstants;
 
 /**
  * <p> XMLStreamReaderUtil provides some utility methods intended to be used
@@ -46,6 +47,16 @@
             reader.close();
         } catch (XMLStreamException e) {
             throw wrapException(e);
+        }
+    }
+
+    public static void readRest(XMLStreamReader reader) {
+        try {
+            while(reader.getEventType() != XMLStreamConstants.END_DOCUMENT) {
+                reader.next();
+            }
+        } catch (XMLStreamException e) {
+            throw wrapException(e);
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/ws/streaming/XMLStreamWriterUtil.java	Tue Aug  4 10:04:41 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/streaming/XMLStreamWriterUtil.java	Tue Aug  4 10:04:41 2009
@@ -53,28 +53,39 @@
      * @throws XMLStreamException if any of writer operations throw the exception
      */
     public static @Nullable OutputStream getOutputStream(XMLStreamWriter writer) throws XMLStreamException {
-        // SJSXP
+        Object obj = null;
+
+        // Hack for JDK6's SJSXP
         if (writer instanceof Map) {
-            Object obj = ((Map) writer).get("sjsxp-outputstream");
-            if (obj != null) {
-                writer.writeCharacters("");  // Force completion of open elems
-                return (OutputStream)obj;
-            }
+            obj = ((Map) writer).get("sjsxp-outputstream");
         }
+
         // woodstox
-        try {
-            Object obj = writer.getProperty("com.ctc.wstx.outputUnderlyingStream");
-            if (obj != null) {
-                writer.writeCharacters("");  // Force completion of open elems
-                writer.flush();
-                return (OutputStream)obj;
+        if (obj == null) {
+            try {
+                obj = writer.getProperty("com.ctc.wstx.outputUnderlyingStream");
+            } catch(Exception ie) {
+                // Catch all exceptions. SJSXP in JDK throws NPE
+                // nothing to do here
             }
-        } catch(Exception ie) {
-            //Above property lookup causes NPE on JDK6u1, should be ignored.
-            // We should not fail due to such lookups.
+        }
 
-            // nothing to do here
+        // SJSXP
+        if (obj == null) {
+            try {
+                obj = writer.getProperty("http://java.sun.com/xml/stream/properties/outputstream");
+            } catch(Exception ie) {
+                // Catch all exceptions. SJSXP in JDK throws NPE
+                // nothing to do here
+            }
         }
+
+
+        if (obj != null) {
+            writer.writeCharacters("");  // Force completion of open elems
+            writer.flush();
+            return (OutputStream)obj;
+        }
         return null;
     }
 
--- old/src/share/classes/com/sun/xml/internal/ws/transport/Headers.java	Tue Aug  4 10:04:43 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/Headers.java	Tue Aug  4 10:04:43 2009
@@ -208,4 +208,9 @@
     public int hashCode() {
         return map.hashCode();
     }
+
+    @Override
+    public String toString() {
+        return map.toString();
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/transport/http/DeploymentDescriptorParser.java	Tue Aug  4 10:04:46 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/DeploymentDescriptorParser.java	Tue Aug  4 10:04:45 2009
@@ -28,8 +28,8 @@
 import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.ws.api.BindingID;
 import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.message.Packet;
 import com.sun.xml.internal.ws.api.server.Container;
-import com.sun.xml.internal.ws.api.server.InstanceResolver;
 import com.sun.xml.internal.ws.api.server.SDDocumentSource;
 import com.sun.xml.internal.ws.api.server.WSEndpoint;
 import com.sun.xml.internal.ws.api.streaming.XMLStreamReaderFactory;
@@ -74,7 +74,7 @@
  * Parses {@code sun-jaxws.xml} into {@link WSEndpoint}.
  *
  * <p>
- * Since {@code sun-jaxws.xml} captures more information that what {@link WSEndpoint}
+ * Since {@code sun-jaxws.xml} captures more information than what {@link WSEndpoint}
  * represents (in particular URL pattern and name), this class
  * takes a parameterization 'A' so that the user of this parser can choose to
  * create another type that wraps {@link WSEndpoint}.
@@ -171,6 +171,8 @@
         if (paths != null) {
             for (String path : paths) {
                 if (path.endsWith("/")) {
+                    if(path.endsWith("/CVS/") || path.endsWith("/.svn/"))
+                        continue;
                     collectDocs(path);
                 } else {
                     URL res = loader.getResource(path);
@@ -239,7 +241,7 @@
             ensureNoContent(reader);
             WSEndpoint<?> endpoint = WSEndpoint.create(
                     implementorClass, !handlersSetInDD,
-                    InstanceResolver.createDefault(implementorClass).createInvoker(),
+                    null,
                     serviceName, portName, container, binding,
                     primaryWSDL, docs.values(), createEntityResolver(),false
             );
@@ -520,6 +522,7 @@
         }
     }
 
+
     /**
      * Loads the class of the given name.
      *
--- old/src/share/classes/com/sun/xml/internal/ws/transport/http/HttpAdapter.java	Tue Aug  4 10:04:48 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/HttpAdapter.java	Tue Aug  4 10:04:47 2009
@@ -36,7 +36,10 @@
 import com.sun.xml.internal.ws.api.pipe.ContentType;
 import com.sun.xml.internal.ws.api.server.AbstractServerAsyncTransport;
 import com.sun.xml.internal.ws.api.server.Adapter;
+import com.sun.xml.internal.ws.api.server.BoundEndpoint;
 import com.sun.xml.internal.ws.api.server.DocumentAddressResolver;
+import com.sun.xml.internal.ws.api.server.EndpointComponent;
+import com.sun.xml.internal.ws.api.server.Module;
 import com.sun.xml.internal.ws.api.server.PortAddressResolver;
 import com.sun.xml.internal.ws.api.server.SDDocument;
 import com.sun.xml.internal.ws.api.server.ServiceDefinition;
@@ -48,7 +51,9 @@
 import com.sun.xml.internal.ws.server.UnsupportedMediaException;
 import com.sun.xml.internal.ws.util.ByteArrayBuffer;
 
+import javax.xml.ws.Binding;
 import javax.xml.ws.WebServiceException;
+import javax.xml.ws.http.HTTPBinding;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -93,6 +98,12 @@
     public final HttpAdapterList<? extends HttpAdapter> owner;
 
     /**
+     * Servlet URL pattern with which this {@link HttpAdapter} is associated.
+     */
+    public final String urlPattern;
+
+
+    /**
      * Creates a lone {@link HttpAdapter} that does not know of any other
      * {@link HttpAdapter}s.
      *
@@ -106,9 +117,18 @@
         return new DummyList().createAdapter("","",endpoint);
     }
 
+    /**
+     * @deprecated
+     *      remove as soon as we can update the test util.
+     */
     protected HttpAdapter(WSEndpoint endpoint, HttpAdapterList<? extends HttpAdapter> owner) {
+        this(endpoint,owner,null);
+    }
+
+    protected HttpAdapter(WSEndpoint endpoint, HttpAdapterList<? extends HttpAdapter> owner, String urlPattern) {
         super(endpoint);
         this.owner = owner;
+        this.urlPattern = urlPattern;
 
         // fill in WSDL map
         ServiceDefinition sdef = this.endpoint.getServiceDefinition();
@@ -150,6 +170,18 @@
         }
     }
 
+    /**
+     * Returns the "/abc/def/ghi" portion if
+     * the URL pattern is "/abc/def/ghi/*".
+     */
+    public String getValidPath() {
+        if (urlPattern.endsWith("/*")) {
+            return urlPattern.substring(0, urlPattern.length() - 2);
+        } else {
+            return urlPattern;
+        }
+    }
+
     protected HttpToolkit createToolkit() {
         return new HttpToolkit();
     }
@@ -173,6 +205,29 @@
      * @throws IOException when I/O errors happen
      */
     public void handle(@NotNull WSHTTPConnection connection) throws IOException {
+        if(connection.getRequestMethod().equals("GET")) {
+            // metadata query. let the interceptor run
+            for( EndpointComponent c : endpoint.getComponentRegistry() ) {
+                HttpMetadataPublisher spi = c.getSPI(HttpMetadataPublisher.class);
+                if(spi!=null && spi.handleMetadataRequest(this,connection))
+                    return; // handled
+            }
+
+            if (isMetadataQuery(connection.getQueryString())) {
+                // Sends published WSDL and schema documents as the default action.
+                publishWSDL(connection);
+                return;
+            }
+
+            Binding binding = getEndpoint().getBinding();
+            if (!(binding instanceof HTTPBinding)) {
+                // Writes HTML page with all the endpoint descriptions
+                writeWebServicesHtmlPage(connection);
+                return;
+            }
+        }
+
+        // normal request handling
         HttpToolkit tk = pool.take();
         try {
             tk.handle(connection);
@@ -194,7 +249,7 @@
         String ct = con.getRequestHeader("Content-Type");
         InputStream in = con.getInput();
         Packet packet = new Packet();
-        packet.soapAction = con.getRequestHeader("SOAPAction");
+        packet.soapAction = fixQuotesAroundSoapAction(con.getRequestHeader("SOAPAction"));
         packet.wasTransportSecure = con.isSecure();
         packet.acceptableMimeTypes = con.getRequestHeader("Accept");
         packet.addSatellite(con);
@@ -204,6 +259,7 @@
         if (dump) {
             ByteArrayBuffer buf = new ByteArrayBuffer();
             buf.write(in);
+            in.close();
             dump(buf, "HTTP request", con.getRequestHeaders());
             in = buf.newInputStream();
         }
@@ -211,9 +267,27 @@
         return packet;
     }
 
+    /**
+     * Some stacks may send non WS-I BP 1.2 conformant SoapAction.
+     * Make sure SOAPAction is quoted as {@link Packet#soapAction} expectsa quoted soapAction value.
+     *
+     * @param soapAction SoapAction HTTP Header
+     * @return
+     */
+    private String fixQuotesAroundSoapAction(String soapAction) {
+        if(soapAction != null && (!soapAction.startsWith("\"") || !soapAction.endsWith("\"")) ) {
+            LOGGER.warning("Received WS-I BP non-conformant Unquoted SoapAction HTTP header: "+ soapAction);
+            String fixedSoapAction = soapAction;
+            if(!soapAction.startsWith("\""))
+                fixedSoapAction = "\"" + fixedSoapAction;
+            if(!soapAction.endsWith("\""))
+                fixedSoapAction = fixedSoapAction + "\"";
+            return fixedSoapAction;
+        }
+        return soapAction;
+    }
 
 
-
     private void encodePacket(@NotNull Packet packet, @NotNull WSHTTPConnection con, @NotNull Codec codec) throws IOException {
         if (con.isClosed()) {
             return;                 // Connection is already closed
@@ -347,7 +421,12 @@
         public void close() {
             if(!con.isClosed()) {
                 // close the response channel now
-                con.setStatus(WSHTTPConnection.ONEWAY);
+                if (con.getStatus() == 0) {
+                    // if the appliation didn't set the status code,
+                    // set the default one.
+                    con.setStatus(WSHTTPConnection.ONEWAY);
+                }
+
                 try {
                     con.getOutput().close(); // no payload
                 } catch (IOException e) {
@@ -360,10 +439,12 @@
 
     final class HttpToolkit extends Adapter.Toolkit {
         public void handle(WSHTTPConnection con) throws IOException {
+            boolean invoke = false;
             try {
                 Packet packet = new Packet();
                 try {
                     packet = decodePacket(con, codec);
+                    invoke = true;
                 } catch(ExceptionHasMessage e) {
                     LOGGER.log(Level.SEVERE, e.getMessage(), e);
                     packet.setMessage(e.getFaultMessage());
@@ -370,10 +451,11 @@
                 } catch(UnsupportedMediaException e) {
                     LOGGER.log(Level.SEVERE, e.getMessage(), e);
                     con.setStatus(WSHTTPConnection.UNSUPPORTED_MEDIA);
-                } catch(ServerRtException e) {
+                } catch(Exception e) {
                     LOGGER.log(Level.SEVERE, e.getMessage(), e);
+                    con.setStatus(HttpURLConnection.HTTP_INTERNAL_ERROR);
                 }
-                if (packet.getMessage() != null && !packet.getMessage().isFault()) {
+                if (invoke) {
                     try {
                         packet = head.process(packet, con.getWebServiceContextDelegate(),
                                 packet.transportBackChannel);
@@ -403,7 +485,7 @@
      * @return true for metadata requests
      *         false for web service requests
      */
-    public final boolean isMetadataQuery(String query) {
+    private boolean isMetadataQuery(String query) {
         // we intentionally return true even if documents don't exist,
         // so that they get 404.
         return query != null && (query.equals("WSDL") || query.startsWith("wsdl") || query.startsWith("xsd="));
@@ -414,24 +496,12 @@
      * in response to the GET requests to URLs like "?wsdl" or "?xsd=2".
      *
      * @param con
-     *      The connection to which the data will be sent. Must not be null.
-     * @param baseAddress
-     *      The requested base URL (such as "http://myhost:2045/foo/bar").
-     *      Used to reference other resoures. Must not be null.
-     * @param queryString
-     *      The query string given by the client (which indicates
-     *      what document to serve.) Can be null (but it causes an 404 not found.)
+     *      The connection to which the data will be sent.
      *
      * @throws IOException when I/O errors happen
      */
-    public void publishWSDL(WSHTTPConnection con, final String baseAddress, String queryString) throws IOException {
-        // Workaround for a bug in http server. Read and close InputStream
-        // TODO remove once the bug is fixed in http server
-        InputStream in = con.getInput();
-        while(in.read() != -1);
-        in.close();
-
-        SDDocument doc = wsdls.get(queryString);
+    public void publishWSDL(@NotNull WSHTTPConnection con) throws IOException {
+        SDDocument doc = wsdls.get(con.getQueryString());
         if (doc == null) {
             writeNotFoundErrorPage(con,"Invalid Request");
             return;
@@ -438,11 +508,11 @@
         }
 
         con.setStatus(HttpURLConnection.HTTP_OK);
-        con.setContentTypeResponseHeader("text/xml;charset=utf-8");
+        con.setContentTypeResponseHeader("text/xml;charset=\"utf-8\"");
 
         OutputStream os = con.getProtocol().contains("1.1") ? con.getOutput() : new Http10OutputStream(con);
 
-        final PortAddressResolver portAddressResolver = owner.createPortAddressResolver(baseAddress);
+        final PortAddressResolver portAddressResolver = owner.createPortAddressResolver(con.getBaseAddress());
         final String address = portAddressResolver.getAddressFor(endpoint.getServiceName(), endpoint.getPortName().getLocalPart());
         assert address != null;
         DocumentAddressResolver resolver = new DocumentAddressResolver() {
@@ -480,7 +550,7 @@
 
     private void writeNotFoundErrorPage(WSHTTPConnection con, String message) throws IOException {
         con.setStatus(HttpURLConnection.HTTP_NOT_FOUND);
-        con.setContentTypeResponseHeader("text/html; charset=UTF-8");
+        con.setContentTypeResponseHeader("text/html; charset=\"utf-8\"");
 
         PrintWriter out = new PrintWriter(new OutputStreamWriter(con.getOutput(),"UTF-8"));
         out.println("<html>");
@@ -502,7 +572,7 @@
     private static final class DummyList extends HttpAdapterList<HttpAdapter> {
         @Override
         protected HttpAdapter createHttpAdapter(String name, String urlPattern, WSEndpoint<?> endpoint) {
-            return new HttpAdapter(endpoint, this);
+            return new HttpAdapter(endpoint,this,urlPattern);
         }
     }
 
@@ -526,20 +596,95 @@
     }
 
     /**
+     * Generates the listing of all services.
+     */
+    private void writeWebServicesHtmlPage(WSHTTPConnection con) throws IOException {
+        if (!publishStatusPage) return;
+
+        // TODO: resurrect the ability to localize according to the current request.
+
+        // standard browsable page
+        con.setStatus(WSHTTPConnection.OK);
+        con.setContentTypeResponseHeader("text/html; charset=\"utf-8\"");
+
+        PrintWriter out = new PrintWriter(new OutputStreamWriter(con.getOutput(),"UTF-8"));
+        out.println("<html>");
+        out.println("<head><title>");
+        // out.println("Web Services");
+        out.println(WsservletMessages.SERVLET_HTML_TITLE());
+        out.println("</title></head>");
+        out.println("<body>");
+        // out.println("<h1>Web Services</h1>");
+        out.println(WsservletMessages.SERVLET_HTML_TITLE_2());
+
+        // what endpoints do we have in this system?
+        Module module = getEndpoint().getContainer().getSPI(Module.class);
+        List<BoundEndpoint> endpoints = Collections.emptyList();
+        if(module!=null) {
+            endpoints = module.getBoundEndpoints();
+        }
+
+        if (endpoints.isEmpty()) {
+            // out.println("<p>No JAX-WS context information available.</p>");
+            out.println(WsservletMessages.SERVLET_HTML_NO_INFO_AVAILABLE());
+        } else {
+            out.println("<table width='100%' border='1'>");
+            out.println("<tr>");
+            out.println("<td>");
+            // out.println("Endpoint");
+            out.println(WsservletMessages.SERVLET_HTML_COLUMN_HEADER_PORT_NAME());
+            out.println("</td>");
+
+            out.println("<td>");
+            // out.println("Information");
+            out.println(WsservletMessages.SERVLET_HTML_COLUMN_HEADER_INFORMATION());
+            out.println("</td>");
+            out.println("</tr>");
+
+            for (BoundEndpoint a : endpoints) {
+                String endpointAddress = a.getAddress(con.getBaseAddress()).toString();
+                out.println("<tr>");
+
+                out.println("<td>");
+                out.println(WsservletMessages.SERVLET_HTML_ENDPOINT_TABLE(
+                    a.getEndpoint().getServiceName(),
+                    a.getEndpoint().getPortName()
+                ));
+                out.println("</td>");
+
+                out.println("<td>");
+                out.println(WsservletMessages.SERVLET_HTML_INFORMATION_TABLE(
+                    endpointAddress,
+                    a.getEndpoint().getImplementationClass().getName()
+                ));
+                out.println("</td>");
+
+                out.println("</tr>");
+            }
+            out.println("</table>");
+        }
+        out.println("</body>");
+        out.println("</html>");
+        out.close();
+    }
+
+    /**
      * Dumps what goes across HTTP transport.
      */
-    public static boolean dump;
+    public static boolean dump = false;
 
+    public static boolean publishStatusPage = true;
+
     static {
-        boolean b;
         try {
-            b = Boolean.getBoolean(HttpAdapter.class.getName()+".dump");
+            dump = Boolean.getBoolean(HttpAdapter.class.getName()+".dump");
         } catch( Throwable t ) {
-            b = false;
         }
-        dump = b;
+        try {
+            publishStatusPage = System.getProperty(HttpAdapter.class.getName()+".publishStatusPage").equals("true");
+        } catch( Throwable t ) {
+        }
     }
 
     private static final Logger LOGGER = Logger.getLogger(HttpAdapter.class.getName());
-
 }
--- old/src/share/classes/com/sun/xml/internal/ws/transport/http/WSHTTPConnection.java	Tue Aug  4 10:04:50 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/WSHTTPConnection.java	Tue Aug  4 10:04:50 2009
@@ -214,6 +214,16 @@
     public abstract @Nullable String getPathInfo();
 
     /**
+     * Gets the absolute URL up to the context path.
+     * @return
+     *      String like "http://myhost/myapp"
+     * @since 2.1.2
+     */
+    public @NotNull String getBaseAddress() {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
      * Whether connection is HTTPS or not
      *
      * @return if the received request is on HTTPS, return true
--- old/src/share/classes/com/sun/xml/internal/ws/transport/http/client/HttpClientTransport.java	Tue Aug  4 10:04:52 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/client/HttpClientTransport.java	Tue Aug  4 10:04:52 2009
@@ -33,6 +33,7 @@
 import com.sun.xml.internal.ws.resources.ClientMessages;
 import com.sun.xml.internal.ws.transport.Headers;
 import com.sun.xml.internal.ws.developer.JAXWSProperties;
+import com.sun.xml.internal.ws.util.RuntimeVersion;
 import com.sun.istack.internal.Nullable;
 import com.sun.istack.internal.NotNull;
 
@@ -47,6 +48,8 @@
 import static javax.xml.ws.BindingProvider.SESSION_MAINTAIN_PROPERTY;
 import javax.xml.ws.WebServiceException;
 import javax.xml.ws.handler.MessageContext;
+import java.io.FilterInputStream;
+import java.io.FilterOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -72,12 +75,9 @@
             // Nothing much can be done. Intentionally left empty
         }
     }
-    private static String LAST_ENDPOINT = "";
-    private static boolean redirect = true;
-    private static final int START_REDIRECT_COUNT = 3;
-    private static int redirectCount = START_REDIRECT_COUNT;
 
     /*package*/ int statusCode;
+    /*package*/ String statusMessage;
     private final Map<String, List<String>> reqHeaders;
     private Map<String, List<String>> respHeaders = null;
 
@@ -84,10 +84,9 @@
     private OutputStream outputStream;
     private boolean https;
     private HttpURLConnection httpConnection = null;
-    private EndpointAddress endpoint = null;
-    private Packet context = null;
+    private final EndpointAddress endpoint;
+    private final Packet context;
     private CookieJar cookieJar = null;
-    private boolean isFailure = false;
     private final Integer chunkSize;
 
 
@@ -98,7 +97,7 @@
         chunkSize = (Integer)context.invocationProperties.get(JAXWSProperties.HTTP_CLIENT_STREAMING_CHUNK_SIZE);
     }
 
-    /**
+    /*
      * Prepare the stream for HTTP request
      */
     public OutputStream getOutput() {
@@ -133,32 +132,24 @@
         }
     }
 
-    /**
+    /*
      * Get the response from HTTP connection and prepare the input stream for response
      */
-    public InputStream getInput() {
+    public @Nullable InputStream getInput() {
         // response processing
 
         InputStream in;
         try {
+            saveCookieAsNeeded();
             in = readResponse();
-            String contentEncoding = httpConnection.getContentEncoding();
-            if (contentEncoding != null && contentEncoding.contains("gzip")) {
-                in = new GZIPInputStream(in);
-            }
-        } catch (IOException e) {
-            if (statusCode == HttpURLConnection.HTTP_NO_CONTENT
-                || (isFailure
-                && statusCode != HttpURLConnection.HTTP_INTERNAL_ERROR)) {
-                try {
-                    throw new ClientTransportException(ClientMessages.localizableHTTP_STATUS_CODE(
-                        statusCode, httpConnection.getResponseMessage()));
-                } catch (IOException ex) {
-                    throw new ClientTransportException(ClientMessages.localizableHTTP_STATUS_CODE(
-                        statusCode, ex));
+            if (in != null) {
+                String contentEncoding = httpConnection.getContentEncoding();
+                if (contentEncoding != null && contentEncoding.contains("gzip")) {
+                    in = new GZIPInputStream(in);
                 }
             }
-            throw new ClientTransportException(ClientMessages.localizableHTTP_CLIENT_FAILED(e),e);
+        } catch (IOException e) {
+            throw new ClientTransportException(ClientMessages.localizableHTTP_STATUS_CODE(statusCode, statusMessage), e);
         }
         return in;
     }
@@ -172,75 +163,43 @@
         return respHeaders;
     }
 
-    protected InputStream readResponse() throws IOException {
-        return (isFailure
-                ? httpConnection.getErrorStream()
-                : httpConnection.getInputStream());
-    }
-
-    /*
-     * Will throw an exception instead of returning 'false' if there is no
-     * return message to be processed (i.e., in the case of an UNAUTHORIZED
-     * response from the servlet or 404 not found)
-     */
-    /*package*/void checkResponseCode() {
+    protected @Nullable InputStream readResponse() {
+        InputStream is;
         try {
-
-            statusCode = httpConnection.getResponseCode();
-
-            if ((httpConnection.getResponseCode()
-                == HttpURLConnection.HTTP_INTERNAL_ERROR)) {
-                isFailure = true;
-                //added HTTP_ACCEPT for 1-way operations
-            } else if (
-                httpConnection.getResponseCode()
-                    == HttpURLConnection.HTTP_UNAUTHORIZED) {
-
-                // no soap message returned, so skip reading message and throw exception
-                throw new ClientTransportException(
-                    ClientMessages.localizableHTTP_CLIENT_UNAUTHORIZED(httpConnection.getResponseMessage()));
-            } else if (
-                httpConnection.getResponseCode()
-                    == HttpURLConnection.HTTP_NOT_FOUND) {
-
-                // no message returned, so skip reading message and throw exception
-                throw new ClientTransportException(
-                    ClientMessages.localizableHTTP_NOT_FOUND(httpConnection.getResponseMessage()));
-            } else if (
-                (statusCode == HttpURLConnection.HTTP_MOVED_TEMP) ||
-                    (statusCode == HttpURLConnection.HTTP_MOVED_PERM)) {
-                isFailure = true;
-
-                if (!redirect || (redirectCount <= 0)) {
-                    throw new ClientTransportException(
-                        ClientMessages.localizableHTTP_STATUS_CODE(statusCode,getStatusMessage()));
+            is = httpConnection.getInputStream();
+        } catch(IOException ioe) {
+            is = httpConnection.getErrorStream();
+        }
+        if (is == null) {
+            return is;
+        }
+        // Since StreamMessage doesn't read </s:Body></s:Envelope>, there
+        // are some bytes left in the InputStream. This confuses JDK and may
+        // not reuse underlying sockets. Hopefully JDK fixes it in its code !
+        final InputStream temp = is;
+        return new FilterInputStream(temp) {
+            // Workaround for "SJSXP XMLStreamReader.next() closes stream".
+            // So it doesn't read from the closed stream
+            boolean closed;
+            @Override
+            public void close() throws IOException {
+                if (!closed) {
+                    closed = true;
+                    byte[] buf = new byte[8192];
+                    while(temp.read(buf) != -1);
+                    super.close();
                 }
-            } else if (
-                statusCode < 200 || (statusCode >= 303 && statusCode < 500)) {
-                throw new ClientTransportException(
-                    ClientMessages.localizableHTTP_STATUS_CODE(statusCode,getStatusMessage()));
-            } else if (statusCode >= 500) {
-                isFailure = true;
             }
-        } catch (IOException e) {
-            throw new WebServiceException(e);
-        }
-        // Hack for now
-        saveCookieAsNeeded();
+        };
     }
 
-    private String getStatusMessage() throws IOException {
-        int statusCode = httpConnection.getResponseCode();
-        String message = httpConnection.getResponseMessage();
-        if (statusCode == HttpURLConnection.HTTP_CREATED
-            || (statusCode >= HttpURLConnection.HTTP_MULT_CHOICE
-            && statusCode != HttpURLConnection.HTTP_NOT_MODIFIED
-            && statusCode < HttpURLConnection.HTTP_BAD_REQUEST)) {
-            String location = httpConnection.getHeaderField("Location");
-            if (location != null)
-                message += " - Location: " + location;
+    protected void readResponseCodeAndMessage() {
+        try {
+            statusCode = httpConnection.getResponseCode();
+            statusMessage = httpConnection.getResponseMessage();
+        } catch(IOException ioe) {
+            throw new WebServiceException(ioe);
         }
-        return message;
     }
 
     protected void sendCookieAsNeeded() {
@@ -264,24 +223,16 @@
         }
     }
 
-
     private void createHttpConnection() throws IOException {
 
-        // does the client want request redirection to occur
-        String redirectProperty =
-            (String) context.invocationProperties.get(REDIRECT_REQUEST_PROPERTY);
-        if (redirectProperty != null) {
-            if (redirectProperty.equalsIgnoreCase("false"))
-                redirect = false;
-        }
-
-        checkEndpoints();
-
         httpConnection = (HttpURLConnection) endpoint.openConnection();
         if (httpConnection instanceof HttpsURLConnection) {
             https = true;
 
             boolean verification = false;
+            // TODO The above property needs to be removed in future version as the semantics of this property are not preoperly defined.
+            // One should use JAXWSProperties.HOSTNAME_VERIFIER to control the behavior
+
             // does the client want client hostname verification by the service
             String verificationProperty =
                 (String) context.invocationProperties.get(HOSTNAME_VERIFICATION_PROPERTY);
@@ -289,7 +240,8 @@
                 if (verificationProperty.equalsIgnoreCase("true"))
                     verification = true;
             }
-            if (!verification) {
+            // By default, JAX-WS should not disable any host verification.
+            if (verification) {
                 ((HttpsURLConnection) httpConnection).setHostnameVerifier(new HttpClientVerifier());
             }
 
@@ -338,6 +290,11 @@
             httpConnection.setReadTimeout(reqTimeout);
         }
 
+        Integer connectTimeout = (Integer)context.invocationProperties.get(JAXWSProperties.CONNECT_TIMEOUT);
+        if (connectTimeout != null) {
+            httpConnection.setConnectTimeout(connectTimeout);
+        }
+
         Integer chunkSize = (Integer)context.invocationProperties.get(JAXWSProperties.HTTP_CLIENT_STREAMING_CHUNK_SIZE);
         if (chunkSize != null) {
             httpConnection.setChunkedStreamingMode(chunkSize);
@@ -347,6 +304,7 @@
         for (Map.Entry<String, List<String>> entry : reqHeaders.entrySet()) {
             httpConnection.addRequestProperty(entry.getKey(), entry.getValue().get(0));
         }
+        httpConnection.addRequestProperty("User-Agent", RuntimeVersion.VERSION.toString());
     }
 
     public boolean isSecure() {
@@ -353,27 +311,6 @@
         return https;
     }
 
-    //    private void redirectRequest(HttpURLConnection httpConnection, SOAPMessageContext context) {
-//        String redirectEndpoint = httpConnection.getHeaderField("Location");
-//        if (redirectEndpoint != null) {
-//            httpConnection.disconnect();
-//            invoke(redirectEndpoint, context);
-//        } else
-//            System.out.println("redirection Failed");
-//    }
-
-    private boolean checkForRedirect(int statusCode) {
-        return (((statusCode == 301) || (statusCode == 302)) && redirect && (redirectCount-- > 0));
-    }
-
-    private void checkEndpoints() {
-        if (!LAST_ENDPOINT.equalsIgnoreCase(endpoint.toString())) {
-            redirectCount = START_REDIRECT_COUNT;
-            LAST_ENDPOINT = endpoint.toString();
-        }
-    }
-
-
     private void writeBasicAuthAsNeeded(Packet context, Map<String, List<String>> reqHeaders) {
         String user = (String) context.invocationProperties.get(BindingProvider.USERNAME_PROPERTY);
         if (user != null) {
@@ -412,48 +349,24 @@
      * is kept in memory. This wraps the ChunkedOuputStream so that it writes only small
      * chunks.
      */
-    private static final class WSChunkedOuputStream extends OutputStream {
-        final OutputStream actual;
+    private static final class WSChunkedOuputStream extends FilterOutputStream {
         final int chunkSize;
 
         WSChunkedOuputStream(OutputStream actual, int chunkSize) {
-            this.actual = actual;
+            super(actual);
             this.chunkSize = chunkSize;
         }
 
         @Override
         public void write(byte b[], int off, int len) throws IOException {
-            int sent = 0;
-            while(sent < len) {
-                int chunk = len-sent;
-                if (chunk > chunkSize) {
-                    chunk = chunkSize;
-                }
-                actual.write(b, off, chunk);
-                off += chunk;
-                sent += chunk;
+            while(len > 0) {
+                int sent = (len > chunkSize) ? chunkSize : len;
+                out.write(b, off, sent);        // don't use super.write() as it writes byte-by-byte
+                len -= sent;
+                off += sent;
             }
         }
 
-        @Override
-        public void write(byte b[]) throws IOException {
-            write(b, 0, b.length);
-        }
-
-        @Override
-        public void write(int b) throws IOException {
-            actual.write(b);
-        }
-
-        @Override
-        public void flush() throws IOException {
-            actual.flush();
-        }
-
-        @Override
-        public void close() throws IOException {
-            actual.close();
-        }
     }
 
 }
--- old/src/share/classes/com/sun/xml/internal/ws/transport/http/client/HttpTransportPipe.java	Tue Aug  4 10:04:55 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/client/HttpTransportPipe.java	Tue Aug  4 10:04:54 2009
@@ -25,19 +25,19 @@
 package com.sun.xml.internal.ws.transport.http.client;
 
 import com.sun.istack.internal.NotNull;
+import com.sun.xml.internal.ws.api.SOAPVersion;
+import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.message.Packet;
-import com.sun.xml.internal.ws.api.pipe.Codec;
-import com.sun.xml.internal.ws.api.pipe.ContentType;
-import com.sun.xml.internal.ws.api.pipe.NextAction;
-import com.sun.xml.internal.ws.api.pipe.Pipe;
-import com.sun.xml.internal.ws.api.pipe.Tube;
-import com.sun.xml.internal.ws.api.pipe.TubeCloner;
+import com.sun.xml.internal.ws.api.pipe.*;
 import com.sun.xml.internal.ws.api.pipe.helper.AbstractTubeImpl;
 import com.sun.xml.internal.ws.transport.http.WSHTTPConnection;
+import com.sun.xml.internal.ws.transport.Headers;
 import com.sun.xml.internal.ws.util.ByteArrayBuffer;
+import com.sun.xml.internal.ws.client.ClientTransportException;
+import com.sun.xml.internal.ws.resources.ClientMessages;
 
-import javax.xml.ws.BindingProvider;
 import javax.xml.ws.WebServiceException;
+import javax.xml.ws.soap.SOAPBinding;
 import javax.xml.ws.handler.MessageContext;
 import java.io.IOException;
 import java.io.InputStream;
@@ -47,18 +47,24 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.net.HttpURLConnection;
 
 /**
  * {@link Pipe} and {@link Tube} that sends a request to a remote HTTP server.
  *
+ * TODO: need to create separate HTTP transport pipes for binding. SOAP1.1, SOAP1.2,
+ * TODO: XML/HTTP differ in handling status codes.
+ *
  * @author Jitendra Kotamraju
  */
 public class HttpTransportPipe extends AbstractTubeImpl {
 
     private final Codec codec;
+    private final WSBinding binding;
 
-    public HttpTransportPipe(Codec codec) {
+    public HttpTransportPipe(Codec codec, WSBinding binding) {
         this.codec = codec;
+        this.binding = binding;
     }
 
     /**
@@ -65,7 +71,7 @@
      * Copy constructor for {@link Tube#copy(TubeCloner)}.
      */
     private HttpTransportPipe(HttpTransportPipe that, TubeCloner cloner) {
-        this( that.codec.copy() );
+        this( that.codec.copy(), that.binding);
         cloner.add(that,this);
     }
 
@@ -85,10 +91,11 @@
         HttpClientTransport con;
         try {
             // get transport headers from message
-            Map<String, List<String>> reqHeaders = (Map<String, List<String>>) request.invocationProperties.get(MessageContext.HTTP_REQUEST_HEADERS);
-            //assign empty map if its null
-            if(reqHeaders == null){
-                reqHeaders = new HashMap<String, List<String>>();
+            Map<String, List<String>> reqHeaders = new Headers();
+            Map<String, List<String>> userHeaders = (Map<String, List<String>>) request.invocationProperties.get(MessageContext.HTTP_REQUEST_HEADERS);
+            if (userHeaders != null) {
+                // userHeaders may not be modifiable like SingletonMap, just copy them
+                reqHeaders.putAll(userHeaders);
             }
 
             con = new HttpClientTransport(request,reqHeaders);
@@ -105,7 +112,9 @@
                 if (ct.getAcceptHeader() != null) {
                     reqHeaders.put("Accept", Collections.singletonList(ct.getAcceptHeader()));
                 }
-                writeSOAPAction(reqHeaders, ct.getSOAPActionHeader(),request);
+                if (binding instanceof SOAPBinding) {
+                    writeSOAPAction(reqHeaders, ct.getSOAPActionHeader(),request);
+                }
 
                 if(dump)
                     dump(buf, "HTTP request", reqHeaders);
@@ -117,12 +126,14 @@
                 if (ct.getAcceptHeader() != null) {
                     reqHeaders.put("Accept", Collections.singletonList(ct.getAcceptHeader()));
                 }
-                writeSOAPAction(reqHeaders, ct.getSOAPActionHeader(), request);
+                if (binding instanceof SOAPBinding) {
+                    writeSOAPAction(reqHeaders, ct.getSOAPActionHeader(), request);
+                }
 
                 if(dump) {
                     ByteArrayBuffer buf = new ByteArrayBuffer();
                     codec.encode(request, buf);
-                    dump(buf, "HTTP request", reqHeaders);
+                    dump(buf, "HTTP request - "+request.endpointAddress, reqHeaders);
                     OutputStream out = con.getOutput();
                     if (out != null) {
                         buf.writeTo(out);
@@ -137,10 +148,25 @@
 
             con.closeOutput();
 
-            con.checkResponseCode();
-            if (con.statusCode== WSHTTPConnection.ONEWAY) {
+            con.readResponseCodeAndMessage();   // throws IOE
+            InputStream response = con.getInput();
+            if(dump) {
+                ByteArrayBuffer buf = new ByteArrayBuffer();
+                if (response != null) {
+                    buf.write(response);
+                    response.close();
+                }
+                dump(buf,"HTTP response - "+request.endpointAddress+" - "+con.statusCode, con.getHeaders());
+                response = buf.newInputStream();
+            }
+
+            if (con.statusCode== WSHTTPConnection.ONEWAY || (request.expectReply != null && !request.expectReply)) {
+                checkStatusCodeOneway(response, con.statusCode, con.statusMessage);   // throws ClientTransportException
                 return request.createClientResponse(null);    // one way. no response given.
             }
+
+            checkStatusCode(response, con.statusCode, con.statusMessage); // throws ClientTransportException
+
             String contentType = con.getContentType();
             if (contentType == null) {
                 throw new WebServiceException("No Content-type in the header!");
@@ -151,13 +177,6 @@
             Packet reply = request.createClientResponse(null);
             //reply.addSatellite(new HttpResponseProperties(con));
             reply.wasTransportSecure = con.isSecure();
-            InputStream response = con.getInput();
-            if(dump) {
-                ByteArrayBuffer buf = new ByteArrayBuffer();
-                buf.write(response);
-                dump(buf,"HTTP response "+con.statusCode, con.getHeaders());
-                response = buf.newInputStream();
-            }
             codec.decode(response, contentType, reply);
             return reply;
         } catch(WebServiceException wex) {
@@ -167,11 +186,36 @@
         }
     }
 
+    private void checkStatusCode(InputStream in, int statusCode, String statusMessage) throws IOException {
+        // SOAP1.1 and SOAP1.2 differ here
+        if (binding instanceof SOAPBinding) {
+            if (statusCode != HttpURLConnection.HTTP_OK && statusCode != HttpURLConnection.HTTP_INTERNAL_ERROR) {
+                if (in != null) {
+                    in.close();
+                }
+                throw new ClientTransportException(ClientMessages.localizableHTTP_STATUS_CODE(statusCode, statusMessage));
+            }
+        }
+        // Every status code is OK for XML/HTTP
+    }
+
+    private void checkStatusCodeOneway(InputStream in, int statusCode, String statusMessage) throws IOException {
+        if (statusCode != WSHTTPConnection.ONEWAY && statusCode != WSHTTPConnection.OK) {
+            if (in != null) {
+                in.close();
+            }
+            throw new ClientTransportException(ClientMessages.localizableHTTP_STATUS_CODE(statusCode,statusMessage));
+        }
+    }
+
     /**
      * write SOAPAction header if the soapAction parameter is non-null or BindingProvider properties set.
      * BindingProvider properties take precedence.
      */
     private void writeSOAPAction(Map<String, List<String>> reqHeaders, String soapAction, Packet packet) {
+        //dont write SOAPAction HTTP header for SOAP 1.2 messages.
+        if(SOAPVersion.SOAP_12.equals(binding.getSOAPVersion()))
+            return;
         if (soapAction != null)
             reqHeaders.put("SOAPAction", Collections.singletonList(soapAction));
         else
--- old/src/share/classes/com/sun/xml/internal/ws/transport/http/server/EndpointImpl.java	Tue Aug  4 10:04:57 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/server/EndpointImpl.java	Tue Aug  4 10:04:57 2009
@@ -46,6 +46,7 @@
 import javax.xml.transform.TransformerException;
 import javax.xml.ws.*;
 import javax.xml.ws.wsaddressing.W3CEndpointReference;
+import javax.xml.parsers.ParserConfigurationException;
 
 import java.io.IOException;
 import java.net.URL;
@@ -57,6 +58,7 @@
 import java.util.concurrent.Executor;
 
 import org.xml.sax.EntityResolver;
+import org.xml.sax.SAXException;
 import org.w3c.dom.Element;
 
 
@@ -205,7 +207,7 @@
         try {
             Class.forName("com.sun.net.httpserver.HttpServer");
         } catch (Exception e) {
-            throw new UnsupportedOperationException("NOT SUPPORTED");
+            throw new UnsupportedOperationException("Couldn't load light weight http server", e);
         }
 
         WSEndpoint wse = WSEndpoint.create(
@@ -243,8 +245,7 @@
             Transformer transformer = XmlUtil.newTransformer();
             for (Source source : metadata) {
                 try {
-                    XMLStreamBufferResult xsbr = new XMLStreamBufferResult();
-                    transformer.transform(source, xsbr);
+                    XMLStreamBufferResult xsbr = XmlUtil.identityTransform(source, new XMLStreamBufferResult());
                     String systemId = source.getSystemId();
 
                     r.add(SDDocumentSource.create(new URL(systemId), xsbr.getXMLStreamBuffer()));
@@ -252,6 +253,10 @@
                     throw new ServerRtException("server.rt.err", te);
                 } catch (IOException te) {
                     throw new ServerRtException("server.rt.err", te);
+                } catch (SAXException e) {
+                    throw new ServerRtException("server.rt.err", e);
+                } catch (ParserConfigurationException e) {
+                    throw new ServerRtException("server.rt.err", e);
                 }
             }
         }
@@ -265,6 +270,7 @@
     private @Nullable SDDocumentSource getPrimaryWsdl() {
         Class implType = implementor.getClass();
         // Takes care of @WebService, @WebServiceProvider's wsdlLocation
+        EndpointFactory.verifyImplementorClass(implType);
         String wsdlLocation = EndpointFactory.getWsdlLocation(implType);
         if (wsdlLocation != null) {
             ClassLoader cl = implType.getClassLoader();
--- old/src/share/classes/com/sun/xml/internal/ws/transport/http/server/HttpEndpoint.java	Tue Aug  4 10:04:59 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/server/HttpEndpoint.java	Tue Aug  4 10:04:59 2009
@@ -51,7 +51,7 @@
  *
  * @author Jitendra Kotamraju
  */
-final class HttpEndpoint {
+public final class HttpEndpoint extends com.sun.xml.internal.ws.api.server.HttpEndpoint {
     private String address;
     private HttpContext httpContext;
     private final HttpAdapter adapter;
--- old/src/share/classes/com/sun/xml/internal/ws/transport/http/server/ServerConnectionImpl.java	Tue Aug  4 10:05:01 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/server/ServerConnectionImpl.java	Tue Aug  4 10:05:01 2009
@@ -32,11 +32,19 @@
 import com.sun.xml.internal.ws.api.message.Packet;
 import com.sun.xml.internal.ws.api.server.WSEndpoint;
 import com.sun.xml.internal.ws.api.server.WebServiceContextDelegate;
+import com.sun.xml.internal.ws.api.server.PortAddressResolver;
 import com.sun.xml.internal.ws.transport.http.HttpAdapter;
 import com.sun.xml.internal.ws.transport.http.WSHTTPConnection;
+import com.sun.xml.internal.ws.developer.JAXWSProperties;
+import com.sun.xml.internal.ws.resources.WsservletMessages;
 
 import javax.xml.ws.handler.MessageContext;
-import java.io.*;
+import javax.xml.ws.WebServiceException;
+import java.io.FilterInputStream;
+import java.io.FilterOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.net.URI;
 import java.security.Principal;
 import java.util.ArrayList;
@@ -81,9 +89,8 @@
         for(Map.Entry <String, List<String>> entry : headers.entrySet()) {
             String name = entry.getKey();
             List<String> values = entry.getValue();
-            if (name.equalsIgnoreCase("Content-Length") || name.equalsIgnoreCase("Content-Type")) {
-                continue;  // ignore headers that interfere with our correct operations
-            } else {
+            // ignore headers that interfere with our correct operations
+            if (!name.equalsIgnoreCase("Content-Length") && !name.equalsIgnoreCase("Content-Type")) {
                 r.put(name,new ArrayList<String>(values));
             }
         }
@@ -111,17 +118,20 @@
     }
 
     public @NotNull InputStream getInput() {
+
         // Light weight http server's InputStream.close() throws exception if
         // all the bytes are not read. Work around until it is fixed.
         return new FilterInputStream(httpExchange.getRequestBody()) {
+            // Workaround for "SJSXP XMLStreamReader.next() closes stream".
+            boolean closed;
+
             @Override
             public void close() throws IOException {
-                try {
+                if (!closed) {
                     while (read() != -1);
-                } catch(IOException e) {
-                    //Ignore
+                    super.close();
+                    closed = true;
                 }
-                super.close();
             }
         };
     }
@@ -146,7 +156,14 @@
                     // Ignoring purposefully.
                 }
             }
+
+            // Otherwise, FilterOutpuStream writes byte by byte
+            @Override
+            public void write(byte[] buf, int start, int len) throws IOException {
+                out.write(buf, start, len);
+            }
         };
+
     }
 
     public @NotNull WebServiceContextDelegate getWebServiceContextDelegate() {
@@ -162,7 +179,14 @@
     }
 
     public @NotNull String getEPRAddress(Packet request, WSEndpoint endpoint) {
-        return WSHttpHandler.getRequestAddress(httpExchange);
+        //return WSHttpHandler.getRequestAddress(httpExchange);
+
+        PortAddressResolver resolver = adapter.owner.createPortAddressResolver(getBaseAddress());
+        String address = resolver.getAddressFor(endpoint.getServiceName(), endpoint.getPortName().getLocalPart());
+        if(address==null)
+            throw new WebServiceException(WsservletMessages.SERVLET_NO_ADDRESS_AVAILABLE(endpoint.getPortName()));
+        return address;
+
     }
 
     public String getWSDLAddress(@NotNull Packet request, @NotNull WSEndpoint endpoint) {
@@ -206,6 +230,16 @@
         return null;
     }
 
+    @Property(JAXWSProperties.HTTP_EXCHANGE)
+    public HttpExchange getExchange() {
+        return httpExchange;
+    }
+
+    @Override @NotNull
+    public String getBaseAddress() {
+        return WSHttpHandler.getRequestAddress(httpExchange);
+    }
+
     @Override
     public String getProtocol() {
         return httpExchange.getProtocol();
--- old/src/share/classes/com/sun/xml/internal/ws/transport/http/server/ServerMgr.java	Tue Aug  4 10:05:04 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/server/ServerMgr.java	Tue Aug  4 10:05:03 2009
@@ -30,7 +30,6 @@
 
 import java.net.InetSocketAddress;
 import java.net.URL;
-import java.net.URI;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
@@ -54,8 +53,9 @@
 
     /**
      * Gets the singleton instance.
+     * @return manager instance
      */
-    public static ServerMgr getInstance() {
+    static ServerMgr getInstance() {
         return serverMgr;
     }
 
@@ -64,7 +64,7 @@
      * it uses that server to create a context. Otherwise, it creates a new
      * HTTP server. This sever is added to servers Map.
      */
-    public HttpContext createContext(String address) {
+    /*package*/ HttpContext createContext(String address) {
         try {
             HttpServer server;
             ServerState state;
@@ -80,7 +80,7 @@
                 if (state == null) {
                     logger.fine("Creating new HTTP Server at "+inetAddress);
                     server = HttpServer.create(inetAddress, 5);
-                    server.setExecutor(Executors.newFixedThreadPool(5));
+                    server.setExecutor(Executors.newCachedThreadPool());
                     String path = url.toURI().getPath();
                     logger.fine("Creating HTTP Context at = "+path);
                     HttpContext context = server.createContext(path);
@@ -105,7 +105,7 @@
      * Removes a context. If the server doesn't have anymore contexts, it
      * would stop the server and server is removed from servers Map.
      */
-    public void removeContext(HttpContext context) {
+    /*package*/ void removeContext(HttpContext context) {
         InetSocketAddress inetAddress = context.getServer().getAddress();
         synchronized(servers) {
             ServerState state = servers.get(inetAddress);
--- old/src/share/classes/com/sun/xml/internal/ws/transport/http/server/WSHttpHandler.java	Tue Aug  4 10:05:06 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/server/WSHttpHandler.java	Tue Aug  4 10:05:05 2009
@@ -90,16 +90,8 @@
         try {
             logger.fine("Received HTTP request:"+msg.getRequestURI());
             String method = msg.getRequestMethod();
-            if (method.equals(GET_METHOD)) {
-                String queryString = msg.getRequestURI().getQuery();
-                logger.fine("Query String for request ="+queryString);
-                if (adapter.isMetadataQuery(queryString)) {
-                    adapter.publishWSDL(con,getRequestAddress(msg), msg.getRequestURI().getQuery());
-                } else {
-                    adapter.handle(con);
-                }
-            } else if (method.equals(POST_METHOD) || method.equals(HEAD_METHOD)
-                        || method.equals(PUT_METHOD) || method.equals(DELETE_METHOD)) {
+            if(method.equals(GET_METHOD) || method.equals(POST_METHOD) || method.equals(HEAD_METHOD)
+            || method.equals(PUT_METHOD) || method.equals(DELETE_METHOD)) {
                 adapter.handle(con);
             } else {
                 logger.warning(HttpserverMessages.UNEXPECTED_HTTP_METHOD(method));
@@ -144,9 +136,9 @@
         strBuf.append((msg instanceof HttpsExchange) ? "https" : "http");
         strBuf.append("://");
 
-        List<String> hostHeader = msg.getRequestHeaders().get("Host");
+        String hostHeader = msg.getRequestHeaders().getFirst("Host");
         if (hostHeader != null) {
-            strBuf.append(hostHeader.get(0));   // Uses Host header
+            strBuf.append(hostHeader);   // Uses Host header
         } else {
             strBuf.append(msg.getLocalAddress().getHostName());
             strBuf.append(":");
--- old/src/share/classes/com/sun/xml/internal/ws/util/ByteArrayBuffer.java	Tue Aug  4 10:05:08 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/ByteArrayBuffer.java	Tue Aug  4 10:05:08 2009
@@ -82,7 +82,12 @@
     }
 
     public ByteArrayBuffer(byte[] data) {
+        this(data,data.length);
+    }
+
+    public ByteArrayBuffer(byte[] data, int length) {
         this.buf = data;
+        this.count = length;
     }
 
     /**
--- old/src/share/classes/com/sun/xml/internal/ws/util/DOMUtil.java	Tue Aug  4 10:05:10 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/DOMUtil.java	Tue Aug  4 10:05:10 2009
@@ -50,7 +50,7 @@
 import com.sun.istack.internal.Nullable;
 
 /**
- * $author: JAXWS Development Team
+ * @author: JAXWS Development Team
  */
 public class DOMUtil {
 
@@ -135,11 +135,13 @@
     public static void writeTagWithAttributes(Element node, XMLStreamWriter writer) throws XMLStreamException {
         String nodePrefix = fixNull(node.getPrefix());
         String nodeNS = fixNull(node.getNamespaceURI());
+        //fix to work with DOM level 1 nodes.
+        String nodeLocalName = node.getLocalName()== null?node.getNodeName():node.getLocalName();
 
         // See if nodePrefix:nodeNS is declared in writer's NamespaceContext before writing start element
         // Writing start element puts nodeNS in NamespaceContext even though namespace declaration not written
         boolean prefixDecl = isPrefixDeclared(writer, nodeNS, nodePrefix);
-        writer.writeStartElement(nodePrefix, node.getLocalName(), nodeNS);
+        writer.writeStartElement(nodePrefix, nodeLocalName, nodeNS);
 
         if (node.hasAttributes()) {
             NamedNodeMap attrs = node.getAttributes();
--- old/src/share/classes/com/sun/xml/internal/ws/util/HandlerAnnotationProcessor.java	Tue Aug  4 10:05:13 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/HandlerAnnotationProcessor.java	Tue Aug  4 10:05:12 2009
@@ -30,6 +30,7 @@
 import com.sun.xml.internal.ws.handler.HandlerChainsModel;
 import com.sun.xml.internal.ws.server.EndpointFactory;
 import com.sun.xml.internal.ws.streaming.XMLStreamReaderUtil;
+import com.sun.istack.internal.NotNull;
 
 import javax.jws.HandlerChain;
 import javax.jws.WebService;
@@ -84,7 +85,7 @@
      * handlers and roles. Will return null if the class passed
      * in has no handler chain annotation.
      */
-    public static HandlerAnnotationInfo buildHandlerInfo(
+    public static HandlerAnnotationInfo buildHandlerInfo(@NotNull
         Class<?> clazz, QName serviceName, QName portName, WSBinding binding) {
 
 //        clazz = checkClass(clazz);
--- old/src/share/classes/com/sun/xml/internal/ws/util/Pool.java	Tue Aug  4 10:05:15 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/Pool.java	Tue Aug  4 10:05:14 2009
@@ -31,6 +31,7 @@
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
 import java.util.concurrent.ConcurrentLinkedQueue;
+import java.lang.ref.WeakReference;
 
 /**
  * General-purpose object pool.
@@ -47,8 +48,10 @@
  * @author Kohsuke Kawaguchi
  */
 public abstract class Pool<T> {
-    private final ConcurrentLinkedQueue<T> queue = new ConcurrentLinkedQueue<T>();
 
+    // volatile since multiple threads may access queue reference
+    private volatile WeakReference<ConcurrentLinkedQueue<T>> queue;
+
     /**
      * Gets a new object from the pool.
      *
@@ -59,17 +62,32 @@
      *      always non-null.
      */
     public final T take() {
-        T t = queue.poll();
+        T t = getQueue().poll();
         if(t==null)
             return create();
         return t;
     }
 
+    private ConcurrentLinkedQueue<T> getQueue() {
+        WeakReference<ConcurrentLinkedQueue<T>> q = queue;
+        if (q != null) {
+            ConcurrentLinkedQueue<T> d = q.get();
+            if (d != null)
+                return d;
+        }
+
+        // overwrite the queue
+        ConcurrentLinkedQueue<T> d = new ConcurrentLinkedQueue<T>();
+        queue = new WeakReference<ConcurrentLinkedQueue<T>>(d);
+
+        return d;
+    }
+
     /**
      * Returns an object back to the pool.
      */
     public final void recycle(T t) {
-        queue.offer(t);
+        getQueue().offer(t);
     }
 
     /**
--- old/src/share/classes/com/sun/xml/internal/ws/util/QNameMap.java	Tue Aug  4 10:05:17 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/QNameMap.java	Tue Aug  4 10:05:17 2009
@@ -25,6 +25,8 @@
 
 package com.sun.xml.internal.ws.util;
 
+import com.sun.istack.internal.NotNull;
+
 import javax.xml.namespace.QName;
 import java.util.AbstractSet;
 import java.util.Collection;
@@ -134,7 +136,7 @@
      *          <tt>null</tt> if the map contains no mapping for this set of keys.
      * @see #put(String,String, Object)
      */
-    public V get( String nsUri, String localPart ) {
+    public V get( @NotNull String nsUri, String localPart ) {
         Entry<V> e = getEntry(nsUri,localPart);
         if(e==null) return null;
         else        return e.value;
@@ -346,7 +348,7 @@
         }
     }
 
-    public boolean containsKey(String nsUri,String localName) {
+    public boolean containsKey(@NotNull String nsUri,String localName) {
         return getEntry(nsUri,localName)!=null;
     }
 
@@ -458,7 +460,7 @@
         }
     }
 
-    private Entry<V> getEntry(String nsUri,String localName) {
+    private Entry<V> getEntry(@NotNull String nsUri,String localName) {
         int hash = hash(localName);
         int i = indexFor(hash, table.length);
         Entry<V> e = table[i];
--- old/src/share/classes/com/sun/xml/internal/ws/util/RuntimeVersion.java	Tue Aug  4 10:05:19 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/RuntimeVersion.java	Tue Aug  4 10:05:19 2009
@@ -25,13 +25,43 @@
 
 package com.sun.xml.internal.ws.util;
 
+import com.sun.xml.internal.ws.util.RuntimeVersionMBean;
+
+import java.io.InputStream;
+import java.io.IOException;
+
 /**
  * Obtains the version number of the JAX-WS runtime.
  *
  * @author Kohsuke Kawaguchi
+ * @author Jitendra Kotamraju
  */
-public abstract class RuntimeVersion {
-    private RuntimeVersion() {}    // no instanciation please
+public final class RuntimeVersion implements RuntimeVersionMBean {
 
-    public static final Version VERSION = Version.create(RuntimeVersion.class.getResourceAsStream("version.properties"));
+    public static final Version VERSION;
+
+    static {
+        Version version = null;
+        InputStream in = RuntimeVersion.class.getResourceAsStream("version.properties");
+        try {
+            version = Version.create(in);
+        } finally {
+            if (in != null) {
+                try {
+                    in.close();
+                } catch(IOException ioe) {
+                    // Nothing to do
+                }
+            }
+        }
+        VERSION = version == null ? Version.create(null) : version;
+    }
+
+    /**
+     * Get JAX-WS version
+     */
+    public String getVersion() {
+        return VERSION.toString();
+    }
+
 }
--- old/src/share/classes/com/sun/xml/internal/ws/util/pipe/DumpTube.java	Tue Aug  4 10:05:21 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/pipe/DumpTube.java	Tue Aug  4 10:05:21 2009
@@ -82,11 +82,13 @@
         this.staxOut = that.staxOut;
     }
 
+    @Override
     public NextAction processRequest(Packet request) {
         dump("request",request);
         return super.processRequest(request);
     }
 
+    @Override
     public NextAction processResponse(Packet response) {
         dump("response",response);
         return super.processResponse(response);
--- old/src/share/classes/com/sun/xml/internal/ws/util/pipe/StandaloneTubeAssembler.java	Tue Aug  4 10:05:24 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/pipe/StandaloneTubeAssembler.java	Tue Aug  4 10:05:23 2009
@@ -51,6 +51,7 @@
         }
         head = context.createWsaTube(head);
         head = context.createClientMUTube(head);
+        head = context.createValidationTube(head);
         return context.createHandlerTube(head);
     }
 
@@ -61,6 +62,7 @@
      */
     public Tube createServer(ServerTubeAssemblerContext context) {
         Tube head = context.getTerminalTube();
+        head = context.createValidationTube(head);
         head = context.createHandlerTube(head);
         head = context.createMonitoringTube(head);
         head = context.createServerMUTube(head);
--- old/src/share/classes/com/sun/xml/internal/ws/util/resources/Messages_en.properties	Tue Aug  4 10:05:26 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/resources/Messages_en.properties	Tue Aug  4 10:05:25 2009
@@ -241,4 +241,3 @@
 V-039 = IDREFS attributes must have at least one value
 
 V-040 = ENTITIES attributes must have at least one value
- 
--- old/src/share/classes/com/sun/xml/internal/ws/util/version.properties	Tue Aug  4 10:05:28 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/version.properties	Tue Aug  4 10:05:28 2009
@@ -23,7 +23,7 @@
 # have any questions.
 #
 
-build-id=JAX-WS RI 2.1.1
-build-version=JAX-WS RI 2.1.1
-major-version=2.1.1
- 
+#Fri May 15 16:16:14 CEST 2009
+build-id=JAX-WS RI 2.1.6
+major-version=2.1.6
+build-version=JAX-WS RI 2.1.6
--- old/src/share/classes/com/sun/xml/internal/ws/util/xml/ContentHandlerToXMLStreamWriter.java	Tue Aug  4 10:05:30 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/xml/ContentHandlerToXMLStreamWriter.java	Tue Aug  4 10:05:30 2009
@@ -175,15 +175,15 @@
     public void startPrefixMapping(String prefix, String uri)
         throws SAXException {
 
-        if (prefix.equals("xml")) {
-            return;
-        }
-
         // defend against parsers that pass null in for "xmlns" prefix
         if (prefix == null) {
             prefix = "";
         }
 
+        if (prefix.equals("xml")) {
+            return;
+        }
+
         prefixBindings.add(prefix);
         prefixBindings.add(uri);
     }
--- old/src/share/classes/com/sun/xml/internal/ws/util/xml/StAXSource.java	Tue Aug  4 10:05:33 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/xml/StAXSource.java	Tue Aug  4 10:05:32 2009
@@ -25,16 +25,10 @@
 
 package com.sun.xml.internal.ws.util.xml;
 
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.SAXParseException2;
 import com.sun.istack.internal.XMLStreamReaderToContentHandler;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.DTDHandler;
-import org.xml.sax.EntityResolver;
-import org.xml.sax.ErrorHandler;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXNotRecognizedException;
-import org.xml.sax.SAXParseException;
-import org.xml.sax.XMLReader;
+import org.xml.sax.*;
 import org.xml.sax.ext.LexicalHandler;
 import org.xml.sax.helpers.XMLFilterImpl;
 
@@ -88,6 +82,8 @@
     // this object will be wrapped by the XMLReader exposed to the client
     private final XMLStreamReaderToContentHandler reader;
 
+    private final XMLStreamReader staxReader;
+
     // SAX allows ContentHandler to be changed during the parsing,
     // but JAXB doesn't. So this repeater will sit between those
     // two components.
@@ -102,7 +98,14 @@
         }
 
         public void setFeature(String name, boolean value) throws SAXNotRecognizedException {
-            throw new SAXNotRecognizedException(name);
+            // Should support these two features according to XMLReader javadoc.
+            if (name.equals("http://xml.org/sax/features/namespaces") && value) {
+                // Ignore for now
+            } else if (name.equals("http://xml.org/sax/features/namespace-prefixes") && !value) {
+                // Ignore for now
+            } else {
+                throw new SAXNotRecognizedException(name);
+            }
         }
 
         public Object getProperty(String name) throws SAXNotRecognizedException {
@@ -171,12 +174,12 @@
             } catch( XMLStreamException e ) {
                 // wrap it in a SAXException
                 SAXParseException se =
-                    new SAXParseException(
+                    new SAXParseException2(
                         e.getMessage(),
                         null,
                         null,
-                        e.getLocation().getLineNumber(),
-                        e.getLocation().getColumnNumber(),
+                        e.getLocation() == null ? -1 : e.getLocation().getLineNumber(),
+                        e.getLocation() == null ? -1 : e.getLocation().getColumnNumber(),
                         e);
 
                 // if the consumer sets an error handler, it is our responsibility
@@ -188,6 +191,12 @@
                 // returns, we will abort anyway.
                 throw se;
 
+            } finally {
+                try {
+                    staxReader.close();
+                } catch(XMLStreamException xe) {
+                    //falls through. Not much can be done.
+                }
             }
         }
     };
@@ -196,18 +205,36 @@
      * Creates a new {@link javax.xml.transform.Source} for the given
      * {@link XMLStreamReader}.
      *
+     * @param reader XMLStreamReader that will be exposed as a Source
+     * @param eagerQuit if true, when the conversion is completed, leave the cursor to the last
+     *                  event that was fired (such as end element)
+     * @see #StAXSource(XMLStreamReader, boolean, String[])
+     */
+    public StAXSource(XMLStreamReader reader, boolean eagerQuit) {
+        this(reader, eagerQuit, new String[0]);
+    }
+
+    /**
+     * Creates a new {@link javax.xml.transform.Source} for the given
+     * {@link XMLStreamReader}.
+     *
      * The XMLStreamReader must be pointing at either a
      * {@link javax.xml.stream.XMLStreamConstants#START_DOCUMENT} or
      * {@link javax.xml.stream.XMLStreamConstants#START_ELEMENT} event.
      *
      * @param reader XMLStreamReader that will be exposed as a Source
+     * @param eagerQuit if true, when the conversion is completed, leave the cursor to the last
+     *                  event that was fired (such as end element)
+     * @param inscope inscope Namespaces
+     *                array of the even length of the form { prefix0, uri0, prefix1, uri1, ... }
      * @throws IllegalArgumentException iff the reader is null
      * @throws IllegalStateException iff the reader is not pointing at either a
      * START_DOCUMENT or START_ELEMENT event
      */
-    public StAXSource(XMLStreamReader reader, boolean eagerQuit) {
+    public StAXSource(XMLStreamReader reader, boolean eagerQuit, @NotNull String[] inscope) {
         if( reader == null )
             throw new IllegalArgumentException();
+        this.staxReader = reader;
 
         int eventType = reader.getEventType();
         if (!(eventType == XMLStreamConstants.START_DOCUMENT)
@@ -215,7 +242,7 @@
             throw new IllegalStateException();
         }
 
-        this.reader = new XMLStreamReaderToContentHandler(reader,repeater,eagerQuit,false);
+        this.reader = new XMLStreamReaderToContentHandler(reader,repeater,eagerQuit,false,inscope);
 
         super.setXMLReader(pseudoParser);
         // pass a dummy InputSource. We don't care
--- old/src/share/classes/com/sun/xml/internal/ws/util/xml/XMLStreamReaderToXMLStreamWriter.java	Tue Aug  4 10:05:35 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/xml/XMLStreamReaderToXMLStreamWriter.java	Tue Aug  4 10:05:34 2009
@@ -43,6 +43,8 @@
  */
 public class XMLStreamReaderToXMLStreamWriter {
 
+    private static final int BUF_SIZE = 4096;
+
     protected XMLStreamReader in;
     protected XMLStreamWriter out;
 
@@ -126,11 +128,13 @@
             in.getPIData());
     }
 
+
     protected void handleCharacters() throws XMLStreamException {
-        out.writeCharacters(
-            in.getTextCharacters(),
-            in.getTextStart(),
-            in.getTextLength() );
+        char[] buf = new char[BUF_SIZE];
+        for (int start=0,read=buf.length; read == buf.length; start+=buf.length) {
+            read = in.getTextCharacters(start, buf, 0, buf.length);
+            out.writeCharacters(buf, 0, read);
+        }
     }
 
     protected void handleEndElement() throws XMLStreamException {
--- old/src/share/classes/com/sun/xml/internal/ws/util/xml/XmlUtil.java	Tue Aug  4 10:05:37 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/xml/XmlUtil.java	Tue Aug  4 10:05:37 2009
@@ -40,11 +40,21 @@
 import org.xml.sax.ErrorHandler;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXParseException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.InputSource;
 
 import javax.xml.namespace.QName;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.parsers.SAXParserFactory;
+import javax.xml.transform.Result;
+import javax.xml.transform.Source;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerException;
 import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.sax.SAXTransformerFactory;
+import javax.xml.transform.sax.TransformerHandler;
+import javax.xml.transform.stream.StreamSource;
 import javax.xml.ws.WebServiceException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -61,6 +71,8 @@
  * @author WS Development Team
  */
 public class XmlUtil {
+    private final static String LEXICAL_HANDLER_PROPERTY =
+        "http://xml.org/sax/properties/lexical-handler";
 
     public static String getPrefix(String s) {
         int i = s.indexOf(':');
@@ -188,6 +200,12 @@
 
     static final TransformerFactory transformerFactory = TransformerFactory.newInstance();
 
+    static final SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
+
+    static {
+        saxParserFactory.setNamespaceAware(true);
+    }
+
     /**
      * Creates a new identity transformer.
      */
@@ -199,6 +217,36 @@
         }
     }
 
+    /**
+     * Performs identity transformation.
+     */
+    public static <T extends Result>
+    T identityTransform(Source src, T result) throws TransformerException, SAXException, ParserConfigurationException, IOException {
+        if (src instanceof StreamSource) {
+            // work around a bug in JAXP in JDK6u4 and earlier where the namespace processing
+            // is not turned on by default
+            StreamSource ssrc = (StreamSource) src;
+            TransformerHandler th = ((SAXTransformerFactory) transformerFactory).newTransformerHandler();
+            th.setResult(result);
+            XMLReader reader = saxParserFactory.newSAXParser().getXMLReader();
+            reader.setContentHandler(th);
+            reader.setProperty(LEXICAL_HANDLER_PROPERTY, th);
+            reader.parse(toInputSource(ssrc));
+        } else {
+            newTransformer().transform(src, result);
+        }
+        return result;
+    }
+
+    private static InputSource toInputSource(StreamSource src) {
+        InputSource is = new InputSource();
+        is.setByteStream(src.getInputStream());
+        is.setCharacterStream(src.getReader());
+        is.setPublicId(src.getPublicId());
+        is.setSystemId(src.getSystemId());
+        return is;
+    }
+
     /*
     * Gets an EntityResolver using XML catalog
     */
--- old/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/DelegatingParserExtension.java	Tue Aug  4 10:05:39 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/DelegatingParserExtension.java	Tue Aug  4 10:05:39 2009
@@ -25,16 +25,7 @@
 
 package com.sun.xml.internal.ws.wsdl.parser;
 
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundOperation;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundPortType;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLFault;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLInput;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLMessage;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLOperation;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLPortType;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLService;
+import com.sun.xml.internal.ws.api.model.wsdl.*;
 import com.sun.xml.internal.ws.api.wsdl.parser.WSDLParserExtension;
 import com.sun.xml.internal.ws.api.wsdl.parser.WSDLParserExtensionContext;
 
@@ -169,12 +160,12 @@
         core.bindingOperationOutputAttributes(operation, reader);
     }
 
-    public boolean bindingOperationFaultElements(WSDLBoundOperation operation, XMLStreamReader reader) {
-        return core.bindingOperationFaultElements(operation, reader);
+    public boolean bindingOperationFaultElements(WSDLBoundFault fault, XMLStreamReader reader) {
+        return core.bindingOperationFaultElements(fault, reader);
     }
 
-    public void bindingOperationFaultAttributes(WSDLBoundOperation operation, XMLStreamReader reader) {
-        core.bindingOperationFaultAttributes(operation, reader);
+    public void bindingOperationFaultAttributes(WSDLBoundFault fault, XMLStreamReader reader) {
+        core.bindingOperationFaultAttributes(fault, reader);
     }
 
     public void finished(WSDLParserExtensionContext context) {
--- old/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/FoolProofParserExtension.java	Tue Aug  4 10:05:42 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/FoolProofParserExtension.java	Tue Aug  4 10:05:41 2009
@@ -25,16 +25,7 @@
 package com.sun.xml.internal.ws.wsdl.parser;
 
 
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundOperation;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundPortType;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLFault;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLInput;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLMessage;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLOperation;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLPortType;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLService;
+import com.sun.xml.internal.ws.api.model.wsdl.*;
 import com.sun.xml.internal.ws.api.wsdl.parser.WSDLParserExtension;
 
 import javax.xml.namespace.QName;
@@ -133,7 +124,7 @@
         return post(pre(reader),reader,super.bindingOperationOutputElements(operation, reader));
     }
 
-    public boolean bindingOperationFaultElements(WSDLBoundOperation operation, XMLStreamReader reader) {
-        return post(pre(reader),reader,super.bindingOperationFaultElements(operation, reader));
+    public boolean bindingOperationFaultElements(WSDLBoundFault fault, XMLStreamReader reader) {
+        return post(pre(reader),reader,super.bindingOperationFaultElements(fault, reader));
     }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/ParserUtil.java	Tue Aug  4 10:05:44 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/ParserUtil.java	Tue Aug  4 10:05:43 2009
@@ -26,9 +26,10 @@
 
 
 import com.sun.xml.internal.ws.streaming.Attributes;
-import com.sun.xml.internal.ws.streaming.XMLReader;
 import com.sun.xml.internal.ws.streaming.XMLReaderException;
 import com.sun.xml.internal.ws.util.xml.XmlUtil;
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
 
 
 import java.io.File;
@@ -56,17 +57,10 @@
         return reader.getAttributeValue(name.getNamespaceURI(), name.getLocalPart());
     }
 
-    public static void verifyTag(XMLReader reader, QName name) {
-        if (!name.equals(reader.getName())) {
-            throw new XMLReaderException("xmlreader.unexpectedState.tag",
-                new Object[] { name, reader.getName() });
-        }
-    }
-
     public static QName getQName(XMLStreamReader reader, String tag){
         String localName = XmlUtil.getLocalPart(tag);
         String pfix = XmlUtil.getPrefix(tag);
-        String uri = reader.getNamespaceURI(pfix);
+        String uri = reader.getNamespaceURI(fixNull(pfix));
         return new QName(uri, localName);
     }
 
@@ -84,18 +78,6 @@
         return value;
     }
 
-    public static void fail(String key, XMLReader reader) {
-        //throw new WebServicesClientException(key,
-        //        Integer.toString(reader.getLineNumber()));
-    }
-
-    public static void failWithFullName(String key, XMLReader reader) {
-        //throw new WebServicesClientException(key,
-        //new Object[]{
-        //  Integer.toString(reader.getLineNumber()),
-        //  reader.getName().toString()});
-    }
-
     public static void failWithFullName(String key, XMLStreamReader reader) {
 //        throw new WebServicesClientException(key,
 //        new Object[]{
@@ -110,7 +92,7 @@
         //          reader.getLocalName()});
     }
 
-    public static void failWithLocalName(String key, XMLReader reader,
+    public static void failWithLocalName(String key, XMLStreamReader reader,
         String arg) {
         //throw new WebServicesClientException(key,
         //      new Object[]{
@@ -119,12 +101,8 @@
         //          arg});
     }
 
-    public static void failWithLocalName(String key, XMLStreamReader reader,
-        String arg) {
-        //throw new WebServicesClientException(key,
-        //      new Object[]{
-        //          Integer.toString(reader.getLineNumber()),
-        //          reader.getLocalName(),
-        //          arg});
+    private static @NotNull String fixNull(@Nullable String s) {
+        if (s == null) return "";
+        else return s;
     }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/RuntimeWSDLParser.java	Tue Aug  4 10:05:46 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/RuntimeWSDLParser.java	Tue Aug  4 10:05:46 2009
@@ -29,13 +29,17 @@
 import com.sun.istack.internal.Nullable;
 import com.sun.xml.internal.ws.api.BindingID;
 import com.sun.xml.internal.ws.api.EndpointAddress;
-import com.sun.xml.internal.ws.api.streaming.XMLStreamReaderFactory;
 import com.sun.xml.internal.ws.api.addressing.AddressingVersion;
 import com.sun.xml.internal.ws.api.addressing.WSEndpointReference;
 import com.sun.xml.internal.ws.api.model.ParameterBinding;
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLDescriptorKind;
-import com.sun.xml.internal.ws.api.model.wsdl.WSDLModel;
-import com.sun.xml.internal.ws.api.wsdl.parser.*;
+import com.sun.xml.internal.ws.api.server.Container;
+import com.sun.xml.internal.ws.api.streaming.XMLStreamReaderFactory;
+import com.sun.xml.internal.ws.api.wsdl.parser.MetaDataResolver;
+import com.sun.xml.internal.ws.api.wsdl.parser.MetadataResolverFactory;
+import com.sun.xml.internal.ws.api.wsdl.parser.ServiceDescriptor;
+import com.sun.xml.internal.ws.api.wsdl.parser.WSDLParserExtension;
+import com.sun.xml.internal.ws.api.wsdl.parser.XMLEntityResolver;
 import com.sun.xml.internal.ws.api.wsdl.parser.XMLEntityResolver.Parser;
 import com.sun.xml.internal.ws.model.wsdl.*;
 import com.sun.xml.internal.ws.resources.ClientMessages;
@@ -60,7 +64,11 @@
 import java.io.InputStream;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import java.util.logging.Logger;
 
 /**
@@ -101,10 +109,10 @@
      *      Either this or <tt>wsdl</tt> parameter must be given.
      *      Null location means the system won't be able to resolve relative references in the WSDL,
      */
-    public static WSDLModelImpl parse(@Nullable URL wsdlLoc, @NotNull Source wsdlSource, @NotNull EntityResolver resolver, boolean isClientSide, WSDLParserExtension... extensions) throws IOException, XMLStreamException, SAXException {
+    public static WSDLModelImpl parse(@Nullable URL wsdlLoc, @NotNull Source wsdlSource, @NotNull EntityResolver resolver, boolean isClientSide, Container container, WSDLParserExtension... extensions) throws IOException, XMLStreamException, SAXException {
         assert resolver != null;
 
-        RuntimeWSDLParser wsdlParser = new RuntimeWSDLParser(wsdlSource.getSystemId(), new EntityResolverWrapper(resolver), isClientSide, extensions);
+        RuntimeWSDLParser wsdlParser = new RuntimeWSDLParser(wsdlSource.getSystemId(), new EntityResolverWrapper(resolver), isClientSide, container, extensions);
         Parser parser;
         try{
             parser = wsdlParser.resolveWSDL(wsdlLoc, wsdlSource);
@@ -116,25 +124,29 @@
             //Try MEX if there is WSDLLoc available
             if(wsdlLoc == null)
                 throw e;
-            return tryWithMex(wsdlParser, wsdlLoc, resolver, isClientSide, e, extensions);
+            return tryWithMex(wsdlParser, wsdlLoc, resolver, isClientSide, container, e, extensions);
 
         }catch(IOException e){
             //Try MEX if there is WSDLLoc available
             if(wsdlLoc == null)
                 throw e;
-            return tryWithMex(wsdlParser, wsdlLoc, resolver, isClientSide, e, extensions);
+            return tryWithMex(wsdlParser, wsdlLoc, resolver, isClientSide, container, e, extensions);
         }
         wsdlParser.parseWSDL(parser, false);
         wsdlParser.wsdlDoc.freeze();
         wsdlParser.extensionFacade.finished(wsdlParser.context);
         wsdlParser.extensionFacade.postFinished(wsdlParser.context);
+
+        if(wsdlParser.wsdlDoc.getServices().isEmpty())
+            throw new WebServiceException(ClientMessages.WSDL_CONTAINS_NO_SERVICE(wsdlLoc));
+
         return wsdlParser.wsdlDoc;
     }
 
-    private static WSDLModelImpl tryWithMex(@NotNull RuntimeWSDLParser wsdlParser, @NotNull URL wsdlLoc, @NotNull EntityResolver resolver, boolean isClientSide, Throwable e, WSDLParserExtension... extensions) throws SAXException, XMLStreamException {
+    private static WSDLModelImpl tryWithMex(@NotNull RuntimeWSDLParser wsdlParser, @NotNull URL wsdlLoc, @NotNull EntityResolver resolver, boolean isClientSide, Container container, Throwable e, WSDLParserExtension... extensions) throws SAXException, XMLStreamException {
         ArrayList<Throwable> exceptions = new ArrayList<Throwable>();
         try {
-            WSDLModelImpl wsdlModel =  wsdlParser.parseUsingMex(wsdlLoc, resolver, isClientSide, extensions);
+            WSDLModelImpl wsdlModel =  wsdlParser.parseUsingMex(wsdlLoc, resolver, isClientSide, container, extensions);
             if(wsdlModel == null){
                 throw new WebServiceException(ClientMessages.FAILED_TO_PARSE(wsdlLoc.toExternalForm(), e.getMessage()), e);
             }
@@ -149,7 +161,7 @@
         throw new InaccessibleWSDLException(exceptions);
     }
 
-    private WSDLModelImpl parseUsingMex(@NotNull URL wsdlLoc, @NotNull EntityResolver resolver, boolean isClientSide, WSDLParserExtension[] extensions) throws IOException, SAXException, XMLStreamException, URISyntaxException {
+    private WSDLModelImpl parseUsingMex(@NotNull URL wsdlLoc, @NotNull EntityResolver resolver, boolean isClientSide, Container container, WSDLParserExtension[] extensions) throws IOException, SAXException, XMLStreamException, URISyntaxException {
         //try MEX
         MetaDataResolver mdResolver = null;
         ServiceDescriptor serviceDescriptor = null;
@@ -165,11 +177,10 @@
         }
         if (serviceDescriptor != null) {
             List<? extends Source> wsdls = serviceDescriptor.getWSDLs();
-            wsdlParser = new RuntimeWSDLParser(wsdlLoc.toExternalForm(), new MexEntityResolver(wsdls), isClientSide, extensions);
+            wsdlParser = new RuntimeWSDLParser(wsdlLoc.toExternalForm(), new MexEntityResolver(wsdls), isClientSide, container, extensions);
 
-            //now parse the first WSDL in the list
-            if(wsdls.size() > 0){
-                String systemId = wsdls.get(0).getSystemId();
+            for(Source src: wsdls ) {
+                String systemId = src.getSystemId();
                 Parser parser = wsdlParser.resolver.resolveEntity(null, systemId);
                 wsdlParser.parseWSDL(parser, false);
             }
@@ -176,11 +187,11 @@
         }
         //Incase that mex is not present or it couldn't get the metadata, try by appending ?wsdl and give
         // it a last shot else fail
-        if (mdResolver == null && (wsdlLoc.getProtocol().equals("http") || wsdlLoc.getProtocol().equals("https")) && (wsdlLoc.getQuery() == null)) {
+        if ((mdResolver == null || serviceDescriptor == null) && (wsdlLoc.getProtocol().equals("http") || wsdlLoc.getProtocol().equals("https")) && (wsdlLoc.getQuery() == null)) {
             String urlString = wsdlLoc.toExternalForm();
             urlString += "?wsdl";
             wsdlLoc = new URL(urlString);
-            wsdlParser = new RuntimeWSDLParser(wsdlLoc.toExternalForm(),new EntityResolverWrapper(resolver), isClientSide, extensions);
+            wsdlParser = new RuntimeWSDLParser(wsdlLoc.toExternalForm(),new EntityResolverWrapper(resolver), isClientSide, container, extensions);
             Parser parser = resolveWSDL(wsdlLoc, new StreamSource(wsdlLoc.toExternalForm()));
             wsdlParser.parseWSDL(parser, false);
         }
@@ -199,9 +210,9 @@
         return reader.getName().equals(WSDLConstants.QNAME_DEFINITIONS);
     }
 
-    public static WSDLModelImpl parse(XMLEntityResolver.Parser wsdl, XMLEntityResolver resolver, boolean isClientSide, WSDLParserExtension... extensions) throws IOException, XMLStreamException, SAXException {
+    public static WSDLModelImpl parse(XMLEntityResolver.Parser wsdl, XMLEntityResolver resolver, boolean isClientSide, Container container, WSDLParserExtension... extensions) throws IOException, XMLStreamException, SAXException {
         assert resolver != null;
-        RuntimeWSDLParser parser = new RuntimeWSDLParser( wsdl.systemId.toExternalForm(), resolver, isClientSide, extensions);
+        RuntimeWSDLParser parser = new RuntimeWSDLParser( wsdl.systemId.toExternalForm(), resolver, isClientSide, container, extensions);
         parser.parseWSDL(wsdl, false);
         parser.wsdlDoc.freeze();
         parser.extensionFacade.finished(parser.context);
@@ -209,16 +220,17 @@
         return parser.wsdlDoc;
     }
 
-    private RuntimeWSDLParser(@NotNull String sourceLocation, XMLEntityResolver resolver, boolean isClientSide, WSDLParserExtension... extensions) {
+    private RuntimeWSDLParser(@NotNull String sourceLocation, XMLEntityResolver resolver, boolean isClientSide, Container container, WSDLParserExtension... extensions) {
         this.wsdlDoc = sourceLocation!=null ? new WSDLModelImpl(sourceLocation) : new WSDLModelImpl();
         this.resolver = resolver;
 
         this.extensions = new ArrayList<WSDLParserExtension>();
-        this.context = new WSDLParserExtensionContextImpl(wsdlDoc, isClientSide);
+        this.context = new WSDLParserExtensionContextImpl(wsdlDoc, isClientSide, container);
 
         // register handlers for default extensions
         register(new MemberSubmissionAddressingWSDLParserExtension());
         register(new W3CAddressingWSDLParserExtension());
+        register(new W3CAddressingMetadataWSDLParserExtension());
 
         for (WSDLParserExtension e : extensions)
             register(e);
@@ -406,7 +418,7 @@
                 } else {
                     binding.setStyle(Style.DOCUMENT);
                 }
-                XMLStreamReaderUtil.next(reader);
+                goToEnd(reader);
             } else if (WSDLConstants.NS_SOAP12_BINDING.equals(name)) {
                 binding.setBindingId(BindingID.SOAP12_HTTP);
                 String style = reader.getAttributeValue(null, "style");
@@ -415,7 +427,7 @@
                 } else {
                     binding.setStyle(Style.DOCUMENT);
                 }
-                XMLStreamReaderUtil.next(reader);
+                goToEnd(reader);
             } else if (WSDLConstants.QNAME_OPERATION.equals(name)) {
                 parseBindingOperation(reader, binding);
             } else {
@@ -441,6 +453,7 @@
 
         while (XMLStreamReaderUtil.nextElementContent(reader) != XMLStreamConstants.END_ELEMENT) {
             QName name = reader.getName();
+            String style = null;
             if (WSDLConstants.QNAME_INPUT.equals(name)) {
                 parseInputBinding(reader, bindingOp);
             } else if (WSDLConstants.QNAME_OUTPUT.equals(name)) {
@@ -449,28 +462,28 @@
                 parseFaultBinding(reader, bindingOp);
             } else if (SOAPConstants.QNAME_OPERATION.equals(name) ||
                     SOAPConstants.QNAME_SOAP12OPERATION.equals(name)) {
-                String style = reader.getAttributeValue(null, "style");
-                /**
-                 *  If style attribute is present set it otherwise set the style as defined
-                 *  on the <soap:binding> element
-                 */
-                if (style != null) {
-                    if (style.equals("rpc"))
-                        bindingOp.setStyle(Style.RPC);
-                    else
-                        bindingOp.setStyle(Style.DOCUMENT);
-                } else {
-                    bindingOp.setStyle(binding.getStyle());
-                }
+                style = reader.getAttributeValue(null, "style");
                 String soapAction = reader.getAttributeValue(null, "soapAction");
 
                 if (soapAction != null)
                     bindingOp.setSoapAction(soapAction);
 
-                XMLStreamReaderUtil.next(reader);
+                goToEnd(reader);
             } else {
                 extensionFacade.bindingOperationElements(bindingOp, reader);
             }
+            /**
+             *  If style attribute is present set it otherwise set the style as defined
+             *  on the <soap:binding> element
+             */
+            if (style != null) {
+                if (style.equals("rpc"))
+                    bindingOp.setStyle(Style.RPC);
+                else
+                    bindingOp.setStyle(Style.DOCUMENT);
+            } else {
+                bindingOp.setStyle(binding.getStyle());
+            }
         }
     }
 
@@ -513,21 +526,14 @@
     }
 
     private void parseFaultBinding(XMLStreamReader reader, WSDLBoundOperationImpl bindingOp) {
-        boolean bodyFound = false;
-        extensionFacade.bindingOperationFaultAttributes(bindingOp, reader);
+        String faultName = ParserUtil.getMandatoryNonEmptyAttribute(reader, "name");
+        WSDLBoundFaultImpl wsdlBoundFault = new WSDLBoundFaultImpl(reader, faultName, bindingOp);
+        bindingOp.addFault(wsdlBoundFault);
+
+        extensionFacade.bindingOperationFaultAttributes(wsdlBoundFault, reader);
+
         while (XMLStreamReaderUtil.nextElementContent(reader) != XMLStreamConstants.END_ELEMENT) {
-            QName name = reader.getName();
-            if ((SOAPConstants.QNAME_BODY.equals(name) || SOAPConstants.QNAME_SOAP12BODY.equals(name)) && !bodyFound) {
-                bodyFound = true;
-                bindingOp.setFaultExplicitBodyParts(parseSOAPBodyBinding(reader, bindingOp.getFaultParts()));
-                goToEnd(reader);
-            } else if ((SOAPConstants.QNAME_HEADER.equals(name) || SOAPConstants.QNAME_SOAP12HEADER.equals(name))) {
-                parseSOAPHeaderBinding(reader, bindingOp.getFaultParts());
-            } else if (MIMEConstants.QNAME_MULTIPART_RELATED.equals(name)) {
-                parseMimeMultipartBinding(reader, bindingOp, BindingMode.FAULT);
-            } else {
-                extensionFacade.bindingOperationFaultElements(bindingOp, reader);
-            }
+            extensionFacade.bindingOperationFaultElements(wsdlBoundFault, reader);
         }
     }
 
@@ -698,7 +704,7 @@
         String msg = ParserUtil.getMandatoryNonEmptyAttribute(reader, "message");
         QName msgName = ParserUtil.getQName(reader, msg);
         String name = ParserUtil.getMandatoryNonEmptyAttribute(reader, "name");
-        WSDLFaultImpl fault = new WSDLFaultImpl(reader,name, msgName);
+        WSDLFaultImpl fault = new WSDLFaultImpl(reader,name, msgName, operation);
         operation.addFault(fault);
         extensionFacade.portTypeOperationFaultAttributes(fault, reader);
         extensionFacade.portTypeOperationFault(operation, reader);
@@ -757,11 +763,10 @@
                         break;
                     }
                 }
-                if (desc == null)
-                    continue;
-
-                WSDLPartImpl wsdlPart = new WSDLPartImpl(reader, part, partIndex, new WSDLPartDescriptorImpl(reader,ParserUtil.getQName(reader, desc), kind));
-                msg.add(wsdlPart);
+                if (desc != null) {
+                    WSDLPartImpl wsdlPart = new WSDLPartImpl(reader, part, partIndex, new WSDLPartDescriptorImpl(reader,ParserUtil.getQName(reader, desc), kind));
+                    msg.add(wsdlPart);
+                }
                 if (reader.getEventType() != XMLStreamConstants.END_ELEMENT)
                     goToEnd(reader);
             } else {
--- old/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/WSDLParserExtensionContextImpl.java	Tue Aug  4 10:05:48 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/WSDLParserExtensionContextImpl.java	Tue Aug  4 10:05:48 2009
@@ -25,6 +25,7 @@
 package com.sun.xml.internal.ws.wsdl.parser;
 
 import com.sun.xml.internal.ws.api.model.wsdl.WSDLModel;
+import com.sun.xml.internal.ws.api.server.Container;
 import com.sun.xml.internal.ws.api.wsdl.parser.WSDLParserExtensionContext;
 
 /**
@@ -31,18 +32,21 @@
  * Provides implementation of {@link WSDLParserExtensionContext}
  *
  * @author Vivek Pandey
+ * @author Fabian Ritzmann
  */
 final class WSDLParserExtensionContextImpl implements WSDLParserExtensionContext {
     private final boolean isClientSide;
     private final WSDLModel wsdlModel;
+    private final Container container;
 
     /**
      * Construct {@link WSDLParserExtensionContextImpl} with information that whether its on client side
      * or server side.
      */
-    protected WSDLParserExtensionContextImpl(WSDLModel model, boolean isClientSide) {
+    protected WSDLParserExtensionContextImpl(WSDLModel model, boolean isClientSide, Container container) {
         this.wsdlModel = model;
         this.isClientSide = isClientSide;
+        this.container = container;
     }
 
     public boolean isClientSide() {
@@ -52,4 +56,8 @@
     public WSDLModel getWSDLModel() {
         return wsdlModel;
     }
+
+    public Container getContainer() {
+        return this.container;
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/WSDLParserExtensionFacade.java	Tue Aug  4 10:05:51 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/WSDLParserExtensionFacade.java	Tue Aug  4 10:05:50 2009
@@ -296,9 +296,9 @@
         }
     }
 
-    public boolean bindingOperationFaultElements(WSDLBoundOperation operation, XMLStreamReader reader) {
+    public boolean bindingOperationFaultElements(WSDLBoundFault fault, XMLStreamReader reader) {
         for (WSDLParserExtension e : extensions) {
-            if (e.bindingOperationFaultElements(operation, reader)) {
+            if (e.bindingOperationFaultElements(fault, reader)) {
                 return true;
             }
         }
@@ -306,9 +306,9 @@
         return true;
     }
 
-    public void bindingOperationFaultAttributes(WSDLBoundOperation operation, XMLStreamReader reader) {
+    public void bindingOperationFaultAttributes(WSDLBoundFault fault, XMLStreamReader reader) {
         for (WSDLParserExtension e : extensions) {
-            e.bindingOperationFaultAttributes(operation, reader);
+            e.bindingOperationFaultAttributes(fault, reader);
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/ws/wsdl/writer/UsingAddressing.java	Tue Aug  4 10:05:53 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/wsdl/writer/UsingAddressing.java	Tue Aug  4 10:05:53 2009
@@ -22,9 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: UsingAddressing.java,v 1.1.2.3 2006/09/26 22:17:15 ramapulavarthi Exp $
- */
 
 package com.sun.xml.internal.ws.wsdl.writer;
 
--- old/src/share/classes/com/sun/xml/internal/ws/wsdl/writer/W3CAddressingWSDLGeneratorExtension.java	Tue Aug  4 10:05:55 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/wsdl/writer/W3CAddressingWSDLGeneratorExtension.java	Tue Aug  4 10:05:55 2009
@@ -22,29 +22,27 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-/*
- * $Id: W3CAddressingWSDLGeneratorExtension.java,v 1.1.2.14 2007/03/15 07:22:13 ramapulavarthi Exp $
- */
 
 package com.sun.xml.internal.ws.wsdl.writer;
 
-import javax.xml.ws.Action;
-import javax.xml.ws.FaultAction;
-import javax.xml.ws.soap.AddressingFeature;
-
-import com.sun.istack.internal.NotNull;
 import com.sun.xml.internal.txw2.TypedXmlWriter;
 import com.sun.xml.internal.ws.api.WSBinding;
 import com.sun.xml.internal.ws.api.addressing.AddressingVersion;
 import com.sun.xml.internal.ws.api.model.CheckedException;
 import com.sun.xml.internal.ws.api.model.JavaMethod;
-import com.sun.xml.internal.ws.api.model.SEIModel;
-import com.sun.xml.internal.ws.api.server.Container;
-import com.sun.xml.internal.ws.api.wsdl.writer.WSDLGeneratorExtension;
 import com.sun.xml.internal.ws.api.wsdl.writer.WSDLGenExtnContext;
+import com.sun.xml.internal.ws.api.wsdl.writer.WSDLGeneratorExtension;
 
+import javax.xml.ws.Action;
+import javax.xml.ws.FaultAction;
+import javax.xml.ws.soap.AddressingFeature;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.logging.Logger;
+
 /**
  * @author Arun Gupta
+ * @author Rama Pulavarthi
  */
 public class W3CAddressingWSDLGeneratorExtension extends WSDLGeneratorExtension {
     private boolean enabled;
@@ -70,9 +68,38 @@
         Action a = method.getSEIMethod().getAnnotation(Action.class);
         if (a != null && !a.input().equals("")) {
             addAttribute(input, a.input());
+        } else {
+            if (method.getBinding().getSOAPAction().equals("")) {
+                //hack: generate default action for interop with .Net3.0 when soapAction is non-empty
+                String defaultAction = getDefaultAction(method);
+                addAttribute(input, defaultAction);
+            }
         }
     }
 
+    protected static final String getDefaultAction(JavaMethod method) {
+        String tns = method.getOwner().getTargetNamespace();
+        String delim = "/";
+        // TODO: is this the correct way to find the separator ?
+        try {
+            URI uri = new URI(tns);
+            if(uri.getScheme().equalsIgnoreCase("urn"))
+                delim = ":";
+        } catch (URISyntaxException e) {
+            LOGGER.warning("TargetNamespace of WebService is not a valid URI");
+        }
+        if (tns.endsWith(delim))
+            tns = tns.substring(0, tns.length() - 1);
+        //this assumes that fromjava case there won't be input name.
+        // if there is input name in future, then here name=inputName
+        //else use operation name as follows.
+        String name = (method.getMEP().isOneWay())?method.getOperationName():method.getOperationName()+"Request";
+
+        return new StringBuilder(tns).append(delim).append(
+                method.getOwner().getPortTypeName().getLocalPart()).append(
+                delim).append(name).toString();
+    }
+
     @Override
     public void addOperationOutputExtension(TypedXmlWriter output, JavaMethod method) {
         if (!enabled)
@@ -124,4 +151,5 @@
         }
         */
     }
+     private static final Logger LOGGER = Logger.getLogger(W3CAddressingWSDLGeneratorExtension.class.getName());
 }
--- old/src/share/classes/com/sun/xml/internal/ws/wsdl/writer/WSDLGenerator.java	Tue Aug  4 10:05:58 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/wsdl/writer/WSDLGenerator.java	Tue Aug  4 10:05:57 2009
@@ -500,9 +500,9 @@
         PortType portType = portDefinitions.portType().name(model.getPortTypeName().getLocalPart());
         extension.addPortTypeExtension(portType);
         for (JavaMethodImpl method : model.getJavaMethods()) {
-//            Operation operation = portType.operation().name(method.getOperation().getLocalName());
             Operation operation = portType.operation().name(method.getOperationName());
             generateParameterOrder(operation, method);
+            extension.addOperationExtension(operation, method);
             switch (method.getMEP()) {
                 case REQUEST_RESPONSE:
                     // input message
@@ -581,7 +581,9 @@
                 }
             }
         }
-        operation.parameterOrder(paramOrder.toString());
+        if (i>1) {
+            operation.parameterOrder(paramOrder.toString());
+        }
     }
 
 
@@ -709,7 +711,7 @@
                 SOAPVersion soapVersion = sBinding.getSOAPVersion();
                 if (soapVersion == SOAPVersion.SOAP_12){
                     com.sun.xml.internal.ws.wsdl.writer.document.soap12.SOAPBinding soapBinding = binding.soap12Binding();
-                    soapBinding.transport(SOAP12_HTTP_TRANSPORT);
+                    soapBinding.transport(this.binding.getBindingId().getTransport());
                     if (sBinding.getStyle().equals(Style.DOCUMENT))
                         soapBinding.style(DOCUMENT);
                     else
@@ -716,7 +718,7 @@
                         soapBinding.style(RPC);
                 } else {
                 com.sun.xml.internal.ws.wsdl.writer.document.soap.SOAPBinding soapBinding = binding.soapBinding();
-                    soapBinding.transport(SOAP_HTTP_TRANSPORT);
+                    soapBinding.transport(this.binding.getBindingId().getTransport());
                     if (sBinding.getStyle().equals(Style.DOCUMENT))
                         soapBinding.style(DOCUMENT);
                     else
@@ -825,6 +827,7 @@
         }
         for (CheckedExceptionImpl exception : method.getCheckedExceptions()) {
             Fault fault = operation.fault().name(exception.getMessageName());
+            extension.addBindingOperationFaultExtension(fault, method, exception);
             SOAPFault soapFault = fault._element(SOAPFault.class).name(exception.getMessageName());
             soapFault.use(LITERAL);
         }
@@ -832,9 +835,9 @@
 
     protected void generateSOAP12BindingOperation(JavaMethodImpl method, Binding binding) {
         BindingOperationType operation = binding.operation().name(method.getOperationName());
+        extension.addBindingOperationExtension(operation, method);
         String targetNamespace = model.getTargetNamespace();
         QName requestMessage = new QName(targetNamespace, method.getOperationName());
-
         ArrayList<ParameterImpl> bodyParams = new ArrayList<ParameterImpl>();
         ArrayList<ParameterImpl> headerParams = new ArrayList<ParameterImpl>();
         splitParameters(bodyParams, headerParams, method.getRequestParameters());
@@ -843,7 +846,7 @@
 
         // input
         TypedXmlWriter input = operation.input();
-
+        extension.addBindingOperationInputExtension(input, method);
         com.sun.xml.internal.ws.wsdl.writer.document.soap12.BodyType body = input._element(com.sun.xml.internal.ws.wsdl.writer.document.soap12.Body.class);
         boolean isRpc = soapBinding.getStyle().equals(Style.RPC);
         if (soapBinding.getUse().equals(Use.LITERAL)) {
@@ -886,6 +889,7 @@
             splitParameters(bodyParams, headerParams, method.getResponseParameters());
             unwrappable = unwrappable ? headerParams.size() == 0 : unwrappable;
             TypedXmlWriter output = operation.output();
+            extension.addBindingOperationOutputExtension(output, method);
             body = output._element(com.sun.xml.internal.ws.wsdl.writer.document.soap12.Body.class);
             body.use(LITERAL);
             if (headerParams.size() > 0) {
@@ -921,6 +925,7 @@
         }
         for (CheckedExceptionImpl exception : method.getCheckedExceptions()) {
             Fault fault = operation.fault().name(exception.getMessageName());
+            extension.addBindingOperationFaultExtension(fault, method, exception);
             com.sun.xml.internal.ws.wsdl.writer.document.soap12.SOAPFault soapFault = fault._element(com.sun.xml.internal.ws.wsdl.writer.document.soap12.SOAPFault.class).name(exception.getMessageName());
             soapFault.use(LITERAL);
         }
--- old/src/share/classes/com/sun/xml/internal/xsom/ForeignAttributes.java	Tue Aug  4 10:06:00 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/ForeignAttributes.java	Tue Aug  4 10:06:00 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom;
 
 import org.xml.sax.Attributes;
--- old/src/share/classes/com/sun/xml/internal/xsom/SCD.java	Tue Aug  4 10:06:02 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/SCD.java	Tue Aug  4 10:06:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom;
 
 import com.sun.xml.internal.xsom.impl.scd.Iterators;
--- old/src/share/classes/com/sun/xml/internal/xsom/XSAnnotation.java	Tue Aug  4 10:06:04 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSAnnotation.java	Tue Aug  4 10:06:04 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import org.xml.sax.Locator;
--- old/src/share/classes/com/sun/xml/internal/xsom/XSAttContainer.java	Tue Aug  4 10:06:06 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSAttContainer.java	Tue Aug  4 10:06:06 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import java.util.Iterator;
--- old/src/share/classes/com/sun/xml/internal/xsom/XSAttGroupDecl.java	Tue Aug  4 10:06:09 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSAttGroupDecl.java	Tue Aug  4 10:06:08 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSAttributeDecl.java	Tue Aug  4 10:06:11 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSAttributeDecl.java	Tue Aug  4 10:06:10 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSAttributeUse.java	Tue Aug  4 10:06:13 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSAttributeUse.java	Tue Aug  4 10:06:13 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import org.relaxng.datatype.ValidationContext;
--- old/src/share/classes/com/sun/xml/internal/xsom/XSComplexType.java	Tue Aug  4 10:06:16 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSComplexType.java	Tue Aug  4 10:06:16 2009
@@ -22,9 +22,13 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
+import java.util.List;
 
+
 /**
  * Complex type.
  *
@@ -98,4 +102,19 @@
      *      if this component has not been redefined.
      */
     public XSComplexType getRedefinedBy();
+
+    /**
+     * Returns a list of direct subtypes of this complex type. If the type is not subtyped, returns empty list.
+     * Doesn't return null.
+     * Note that the complex type may be extended outside of the scope of the schemaset known to XSOM.
+     * @return
+     */
+    public List<XSComplexType> getSubtypes();
+
+    /**
+     * Returns a list of element declarations of this type.
+     * @return
+     */
+    public List<XSElementDecl> getElementDecls();
+
 }
--- old/src/share/classes/com/sun/xml/internal/xsom/XSComponent.java	Tue Aug  4 10:06:18 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSComponent.java	Tue Aug  4 10:06:18 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import com.sun.xml.internal.xsom.parser.SchemaDocument;
--- old/src/share/classes/com/sun/xml/internal/xsom/XSContentType.java	Tue Aug  4 10:06:20 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSContentType.java	Tue Aug  4 10:06:20 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import com.sun.xml.internal.xsom.visitor.XSContentTypeFunction;
--- old/src/share/classes/com/sun/xml/internal/xsom/XSDeclaration.java	Tue Aug  4 10:06:23 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSDeclaration.java	Tue Aug  4 10:06:22 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSElementDecl.java	Tue Aug  4 10:06:25 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSElementDecl.java	Tue Aug  4 10:06:25 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import java.util.List;
@@ -140,4 +142,15 @@
 
     XmlString getDefaultValue();
     XmlString getFixedValue();
+
+    /**
+     * Used for javadoc schema generation
+     *
+     * @return
+     *    null if form attribute not present,
+     *    true if form attribute present and set to qualified,
+     *    false if form attribute present and set to unqualified.
+     */
+
+    Boolean getForm();
 }
--- old/src/share/classes/com/sun/xml/internal/xsom/XSFacet.java	Tue Aug  4 10:06:27 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSFacet.java	Tue Aug  4 10:06:27 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSIdentityConstraint.java	Tue Aug  4 10:06:30 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSIdentityConstraint.java	Tue Aug  4 10:06:29 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom;
 
 import java.util.List;
--- old/src/share/classes/com/sun/xml/internal/xsom/XSListSimpleType.java	Tue Aug  4 10:06:32 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSListSimpleType.java	Tue Aug  4 10:06:31 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSModelGroup.java	Tue Aug  4 10:06:34 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSModelGroup.java	Tue Aug  4 10:06:34 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSModelGroupDecl.java	Tue Aug  4 10:06:37 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSModelGroupDecl.java	Tue Aug  4 10:06:37 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 
--- old/src/share/classes/com/sun/xml/internal/xsom/XSNotation.java	Tue Aug  4 10:06:39 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSNotation.java	Tue Aug  4 10:06:39 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSParticle.java	Tue Aug  4 10:06:42 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSParticle.java	Tue Aug  4 10:06:41 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSRestrictionSimpleType.java	Tue Aug  4 10:06:44 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSRestrictionSimpleType.java	Tue Aug  4 10:06:44 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import java.util.Iterator;
@@ -40,6 +42,12 @@
     /** Iterates facets that are specified in this step of derivation. */
     public Iterator<XSFacet> iterateDeclaredFacets();
 
+    /**
+     * Gets all the facets that are declared on this restriction.
+     *
+     * @return
+     *      Can be empty but always non-null.
+     */
     public Collection<? extends XSFacet> getDeclaredFacets();
 
     /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSSchema.java	Tue Aug  4 10:06:47 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSSchema.java	Tue Aug  4 10:06:46 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import com.sun.xml.internal.xsom.parser.SchemaDocument;
--- old/src/share/classes/com/sun/xml/internal/xsom/XSSchemaSet.java	Tue Aug  4 10:06:49 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSSchemaSet.java	Tue Aug  4 10:06:48 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import javax.xml.namespace.NamespaceContext;
--- old/src/share/classes/com/sun/xml/internal/xsom/XSSimpleType.java	Tue Aug  4 10:06:51 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSSimpleType.java	Tue Aug  4 10:06:51 2009
@@ -22,11 +22,15 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import com.sun.xml.internal.xsom.visitor.XSSimpleTypeFunction;
 import com.sun.xml.internal.xsom.visitor.XSSimpleTypeVisitor;
 
+import java.util.List;
+
 /**
  * Simple type.
  *
@@ -131,7 +135,17 @@
      */
     XSFacet getFacet( String name );
 
+    /**
+     * For multi-valued facets (enumeration and pattern), obtain all values.
+     *
+     * @see #getFacet(String)
+     *
+     * @return
+     *      can be empty but never null.
+     */
+    List<XSFacet> getFacets( String name );
 
+
 
     void visit( XSSimpleTypeVisitor visitor );
     <T> T apply( XSSimpleTypeFunction<T> function );
--- old/src/share/classes/com/sun/xml/internal/xsom/XSTerm.java	Tue Aug  4 10:06:54 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSTerm.java	Tue Aug  4 10:06:53 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import com.sun.xml.internal.xsom.visitor.XSTermFunction;
--- old/src/share/classes/com/sun/xml/internal/xsom/XSType.java	Tue Aug  4 10:06:57 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSType.java	Tue Aug  4 10:06:56 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSUnionSimpleType.java	Tue Aug  4 10:06:59 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSUnionSimpleType.java	Tue Aug  4 10:06:58 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSVariety.java	Tue Aug  4 10:07:01 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSVariety.java	Tue Aug  4 10:07:01 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XSWildcard.java	Tue Aug  4 10:07:03 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSWildcard.java	Tue Aug  4 10:07:03 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom;
 
 import java.util.Iterator;
--- old/src/share/classes/com/sun/xml/internal/xsom/XSXPath.java	Tue Aug  4 10:07:06 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XSXPath.java	Tue Aug  4 10:07:05 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/XmlString.java	Tue Aug  4 10:07:08 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/XmlString.java	Tue Aug  4 10:07:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom;
 
 import org.relaxng.datatype.ValidationContext;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/AnnotationImpl.java	Tue Aug  4 10:07:10 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/AnnotationImpl.java	Tue Aug  4 10:07:10 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSAnnotation;
@@ -51,6 +53,28 @@
         locator = NULL_LOCATION;
     }
 
+    private static class LocatorImplUnmodifiable extends LocatorImpl {
 
-    private static final LocatorImpl NULL_LOCATION = new LocatorImpl();
+        @Override
+        public void setColumnNumber(int columnNumber) {
+            return;
+        }
+
+        @Override
+        public void setPublicId(String publicId) {
+            return;
+        }
+
+        @Override
+        public void setSystemId(String systemId) {
+            return;
+        }
+
+        @Override
+        public void setLineNumber(int lineNumber) {
+            return;
+        }
+    };
+
+    private static final LocatorImplUnmodifiable NULL_LOCATION = new LocatorImplUnmodifiable();
 }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/AttGroupDeclImpl.java	Tue Aug  4 10:07:13 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/AttGroupDeclImpl.java	Tue Aug  4 10:07:12 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSAttGroupDecl;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/AttributeDeclImpl.java	Tue Aug  4 10:07:15 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/AttributeDeclImpl.java	Tue Aug  4 10:07:15 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSAttributeDecl;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/AttributeUseImpl.java	Tue Aug  4 10:07:17 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/AttributeUseImpl.java	Tue Aug  4 10:07:17 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSAttributeDecl;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/AttributesHolder.java	Tue Aug  4 10:07:20 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/AttributesHolder.java	Tue Aug  4 10:07:19 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSAttGroupDecl;
@@ -67,7 +69,12 @@
     public void addProhibitedAttribute( UName name ) {
         prohibitedAtts.add(name);
     }
-    public List<XSAttributeUse> getAttributeUses() {
+
+    /**
+     * Returns the attribute uses by looking at attribute groups and etc.
+     * Searching for the base type is done in {@link ComplexTypeImpl}.
+     */
+    public Collection<XSAttributeUse> getAttributeUses() {
         // TODO: this is fairly inefficient
         List<XSAttributeUse> v = new ArrayList<XSAttributeUse>();
         v.addAll(attributes.values());
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/ComplexTypeImpl.java	Tue Aug  4 10:07:22 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/ComplexTypeImpl.java	Tue Aug  4 10:07:22 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSAttGroupDecl;
@@ -30,6 +32,8 @@
 import com.sun.xml.internal.xsom.XSComplexType;
 import com.sun.xml.internal.xsom.XSContentType;
 import com.sun.xml.internal.xsom.XSElementDecl;
+import com.sun.xml.internal.xsom.XSSchema;
+import com.sun.xml.internal.xsom.XSSchemaSet;
 import com.sun.xml.internal.xsom.XSSimpleType;
 import com.sun.xml.internal.xsom.XSType;
 import com.sun.xml.internal.xsom.XSWildcard;
@@ -38,9 +42,14 @@
 import com.sun.xml.internal.xsom.impl.scd.Iterators;
 import com.sun.xml.internal.xsom.visitor.XSFunction;
 import com.sun.xml.internal.xsom.visitor.XSVisitor;
+import java.util.ArrayList;
+import java.util.List;
 import org.xml.sax.Locator;
 
+import java.util.Collection;
+import java.util.HashMap;
 import java.util.Iterator;
+import java.util.Map;
 
 public class ComplexTypeImpl extends AttributesHolder implements XSComplexType, Ref.ComplexType
 {
@@ -230,13 +239,29 @@
             super.iterateAttributeUses() );
     }
 
+    public Collection<XSAttributeUse> getAttributeUses() {
+        XSComplexType baseType = getBaseType().asComplexType();
 
+        if( baseType==null )    return super.getAttributeUses();
+
+        // TODO: this is fairly inefficient
+        Map<UName,XSAttributeUse> uses = new HashMap<UName, XSAttributeUse>();
+        for( XSAttributeUse a : baseType.getAttributeUses())
+            uses.put(new UName(a.getDecl()),a);
+
+        uses.keySet().removeAll(prohibitedAtts);
+
+        for( XSAttributeUse a : super.getAttributeUses())
+            uses.put(new UName(a.getDecl()),a);
+
+        return uses.values();
+    }
+
+
     public XSType[] listSubstitutables() {
         return Util.listSubstitutables(this);
     }
 
-
-
     public void visit( XSVisitor visitor ) {
         visitor.complexType(this);
     }
@@ -246,4 +271,30 @@
 
     // Ref.ComplexType implementation
     public XSComplexType getType() { return this; }
+
+    public List<XSComplexType> getSubtypes() {
+        ArrayList subtypeList = new ArrayList();
+        Iterator<XSComplexType> cTypes = getRoot().iterateComplexTypes();
+        while (cTypes.hasNext()) {
+            XSComplexType cType= cTypes.next();
+            XSType base = cType.getBaseType();
+            if ((base != null) && (base.equals(this))) {
+                subtypeList.add(cType);
+            }
+        }
+        return subtypeList;
+    }
+
+    public List<XSElementDecl> getElementDecls() {
+        ArrayList declList = new ArrayList();
+        XSSchemaSet schemaSet = getRoot();
+        for (XSSchema sch : schemaSet.getSchemas()) {
+            for (XSElementDecl decl : sch.getElementDecls().values()) {
+                if (decl.getType().equals(this)) {
+                    declList.add(decl);
+                }
+            }
+        }
+        return declList;
+    }
 }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/ComponentImpl.java	Tue Aug  4 10:07:25 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/ComponentImpl.java	Tue Aug  4 10:07:24 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.SCD;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/Const.java	Tue Aug  4 10:07:27 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/Const.java	Tue Aug  4 10:07:27 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 public class Const
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/ContentTypeImpl.java	Tue Aug  4 10:07:29 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/ContentTypeImpl.java	Tue Aug  4 10:07:29 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSContentType;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/DeclarationImpl.java	Tue Aug  4 10:07:32 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/DeclarationImpl.java	Tue Aug  4 10:07:32 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSDeclaration;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/ElementDecl.java	Tue Aug  4 10:07:35 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/ElementDecl.java	Tue Aug  4 10:07:35 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSElementDecl;
@@ -53,10 +55,10 @@
         String _tns, String _name, boolean _anonymous,
 
         XmlString _defv, XmlString _fixedv,
-        boolean _nillable, boolean _abstract,
+        boolean _nillable, boolean _abstract, Boolean _form,
         Ref.Type _type, Ref.Element _substHead,
         int _substDisallowed, int _substExcluded,
-        List<IdentityConstraintImpl> idConstraints ) {
+        List<IdentityConstraintImpl> idConstraints) {
 
         super(owner,_annon,_loc,fa,_tns,_name,_anonymous);
 
@@ -64,6 +66,7 @@
         this.fixedValue = _fixedv;
         this.nillable = _nillable;
         this._abstract = _abstract;
+        this.form = _form;
         this.type = _type;
         this.substHead = _substHead;
         this.substDisallowed = _substDisallowed;
@@ -113,6 +116,11 @@
         return idConstraints;
     }
 
+    private Boolean form;
+    public Boolean getForm() {
+        return form;
+    }
+
 
     /**
      * @deprecated
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/EmptyImpl.java	Tue Aug  4 10:07:38 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/EmptyImpl.java	Tue Aug  4 10:07:37 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSContentType;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/FacetImpl.java	Tue Aug  4 10:07:40 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/FacetImpl.java	Tue Aug  4 10:07:39 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSFacet;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/ForeignAttributesImpl.java	Tue Aug  4 10:07:42 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/ForeignAttributesImpl.java	Tue Aug  4 10:07:42 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.ForeignAttributes;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/IdentityConstraintImpl.java	Tue Aug  4 10:07:44 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/IdentityConstraintImpl.java	Tue Aug  4 10:07:44 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSElementDecl;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/ListSimpleTypeImpl.java	Tue Aug  4 10:07:47 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/ListSimpleTypeImpl.java	Tue Aug  4 10:07:47 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSFacet;
@@ -33,6 +35,8 @@
 import com.sun.xml.internal.xsom.visitor.XSSimpleTypeVisitor;
 import org.xml.sax.Locator;
 
+import java.util.Collections;
+import java.util.List;
 import java.util.Set;
 
 public class ListSimpleTypeImpl extends SimpleTypeImpl implements XSListSimpleType
@@ -60,6 +64,7 @@
 
     // list type by itself doesn't have any facet. */
     public XSFacet getFacet( String name ) { return null; }
+    public List<XSFacet> getFacets( String name ) { return Collections.EMPTY_LIST; }
 
     public XSVariety getVariety() { return XSVariety.LIST; }
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/ModelGroupDeclImpl.java	Tue Aug  4 10:07:49 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/ModelGroupDeclImpl.java	Tue Aug  4 10:07:49 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSElementDecl;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/ModelGroupImpl.java	Tue Aug  4 10:07:52 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/ModelGroupImpl.java	Tue Aug  4 10:07:51 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSElementDecl;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/NotationImpl.java	Tue Aug  4 10:07:55 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/NotationImpl.java	Tue Aug  4 10:07:54 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSNotation;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/ParticleImpl.java	Tue Aug  4 10:07:57 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/ParticleImpl.java	Tue Aug  4 10:07:57 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSContentType;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/Ref.java	Tue Aug  4 10:08:00 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/Ref.java	Tue Aug  4 10:07:59 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSAttGroupDecl;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/RestrictionSimpleTypeImpl.java	Tue Aug  4 10:08:02 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/RestrictionSimpleTypeImpl.java	Tue Aug  4 10:08:02 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSFacet;
@@ -88,6 +90,14 @@
         return getSimpleBaseType().getFacet(name);
     }
 
+    public List<XSFacet> getFacets( String name ) {
+        List<XSFacet> f = getDeclaredFacets(name);
+        if(!f.isEmpty())     return f;
+
+        // none was found on this datatype. check the base type.
+        return getSimpleBaseType().getFacets(name);
+    }
+
     public XSVariety getVariety() { return getSimpleBaseType().getVariety(); }
 
     public XSSimpleType getPrimitiveType() {
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/SchemaImpl.java	Tue Aug  4 10:08:04 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/SchemaImpl.java	Tue Aug  4 10:08:04 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.ForeignAttributes;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/SchemaSetImpl.java	Tue Aug  4 10:08:07 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/SchemaSetImpl.java	Tue Aug  4 10:08:07 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.SCD;
@@ -58,6 +60,7 @@
 
 import javax.xml.namespace.NamespaceContext;
 import java.text.ParseException;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
@@ -285,6 +288,7 @@
         public XSListSimpleType getBaseListType() {return null;}
         public XSUnionSimpleType getBaseUnionType() {return null;}
         public XSFacet getFacet(String name) { return null; }
+        public List<XSFacet> getFacets( String name ) { return Collections.EMPTY_LIST; }
         public XSFacet getDeclaredFacet(String name) { return null; }
         public List<XSFacet> getDeclaredFacets(String name) { return Collections.EMPTY_LIST; }
 
@@ -362,5 +366,30 @@
                         XSParticle.UNBOUNDED, 0 )
                 })
                 ,null,1,1);
+        public List<XSComplexType> getSubtypes() {
+            ArrayList subtypeList = new ArrayList();
+            Iterator<XSComplexType> cTypes = getRoot().iterateComplexTypes();
+            while (cTypes.hasNext()) {
+                XSComplexType cType= cTypes.next();
+                XSType base = cType.getBaseType();
+                if ((base != null) && (base.equals(this))) {
+                    subtypeList.add(cType);
+                }
+            }
+            return subtypeList;
+        }
+
+        public List<XSElementDecl> getElementDecls() {
+            ArrayList declList = new ArrayList();
+            XSSchemaSet schemaSet = getRoot();
+            for (XSSchema sch : schemaSet.getSchemas()) {
+                for (XSElementDecl decl : sch.getElementDecls().values()) {
+                    if (decl.getType().equals(this)) {
+                        declList.add(decl);
+                    }
+                }
+            }
+            return declList;
+        }
     }
 }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/SimpleTypeImpl.java	Tue Aug  4 10:08:09 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/SimpleTypeImpl.java	Tue Aug  4 10:08:09 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSComplexType;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/UName.java	Tue Aug  4 10:08:12 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/UName.java	Tue Aug  4 10:08:11 2009
@@ -22,8 +22,11 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl;
 
+import com.sun.xml.internal.xsom.XSDeclaration;
+
 import java.util.Comparator;
 
 /**
@@ -49,6 +52,10 @@
         this(nsUri,localName,localName);
     }
 
+    public UName(XSDeclaration decl) {
+        this(decl.getTargetNamespace(),decl.getName());
+    }
+
     private final String nsUri;
     private final String localName;
     private final String qname;
@@ -57,6 +64,32 @@
     public String getNamespaceURI() { return nsUri; }
     public String getQualifiedName() { return qname; }
 
+
+    // Issue 540; XSComplexType.getAttributeUse(String,String) always return null
+    // UName was used in HashMap without overriden equals and hashCode methods.
+
+    @Override
+    public boolean equals(Object obj) {
+        if(obj instanceof UName) {
+            UName u = (UName)obj;
+
+            return ((this.getName().compareTo(u.getName()) == 0) &&
+                    (this.getNamespaceURI().compareTo(u.getNamespaceURI()) == 0) &&
+                    (this.getQualifiedName().compareTo(u.getQualifiedName()) == 0));
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = 7;
+        hash = 13 * hash + (this.nsUri != null ? this.nsUri.hashCode() : 0);
+        hash = 13 * hash + (this.localName != null ? this.localName.hashCode() : 0);
+        hash = 13 * hash + (this.qname != null ? this.qname.hashCode() : 0);
+        return hash;
+    }
+
     /**
      * Compares {@link UName}s by their names.
      */
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/UnionSimpleTypeImpl.java	Tue Aug  4 10:08:14 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/UnionSimpleTypeImpl.java	Tue Aug  4 10:08:14 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSFacet;
@@ -35,6 +37,8 @@
 
 import java.util.Iterator;
 import java.util.Set;
+import java.util.List;
+import java.util.Collections;
 
 public class UnionSimpleTypeImpl extends SimpleTypeImpl implements XSUnionSimpleType
 {
@@ -83,8 +87,9 @@
 
     // union type by itself doesn't have any facet. */
     public XSFacet getFacet( String name ) { return null; }
+    public List<XSFacet> getFacets( String name ) { return Collections.EMPTY_LIST; }
 
-    public XSVariety getVariety() { return XSVariety.LIST; }
+    public XSVariety getVariety() { return XSVariety.UNION; }
 
     public XSSimpleType getPrimitiveType() { return null; }
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/Util.java	Tue Aug  4 10:08:18 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/Util.java	Tue Aug  4 10:08:17 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSComplexType;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/WildcardImpl.java	Tue Aug  4 10:08:20 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/WildcardImpl.java	Tue Aug  4 10:08:20 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSElementDecl;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/XPathImpl.java	Tue Aug  4 10:08:23 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/XPathImpl.java	Tue Aug  4 10:08:23 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl;
 
 import com.sun.xml.internal.xsom.XSIdentityConstraint;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/package.html	Tue Aug  4 10:08:26 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/package.html	Tue Aug  4 10:08:26 2009
@@ -23,5 +23,5 @@
  have any questions.
 -->
 <html><body>
-Implementation of the <code>com.sun.xml.xsom</code> package.
+Implementation of the <code>com.sun.xml.internal.xsom</code> package.
 </body></html>
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/BaseContentRef.java	Tue Aug  4 10:08:28 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/BaseContentRef.java	Tue Aug  4 10:08:28 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl.parser;
 
 import com.sun.xml.internal.xsom.impl.Ref;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/DefaultAnnotationParser.java	Tue Aug  4 10:08:31 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/DefaultAnnotationParser.java	Tue Aug  4 10:08:30 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl.parser;
 
 import com.sun.xml.internal.xsom.parser.AnnotationContext;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/DelayedRef.java	Tue Aug  4 10:08:33 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/DelayedRef.java	Tue Aug  4 10:08:33 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl.parser;
 
 import com.sun.xml.internal.xsom.XSAttGroupDecl;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/Messages.java	Tue Aug  4 10:08:36 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/Messages.java	Tue Aug  4 10:08:35 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl.parser;
 
 import java.text.MessageFormat;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/Messages.properties	Tue Aug  4 10:08:38 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/Messages.properties	Tue Aug  4 10:08:38 2009
@@ -24,50 +24,49 @@
 #
 
 UndefinedSimpleType = \
-	undefined simple type ''{0}''
+        undefined simple type ''{0}''
 
 UndefinedCompplexType = \
-	undefined complex type ''{0}''
+        undefined complex type ''{0}''
 
 UndefinedType = \
-	undefined simple or complex type ''{0}''
+        undefined simple or complex type ''{0}''
 
 UndefinedElement = \
-	undefined element declaration ''{0}''
+        undefined element declaration ''{0}''
 
 UndefinedModelGroup = \
-	undefined model group ''{0}''
+        undefined model group ''{0}''
 
 UndefinedAttribute = \
-	undefined attribute ''{0}''
+        undefined attribute ''{0}''
 
 UndefinedAttributeGroup = \
-	undefined attribute group ''{0}''
+        undefined attribute group ''{0}''
 
 UndefinedIdentityConstraint = \
     undefined identity constraint ''{0}''
 
 UndefinedPrefix = \
-	unbounded prefix ''{0}''
+        unbounded prefix ''{0}''
 
 UnexpectedTargetnamespace.Include = \
-	the target namespace of the included schema "{0}" doesn''t agree with the expected value "{1}"
+        the target namespace of the included schema "{0}" doesn''t agree with the expected value "{1}"
 
 UnexpectedTargetnamespace.Import = \
-	the target namespace of the imported schema "{0}" doesn''t agree with the expected value "{1}"
+        the target namespace of the imported schema "{0}" doesn''t agree with the expected value "{1}"
 
 DoubleDefinition = \
-	''{0}'' is already defined
+        ''{0}'' is already defined
 
 DoubleDefinition.Original = \
-	(related to above error) the first definition appears here
-	
+        (related to above error) the first definition appears here
+
 MissingSchemaLocation = \
-	a "schemaLocation" attribute is required
+        a "schemaLocation" attribute is required
 
 EntityResolutionFailure = \
-	failed to retrieve ''{0}'': {1}
+        failed to retrieve ''{0}'': {1}
 
 SimpleContentExpected = \
   A complex type with a simple content or a simple type is expected but found ''{0}'':{1}
- 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/Messages_ja.properties	Tue Aug  4 10:08:40 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/Messages_ja.properties	Tue Aug  4 10:08:40 2009
@@ -24,47 +24,46 @@
 #
 
 UndefinedSimpleType = \
-	\u672A\u5B9A\u7FA9\u306E\u30B7\u30F3\u30D7\u30EB\u30BF\u30A4\u30D7''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
+        \u672A\u5B9A\u7FA9\u306E\u30B7\u30F3\u30D7\u30EB\u30BF\u30A4\u30D7''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
 
 UndefinedCompplexType = \
-	\u672A\u5B9A\u7FA9\u306E\u30B3\u30F3\u30D7\u30EC\u30C3\u30AF\u30B9\u30BF\u30A4\u30D7''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
+        \u672A\u5B9A\u7FA9\u306E\u30B3\u30F3\u30D7\u30EC\u30C3\u30AF\u30B9\u30BF\u30A4\u30D7''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
 
 UndefinedType = \
-	\u672A\u5B9A\u7FA9\u306E\u578B''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
+        \u672A\u5B9A\u7FA9\u306E\u578B''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
 
 UndefinedElement = \
-	\u672A\u5B9A\u7FA9\u306E\u8981\u7D20''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
+        \u672A\u5B9A\u7FA9\u306E\u8981\u7D20''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
 
 UndefinedModelGroup = \
-	\u672A\u5B9A\u7FA9\u306E\u30E2\u30C7\u30EB\u30B0\u30EB\u30FC\u30D7''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
+        \u672A\u5B9A\u7FA9\u306E\u30E2\u30C7\u30EB\u30B0\u30EB\u30FC\u30D7''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
 
 UndefinedAttribute = \
-	\u672A\u5B9A\u7FA9\u306E\u5C5E\u6027''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
+        \u672A\u5B9A\u7FA9\u306E\u5C5E\u6027''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
 
 UndefinedAttributeGroup = \
-	\u672A\u5B9A\u7FA9\u306E\u5C5E\u6027\u30B0\u30EB\u30FC\u30D7''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
+        \u672A\u5B9A\u7FA9\u306E\u5C5E\u6027\u30B0\u30EB\u30FC\u30D7''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
 
 UndefinedIdentityConstraint = \
-	\u672A\u5B9A\u7FA9\u306E\u4E00\u610F\u6027\u5236\u7D04''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
+        \u672A\u5B9A\u7FA9\u306E\u4E00\u610F\u6027\u5236\u7D04''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
 
 UndefinedPrefix = \
-	xmlns\u5BA3\u8A00\u306E\u3055\u308C\u3066\u3044\u306A\u3044\u30D7\u30EC\u30D5\u30A3\u30C3\u30AF\u30B9''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
+        xmlns\u5BA3\u8A00\u306E\u3055\u308C\u3066\u3044\u306A\u3044\u30D7\u30EC\u30D5\u30A3\u30C3\u30AF\u30B9''{0}''\u304C\u4F7F\u308F\u308C\u3066\u3044\u307E\u3059
 
 UnexpectedTargetnamespace.Include = \
-	include\u3057\u305F\u5074\u3068\u3055\u308C\u305F\u5074\u306EtargetNamespace\u5C5E\u6027\u306E\u5024\u304C\u98DF\u3044\u9055\u3063\u3066\u3044\u307E\u3059({0}\u3068{1})
+        include\u3057\u305F\u5074\u3068\u3055\u308C\u305F\u5074\u306EtargetNamespace\u5C5E\u6027\u306E\u5024\u304C\u98DF\u3044\u9055\u3063\u3066\u3044\u307E\u3059({0}\u3068{1})
 
 UnexpectedTargetnamespace.Import = \
-	import\u3057\u305F\u5074\u3068\u3055\u308C\u305F\u5074\u306EtargetNamespace\u5C5E\u6027\u306E\u5024\u304C\u98DF\u3044\u9055\u3063\u3066\u3044\u307E\u3059({0}\u3068{1})
+        import\u3057\u305F\u5074\u3068\u3055\u308C\u305F\u5074\u306EtargetNamespace\u5C5E\u6027\u306E\u5024\u304C\u98DF\u3044\u9055\u3063\u3066\u3044\u307E\u3059({0}\u3068{1})
 
 DoubleDefinition = \
-	''{0}''\u306F\u65E2\u306B\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u3059
+        ''{0}''\u306F\u65E2\u306B\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u3059
 
 DoubleDefinition.Original = \
-	\uFF08\u4E0A\u306E\u30A8\u30E9\u30FC\u306B\u95A2\u9023\uFF09\u5143\u3005\u306E\u5B9A\u7FA9\u306F\u3053\u3053\u3067\u884C\u308F\u308C\u3066\u3044\u307E\u3059
+        \uFF08\u4E0A\u306E\u30A8\u30E9\u30FC\u306B\u95A2\u9023\uFF09\u5143\u3005\u306E\u5B9A\u7FA9\u306F\u3053\u3053\u3067\u884C\u308F\u308C\u3066\u3044\u307E\u3059
 
 MissingSchemaLocation = \
-	schemaLocation\u5C5E\u6027\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093
+        schemaLocation\u5C5E\u6027\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093
 
 EntityResolutionFailure = \
-	''{0}''\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093: {1}
- 
+        ''{0}''\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093: {1}
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/NGCCRuntimeEx.java	Tue Aug  4 10:08:43 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/NGCCRuntimeEx.java	Tue Aug  4 10:08:42 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl.parser;
 
 import com.sun.xml.internal.xsom.XSDeclaration;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/ParserContext.java	Tue Aug  4 10:08:45 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/ParserContext.java	Tue Aug  4 10:08:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl.parser;
 
 import com.sun.xml.internal.xsom.XSSchemaSet;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/Patch.java	Tue Aug  4 10:08:47 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/Patch.java	Tue Aug  4 10:08:47 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl.parser;
 
 import org.xml.sax.SAXException;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/PatcherManager.java	Tue Aug  4 10:08:50 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/PatcherManager.java	Tue Aug  4 10:08:49 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl.parser;
 
 import org.xml.sax.Locator;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/SAXParserFactoryAdaptor.java	Tue Aug  4 10:08:52 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/SAXParserFactoryAdaptor.java	Tue Aug  4 10:08:52 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl.parser;
 
 import com.sun.xml.internal.xsom.parser.XMLParser;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/SchemaDocumentImpl.java	Tue Aug  4 10:08:54 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/SchemaDocumentImpl.java	Tue Aug  4 10:08:54 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl.parser;
 
 import com.sun.xml.internal.xsom.impl.SchemaImpl;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/SubstGroupBaseTypeRef.java	Tue Aug  4 10:08:57 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/SubstGroupBaseTypeRef.java	Tue Aug  4 10:08:56 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl.parser;
 
 import com.sun.xml.internal.xsom.XSType;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/Schema.java	Tue Aug  4 10:08:59 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/Schema.java	Tue Aug  4 10:08:59 2009
@@ -194,30 +194,51 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 41:
+        case 16:
             {
-                if(($ai = $runtime.getAttributeIndex("","blockDefault"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 37;
+                    $_ngcc_current_state = 12;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 16:
+        case 11:
             {
-                if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if((($ai = $runtime.getAttributeIndex("","name"))>=0 || ($ai = $runtime.getAttributeIndex("","form"))>=0)) {
+                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 24, locator,false,defaultValue,fixedValue);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 12;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
+        case 36:
+            {
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("import")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("redefine")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("include")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("notation")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))))))))))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 130, null);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
+            }
+            break;
+        case 27:
+            {
+                if((($ai = $runtime.getAttributeIndex("","default"))>=0 || (($ai = $runtime.getAttributeIndex("","block"))>=0 || (($ai = $runtime.getAttributeIndex("","fixed"))>=0 || (($ai = $runtime.getAttributeIndex("","form"))>=0 || (($ai = $runtime.getAttributeIndex("","final"))>=0 || (($ai = $runtime.getAttributeIndex("","abstract"))>=0 || ($ai = $runtime.getAttributeIndex("","name"))>=0))))))) {
+                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 42, locator,true);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
+            }
+            break;
         case 45:
             {
                 if(($ai = $runtime.getAttributeIndex("","elementFormDefault"))>=0) {
@@ -230,23 +251,42 @@
                 }
             }
             break;
-        case 0:
+        case 41:
             {
-                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","blockDefault"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 37;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
             }
             break;
-        case 12:
+        case 37:
             {
-                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","finalDefault"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 11;
+                    $_ngcc_current_state = 36;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
+        case 49:
+            {
+                if(($ai = $runtime.getAttributeIndex("","attributeFormDefault"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 45;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+            }
+            break;
         case 53:
             {
                 if(($ai = $runtime.getAttributeIndex("","targetNamespace"))>=0) {
@@ -259,25 +299,37 @@
                 }
             }
             break;
+        case 12:
+            {
+                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 11;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+            }
+            break;
         case 2:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 376, anno,AnnotationContext.SCHEMA);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 118, anno,AnnotationContext.SCHEMA);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("include"))) {
-                        NGCCHandler h = new includeDecl(this, super._source, $runtime, 377);
+                        NGCCHandler h = new includeDecl(this, super._source, $runtime, 119);
                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                     }
                     else {
                         if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("import"))) {
-                            NGCCHandler h = new importDecl(this, super._source, $runtime, 378);
+                            NGCCHandler h = new importDecl(this, super._source, $runtime, 120);
                             spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                         }
                         else {
                             if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("redefine"))) {
-                                NGCCHandler h = new redefine(this, super._source, $runtime, 379);
+                                NGCCHandler h = new redefine(this, super._source, $runtime, 121);
                                 spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                             }
                             else {
@@ -288,12 +340,12 @@
                                 }
                                 else {
                                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                                        NGCCHandler h = new simpleType(this, super._source, $runtime, 381);
+                                        NGCCHandler h = new simpleType(this, super._source, $runtime, 123);
                                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                     }
                                     else {
                                         if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
-                                            NGCCHandler h = new complexType(this, super._source, $runtime, 382);
+                                            NGCCHandler h = new complexType(this, super._source, $runtime, 124);
                                             spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                         }
                                         else {
@@ -304,17 +356,17 @@
                                             }
                                             else {
                                                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) {
-                                                    NGCCHandler h = new group(this, super._source, $runtime, 384);
+                                                    NGCCHandler h = new group(this, super._source, $runtime, 126);
                                                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                                 }
                                                 else {
                                                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("notation"))) {
-                                                        NGCCHandler h = new notation(this, super._source, $runtime, 385);
+                                                        NGCCHandler h = new notation(this, super._source, $runtime, 127);
                                                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                                     }
                                                     else {
                                                         if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
-                                                            NGCCHandler h = new attributeGroupDecl(this, super._source, $runtime, 386);
+                                                            NGCCHandler h = new attributeGroupDecl(this, super._source, $runtime, 128);
                                                             spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                                         }
                                                         else {
@@ -333,28 +385,11 @@
                 }
             }
             break;
-        case 27:
+        case 0:
             {
-                if((($ai = $runtime.getAttributeIndex("","default"))>=0 || (($ai = $runtime.getAttributeIndex("","block"))>=0 || (($ai = $runtime.getAttributeIndex("","fixed"))>=0 || (($ai = $runtime.getAttributeIndex("","name"))>=0 || (($ai = $runtime.getAttributeIndex("","form"))>=0 || (($ai = $runtime.getAttributeIndex("","abstract"))>=0 || ($ai = $runtime.getAttributeIndex("","final"))>=0))))))) {
-                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 300, locator,true);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
+                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
-        case 11:
-            {
-                if((($ai = $runtime.getAttributeIndex("","form"))>=0 || ($ai = $runtime.getAttributeIndex("","name"))>=0)) {
-                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 282, locator,false,defaultValue,fixedValue);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
         case 57:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("schema"))) {
@@ -370,22 +405,22 @@
         case 1:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 365, anno,AnnotationContext.SCHEMA);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 107, anno,AnnotationContext.SCHEMA);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("include"))) {
-                        NGCCHandler h = new includeDecl(this, super._source, $runtime, 366);
+                        NGCCHandler h = new includeDecl(this, super._source, $runtime, 108);
                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                     }
                     else {
                         if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("import"))) {
-                            NGCCHandler h = new importDecl(this, super._source, $runtime, 367);
+                            NGCCHandler h = new importDecl(this, super._source, $runtime, 109);
                             spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                         }
                         else {
                             if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("redefine"))) {
-                                NGCCHandler h = new redefine(this, super._source, $runtime, 368);
+                                NGCCHandler h = new redefine(this, super._source, $runtime, 110);
                                 spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                             }
                             else {
@@ -396,12 +431,12 @@
                                 }
                                 else {
                                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                                        NGCCHandler h = new simpleType(this, super._source, $runtime, 370);
+                                        NGCCHandler h = new simpleType(this, super._source, $runtime, 112);
                                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                     }
                                     else {
                                         if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
-                                            NGCCHandler h = new complexType(this, super._source, $runtime, 371);
+                                            NGCCHandler h = new complexType(this, super._source, $runtime, 113);
                                             spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                         }
                                         else {
@@ -412,17 +447,17 @@
                                             }
                                             else {
                                                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) {
-                                                    NGCCHandler h = new group(this, super._source, $runtime, 373);
+                                                    NGCCHandler h = new group(this, super._source, $runtime, 115);
                                                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                                 }
                                                 else {
                                                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("notation"))) {
-                                                        NGCCHandler h = new notation(this, super._source, $runtime, 374);
+                                                        NGCCHandler h = new notation(this, super._source, $runtime, 116);
                                                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                                     }
                                                     else {
                                                         if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
-                                                            NGCCHandler h = new attributeGroupDecl(this, super._source, $runtime, 375);
+                                                            NGCCHandler h = new attributeGroupDecl(this, super._source, $runtime, 117);
                                                             spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                                         }
                                                         else {
@@ -440,41 +475,6 @@
                 }
             }
             break;
-        case 49:
-            {
-                if(($ai = $runtime.getAttributeIndex("","attributeFormDefault"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    $_ngcc_current_state = 45;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-            }
-            break;
-        case 36:
-            {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("import")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("include")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("notation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("redefine")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))))))))))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 388, null);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
-        case 37:
-            {
-                if(($ai = $runtime.getAttributeIndex("","finalDefault"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    $_ngcc_current_state = 36;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-            }
-            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -489,18 +489,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 41:
-            {
-                if(($ai = $runtime.getAttributeIndex("","blockDefault"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
-                else {
-                    $_ngcc_current_state = 37;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
-            }
-            break;
         case 16:
             {
                 if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
@@ -513,57 +501,43 @@
                 }
             }
             break;
-        case 45:
+        case 11:
             {
-                if(($ai = $runtime.getAttributeIndex("","elementFormDefault"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(((($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) || (($ai = $runtime.getAttributeIndex("","form"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))))) {
+                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 24, locator,false,defaultValue,fixedValue);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 41;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedLeaveElement($__qname);
                 }
             }
             break;
-        case 0:
+        case 36:
             {
-                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 12:
-            {
-                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("schema"))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 130, null);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 11;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedLeaveElement($__qname);
                 }
             }
             break;
-        case 53:
+        case 10:
             {
-                if(($ai = $runtime.getAttributeIndex("","targetNamespace"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 1;
                 }
                 else {
-                    $_ngcc_current_state = 49;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedLeaveElement($__qname);
                 }
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 27:
             {
-                if(((($ai = $runtime.getAttributeIndex("","default"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","block"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","fixed"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","form"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","abstract"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || (($ai = $runtime.getAttributeIndex("","final"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")))))))))) {
-                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 300, locator,true);
+                if(((($ai = $runtime.getAttributeIndex("","default"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","block"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","fixed"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","form"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","final"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","abstract"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || (($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")))))))))) {
+                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 42, locator,true);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -571,36 +545,39 @@
                 }
             }
             break;
-        case 11:
+        case 45:
             {
-                if(((($ai = $runtime.getAttributeIndex("","form"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) || (($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))))) {
-                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 282, locator,false,defaultValue,fixedValue);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                if(($ai = $runtime.getAttributeIndex("","elementFormDefault"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    unexpectedLeaveElement($__qname);
+                    $_ngcc_current_state = 41;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 10:
+        case 41:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 1;
+                if(($ai = $runtime.getAttributeIndex("","blockDefault"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    unexpectedLeaveElement($__qname);
+                    $_ngcc_current_state = 37;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 1:
+        case 37:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("schema"))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 0;
+                if(($ai = $runtime.getAttributeIndex("","finalDefault"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    unexpectedLeaveElement($__qname);
+                    $_ngcc_current_state = 36;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
@@ -616,34 +593,57 @@
                 }
             }
             break;
-        case 36:
+        case 53:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("schema"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 388, null);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                if(($ai = $runtime.getAttributeIndex("","targetNamespace"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
+                    $_ngcc_current_state = 49;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                }
+            }
+            break;
+        case 26:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 1;
+                }
+                else {
                     unexpectedLeaveElement($__qname);
                 }
             }
             break;
-        case 37:
+        case 12:
             {
-                if(($ai = $runtime.getAttributeIndex("","finalDefault"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 36;
+                    $_ngcc_current_state = 11;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 26:
+        case 2:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) {
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 0:
+            {
+                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 1:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("schema"))) {
                     $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 1;
+                    $_ngcc_current_state = 0;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -664,62 +664,68 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 41:
+        case 37:
             {
-                if(($__uri.equals("") && $__local.equals("blockDefault"))) {
-                    $_ngcc_current_state = 43;
+                if(($__uri.equals("") && $__local.equals("finalDefault"))) {
+                    $_ngcc_current_state = 39;
                 }
                 else {
-                    $_ngcc_current_state = 37;
+                    $_ngcc_current_state = 36;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 45:
+        case 16:
             {
-                if(($__uri.equals("") && $__local.equals("elementFormDefault"))) {
-                    $_ngcc_current_state = 47;
+                if(($__uri.equals("") && $__local.equals("default"))) {
+                    $_ngcc_current_state = 18;
                 }
                 else {
-                    $_ngcc_current_state = 41;
+                    $_ngcc_current_state = 12;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 16:
+        case 11:
             {
-                if(($__uri.equals("") && $__local.equals("default"))) {
-                    $_ngcc_current_state = 18;
+                if((($__uri.equals("") && $__local.equals("name")) || ($__uri.equals("") && $__local.equals("form")))) {
+                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 24, locator,false,defaultValue,fixedValue);
+                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 12;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedEnterAttribute($__qname);
                 }
             }
             break;
-        case 12:
+        case 53:
             {
-                if(($__uri.equals("") && $__local.equals("fixed"))) {
-                    $_ngcc_current_state = 14;
+                if(($__uri.equals("") && $__local.equals("targetNamespace"))) {
+                    $_ngcc_current_state = 55;
                 }
                 else {
-                    $_ngcc_current_state = 11;
+                    $_ngcc_current_state = 49;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 0:
+        case 49:
             {
-                revertToParentFromEnterAttribute(this, super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("attributeFormDefault"))) {
+                    $_ngcc_current_state = 51;
+                }
+                else {
+                    $_ngcc_current_state = 45;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                }
             }
             break;
-        case 53:
+        case 12:
             {
-                if(($__uri.equals("") && $__local.equals("targetNamespace"))) {
-                    $_ngcc_current_state = 55;
+                if(($__uri.equals("") && $__local.equals("fixed"))) {
+                    $_ngcc_current_state = 14;
                 }
                 else {
-                    $_ngcc_current_state = 49;
+                    $_ngcc_current_state = 11;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
@@ -730,10 +736,15 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 0:
+            {
+                revertToParentFromEnterAttribute(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 27:
             {
-                if((($__uri.equals("") && $__local.equals("default")) || (($__uri.equals("") && $__local.equals("block")) || (($__uri.equals("") && $__local.equals("fixed")) || (($__uri.equals("") && $__local.equals("name")) || (($__uri.equals("") && $__local.equals("form")) || (($__uri.equals("") && $__local.equals("abstract")) || ($__uri.equals("") && $__local.equals("final"))))))))) {
-                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 300, locator,true);
+                if((($__uri.equals("") && $__local.equals("default")) || (($__uri.equals("") && $__local.equals("block")) || (($__uri.equals("") && $__local.equals("fixed")) || (($__uri.equals("") && $__local.equals("form")) || (($__uri.equals("") && $__local.equals("final")) || (($__uri.equals("") && $__local.equals("abstract")) || ($__uri.equals("") && $__local.equals("name"))))))))) {
+                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 42, locator,true);
                     spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -741,39 +752,28 @@
                 }
             }
             break;
-        case 49:
+        case 45:
             {
-                if(($__uri.equals("") && $__local.equals("attributeFormDefault"))) {
-                    $_ngcc_current_state = 51;
+                if(($__uri.equals("") && $__local.equals("elementFormDefault"))) {
+                    $_ngcc_current_state = 47;
                 }
                 else {
-                    $_ngcc_current_state = 45;
+                    $_ngcc_current_state = 41;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 37:
+        case 41:
             {
-                if(($__uri.equals("") && $__local.equals("finalDefault"))) {
-                    $_ngcc_current_state = 39;
+                if(($__uri.equals("") && $__local.equals("blockDefault"))) {
+                    $_ngcc_current_state = 43;
                 }
                 else {
-                    $_ngcc_current_state = 36;
+                    $_ngcc_current_state = 37;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 11:
-            {
-                if((($__uri.equals("") && $__local.equals("form")) || ($__uri.equals("") && $__local.equals("name")))) {
-                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 282, locator,false,defaultValue,fixedValue);
-                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedEnterAttribute($__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -788,16 +788,20 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 41:
+        case 16:
             {
-                $_ngcc_current_state = 37;
+                $_ngcc_current_state = 12;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 16:
+        case 17:
             {
-                $_ngcc_current_state = 12;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("default"))) {
+                    $_ngcc_current_state = 12;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
         case 45:
@@ -806,33 +810,26 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 0:
+        case 13:
             {
-                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("fixed"))) {
+                    $_ngcc_current_state = 11;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
-        case 12:
+        case 41:
             {
-                $_ngcc_current_state = 11;
+                $_ngcc_current_state = 37;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 53:
+        case 46:
             {
-                $_ngcc_current_state = 49;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 50:
-            {
-                if(($__uri.equals("") && $__local.equals("attributeFormDefault"))) {
-                    $_ngcc_current_state = 45;
+                if(($__uri.equals("") && $__local.equals("elementFormDefault"))) {
+                    $_ngcc_current_state = 41;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -839,6 +836,12 @@
                 }
             }
             break;
+        case 37:
+            {
+                $_ngcc_current_state = 36;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 54:
             {
                 if(($__uri.equals("") && $__local.equals("targetNamespace"))) {
@@ -849,16 +852,18 @@
                 }
             }
             break;
-        case 38:
+        case 49:
             {
-                if(($__uri.equals("") && $__local.equals("finalDefault"))) {
-                    $_ngcc_current_state = 36;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                $_ngcc_current_state = 45;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 53:
+            {
+                $_ngcc_current_state = 49;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 42:
             {
                 if(($__uri.equals("") && $__local.equals("blockDefault"))) {
@@ -869,10 +874,10 @@
                 }
             }
             break;
-        case 17:
+        case 38:
             {
-                if(($__uri.equals("") && $__local.equals("default"))) {
-                    $_ngcc_current_state = 12;
+                if(($__uri.equals("") && $__local.equals("finalDefault"))) {
+                    $_ngcc_current_state = 36;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -879,22 +884,22 @@
                 }
             }
             break;
-        case 49:
+        case 12:
             {
-                $_ngcc_current_state = 45;
+                $_ngcc_current_state = 11;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 37:
+        case 2:
             {
-                $_ngcc_current_state = 36;
+                $_ngcc_current_state = 1;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 13:
+        case 50:
             {
-                if(($__uri.equals("") && $__local.equals("fixed"))) {
-                    $_ngcc_current_state = 11;
+                if(($__uri.equals("") && $__local.equals("attributeFormDefault"))) {
+                    $_ngcc_current_state = 45;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -901,14 +906,9 @@
                 }
             }
             break;
-        case 46:
+        case 0:
             {
-                if(($__uri.equals("") && $__local.equals("elementFormDefault"))) {
-                    $_ngcc_current_state = 41;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
             }
             break;
         default:
@@ -922,24 +922,6 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 41:
-            {
-                if(($ai = $runtime.getAttributeIndex("","blockDefault"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 37;
-                    $runtime.sendText(super._cookie, $value);
-                }
-            }
-            break;
-        case 39:
-            {
-                NGCCHandler h = new erSet(this, super._source, $runtime, 390);
-                spawnChildFromText(h, $value);
-            }
-            break;
         case 16:
             {
                 if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
@@ -952,107 +934,74 @@
                 }
             }
             break;
-        case 45:
+        case 47:
             {
-                if(($ai = $runtime.getAttributeIndex("","elementFormDefault"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 41;
-                    $runtime.sendText(super._cookie, $value);
-                }
-            }
-            break;
-        case 51:
-            {
                 if($value.equals("unqualified")) {
-                    NGCCHandler h = new qualification(this, super._source, $runtime, 405);
+                    NGCCHandler h = new qualification(this, super._source, $runtime, 142);
                     spawnChildFromText(h, $value);
                 }
                 else {
                     if($value.equals("qualified")) {
-                        NGCCHandler h = new qualification(this, super._source, $runtime, 405);
+                        NGCCHandler h = new qualification(this, super._source, $runtime, 142);
                         spawnChildFromText(h, $value);
                     }
                 }
             }
             break;
-        case 18:
+        case 11:
             {
-                defaultValue = $value;
-                $_ngcc_current_state = 17;
-            }
-            break;
-        case 0:
-            {
-                revertToParentFromText(this, super._cookie, $value);
-            }
-            break;
-        case 12:
-            {
-                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
+                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 24, locator,false,defaultValue,fixedValue);
+                    spawnChildFromText(h, $value);
                 }
                 else {
-                    $_ngcc_current_state = 11;
-                    $runtime.sendText(super._cookie, $value);
+                    if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                        NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 24, locator,false,defaultValue,fixedValue);
+                        spawnChildFromText(h, $value);
+                    }
                 }
             }
             break;
-        case 53:
+        case 14:
             {
-                if(($ai = $runtime.getAttributeIndex("","targetNamespace"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 49;
-                    $runtime.sendText(super._cookie, $value);
-                }
+                fixedValue = $value;
+                $_ngcc_current_state = 13;
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendText(super._cookie, $value);
-            }
-            break;
         case 27:
             {
-                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
-                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 300, locator,true);
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 42, locator,true);
                     spawnChildFromText(h, $value);
                 }
                 else {
                     if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
-                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 300, locator,true);
+                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 42, locator,true);
                         spawnChildFromText(h, $value);
                     }
                     else {
-                        if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
-                            NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 300, locator,true);
+                        if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
+                            NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 42, locator,true);
                             spawnChildFromText(h, $value);
                         }
                         else {
-                            if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                                NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 300, locator,true);
+                            if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                                NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 42, locator,true);
                                 spawnChildFromText(h, $value);
                             }
                             else {
                                 if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
-                                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 300, locator,true);
+                                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 42, locator,true);
                                     spawnChildFromText(h, $value);
                                 }
                                 else {
                                     if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
-                                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 300, locator,true);
+                                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 42, locator,true);
                                         spawnChildFromText(h, $value);
                                     }
                                     else {
                                         if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
-                                            NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 300, locator,true);
+                                            NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 42, locator,true);
                                             spawnChildFromText(h, $value);
                                         }
                                     }
@@ -1063,51 +1012,48 @@
                 }
             }
             break;
-        case 11:
+        case 45:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 282, locator,false,defaultValue,fixedValue);
-                    spawnChildFromText(h, $value);
+                if(($ai = $runtime.getAttributeIndex("","elementFormDefault"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
-                        NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 282, locator,false,defaultValue,fixedValue);
-                        spawnChildFromText(h, $value);
-                    }
+                    $_ngcc_current_state = 41;
+                    $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
-        case 47:
+        case 41:
             {
-                if($value.equals("unqualified")) {
-                    NGCCHandler h = new qualification(this, super._source, $runtime, 400);
-                    spawnChildFromText(h, $value);
+                if(($ai = $runtime.getAttributeIndex("","blockDefault"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    if($value.equals("qualified")) {
-                        NGCCHandler h = new qualification(this, super._source, $runtime, 400);
-                        spawnChildFromText(h, $value);
-                    }
+                    $_ngcc_current_state = 37;
+                    $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
-        case 43:
+        case 37:
             {
-                NGCCHandler h = new ersSet(this, super._source, $runtime, 395);
-                spawnChildFromText(h, $value);
+                if(($ai = $runtime.getAttributeIndex("","finalDefault"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 36;
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
-        case 55:
+        case 43:
             {
-                $_ngcc_current_state = 54;
+                NGCCHandler h = new ersSet(this, super._source, $runtime, 137);
+                spawnChildFromText(h, $value);
             }
             break;
-        case 14:
-            {
-                fixedValue = $value;
-                $_ngcc_current_state = 13;
-            }
-            break;
         case 49:
             {
                 if(($ai = $runtime.getAttributeIndex("","attributeFormDefault"))>=0) {
@@ -1120,31 +1066,85 @@
                 }
             }
             break;
-        case 37:
+        case 53:
             {
-                if(($ai = $runtime.getAttributeIndex("","finalDefault"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","targetNamespace"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    $_ngcc_current_state = 36;
+                    $_ngcc_current_state = 49;
                     $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
+        case 12:
+            {
+                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 11;
+                    $runtime.sendText(super._cookie, $value);
+                }
+            }
+            break;
+        case 51:
+            {
+                if($value.equals("unqualified")) {
+                    NGCCHandler h = new qualification(this, super._source, $runtime, 147);
+                    spawnChildFromText(h, $value);
+                }
+                else {
+                    if($value.equals("qualified")) {
+                        NGCCHandler h = new qualification(this, super._source, $runtime, 147);
+                        spawnChildFromText(h, $value);
+                    }
+                }
+            }
+            break;
+        case 18:
+            {
+                defaultValue = $value;
+                $_ngcc_current_state = 17;
+            }
+            break;
+        case 2:
+            {
+                $_ngcc_current_state = 1;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
+        case 0:
+            {
+                revertToParentFromText(this, super._cookie, $value);
+            }
+            break;
+        case 39:
+            {
+                NGCCHandler h = new erSet(this, super._source, $runtime, 132);
+                spawnChildFromText(h, $value);
+            }
+            break;
+        case 55:
+            {
+                $_ngcc_current_state = 54;
+            }
+            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 395:
+        case 24:
             {
-                blockDefault = ((Integer)$__result__);
-                action12();
-                $_ngcc_current_state = 42;
+                ad = ((AttributeDeclImpl)$__result__);
+                action3();
+                $_ngcc_current_state = 10;
             }
             break;
-        case 388:
+        case 130:
             {
                 fa = ((ForeignAttributesImpl)$__result__);
                 action10();
@@ -1151,50 +1151,43 @@
                 $_ngcc_current_state = 2;
             }
             break;
-        case 390:
+        case 137:
             {
+                blockDefault = ((Integer)$__result__);
+                action12();
+                $_ngcc_current_state = 42;
+            }
+            break;
+        case 132:
+            {
                 finalDefault = ((Integer)$__result__);
                 action11();
                 $_ngcc_current_state = 38;
             }
             break;
-        case 405:
+        case 107:
             {
-                afd = ((Boolean)$__result__).booleanValue();
-                action14();
-                $_ngcc_current_state = 50;
-            }
-            break;
-        case 300:
-            {
-                e = ((ElementDecl)$__result__);
-                action7();
-                $_ngcc_current_state = 26;
-            }
-            break;
-        case 376:
-            {
                 anno = ((AnnotationImpl)$__result__);
                 action9();
                 $_ngcc_current_state = 1;
             }
             break;
-        case 377:
+        case 108:
             {
                 $_ngcc_current_state = 1;
             }
             break;
-        case 378:
+        case 109:
             {
                 $_ngcc_current_state = 1;
             }
             break;
-        case 379:
+        case 110:
             {
                 $_ngcc_current_state = 1;
             }
             break;
-        case 381:
+        case 112:
             {
                 st = ((SimpleTypeImpl)$__result__);
                 action6();
@@ -1201,7 +1194,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 382:
+        case 113:
             {
                 ct = ((ComplexTypeImpl)$__result__);
                 action5();
@@ -1208,7 +1201,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 384:
+        case 115:
             {
                 group = ((ModelGroupDeclImpl)$__result__);
                 action2();
@@ -1215,7 +1208,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 385:
+        case 116:
             {
                 notation = ((XSNotation)$__result__);
                 action1();
@@ -1222,7 +1215,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 386:
+        case 117:
             {
                 ag = ((AttGroupDeclImpl)$__result__);
                 action0();
@@ -1229,43 +1222,50 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 282:
+        case 142:
             {
-                ad = ((AttributeDeclImpl)$__result__);
-                action3();
-                $_ngcc_current_state = 10;
-            }
-            break;
-        case 400:
-            {
                 efd = ((Boolean)$__result__).booleanValue();
                 action13();
                 $_ngcc_current_state = 46;
             }
             break;
-        case 365:
+        case 147:
             {
+                afd = ((Boolean)$__result__).booleanValue();
+                action14();
+                $_ngcc_current_state = 50;
+            }
+            break;
+        case 42:
+            {
+                e = ((ElementDecl)$__result__);
+                action7();
+                $_ngcc_current_state = 26;
+            }
+            break;
+        case 118:
+            {
                 anno = ((AnnotationImpl)$__result__);
                 action9();
                 $_ngcc_current_state = 1;
             }
             break;
-        case 366:
+        case 119:
             {
                 $_ngcc_current_state = 1;
             }
             break;
-        case 367:
+        case 120:
             {
                 $_ngcc_current_state = 1;
             }
             break;
-        case 368:
+        case 121:
             {
                 $_ngcc_current_state = 1;
             }
             break;
-        case 370:
+        case 123:
             {
                 st = ((SimpleTypeImpl)$__result__);
                 action6();
@@ -1272,7 +1272,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 371:
+        case 124:
             {
                 ct = ((ComplexTypeImpl)$__result__);
                 action5();
@@ -1279,7 +1279,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 373:
+        case 126:
             {
                 group = ((ModelGroupDeclImpl)$__result__);
                 action2();
@@ -1286,7 +1286,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 374:
+        case 127:
             {
                 notation = ((XSNotation)$__result__);
                 action1();
@@ -1293,7 +1293,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 375:
+        case 128:
             {
                 ag = ((AttGroupDeclImpl)$__result__);
                 action0();
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/SimpleType_List.java	Tue Aug  4 10:09:02 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/SimpleType_List.java	Tue Aug  4 10:09:02 2009
@@ -97,17 +97,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 9:
-            {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ((($ai = $runtime.getAttributeIndex("","itemType"))>=0 && (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 11, fa);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
         case 2:
             {
                 if(($ai = $runtime.getAttributeIndex("","itemType"))>=0) {
@@ -116,7 +105,7 @@
                 }
                 else {
                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                        NGCCHandler h = new simpleType(this, super._source, $runtime, 3);
+                        NGCCHandler h = new simpleType(this, super._source, $runtime, 166);
                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                     }
                     else {
@@ -140,7 +129,7 @@
         case 7:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 9, annotation,AnnotationContext.SIMPLETYPE_DECL);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 172, annotation,AnnotationContext.SIMPLETYPE_DECL);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -154,6 +143,17 @@
                 revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
+        case 9:
+            {
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ((($ai = $runtime.getAttributeIndex("","itemType"))>=0 && (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 174, fa);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
+            }
+            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -168,17 +168,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 9:
-            {
-                if((($ai = $runtime.getAttributeIndex("","itemType"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("list")))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 11, fa);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
-            }
-            break;
         case 2:
             {
                 if(($ai = $runtime.getAttributeIndex("","itemType"))>=0) {
@@ -213,6 +202,17 @@
                 revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 9:
+            {
+                if((($ai = $runtime.getAttributeIndex("","itemType"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("list")))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 174, fa);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
+            }
+            break;
         default:
             {
                 unexpectedLeaveElement($__qname);
@@ -227,17 +227,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 9:
-            {
-                if(($__uri.equals("") && $__local.equals("itemType"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 11, fa);
-                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedEnterAttribute($__qname);
-                }
-            }
-            break;
         case 2:
             {
                 if(($__uri.equals("") && $__local.equals("itemType"))) {
@@ -259,6 +248,17 @@
                 revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 9:
+            {
+                if(($__uri.equals("") && $__local.equals("itemType"))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 174, fa);
+                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedEnterAttribute($__qname);
+                }
+            }
+            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -273,6 +273,16 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 4:
+            {
+                if(($__uri.equals("") && $__local.equals("itemType"))) {
+                    $_ngcc_current_state = 1;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
+            }
+            break;
         case 7:
             {
                 $_ngcc_current_state = 2;
@@ -284,16 +294,6 @@
                 revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 4:
-            {
-                if(($__uri.equals("") && $__local.equals("itemType"))) {
-                    $_ngcc_current_state = 1;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -305,20 +305,6 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 5:
-            {
-                NGCCHandler h = new qname(this, super._source, $runtime, 5);
-                spawnChildFromText(h, $value);
-            }
-            break;
-        case 9:
-            {
-                if(($ai = $runtime.getAttributeIndex("","itemType"))>=0) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 11, fa);
-                    spawnChildFromText(h, $value);
-                }
-            }
-            break;
         case 2:
             {
                 if(($ai = $runtime.getAttributeIndex("","itemType"))>=0) {
@@ -327,6 +313,12 @@
                 }
             }
             break;
+        case 5:
+            {
+                NGCCHandler h = new qname(this, super._source, $runtime, 168);
+                spawnChildFromText(h, $value);
+            }
+            break;
         case 7:
             {
                 $_ngcc_current_state = 2;
@@ -338,36 +330,44 @@
                 revertToParentFromText(result, super._cookie, $value);
             }
             break;
+        case 9:
+            {
+                if(($ai = $runtime.getAttributeIndex("","itemType"))>=0) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 174, fa);
+                    spawnChildFromText(h, $value);
+                }
+            }
+            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 11:
+        case 168:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 7;
-            }
-            break;
-        case 5:
-            {
                 itemTypeName = ((UName)$__result__);
                 action1();
                 $_ngcc_current_state = 4;
             }
             break;
-        case 3:
+        case 166:
             {
                 itemType = ((SimpleTypeImpl)$__result__);
                 $_ngcc_current_state = 1;
             }
             break;
-        case 9:
+        case 172:
             {
                 annotation = ((AnnotationImpl)$__result__);
                 $_ngcc_current_state = 2;
             }
             break;
+        case 174:
+            {
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 7;
+            }
+            break;
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/SimpleType_Restriction.java	Tue Aug  4 10:09:04 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/SimpleType_Restriction.java	Tue Aug  4 10:09:04 2009
@@ -106,7 +106,7 @@
         case 1:
             {
                 if((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern")))) {
-                    NGCCHandler h = new facet(this, super._source, $runtime, 40);
+                    NGCCHandler h = new facet(this, super._source, $runtime, 529);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -114,11 +114,6 @@
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
         case 13:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
@@ -134,7 +129,7 @@
         case 10:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 51, annotation,AnnotationContext.SIMPLETYPE_DECL);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 540, annotation,AnnotationContext.SIMPLETYPE_DECL);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -151,7 +146,7 @@
                 }
                 else {
                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                        NGCCHandler h = new simpleType(this, super._source, $runtime, 45);
+                        NGCCHandler h = new simpleType(this, super._source, $runtime, 534);
                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                     }
                     else {
@@ -162,8 +157,8 @@
             break;
         case 12:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ((($ai = $runtime.getAttributeIndex("","base"))>=0 && ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || (((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 53, fa);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ((($ai = $runtime.getAttributeIndex("","base"))>=0 && (((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 542, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -181,7 +176,7 @@
         case 2:
             {
                 if((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern")))) {
-                    NGCCHandler h = new facet(this, super._source, $runtime, 41);
+                    NGCCHandler h = new facet(this, super._source, $runtime, 530);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -190,6 +185,11 @@
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -215,11 +215,6 @@
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 10:
             {
                 $_ngcc_current_state = 5;
@@ -240,7 +235,7 @@
         case 12:
             {
                 if((($ai = $runtime.getAttributeIndex("","base"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction")))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 53, fa);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 542, fa);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -261,6 +256,11 @@
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 0:
+            {
+                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedLeaveElement($__qname);
@@ -275,11 +275,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
-            {
-                revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 10:
             {
                 $_ngcc_current_state = 5;
@@ -299,7 +294,7 @@
         case 12:
             {
                 if(($__uri.equals("") && $__local.equals("base"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 53, fa);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 542, fa);
                     spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -320,6 +315,11 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 0:
+            {
+                revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -334,17 +334,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
-            {
-                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 10:
-            {
-                $_ngcc_current_state = 5;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 7:
             {
                 if(($__uri.equals("") && $__local.equals("base"))) {
@@ -355,6 +344,12 @@
                 }
             }
             break;
+        case 10:
+            {
+                $_ngcc_current_state = 5;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 4:
             {
                 action1();
@@ -368,6 +363,11 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 0:
+            {
+                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -379,9 +379,10 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 0:
+        case 8:
             {
-                revertToParentFromText(result, super._cookie, $value);
+                NGCCHandler h = new qname(this, super._source, $runtime, 536);
+                spawnChildFromText(h, $value);
             }
             break;
         case 10:
@@ -401,17 +402,11 @@
         case 12:
             {
                 if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 53, fa);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 542, fa);
                     spawnChildFromText(h, $value);
                 }
             }
             break;
-        case 8:
-            {
-                NGCCHandler h = new qname(this, super._source, $runtime, 47);
-                spawnChildFromText(h, $value);
-            }
-            break;
         case 4:
             {
                 action1();
@@ -425,12 +420,17 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
+        case 0:
+            {
+                revertToParentFromText(result, super._cookie, $value);
+            }
+            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 40:
+        case 529:
             {
                 facet = ((XSFacet)$__result__);
                 action0();
@@ -437,13 +437,14 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 51:
+        case 530:
             {
-                annotation = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 5;
+                facet = ((XSFacet)$__result__);
+                action0();
+                $_ngcc_current_state = 1;
             }
             break;
-        case 47:
+        case 536:
             {
                 baseTypeName = ((UName)$__result__);
                 action2();
@@ -450,23 +451,22 @@
                 $_ngcc_current_state = 7;
             }
             break;
-        case 53:
+        case 540:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 10;
+                annotation = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 5;
             }
             break;
-        case 45:
+        case 534:
             {
                 baseType = ((SimpleTypeImpl)$__result__);
                 $_ngcc_current_state = 4;
             }
             break;
-        case 41:
+        case 542:
             {
-                facet = ((XSFacet)$__result__);
-                action0();
-                $_ngcc_current_state = 1;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 10;
             }
             break;
         }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/SimpleType_Union.java	Tue Aug  4 10:09:07 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/SimpleType_Union.java	Tue Aug  4 10:09:06 2009
@@ -109,39 +109,34 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 7:
+        case 4:
             {
-                if(($ai = $runtime.getAttributeIndex("","memberTypes"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 191, annotation,AnnotationContext.SIMPLETYPE_DECL);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 6;
+                    $_ngcc_current_state = 2;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 12:
+        case 2:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("union"))) {
-                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    action4();
-                    $_ngcc_current_state = 7;
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
+                    NGCCHandler h = new simpleType(this, super._source, $runtime, 188);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 1;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 0:
+        case 6:
             {
-                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 1:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                    NGCCHandler h = new simpleType(this, super._source, $runtime, 682);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 193, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -149,35 +144,35 @@
                 }
             }
             break;
-        case 2:
+        case 7:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                    NGCCHandler h = new simpleType(this, super._source, $runtime, 683);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","memberTypes"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 1;
+                    $_ngcc_current_state = 6;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 4:
+        case 1:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 686, annotation,AnnotationContext.SIMPLETYPE_DECL);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
+                    NGCCHandler h = new simpleType(this, super._source, $runtime, 187);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 2;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 6:
+        case 12:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 688, fa);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("union"))) {
+                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                    action4();
+                    $_ngcc_current_state = 7;
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -184,6 +179,11 @@
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -198,6 +198,29 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 4:
+            {
+                $_ngcc_current_state = 2;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 2:
+            {
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 6:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("union"))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 193, fa);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
+            }
+            break;
         case 7:
             {
                 if(($ai = $runtime.getAttributeIndex("","memberTypes"))>=0) {
@@ -210,11 +233,6 @@
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 1:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("union"))) {
@@ -227,29 +245,11 @@
                 }
             }
             break;
-        case 2:
+        case 0:
             {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 4:
-            {
-                $_ngcc_current_state = 2;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 6:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("union"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 688, fa);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedLeaveElement($__qname);
@@ -264,6 +264,18 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 4:
+            {
+                $_ngcc_current_state = 2;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 2:
+            {
+                $_ngcc_current_state = 1;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 7:
             {
                 if(($__uri.equals("") && $__local.equals("memberTypes"))) {
@@ -280,18 +292,6 @@
                 revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 4:
-            {
-                $_ngcc_current_state = 2;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -306,17 +306,12 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 7:
+        case 4:
             {
-                $_ngcc_current_state = 6;
+                $_ngcc_current_state = 2;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 0:
-            {
-                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 2:
             {
                 $_ngcc_current_state = 1;
@@ -323,9 +318,9 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 4:
+        case 7:
             {
-                $_ngcc_current_state = 2;
+                $_ngcc_current_state = 6;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -339,6 +334,11 @@
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -350,21 +350,16 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 7:
+        case 4:
             {
-                if(($ai = $runtime.getAttributeIndex("","memberTypes"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 6;
-                    $runtime.sendText(super._cookie, $value);
-                }
+                $_ngcc_current_state = 2;
+                $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 0:
+        case 9:
             {
-                revertToParentFromText(result, super._cookie, $value);
+                NGCCHandler h = new qname(this, super._source, $runtime, 195);
+                spawnChildFromText(h, $value);
             }
             break;
         case 2:
@@ -373,12 +368,6 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 4:
-            {
-                $_ngcc_current_state = 2;
-                $runtime.sendText(super._cookie, $value);
-            }
-            break;
         case 10:
             {
                 __text = $value;
@@ -386,24 +375,35 @@
                 action3();
             }
             break;
-        case 9:
+        case 7:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 690);
-                spawnChildFromText(h, $value);
+                if(($ai = $runtime.getAttributeIndex("","memberTypes"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 6;
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
         case 8:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 691);
+                NGCCHandler h = new qname(this, super._source, $runtime, 196);
                 spawnChildFromText(h, $value);
             }
             break;
+        case 0:
+            {
+                revertToParentFromText(result, super._cookie, $value);
+            }
+            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 682:
+        case 188:
             {
                 anonymousMemberType = ((SimpleTypeImpl)$__result__);
                 action1();
@@ -410,37 +410,37 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 683:
+        case 196:
             {
-                anonymousMemberType = ((SimpleTypeImpl)$__result__);
-                action1();
-                $_ngcc_current_state = 1;
-            }
-            break;
-        case 691:
-            {
                 memberTypeName = ((UName)$__result__);
                 action2();
                 $_ngcc_current_state = 8;
             }
             break;
-        case 690:
+        case 191:
             {
+                annotation = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 2;
+            }
+            break;
+        case 195:
+            {
                 memberTypeName = ((UName)$__result__);
                 action2();
                 $_ngcc_current_state = 8;
             }
             break;
-        case 686:
+        case 193:
             {
-                annotation = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 2;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 4;
             }
             break;
-        case 688:
+        case 187:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 4;
+                anonymousMemberType = ((SimpleTypeImpl)$__result__);
+                action1();
+                $_ngcc_current_state = 1;
             }
             break;
         }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/annotation.java	Tue Aug  4 10:09:09 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/annotation.java	Tue Aug  4 10:09:09 2009
@@ -85,6 +85,11 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 0:
+            {
+                revertToParentFromEnterElement(makeResult(), super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
         case 2:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
@@ -97,11 +102,6 @@
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromEnterElement(makeResult(), super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
         default:
             {
                 unexpectedEnterElement($__qname);
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/attributeDeclBody.java	Tue Aug  4 10:09:11 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/attributeDeclBody.java	Tue Aug  4 10:09:11 2009
@@ -90,14 +90,42 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 13:
+            {
+                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 12;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+            }
+            break;
+        case 0:
+            {
+                revertToParentFromEnterElement(makeResult(), super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
+        case 12:
+            {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
+            }
+            break;
         case 9:
             {
                 if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ((($ai = $runtime.getAttributeIndex("","type"))>=0 && (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 218, fa);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 340, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 218, fa);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 340, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
             }
@@ -105,7 +133,7 @@
         case 7:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 216, null,AnnotationContext.ATTRIBUTE_DECL);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 338, null,AnnotationContext.ATTRIBUTE_DECL);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -114,11 +142,6 @@
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromEnterElement(makeResult(), super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
         case 1:
             {
                 if(($ai = $runtime.getAttributeIndex("","type"))>=0) {
@@ -127,7 +150,7 @@
                 }
                 else {
                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                        NGCCHandler h = new simpleType(this, super._source, $runtime, 207);
+                        NGCCHandler h = new simpleType(this, super._source, $runtime, 329);
                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                     }
                     else {
@@ -137,51 +160,56 @@
                 }
             }
             break;
+        default:
+            {
+                unexpectedEnterElement($__qname);
+            }
+            break;
+        }
+    }
+
+    public void leaveElement(String $__uri, String $__local, String $__qname) throws SAXException {
+        int $ai;
+        $uri = $__uri;
+        $localName = $__local;
+        $qname = $__qname;
+        switch($_ngcc_current_state) {
         case 13:
             {
                 if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
                     $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
                     $_ngcc_current_state = 12;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromLeaveElement(makeResult(), super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 12:
             {
                 if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
                     $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    unexpectedLeaveElement($__qname);
                 }
             }
             break;
-        default:
-            {
-                unexpectedEnterElement($__qname);
-            }
-            break;
-        }
-    }
-
-    public void leaveElement(String $__uri, String $__local, String $__qname) throws SAXException {
-        int $ai;
-        $uri = $__uri;
-        $localName = $__local;
-        $qname = $__qname;
-        switch($_ngcc_current_state) {
         case 9:
             {
                 if(($ai = $runtime.getAttributeIndex("","type"))>=0) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 218, fa);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 340, fa);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 218, fa);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 340, fa);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
             }
@@ -192,11 +220,6 @@
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 0:
-            {
-                revertToParentFromLeaveElement(makeResult(), super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 1:
             {
                 if(($ai = $runtime.getAttributeIndex("","type"))>=0) {
@@ -209,29 +232,6 @@
                 }
             }
             break;
-        case 13:
-            {
-                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
-                else {
-                    $_ngcc_current_state = 12;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
-            }
-            break;
-        case 12:
-            {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedLeaveElement($__qname);
@@ -246,58 +246,58 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 9:
+        case 13:
             {
-                if(($__uri.equals("") && $__local.equals("type"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 218, fa);
-                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("form"))) {
+                    $_ngcc_current_state = 15;
                 }
                 else {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 218, fa);
-                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+                    $_ngcc_current_state = 12;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 7:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 0:
             {
                 revertToParentFromEnterAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 1:
+        case 12:
             {
-                if(($__uri.equals("") && $__local.equals("type"))) {
-                    $_ngcc_current_state = 5;
+                if(($__uri.equals("") && $__local.equals("name"))) {
+                    $_ngcc_current_state = 11;
                 }
                 else {
-                    $_ngcc_current_state = 0;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedEnterAttribute($__qname);
                 }
             }
             break;
-        case 13:
+        case 9:
             {
-                if(($__uri.equals("") && $__local.equals("form"))) {
-                    $_ngcc_current_state = 15;
+                if(($__uri.equals("") && $__local.equals("type"))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 340, fa);
+                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 12;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 340, fa);
+                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 12:
+        case 7:
             {
-                if(($__uri.equals("") && $__local.equals("name"))) {
-                    $_ngcc_current_state = 11;
+                $_ngcc_current_state = 1;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 1:
+            {
+                if(($__uri.equals("") && $__local.equals("type"))) {
+                    $_ngcc_current_state = 5;
                 }
                 else {
-                    unexpectedEnterAttribute($__qname);
+                    $_ngcc_current_state = 0;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
@@ -315,6 +315,17 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 13:
+            {
+                $_ngcc_current_state = 12;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 0:
+            {
+                revertToParentFromLeaveAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 10:
             {
                 if(($__uri.equals("") && $__local.equals("name"))) {
@@ -327,7 +338,7 @@
             break;
         case 9:
             {
-                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 218, fa);
+                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 340, fa);
                 spawnChildFromLeaveAttribute(h, $__uri, $__local, $__qname);
             }
             break;
@@ -337,10 +348,10 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 14:
+        case 4:
             {
-                if(($__uri.equals("") && $__local.equals("form"))) {
-                    $_ngcc_current_state = 12;
+                if(($__uri.equals("") && $__local.equals("type"))) {
+                    $_ngcc_current_state = 0;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -347,21 +358,10 @@
                 }
             }
             break;
-        case 0:
+        case 14:
             {
-                revertToParentFromLeaveAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 1:
-            {
-                $_ngcc_current_state = 0;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 4:
-            {
-                if(($__uri.equals("") && $__local.equals("type"))) {
-                    $_ngcc_current_state = 0;
+                if(($__uri.equals("") && $__local.equals("form"))) {
+                    $_ngcc_current_state = 12;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -368,9 +368,9 @@
                 }
             }
             break;
-        case 13:
+        case 1:
             {
-                $_ngcc_current_state = 12;
+                $_ngcc_current_state = 0;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -385,34 +385,59 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
+        case 11:
+            {
+                name = $value;
+                $_ngcc_current_state = 10;
+            }
+            break;
+        case 13:
+            {
+                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 12;
+                    $runtime.sendText(super._cookie, $value);
+                }
+            }
+            break;
+        case 0:
+            {
+                revertToParentFromText(makeResult(), super._cookie, $value);
+            }
+            break;
         case 15:
             {
                 if($value.equals("unqualified")) {
-                    NGCCHandler h = new qualification(this, super._source, $runtime, 223);
+                    NGCCHandler h = new qualification(this, super._source, $runtime, 345);
                     spawnChildFromText(h, $value);
                 }
                 else {
                     if($value.equals("qualified")) {
-                        NGCCHandler h = new qualification(this, super._source, $runtime, 223);
+                        NGCCHandler h = new qualification(this, super._source, $runtime, 345);
                         spawnChildFromText(h, $value);
                     }
                 }
             }
             break;
-        case 5:
+        case 12:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 209);
-                spawnChildFromText(h, $value);
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
         case 9:
             {
                 if(($ai = $runtime.getAttributeIndex("","type"))>=0) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 218, fa);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 340, fa);
                     spawnChildFromText(h, $value);
                 }
                 else {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 218, fa);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 340, fa);
                     spawnChildFromText(h, $value);
                 }
             }
@@ -423,17 +448,6 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 11:
-            {
-                name = $value;
-                $_ngcc_current_state = 10;
-            }
-            break;
-        case 0:
-            {
-                revertToParentFromText(makeResult(), super._cookie, $value);
-            }
-            break;
         case 1:
             {
                 if(($ai = $runtime.getAttributeIndex("","type"))>=0) {
@@ -446,32 +460,18 @@
                 }
             }
             break;
-        case 13:
+        case 5:
             {
-                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 12;
-                    $runtime.sendText(super._cookie, $value);
-                }
+                NGCCHandler h = new qname(this, super._source, $runtime, 331);
+                spawnChildFromText(h, $value);
             }
             break;
-        case 12:
-            {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-            }
-            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 223:
+        case 345:
             {
                 form = ((Boolean)$__result__).booleanValue();
                 action1();
@@ -478,25 +478,25 @@
                 $_ngcc_current_state = 14;
             }
             break;
-        case 216:
+        case 340:
             {
-                annotation = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 1;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 7;
             }
             break;
-        case 218:
+        case 338:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 7;
+                annotation = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 1;
             }
             break;
-        case 207:
+        case 329:
             {
                 type = ((SimpleTypeImpl)$__result__);
                 $_ngcc_current_state = 0;
             }
             break;
-        case 209:
+        case 331:
             {
                 typeName = ((UName)$__result__);
                 action0();
@@ -507,7 +507,7 @@
     }
 
     public boolean accepted() {
-        return((($_ngcc_current_state == 0) || (($_ngcc_current_state == 1) || ($_ngcc_current_state == 7))));
+        return((($_ngcc_current_state == 1) || (($_ngcc_current_state == 0) || ($_ngcc_current_state == 7))));
     }
 
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/attributeGroupDecl.java	Tue Aug  4 10:09:14 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/attributeGroupDecl.java	Tue Aug  4 10:09:13 2009
@@ -81,34 +81,28 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 7:
+        case 13:
             {
-                if(($ai = $runtime.getAttributeIndex("","id"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 6;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 4:
+        case 3:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 17, null,AnnotationContext.ATTRIBUTE_GROUP);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    $_ngcc_current_state = 3;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
+                action0();
+                $_ngcc_current_state = 2;
+                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
         case 6:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 19, fa);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 674, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -128,16 +122,11 @@
                 }
             }
             break;
-        case 0:
+        case 2:
             {
-                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 13:
-            {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))))) {
+                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 669, result);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -144,24 +133,35 @@
                 }
             }
             break;
-        case 3:
+        case 0:
             {
-                action0();
-                $_ngcc_current_state = 2;
-                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
-        case 2:
+        case 4:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))))) {
-                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 14, result);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 672, null,AnnotationContext.ATTRIBUTE_GROUP);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 3;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
+        case 7:
+            {
+                if(($ai = $runtime.getAttributeIndex("","id"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 6;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+            }
+            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -176,21 +176,21 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 7:
+        case 13:
             {
-                if(($ai = $runtime.getAttributeIndex("","id"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 6;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedLeaveElement($__qname);
                 }
             }
             break;
-        case 4:
+        case 3:
             {
-                $_ngcc_current_state = 3;
+                action0();
+                $_ngcc_current_state = 2;
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -197,7 +197,7 @@
         case 6:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 19, fa);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 674, fa);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -205,16 +205,11 @@
                 }
             }
             break;
-        case 0:
+        case 2:
             {
-                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 13:
-            {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
+                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 669, result);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -221,13 +216,6 @@
                 }
             }
             break;
-        case 3:
-            {
-                action0();
-                $_ngcc_current_state = 2;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 1:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
@@ -239,14 +227,26 @@
                 }
             }
             break;
-        case 2:
+        case 0:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
-                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 14, result);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 4:
+            {
+                $_ngcc_current_state = 3;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 7:
+            {
+                if(($ai = $runtime.getAttributeIndex("","id"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    unexpectedLeaveElement($__qname);
+                    $_ngcc_current_state = 6;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
@@ -264,20 +264,20 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 7:
+        case 13:
             {
-                if(($__uri.equals("") && $__local.equals("id"))) {
-                    $_ngcc_current_state = 9;
+                if(($__uri.equals("") && $__local.equals("name"))) {
+                    $_ngcc_current_state = 12;
                 }
                 else {
-                    $_ngcc_current_state = 6;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedEnterAttribute($__qname);
                 }
             }
             break;
-        case 4:
+        case 3:
             {
-                $_ngcc_current_state = 3;
+                action0();
+                $_ngcc_current_state = 2;
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -286,23 +286,23 @@
                 revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 13:
+        case 4:
             {
-                if(($__uri.equals("") && $__local.equals("name"))) {
-                    $_ngcc_current_state = 12;
+                $_ngcc_current_state = 3;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 7:
+            {
+                if(($__uri.equals("") && $__local.equals("id"))) {
+                    $_ngcc_current_state = 9;
                 }
                 else {
-                    unexpectedEnterAttribute($__qname);
+                    $_ngcc_current_state = 6;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 3:
-            {
-                action0();
-                $_ngcc_current_state = 2;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -317,6 +317,13 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 3:
+            {
+                action0();
+                $_ngcc_current_state = 2;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 8:
             {
                 if(($__uri.equals("") && $__local.equals("id"))) {
@@ -327,38 +334,31 @@
                 }
             }
             break;
-        case 7:
+        case 11:
             {
-                $_ngcc_current_state = 6;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("name"))) {
+                    $_ngcc_current_state = 7;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
-        case 4:
-            {
-                $_ngcc_current_state = 3;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 0:
             {
                 revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 3:
+        case 4:
             {
-                action0();
-                $_ngcc_current_state = 2;
+                $_ngcc_current_state = 3;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 11:
+        case 7:
             {
-                if(($__uri.equals("") && $__local.equals("name"))) {
-                    $_ngcc_current_state = 7;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                $_ngcc_current_state = 6;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
         default:
@@ -372,22 +372,18 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 7:
+        case 13:
             {
-                if(($ai = $runtime.getAttributeIndex("","id"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
-                else {
-                    $_ngcc_current_state = 6;
-                    $runtime.sendText(super._cookie, $value);
-                }
             }
             break;
-        case 4:
+        case 12:
             {
-                $_ngcc_current_state = 3;
-                $runtime.sendText(super._cookie, $value);
+                name = $value;
+                $_ngcc_current_state = 11;
             }
             break;
         case 9:
@@ -395,10 +391,11 @@
                 $_ngcc_current_state = 8;
             }
             break;
-        case 12:
+        case 3:
             {
-                name = $value;
-                $_ngcc_current_state = 11;
+                action0();
+                $_ngcc_current_state = 2;
+                $runtime.sendText(super._cookie, $value);
             }
             break;
         case 0:
@@ -406,41 +403,44 @@
                 revertToParentFromText(result, super._cookie, $value);
             }
             break;
-        case 13:
+        case 4:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                $_ngcc_current_state = 3;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
+        case 7:
+            {
+                if(($ai = $runtime.getAttributeIndex("","id"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
+                else {
+                    $_ngcc_current_state = 6;
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
-        case 3:
-            {
-                action0();
-                $_ngcc_current_state = 2;
-                $runtime.sendText(super._cookie, $value);
-            }
-            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 19:
+        case 669:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 4;
+                $_ngcc_current_state = 1;
             }
             break;
-        case 17:
+        case 672:
             {
                 annotation = ((AnnotationImpl)$__result__);
                 $_ngcc_current_state = 3;
             }
             break;
-        case 14:
+        case 674:
             {
-                $_ngcc_current_state = 1;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 4;
             }
             break;
         }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/attributeUses.java	Tue Aug  4 10:09:16 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/attributeUses.java	Tue Aug  4 10:09:16 2009
@@ -141,27 +141,41 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 33:
+        case 1:
             {
-                if(($ai = $runtime.getAttributeIndex("","use"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) {
+                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                    action7();
+                    $_ngcc_current_state = 33;
                 }
                 else {
-                    $_ngcc_current_state = 29;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
+                        $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                        action3();
+                        $_ngcc_current_state = 13;
+                    }
+                    else {
+                        if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))) {
+                            $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                            action1();
+                            $_ngcc_current_state = 3;
+                        }
+                        else {
+                            $_ngcc_current_state = 0;
+                            $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                        }
+                    }
                 }
             }
             break;
-        case 19:
+        case 13:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 621, null,AnnotationContext.ATTRIBUTE_USE);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 18;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
@@ -177,26 +191,6 @@
                 }
             }
             break;
-        case 5:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) {
-                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    action7();
-                    $_ngcc_current_state = 33;
-                }
-                else {
-                    if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
-                        $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                        action3();
-                        $_ngcc_current_state = 13;
-                    }
-                    else {
-                        $_ngcc_current_state = 1;
-                        $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                    }
-                }
-            }
-            break;
         case 8:
             {
                 action2();
@@ -204,28 +198,22 @@
                 $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
-        case 3:
+        case 33:
             {
-                if((($ai = $runtime.getAttributeIndex("","namespace"))>=0 || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ($ai = $runtime.getAttributeIndex("","processContents"))>=0))) {
-                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 603, wloc);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","use"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 29;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 16:
-            {
-                action4();
-                $_ngcc_current_state = 15;
-                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
         case 9:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 610, null,AnnotationContext.ATTRIBUTE_USE);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 409, null,AnnotationContext.ATTRIBUTE_USE);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -234,6 +222,17 @@
                 }
             }
             break;
+        case 3:
+            {
+                if((($ai = $runtime.getAttributeIndex("","processContents"))>=0 || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ($ai = $runtime.getAttributeIndex("","namespace"))>=0))) {
+                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 402, wloc);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
+            }
+            break;
         case 29:
             {
                 if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
@@ -246,66 +245,67 @@
                 }
             }
             break;
-        case 17:
+        case 0:
             {
-                if((($ai = $runtime.getAttributeIndex("","form"))>=0 || ($ai = $runtime.getAttributeIndex("","name"))>=0)) {
-                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 628, locator,true,defaultValue,fixedValue);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
+        case 5:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) {
+                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                    action7();
+                    $_ngcc_current_state = 33;
                 }
                 else {
-                    if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
-                        $runtime.consumeAttribute($ai);
-                        $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
+                        $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                        action3();
+                        $_ngcc_current_state = 13;
                     }
                     else {
-                        unexpectedEnterElement($__qname);
+                        $_ngcc_current_state = 1;
+                        $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                     }
                 }
             }
             break;
-        case 0:
+        case 19:
             {
-                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 13:
-            {
-                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 420, null,AnnotationContext.ATTRIBUTE_USE);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 18;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 1:
+        case 17:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) {
-                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    action7();
-                    $_ngcc_current_state = 33;
+                if((($ai = $runtime.getAttributeIndex("","name"))>=0 || ($ai = $runtime.getAttributeIndex("","form"))>=0)) {
+                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 427, locator,true,defaultValue,fixedValue);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
-                        $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                        action3();
-                        $_ngcc_current_state = 13;
+                    if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
+                        $runtime.consumeAttribute($ai);
+                        $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                     }
                     else {
-                        if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))) {
-                            $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                            action1();
-                            $_ngcc_current_state = 3;
-                        }
-                        else {
-                            $_ngcc_current_state = 0;
-                            $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                        }
+                        unexpectedEnterElement($__qname);
                     }
                 }
             }
             break;
+        case 16:
+            {
+                action4();
+                $_ngcc_current_state = 15;
+                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -320,61 +320,43 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 33:
+        case 2:
             {
-                if(($ai = $runtime.getAttributeIndex("","use"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 0;
                 }
                 else {
-                    $_ngcc_current_state = 29;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedLeaveElement($__qname);
                 }
             }
             break;
-        case 19:
+        case 1:
             {
-                $_ngcc_current_state = 18;
+                $_ngcc_current_state = 0;
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 25:
+        case 13:
             {
-                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 17;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
-            }
-            break;
-        case 5:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 2:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 0;
-                }
-                else {
                     unexpectedLeaveElement($__qname);
                 }
             }
             break;
-        case 15:
+        case 25:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 1;
+                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    unexpectedLeaveElement($__qname);
+                    $_ngcc_current_state = 17;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
@@ -385,24 +367,18 @@
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 3:
+        case 33:
             {
-                if(((($ai = $runtime.getAttributeIndex("","namespace"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))) || ((($ai = $runtime.getAttributeIndex("","processContents"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))))) {
-                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 603, wloc);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                if(($ai = $runtime.getAttributeIndex("","use"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    unexpectedLeaveElement($__qname);
+                    $_ngcc_current_state = 29;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 16:
-            {
-                action4();
-                $_ngcc_current_state = 15;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 9:
             {
                 $_ngcc_current_state = 8;
@@ -421,11 +397,11 @@
                 }
             }
             break;
-        case 7:
+        case 3:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 1;
+                if(((($ai = $runtime.getAttributeIndex("","processContents"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))) || ((($ai = $runtime.getAttributeIndex("","namespace"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))))) {
+                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 402, wloc);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -432,20 +408,14 @@
                 }
             }
             break;
-        case 17:
+        case 7:
             {
-                if(((($ai = $runtime.getAttributeIndex("","form"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) || (($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))))) {
-                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 628, locator,true,defaultValue,fixedValue);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 1;
                 }
                 else {
-                    if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
-                        $runtime.consumeAttribute($ai);
-                        $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                    }
-                    else {
-                        unexpectedLeaveElement($__qname);
-                    }
+                    unexpectedLeaveElement($__qname);
                 }
             }
             break;
@@ -454,10 +424,16 @@
                 revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 5:
+            {
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 18:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 619, null);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 418, null);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -465,11 +441,11 @@
                 }
             }
             break;
-        case 13:
+        case 15:
             {
-                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 1;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -476,12 +452,36 @@
                 }
             }
             break;
-        case 1:
+        case 17:
             {
-                $_ngcc_current_state = 0;
+                if(((($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))) || (($ai = $runtime.getAttributeIndex("","form"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))))) {
+                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 427, locator,true,defaultValue,fixedValue);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                }
+                else {
+                    if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
+                        $runtime.consumeAttribute($ai);
+                        $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                    }
+                    else {
+                        unexpectedLeaveElement($__qname);
+                    }
+                }
+            }
+            break;
+        case 19:
+            {
+                $_ngcc_current_state = 18;
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 16:
+            {
+                action4();
+                $_ngcc_current_state = 15;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedLeaveElement($__qname);
@@ -496,23 +496,22 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 33:
+        case 1:
             {
-                if(($__uri.equals("") && $__local.equals("use"))) {
-                    $_ngcc_current_state = 35;
+                $_ngcc_current_state = 0;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 13:
+            {
+                if(($__uri.equals("") && $__local.equals("ref"))) {
+                    $_ngcc_current_state = 12;
                 }
                 else {
-                    $_ngcc_current_state = 29;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedEnterAttribute($__qname);
                 }
             }
             break;
-        case 19:
-            {
-                $_ngcc_current_state = 18;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 25:
             {
                 if(($__uri.equals("") && $__local.equals("fixed"))) {
@@ -524,12 +523,6 @@
                 }
             }
             break;
-        case 5:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 8:
             {
                 action2();
@@ -537,28 +530,32 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 3:
+        case 33:
             {
-                if((($__uri.equals("") && $__local.equals("namespace")) || ($__uri.equals("") && $__local.equals("processContents")))) {
-                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 603, wloc);
-                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("use"))) {
+                    $_ngcc_current_state = 35;
                 }
                 else {
-                    unexpectedEnterAttribute($__qname);
+                    $_ngcc_current_state = 29;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 16:
+        case 9:
             {
-                action4();
-                $_ngcc_current_state = 15;
+                $_ngcc_current_state = 8;
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 9:
+        case 3:
             {
-                $_ngcc_current_state = 8;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                if((($__uri.equals("") && $__local.equals("processContents")) || ($__uri.equals("") && $__local.equals("namespace")))) {
+                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 402, wloc);
+                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedEnterAttribute($__qname);
+                }
             }
             break;
         case 29:
@@ -572,10 +569,27 @@
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromEnterAttribute(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 5:
+            {
+                $_ngcc_current_state = 1;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 19:
+            {
+                $_ngcc_current_state = 18;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 17:
             {
-                if((($__uri.equals("") && $__local.equals("form")) || ($__uri.equals("") && $__local.equals("name")))) {
-                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 628, locator,true,defaultValue,fixedValue);
+                if((($__uri.equals("") && $__local.equals("name")) || ($__uri.equals("") && $__local.equals("form")))) {
+                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 427, locator,true,defaultValue,fixedValue);
                     spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -588,24 +602,10 @@
                 }
             }
             break;
-        case 0:
+        case 16:
             {
-                revertToParentFromEnterAttribute(this, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 13:
-            {
-                if(($__uri.equals("") && $__local.equals("ref"))) {
-                    $_ngcc_current_state = 12;
-                }
-                else {
-                    unexpectedEnterAttribute($__qname);
-                }
-            }
-            break;
-        case 1:
-            {
-                $_ngcc_current_state = 0;
+                action4();
+                $_ngcc_current_state = 15;
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -623,58 +623,62 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 33:
+        case 1:
             {
-                $_ngcc_current_state = 29;
+                $_ngcc_current_state = 0;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 19:
+        case 25:
             {
-                $_ngcc_current_state = 18;
+                $_ngcc_current_state = 17;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 25:
+        case 8:
             {
-                $_ngcc_current_state = 17;
+                action2();
+                $_ngcc_current_state = 7;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 5:
+        case 33:
             {
-                $_ngcc_current_state = 1;
+                $_ngcc_current_state = 29;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 30:
+        case 9:
             {
-                if(($__uri.equals("") && $__local.equals("default"))) {
-                    $_ngcc_current_state = 25;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                $_ngcc_current_state = 8;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 8:
+        case 29:
             {
-                action2();
-                $_ngcc_current_state = 7;
+                $_ngcc_current_state = 25;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 16:
+        case 34:
             {
-                action4();
-                $_ngcc_current_state = 15;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("use"))) {
+                    $_ngcc_current_state = 29;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
-        case 26:
+        case 0:
             {
-                if(($__uri.equals("") && $__local.equals("fixed"))) {
-                    $_ngcc_current_state = 17;
+                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 30:
+            {
+                if(($__uri.equals("") && $__local.equals("default"))) {
+                    $_ngcc_current_state = 25;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -681,9 +685,9 @@
                 }
             }
             break;
-        case 9:
+        case 5:
             {
-                $_ngcc_current_state = 8;
+                $_ngcc_current_state = 1;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -697,27 +701,26 @@
                 }
             }
             break;
-        case 29:
+        case 21:
             {
-                $_ngcc_current_state = 25;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("ref"))) {
+                    $_ngcc_current_state = 19;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
-        case 0:
+        case 19:
             {
-                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 1:
-            {
-                $_ngcc_current_state = 0;
+                $_ngcc_current_state = 18;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 34:
+        case 26:
             {
-                if(($__uri.equals("") && $__local.equals("use"))) {
-                    $_ngcc_current_state = 29;
+                if(($__uri.equals("") && $__local.equals("fixed"))) {
+                    $_ngcc_current_state = 17;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -724,14 +727,11 @@
                 }
             }
             break;
-        case 21:
+        case 16:
             {
-                if(($__uri.equals("") && $__local.equals("ref"))) {
-                    $_ngcc_current_state = 19;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                action4();
+                $_ngcc_current_state = 15;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
         default:
@@ -745,30 +745,32 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 33:
+        case 12:
             {
-                if(($ai = $runtime.getAttributeIndex("","use"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 29;
-                    $runtime.sendText(super._cookie, $value);
-                }
+                NGCCHandler h = new qname(this, super._source, $runtime, 412);
+                spawnChildFromText(h, $value);
             }
             break;
-        case 19:
+        case 1:
             {
-                $_ngcc_current_state = 18;
+                $_ngcc_current_state = 0;
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 12:
+        case 13:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 613);
-                spawnChildFromText(h, $value);
+                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
+        case 27:
+            {
+                fixedValue = $value;
+                $_ngcc_current_state = 26;
+            }
+            break;
         case 25:
             {
                 if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
@@ -781,85 +783,83 @@
                 }
             }
             break;
-        case 5:
+        case 8:
             {
-                $_ngcc_current_state = 1;
+                action2();
+                $_ngcc_current_state = 7;
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 35:
+        case 33:
             {
-                use = $value;
-                $_ngcc_current_state = 34;
+                if(($ai = $runtime.getAttributeIndex("","use"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 29;
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
-        case 8:
+        case 9:
             {
-                action2();
-                $_ngcc_current_state = 7;
+                $_ngcc_current_state = 8;
                 $runtime.sendText(super._cookie, $value);
             }
             break;
         case 3:
             {
-                if(($ai = $runtime.getAttributeIndex("","processContents"))>=0) {
-                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 603, wloc);
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 402, wloc);
                     spawnChildFromText(h, $value);
                 }
                 else {
-                    if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
-                        NGCCHandler h = new wildcardBody(this, super._source, $runtime, 603, wloc);
+                    if(($ai = $runtime.getAttributeIndex("","processContents"))>=0) {
+                        NGCCHandler h = new wildcardBody(this, super._source, $runtime, 402, wloc);
                         spawnChildFromText(h, $value);
                     }
                 }
             }
             break;
-        case 16:
+        case 29:
             {
-                action4();
-                $_ngcc_current_state = 15;
-                $runtime.sendText(super._cookie, $value);
+                if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 25;
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
-        case 27:
+        case 0:
             {
-                fixedValue = $value;
-                $_ngcc_current_state = 26;
+                revertToParentFromText(this, super._cookie, $value);
             }
             break;
-        case 31:
+        case 5:
             {
-                defaultValue = $value;
-                $_ngcc_current_state = 30;
-            }
-            break;
-        case 9:
-            {
-                $_ngcc_current_state = 8;
+                $_ngcc_current_state = 1;
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 29:
+        case 22:
             {
-                if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 25;
-                    $runtime.sendText(super._cookie, $value);
-                }
+                NGCCHandler h = new qname(this, super._source, $runtime, 423);
+                spawnChildFromText(h, $value);
             }
             break;
         case 17:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 628, locator,true,defaultValue,fixedValue);
+                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                    NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 427, locator,true,defaultValue,fixedValue);
                     spawnChildFromText(h, $value);
                 }
                 else {
-                    if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
-                        NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 628, locator,true,defaultValue,fixedValue);
+                    if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                        NGCCHandler h = new attributeDeclBody(this, super._source, $runtime, 427, locator,true,defaultValue,fixedValue);
                         spawnChildFromText(h, $value);
                     }
                     else {
@@ -871,29 +871,29 @@
                 }
             }
             break;
-        case 0:
+        case 19:
             {
-                revertToParentFromText(this, super._cookie, $value);
+                $_ngcc_current_state = 18;
+                $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 22:
+        case 31:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 624);
-                spawnChildFromText(h, $value);
+                defaultValue = $value;
+                $_ngcc_current_state = 30;
             }
             break;
-        case 13:
+        case 16:
             {
-                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
+                action4();
+                $_ngcc_current_state = 15;
+                $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 1:
+        case 35:
             {
-                $_ngcc_current_state = 0;
-                $runtime.sendText(super._cookie, $value);
+                use = $value;
+                $_ngcc_current_state = 34;
             }
             break;
         }
@@ -901,13 +901,13 @@
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 621:
+        case 412:
             {
-                annotation = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 18;
+                groupName = ((UName)$__result__);
+                $_ngcc_current_state = 11;
             }
             break;
-        case 603:
+        case 402:
             {
                 wildcard = ((WildcardImpl)$__result__);
                 action0();
@@ -914,31 +914,24 @@
                 $_ngcc_current_state = 2;
             }
             break;
-        case 610:
+        case 418:
             {
-                $_ngcc_current_state = 8;
-            }
-            break;
-        case 628:
-            {
-                anonymousDecl = ((AttributeDeclImpl)$__result__);
-                action6();
+                fa = ((ForeignAttributesImpl)$__result__);
                 $_ngcc_current_state = 16;
             }
             break;
-        case 619:
+        case 420:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 16;
+                annotation = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 18;
             }
             break;
-        case 613:
+        case 409:
             {
-                groupName = ((UName)$__result__);
-                $_ngcc_current_state = 11;
+                $_ngcc_current_state = 8;
             }
             break;
-        case 624:
+        case 423:
             {
                 attDeclName = ((UName)$__result__);
                 action5();
@@ -945,11 +938,18 @@
                 $_ngcc_current_state = 21;
             }
             break;
+        case 427:
+            {
+                anonymousDecl = ((AttributeDeclImpl)$__result__);
+                action6();
+                $_ngcc_current_state = 16;
+            }
+            break;
         }
     }
 
     public boolean accepted() {
-        return((($_ngcc_current_state == 1) || (($_ngcc_current_state == 0) || ($_ngcc_current_state == 5))));
+        return((($_ngcc_current_state == 5) || (($_ngcc_current_state == 0) || ($_ngcc_current_state == 1))));
     }
 
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/complexType.java	Tue Aug  4 10:09:19 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/complexType.java	Tue Aug  4 10:09:18 2009
@@ -187,14 +187,42 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 28:
+        case 7:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 113, fa);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
+                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                    action7();
+                    $_ngcc_current_state = 24;
+                }
+                else {
+                    if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
+                        $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                        action4();
+                        $_ngcc_current_state = 15;
+                    }
+                    else {
+                        unexpectedEnterElement($__qname);
+                    }
+                }
+            }
+            break;
+        case 38:
+            {
+                action8();
+                $_ngcc_current_state = 37;
+                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
+        case 48:
+            {
+                if((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern")))) {
+                    NGCCHandler h = new facet(this, super._source, $runtime, 257);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    action11();
+                    $_ngcc_current_state = 47;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
@@ -210,11 +238,11 @@
                 }
             }
             break;
-        case 47:
+        case 44:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))))) {
-                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 135, result);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -221,67 +249,40 @@
                 }
             }
             break;
-        case 18:
+        case 49:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))))))))) {
-                    NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 100, result);
+                if((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern")))) {
+                    NGCCHandler h = new facet(this, super._source, $runtime, 258);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 48;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 52:
+        case 18:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                    NGCCHandler h = new simpleType(this, super._source, $runtime, 143);
+                if((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))))))))) {
+                    NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 219, result);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 51;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 38:
+        case 67:
             {
-                action8();
-                $_ngcc_current_state = 37;
-                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 61:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 155, annotation,AnnotationContext.COMPLEXTYPE_DECL);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexContent")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleContent")))))))))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 284, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 35;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 35:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
-                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    action15();
-                    $_ngcc_current_state = 59;
-                }
-                else {
-                    if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
-                        $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                        action10();
-                        $_ngcc_current_state = 44;
-                    }
-                    else {
-                        unexpectedEnterElement($__qname);
-                    }
-                }
-            }
-            break;
         case 88:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
@@ -294,90 +295,101 @@
                 }
             }
             break;
-        case 48:
+        case 61:
             {
-                if((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern")))) {
-                    NGCCHandler h = new facet(this, super._source, $runtime, 138);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 274, annotation,AnnotationContext.COMPLEXTYPE_DECL);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    action11();
-                    $_ngcc_current_state = 47;
+                    $_ngcc_current_state = 35;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 49:
+        case 28:
             {
-                if((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern")))) {
-                    NGCCHandler h = new facet(this, super._source, $runtime, 139);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 232, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 48;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 59:
+        case 80:
             {
-                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 76;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 39:
+        case 12:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 126, annotation,AnnotationContext.COMPLEXTYPE_DECL);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")))))))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 212, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 38;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 2:
+        case 35:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleContent"))) {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
                     $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    $_ngcc_current_state = 63;
+                    action15();
+                    $_ngcc_current_state = 59;
                 }
                 else {
-                    if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexContent"))) {
+                    if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
                         $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                        $_ngcc_current_state = 29;
+                        action10();
+                        $_ngcc_current_state = 44;
                     }
                     else {
-                        if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))))))))) {
-                            action1();
-                            NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 86, result);
-                            spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                        }
-                        else {
-                            unexpectedEnterElement($__qname);
-                        }
+                        unexpectedEnterElement($__qname);
                     }
                 }
             }
             break;
-        case 65:
+        case 76:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 163, null,AnnotationContext.COMPLEXTYPE_DECL);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 2;
+                    $_ngcc_current_state = 72;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
+        case 51:
+            {
+                action13();
+                $_ngcc_current_state = 49;
+                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
+        case 47:
+            {
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))))) {
+                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 254, result);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
+            }
+            break;
         case 68:
             {
                 if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
@@ -401,40 +413,33 @@
                 }
             }
             break;
-        case 7:
+        case 37:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
-                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    action7();
-                    $_ngcc_current_state = 24;
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))))) {
+                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 242, result);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
-                        $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                        action4();
-                        $_ngcc_current_state = 15;
-                    }
-                    else {
-                        unexpectedEnterElement($__qname);
-                    }
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 24:
+        case 26:
             {
-                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 230, annotation,AnnotationContext.COMPLEXTYPE_DECL);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 7;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 21:
+        case 56:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")))))))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 104, fa);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || (((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern"))))))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 267, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -442,34 +447,33 @@
                 }
             }
             break;
-        case 54:
+        case 24:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 146, annotation,AnnotationContext.COMPLEXTYPE_DECL);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 52;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 80:
+        case 10:
             {
-                if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 210, annotation,AnnotationContext.COMPLEXTYPE_DECL);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 76;
+                    $_ngcc_current_state = 9;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 9:
+        case 41:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))))))))) {
-                    NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 89, result);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 247, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -477,40 +481,58 @@
                 }
             }
             break;
-        case 51:
+        case 84:
             {
-                action13();
-                $_ngcc_current_state = 49;
-                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 80;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
             }
             break;
-        case 12:
+        case 2:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")))))))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 93, fa);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleContent"))) {
+                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                    $_ngcc_current_state = 63;
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexContent"))) {
+                        $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                        $_ngcc_current_state = 29;
+                    }
+                    else {
+                        if((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))))))))) {
+                            action1();
+                            NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 205, result);
+                            spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                        }
+                        else {
+                            unexpectedEnterElement($__qname);
+                        }
+                    }
                 }
             }
             break;
-        case 26:
+        case 65:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 111, annotation,AnnotationContext.COMPLEXTYPE_DECL);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 282, null,AnnotationContext.COMPLEXTYPE_DECL);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 7;
+                    $_ngcc_current_state = 2;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 67:
+        case 21:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexContent")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleContent")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")))))))))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 165, fa);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")))))))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 223, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -518,38 +540,38 @@
                 }
             }
             break;
-        case 10:
+        case 54:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 91, annotation,AnnotationContext.COMPLEXTYPE_DECL);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 265, annotation,AnnotationContext.COMPLEXTYPE_DECL);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 9;
+                    $_ngcc_current_state = 52;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 29:
+        case 52:
             {
-                if(($ai = $runtime.getAttributeIndex("","mixed"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
+                    NGCCHandler h = new simpleType(this, super._source, $runtime, 262);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 28;
+                    $_ngcc_current_state = 51;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 84:
+        case 39:
             {
-                if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 245, annotation,AnnotationContext.COMPLEXTYPE_DECL);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 80;
+                    $_ngcc_current_state = 38;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
@@ -559,23 +581,23 @@
                 revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
-        case 76:
+        case 29:
             {
-                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","mixed"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 72;
+                    $_ngcc_current_state = 28;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 44:
+        case 9:
             {
-                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))))))))) {
+                    NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 208, result);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -585,7 +607,7 @@
         case 19:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 102, annotation,AnnotationContext.COMPLEXTYPE_DECL);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 221, annotation,AnnotationContext.COMPLEXTYPE_DECL);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -594,10 +616,10 @@
                 }
             }
             break;
-        case 37:
+        case 63:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))))) {
-                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 123, result);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 276, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -605,11 +627,11 @@
                 }
             }
             break;
-        case 41:
+        case 59:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 128, fa);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -616,28 +638,6 @@
                 }
             }
             break;
-        case 56:
-            {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")))))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 148, fa);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
-        case 63:
-            {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 157, fa);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -652,11 +652,25 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 1:
+        case 38:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
+                action8();
+                $_ngcc_current_state = 37;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 48:
+            {
+                action11();
+                $_ngcc_current_state = 47;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 6:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexContent"))) {
                     $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 0;
+                    $_ngcc_current_state = 1;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -663,11 +677,11 @@
                 }
             }
             break;
-        case 8:
+        case 36:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
                     $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 6;
+                    $_ngcc_current_state = 34;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -674,6 +688,17 @@
                 }
             }
             break;
+        case 44:
+            {
+                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
+            }
+            break;
         case 72:
             {
                 if(($ai = $runtime.getAttributeIndex("","mixed"))>=0) {
@@ -686,21 +711,16 @@
                 }
             }
             break;
-        case 47:
+        case 49:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
-                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 135, result);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
+                $_ngcc_current_state = 48;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
         case 18:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
-                    NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 100, result);
+                    NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 219, result);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -708,11 +728,11 @@
                 }
             }
             break;
-        case 46:
+        case 67:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 34;
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 284, fa);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -719,60 +739,69 @@
                 }
             }
             break;
-        case 52:
+        case 61:
             {
-                $_ngcc_current_state = 51;
+                $_ngcc_current_state = 35;
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 38:
+        case 34:
             {
-                action8();
-                $_ngcc_current_state = 37;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleContent"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 1;
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
             }
             break;
-        case 61:
+        case 80:
             {
-                $_ngcc_current_state = 35;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                }
+                else {
+                    $_ngcc_current_state = 76;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                }
             }
             break;
-        case 48:
+        case 12:
             {
-                action11();
-                $_ngcc_current_state = 47;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 212, fa);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
             }
             break;
-        case 49:
+        case 76:
             {
-                $_ngcc_current_state = 48;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 59:
-            {
-                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    unexpectedLeaveElement($__qname);
+                    $_ngcc_current_state = 72;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 39:
+        case 51:
             {
-                $_ngcc_current_state = 38;
+                action13();
+                $_ngcc_current_state = 49;
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 2:
+        case 47:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
-                    action1();
-                    NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 86, result);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
+                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 254, result);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -780,12 +809,6 @@
                 }
             }
             break;
-        case 65:
-            {
-                $_ngcc_current_state = 2;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 68:
             {
                 if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
@@ -809,11 +832,11 @@
                 }
             }
             break;
-        case 24:
+        case 37:
             {
-                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
+                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 242, result);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -820,11 +843,11 @@
                 }
             }
             break;
-        case 21:
+        case 46:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 104, fa);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 34;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -831,28 +854,44 @@
                 }
             }
             break;
-        case 54:
+        case 26:
             {
-                $_ngcc_current_state = 52;
+                $_ngcc_current_state = 7;
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 80:
+        case 56:
             {
-                if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 267, fa);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
+            }
+            break;
+        case 24:
+            {
+                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 76;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedLeaveElement($__qname);
                 }
             }
             break;
-        case 9:
+        case 10:
             {
+                $_ngcc_current_state = 9;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 41:
+            {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
-                    NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 89, result);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 247, fa);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -860,17 +899,23 @@
                 }
             }
             break;
-        case 51:
+        case 84:
             {
-                action13();
-                $_ngcc_current_state = 49;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                }
+                else {
+                    $_ngcc_current_state = 80;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                }
             }
             break;
-        case 12:
+        case 2:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 93, fa);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
+                    action1();
+                    NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 205, result);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -878,9 +923,9 @@
                 }
             }
             break;
-        case 26:
+        case 65:
             {
-                $_ngcc_current_state = 7;
+                $_ngcc_current_state = 2;
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -895,10 +940,10 @@
                 }
             }
             break;
-        case 67:
+        case 21:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 165, fa);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 223, fa);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -906,40 +951,29 @@
                 }
             }
             break;
-        case 10:
+        case 54:
             {
-                $_ngcc_current_state = 9;
+                $_ngcc_current_state = 52;
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 34:
+        case 52:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleContent"))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 1;
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
+                $_ngcc_current_state = 51;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 29:
+        case 39:
             {
-                if(($ai = $runtime.getAttributeIndex("","mixed"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
-                else {
-                    $_ngcc_current_state = 28;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
+                $_ngcc_current_state = 38;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 6:
+        case 8:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexContent"))) {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
                     $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 1;
+                    $_ngcc_current_state = 6;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -946,15 +980,14 @@
                 }
             }
             break;
-        case 84:
+        case 1:
             {
-                if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 0;
                 }
                 else {
-                    $_ngcc_current_state = 80;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedLeaveElement($__qname);
                 }
             }
             break;
@@ -963,23 +996,23 @@
                 revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 76:
+        case 29:
             {
-                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","mixed"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 72;
+                    $_ngcc_current_state = 28;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 44:
+        case 9:
             {
-                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
+                    NGCCHandler h = new complexType_complexContent_body(this, super._source, $runtime, 208, result);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -992,11 +1025,11 @@
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 37:
+        case 59:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
-                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 123, result);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -1003,57 +1036,49 @@
                 }
             }
             break;
-        case 41:
+        default:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 128, fa);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
+                unexpectedLeaveElement($__qname);
             }
             break;
-        case 56:
+        }
+    }
+
+    public void enterAttribute(String $__uri, String $__local, String $__qname) throws SAXException {
+        int $ai;
+        $uri = $__uri;
+        $localName = $__local;
+        $qname = $__qname;
+        switch($_ngcc_current_state) {
+        case 68:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 148, fa);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("name"))) {
+                    $_ngcc_current_state = 70;
                 }
                 else {
-                    unexpectedLeaveElement($__qname);
+                    $_ngcc_current_state = 67;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 36:
+        case 38:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("extension"))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 34;
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
+                action8();
+                $_ngcc_current_state = 37;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        default:
+        case 48:
             {
-                unexpectedLeaveElement($__qname);
+                action11();
+                $_ngcc_current_state = 47;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        }
-    }
-
-    public void enterAttribute(String $__uri, String $__local, String $__qname) throws SAXException {
-        int $ai;
-        $uri = $__uri;
-        $localName = $__local;
-        $qname = $__qname;
-        switch($_ngcc_current_state) {
-        case 59:
+        case 15:
             {
                 if(($__uri.equals("") && $__local.equals("base"))) {
-                    $_ngcc_current_state = 58;
+                    $_ngcc_current_state = 14;
                 }
                 else {
                     unexpectedEnterAttribute($__qname);
@@ -1060,39 +1085,43 @@
                 }
             }
             break;
-        case 49:
+        case 26:
             {
-                $_ngcc_current_state = 48;
+                $_ngcc_current_state = 7;
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 39:
+        case 24:
             {
-                $_ngcc_current_state = 38;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("base"))) {
+                    $_ngcc_current_state = 23;
+                }
+                else {
+                    unexpectedEnterAttribute($__qname);
+                }
             }
             break;
-        case 65:
+        case 10:
             {
-                $_ngcc_current_state = 2;
+                $_ngcc_current_state = 9;
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 68:
+        case 84:
             {
-                if(($__uri.equals("") && $__local.equals("name"))) {
-                    $_ngcc_current_state = 70;
+                if(($__uri.equals("") && $__local.equals("abstract"))) {
+                    $_ngcc_current_state = 86;
                 }
                 else {
-                    $_ngcc_current_state = 67;
+                    $_ngcc_current_state = 80;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 15:
+        case 44:
             {
                 if(($__uri.equals("") && $__local.equals("base"))) {
-                    $_ngcc_current_state = 14;
+                    $_ngcc_current_state = 43;
                 }
                 else {
                     unexpectedEnterAttribute($__qname);
@@ -1099,16 +1128,29 @@
                 }
             }
             break;
-        case 24:
+        case 72:
             {
-                if(($__uri.equals("") && $__local.equals("base"))) {
-                    $_ngcc_current_state = 23;
+                if(($__uri.equals("") && $__local.equals("mixed"))) {
+                    $_ngcc_current_state = 74;
                 }
                 else {
-                    unexpectedEnterAttribute($__qname);
+                    $_ngcc_current_state = 68;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
+        case 49:
+            {
+                $_ngcc_current_state = 48;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 65:
+            {
+                $_ngcc_current_state = 2;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 54:
             {
                 $_ngcc_current_state = 52;
@@ -1115,43 +1157,36 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 80:
+        case 52:
             {
-                if(($__uri.equals("") && $__local.equals("block"))) {
-                    $_ngcc_current_state = 82;
-                }
-                else {
-                    $_ngcc_current_state = 76;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-                }
+                $_ngcc_current_state = 51;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 51:
+        case 39:
             {
-                action13();
-                $_ngcc_current_state = 49;
+                $_ngcc_current_state = 38;
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 26:
+        case 61:
             {
-                $_ngcc_current_state = 7;
+                $_ngcc_current_state = 35;
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 10:
+        case 0:
             {
-                $_ngcc_current_state = 9;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 72:
+        case 80:
             {
-                if(($__uri.equals("") && $__local.equals("mixed"))) {
-                    $_ngcc_current_state = 74;
+                if(($__uri.equals("") && $__local.equals("block"))) {
+                    $_ngcc_current_state = 82;
                 }
                 else {
-                    $_ngcc_current_state = 68;
+                    $_ngcc_current_state = 76;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
@@ -1167,22 +1202,6 @@
                 }
             }
             break;
-        case 84:
-            {
-                if(($__uri.equals("") && $__local.equals("abstract"))) {
-                    $_ngcc_current_state = 86;
-                }
-                else {
-                    $_ngcc_current_state = 80;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-                }
-            }
-            break;
-        case 0:
-            {
-                revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 76:
             {
                 if(($__uri.equals("") && $__local.equals("final"))) {
@@ -1194,35 +1213,13 @@
                 }
             }
             break;
-        case 52:
+        case 51:
             {
-                $_ngcc_current_state = 51;
+                action13();
+                $_ngcc_current_state = 49;
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 44:
-            {
-                if(($__uri.equals("") && $__local.equals("base"))) {
-                    $_ngcc_current_state = 43;
-                }
-                else {
-                    unexpectedEnterAttribute($__qname);
-                }
-            }
-            break;
-        case 38:
-            {
-                action8();
-                $_ngcc_current_state = 37;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 61:
-            {
-                $_ngcc_current_state = 35;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 19:
             {
                 $_ngcc_current_state = 18;
@@ -1229,11 +1226,14 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 48:
+        case 59:
             {
-                action11();
-                $_ngcc_current_state = 47;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("base"))) {
+                    $_ngcc_current_state = 58;
+                }
+                else {
+                    unexpectedEnterAttribute($__qname);
+                }
             }
             break;
         default:
@@ -1250,10 +1250,10 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 42:
+        case 81:
             {
-                if(($__uri.equals("") && $__local.equals("base"))) {
-                    $_ngcc_current_state = 41;
+                if(($__uri.equals("") && $__local.equals("block"))) {
+                    $_ngcc_current_state = 76;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -1260,22 +1260,10 @@
                 }
             }
             break;
-        case 72:
+        case 22:
             {
-                $_ngcc_current_state = 68;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 52:
-            {
-                $_ngcc_current_state = 51;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 69:
-            {
-                if(($__uri.equals("") && $__local.equals("name"))) {
-                    $_ngcc_current_state = 67;
+                if(($__uri.equals("") && $__local.equals("base"))) {
+                    $_ngcc_current_state = 21;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -1289,16 +1277,17 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 61:
+        case 48:
             {
-                $_ngcc_current_state = 35;
+                action11();
+                $_ngcc_current_state = 47;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 81:
+        case 73:
             {
-                if(($__uri.equals("") && $__local.equals("block"))) {
-                    $_ngcc_current_state = 76;
+                if(($__uri.equals("") && $__local.equals("mixed"))) {
+                    $_ngcc_current_state = 68;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -1305,10 +1294,10 @@
                 }
             }
             break;
-        case 73:
+        case 30:
             {
                 if(($__uri.equals("") && $__local.equals("mixed"))) {
-                    $_ngcc_current_state = 68;
+                    $_ngcc_current_state = 28;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -1315,10 +1304,9 @@
                 }
             }
             break;
-        case 48:
+        case 72:
             {
-                action11();
-                $_ngcc_current_state = 47;
+                $_ngcc_current_state = 68;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -1328,28 +1316,22 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 39:
+        case 61:
             {
-                $_ngcc_current_state = 38;
+                $_ngcc_current_state = 35;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 65:
+        case 80:
             {
-                $_ngcc_current_state = 2;
+                $_ngcc_current_state = 76;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 68:
+        case 69:
             {
-                $_ngcc_current_state = 67;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 57:
-            {
-                if(($__uri.equals("") && $__local.equals("base"))) {
-                    $_ngcc_current_state = 56;
+                if(($__uri.equals("") && $__local.equals("name"))) {
+                    $_ngcc_current_state = 67;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -1356,18 +1338,12 @@
                 }
             }
             break;
-        case 80:
+        case 76:
             {
-                $_ngcc_current_state = 76;
+                $_ngcc_current_state = 72;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 54:
-            {
-                $_ngcc_current_state = 52;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 51:
             {
                 action13();
@@ -1375,28 +1351,26 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 26:
+        case 77:
             {
-                $_ngcc_current_state = 7;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("final"))) {
+                    $_ngcc_current_state = 72;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
-        case 10:
+        case 68:
             {
-                $_ngcc_current_state = 9;
+                $_ngcc_current_state = 67;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 29:
+        case 85:
             {
-                $_ngcc_current_state = 28;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 22:
-            {
-                if(($__uri.equals("") && $__local.equals("base"))) {
-                    $_ngcc_current_state = 21;
+                if(($__uri.equals("") && $__local.equals("abstract"))) {
+                    $_ngcc_current_state = 80;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -1403,16 +1377,10 @@
                 }
             }
             break;
-        case 84:
+        case 13:
             {
-                $_ngcc_current_state = 80;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 77:
-            {
-                if(($__uri.equals("") && $__local.equals("final"))) {
-                    $_ngcc_current_state = 72;
+                if(($__uri.equals("") && $__local.equals("base"))) {
+                    $_ngcc_current_state = 12;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -1419,21 +1387,10 @@
                 }
             }
             break;
-        case 0:
+        case 42:
             {
-                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 76:
-            {
-                $_ngcc_current_state = 72;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 30:
-            {
-                if(($__uri.equals("") && $__local.equals("mixed"))) {
-                    $_ngcc_current_state = 28;
+                if(($__uri.equals("") && $__local.equals("base"))) {
+                    $_ngcc_current_state = 41;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -1440,91 +1397,86 @@
                 }
             }
             break;
-        case 19:
+        case 10:
             {
-                $_ngcc_current_state = 18;
+                $_ngcc_current_state = 9;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 85:
+        case 26:
             {
-                if(($__uri.equals("") && $__local.equals("abstract"))) {
-                    $_ngcc_current_state = 80;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                $_ngcc_current_state = 7;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 13:
+        case 84:
             {
-                if(($__uri.equals("") && $__local.equals("base"))) {
-                    $_ngcc_current_state = 12;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                $_ngcc_current_state = 80;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        default:
+        case 65:
             {
-                unexpectedLeaveAttribute($__qname);
+                $_ngcc_current_state = 2;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        }
-    }
-
-    public void text(String $value) throws SAXException {
-        int $ai;
-        switch($_ngcc_current_state) {
-        case 82:
+        case 54:
             {
-                NGCCHandler h = new erSet(this, super._source, $runtime, 182);
-                spawnChildFromText(h, $value);
+                $_ngcc_current_state = 52;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 23:
+        case 52:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 106);
-                spawnChildFromText(h, $value);
+                $_ngcc_current_state = 51;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 43:
+        case 39:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 130);
-                spawnChildFromText(h, $value);
+                $_ngcc_current_state = 38;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 72:
+        case 57:
             {
-                if(($ai = $runtime.getAttributeIndex("","mixed"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
+                if(($__uri.equals("") && $__local.equals("base"))) {
+                    $_ngcc_current_state = 56;
                 }
                 else {
-                    $_ngcc_current_state = 68;
-                    $runtime.sendText(super._cookie, $value);
+                    unexpectedLeaveAttribute($__qname);
                 }
             }
             break;
-        case 58:
+        case 0:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 150);
-                spawnChildFromText(h, $value);
+                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 31:
+        case 29:
             {
-                mixedValue = $value;
-                $_ngcc_current_state = 30;
+                $_ngcc_current_state = 28;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 52:
+        case 19:
             {
-                $_ngcc_current_state = 51;
-                $runtime.sendText(super._cookie, $value);
+                $_ngcc_current_state = 18;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        default:
+            {
+                unexpectedLeaveAttribute($__qname);
+            }
+            break;
+        }
+    }
+
+    public void text(String $value) throws SAXException {
+        int $ai;
+        switch($_ngcc_current_state) {
         case 38:
             {
                 action8();
@@ -1532,9 +1484,10 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 61:
+        case 48:
             {
-                $_ngcc_current_state = 35;
+                action11();
+                $_ngcc_current_state = 47;
                 $runtime.sendText(super._cookie, $value);
             }
             break;
@@ -1544,21 +1497,32 @@
                 $_ngcc_current_state = 69;
             }
             break;
-        case 48:
+        case 82:
             {
-                action11();
-                $_ngcc_current_state = 47;
-                $runtime.sendText(super._cookie, $value);
+                NGCCHandler h = new erSet(this, super._source, $runtime, 301);
+                spawnChildFromText(h, $value);
             }
             break;
-        case 49:
+        case 78:
             {
-                $_ngcc_current_state = 48;
-                $runtime.sendText(super._cookie, $value);
+                NGCCHandler h = new erSet(this, super._source, $runtime, 296);
+                spawnChildFromText(h, $value);
             }
             break;
-        case 59:
+        case 72:
             {
+                if(($ai = $runtime.getAttributeIndex("","mixed"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 68;
+                    $runtime.sendText(super._cookie, $value);
+                }
+            }
+            break;
+        case 44:
+            {
                 if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
@@ -1565,30 +1529,42 @@
                 }
             }
             break;
-        case 39:
+        case 49:
             {
-                $_ngcc_current_state = 38;
+                $_ngcc_current_state = 48;
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 65:
+        case 31:
             {
-                $_ngcc_current_state = 2;
+                mixedValue = $value;
+                $_ngcc_current_state = 30;
+            }
+            break;
+        case 61:
+            {
+                $_ngcc_current_state = 35;
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 68:
+        case 80:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    $_ngcc_current_state = 67;
+                    $_ngcc_current_state = 76;
                     $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
+        case 14:
+            {
+                NGCCHandler h = new qname(this, super._source, $runtime, 214);
+                spawnChildFromText(h, $value);
+            }
+            break;
         case 74:
             {
                 mixedValue = $value;
@@ -1595,56 +1571,48 @@
                 $_ngcc_current_state = 73;
             }
             break;
-        case 15:
+        case 76:
             {
-                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
-            }
-            break;
-        case 24:
-            {
-                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
-                    $runtime.consumeAttribute($ai);
+                else {
+                    $_ngcc_current_state = 72;
                     $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
-        case 86:
+        case 51:
             {
-                abstractValue = $value;
-                $_ngcc_current_state = 85;
-            }
-            break;
-        case 54:
-            {
-                $_ngcc_current_state = 52;
+                action13();
+                $_ngcc_current_state = 49;
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 80:
+        case 68:
             {
-                if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    $_ngcc_current_state = 76;
+                    $_ngcc_current_state = 67;
                     $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
-        case 51:
+        case 15:
             {
-                action13();
-                $_ngcc_current_state = 49;
-                $runtime.sendText(super._cookie, $value);
+                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
-        case 78:
+        case 58:
             {
-                NGCCHandler h = new erSet(this, super._source, $runtime, 177);
+                NGCCHandler h = new qname(this, super._source, $runtime, 269);
                 spawnChildFromText(h, $value);
             }
             break;
@@ -1660,16 +1628,12 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 29:
+        case 24:
             {
-                if(($ai = $runtime.getAttributeIndex("","mixed"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
-                else {
-                    $_ngcc_current_state = 28;
-                    $runtime.sendText(super._cookie, $value);
-                }
             }
             break;
         case 84:
@@ -1684,35 +1648,63 @@
                 }
             }
             break;
-        case 14:
+        case 65:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 95);
-                spawnChildFromText(h, $value);
+                $_ngcc_current_state = 2;
+                $runtime.sendText(super._cookie, $value);
             }
             break;
+        case 54:
+            {
+                $_ngcc_current_state = 52;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
+        case 52:
+            {
+                $_ngcc_current_state = 51;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
+        case 39:
+            {
+                $_ngcc_current_state = 38;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
         case 0:
             {
                 revertToParentFromText(result, super._cookie, $value);
             }
             break;
-        case 76:
+        case 86:
             {
-                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
+                abstractValue = $value;
+                $_ngcc_current_state = 85;
+            }
+            break;
+        case 23:
+            {
+                NGCCHandler h = new qname(this, super._source, $runtime, 225);
+                spawnChildFromText(h, $value);
+            }
+            break;
+        case 29:
+            {
+                if(($ai = $runtime.getAttributeIndex("","mixed"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    $_ngcc_current_state = 72;
+                    $_ngcc_current_state = 28;
                     $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
-        case 44:
+        case 43:
             {
-                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
+                NGCCHandler h = new qname(this, super._source, $runtime, 249);
+                spawnChildFromText(h, $value);
             }
             break;
         case 19:
@@ -1721,107 +1713,109 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
+        case 59:
+            {
+                if(($ai = $runtime.getAttributeIndex("","base"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+            }
+            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 106:
+        case 257:
             {
-                baseTypeName = ((UName)$__result__);
-                action6();
-                $_ngcc_current_state = 22;
+                facet = ((XSFacet)$__result__);
+                action12();
+                $_ngcc_current_state = 48;
             }
             break;
-        case 143:
+        case 301:
             {
-                baseContentType = ((SimpleTypeImpl)$__result__);
-                $_ngcc_current_state = 51;
+                blockValue = ((Integer)$__result__);
+                $_ngcc_current_state = 81;
             }
             break;
-        case 155:
+        case 258:
             {
-                annotation = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 35;
-            }
-            break;
-        case 138:
-            {
                 facet = ((XSFacet)$__result__);
                 action12();
                 $_ngcc_current_state = 48;
             }
             break;
-        case 139:
+        case 219:
             {
-                facet = ((XSFacet)$__result__);
-                action12();
-                $_ngcc_current_state = 48;
+                explicitContent = ((ContentTypeImpl)$__result__);
+                action5();
+                $_ngcc_current_state = 17;
             }
             break;
-        case 86:
+        case 232:
             {
-                explicitContent = ((ContentTypeImpl)$__result__);
-                action0();
-                $_ngcc_current_state = 1;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 26;
             }
             break;
-        case 89:
+        case 212:
             {
-                explicitContent = ((ContentTypeImpl)$__result__);
-                action2();
-                $_ngcc_current_state = 8;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 10;
             }
             break;
-        case 177:
+        case 242:
             {
-                finalValue = ((Integer)$__result__);
-                $_ngcc_current_state = 77;
+                $_ngcc_current_state = 36;
             }
             break;
-        case 111:
+        case 267:
             {
-                annotation = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 7;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 54;
             }
             break;
-        case 91:
+        case 210:
             {
                 annotation = ((AnnotationImpl)$__result__);
                 $_ngcc_current_state = 9;
             }
             break;
-        case 95:
+        case 247:
             {
-                baseTypeName = ((UName)$__result__);
-                action3();
-                $_ngcc_current_state = 13;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 39;
             }
             break;
-        case 102:
+        case 205:
             {
-                annotation = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 18;
+                explicitContent = ((ContentTypeImpl)$__result__);
+                action0();
+                $_ngcc_current_state = 1;
             }
             break;
-        case 123:
+        case 262:
             {
-                $_ngcc_current_state = 36;
+                baseContentType = ((SimpleTypeImpl)$__result__);
+                $_ngcc_current_state = 51;
             }
             break;
-        case 113:
+        case 225:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 26;
+                baseTypeName = ((UName)$__result__);
+                action6();
+                $_ngcc_current_state = 22;
             }
             break;
-        case 182:
+        case 208:
             {
-                blockValue = ((Integer)$__result__);
-                $_ngcc_current_state = 81;
+                explicitContent = ((ContentTypeImpl)$__result__);
+                action2();
+                $_ngcc_current_state = 8;
             }
             break;
-        case 130:
+        case 249:
             {
                 baseTypeName = ((UName)$__result__);
                 action9();
@@ -1828,79 +1822,85 @@
                 $_ngcc_current_state = 42;
             }
             break;
-        case 150:
+        case 296:
             {
+                finalValue = ((Integer)$__result__);
+                $_ngcc_current_state = 77;
+            }
+            break;
+        case 284:
+            {
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 65;
+            }
+            break;
+        case 274:
+            {
+                annotation = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 35;
+            }
+            break;
+        case 214:
+            {
                 baseTypeName = ((UName)$__result__);
-                action14();
-                $_ngcc_current_state = 57;
+                action3();
+                $_ngcc_current_state = 13;
             }
             break;
-        case 135:
+        case 254:
             {
                 $_ngcc_current_state = 46;
             }
             break;
-        case 100:
+        case 269:
             {
-                explicitContent = ((ContentTypeImpl)$__result__);
-                action5();
-                $_ngcc_current_state = 17;
+                baseTypeName = ((UName)$__result__);
+                action14();
+                $_ngcc_current_state = 57;
             }
             break;
-        case 126:
+        case 230:
             {
                 annotation = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 38;
+                $_ngcc_current_state = 7;
             }
             break;
-        case 163:
+        case 282:
             {
                 annotation = ((AnnotationImpl)$__result__);
                 $_ngcc_current_state = 2;
             }
             break;
-        case 146:
+        case 265:
             {
                 annotation = ((AnnotationImpl)$__result__);
                 $_ngcc_current_state = 52;
             }
             break;
-        case 104:
+        case 223:
             {
                 fa = ((ForeignAttributesImpl)$__result__);
                 $_ngcc_current_state = 19;
             }
             break;
-        case 93:
+        case 245:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 10;
+                annotation = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 38;
             }
             break;
-        case 165:
+        case 276:
             {
                 fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 65;
+                $_ngcc_current_state = 61;
             }
             break;
-        case 128:
+        case 221:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 39;
+                annotation = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 18;
             }
             break;
-        case 148:
-            {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 54;
-            }
-            break;
-        case 157:
-            {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 61;
-            }
-            break;
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/complexType_complexContent_body.java	Tue Aug  4 10:09:22 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/complexType_complexContent_body.java	Tue Aug  4 10:09:22 2009
@@ -81,12 +81,12 @@
             break;
         case 1:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute"))))) {
-                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 676, owner);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("anyAttribute")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attribute"))))) {
+                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 515, owner);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 676, owner);
+                    NGCCHandler h = new attributeUses(this, super._source, $runtime, 515, owner);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
             }
@@ -93,8 +93,8 @@
             break;
         case 2:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")))))) {
-                    NGCCHandler h = new particle(this, super._source, $runtime, 678);
+                if((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")))))) {
+                    NGCCHandler h = new particle(this, super._source, $runtime, 517);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -124,7 +124,7 @@
             break;
         case 1:
             {
-                NGCCHandler h = new attributeUses(this, super._source, $runtime, 676, owner);
+                NGCCHandler h = new attributeUses(this, super._source, $runtime, 515, owner);
                 spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
             }
             break;
@@ -155,7 +155,7 @@
             break;
         case 1:
             {
-                NGCCHandler h = new attributeUses(this, super._source, $runtime, 676, owner);
+                NGCCHandler h = new attributeUses(this, super._source, $runtime, 515, owner);
                 spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
             }
             break;
@@ -186,7 +186,7 @@
             break;
         case 1:
             {
-                NGCCHandler h = new attributeUses(this, super._source, $runtime, 676, owner);
+                NGCCHandler h = new attributeUses(this, super._source, $runtime, 515, owner);
                 spawnChildFromLeaveAttribute(h, $__uri, $__local, $__qname);
             }
             break;
@@ -214,7 +214,7 @@
             break;
         case 1:
             {
-                NGCCHandler h = new attributeUses(this, super._source, $runtime, 676, owner);
+                NGCCHandler h = new attributeUses(this, super._source, $runtime, 515, owner);
                 spawnChildFromText(h, $value);
             }
             break;
@@ -229,13 +229,13 @@
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 676:
+        case 515:
             {
                 action0();
                 $_ngcc_current_state = 0;
             }
             break;
-        case 678:
+        case 517:
             {
                 particle = ((ParticleImpl)$__result__);
                 $_ngcc_current_state = 1;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/elementDeclBody.java	Tue Aug  4 10:09:24 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/elementDeclBody.java	Tue Aug  4 10:09:24 2009
@@ -105,10 +105,22 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 24:
+            {
+                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 23;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+            }
+            break;
         case 0:
             {
                 if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) {
-                    NGCCHandler h = new identityConstraint(this, super._source, $runtime, 492);
+                    NGCCHandler h = new identityConstraint(this, super._source, $runtime, 451);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -116,6 +128,18 @@
                 }
             }
             break;
+        case 11:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 469, null,AnnotationContext.ELEMENT_DECL);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 3;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+            }
+            break;
         case 17:
             {
                 if(($ai = $runtime.getAttributeIndex("","nillable"))>=0) {
@@ -140,27 +164,26 @@
                 }
             }
             break;
-        case 32:
+        case 1:
             {
-                if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) {
+                    NGCCHandler h = new identityConstraint(this, super._source, $runtime, 452);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 28;
+                    $_ngcc_current_state = 0;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 44:
+        case 48:
             {
-                if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(((($ai = $runtime.getAttributeIndex("","block"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType")))) || ((($ai = $runtime.getAttributeIndex("","default"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType")))) || ((($ai = $runtime.getAttributeIndex("","fixed"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType")))) || ((($ai = $runtime.getAttributeIndex("","abstract"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType")))) || ((($ai = $runtime.getAttributeIndex("","final"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType")))) || ((($ai = $runtime.getAttributeIndex("","form"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType")))) || (($ai = $runtime.getAttributeIndex("","name"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))))))))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 514, fa);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 40;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
@@ -176,38 +199,27 @@
                 }
             }
             break;
-        case 11:
+        case 32:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 510, null,AnnotationContext.ELEMENT_DECL);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    $_ngcc_current_state = 3;
+                if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
+                    $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
-            }
-            break;
-        case 1:
-            {
-                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) {
-                    NGCCHandler h = new identityConstraint(this, super._source, $runtime, 493);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
                 else {
-                    $_ngcc_current_state = 0;
+                    $_ngcc_current_state = 28;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 23:
+        case 13:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","substitutionGroup"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 11;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
@@ -214,12 +226,12 @@
         case 3:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                    NGCCHandler h = new simpleType(this, super._source, $runtime, 505);
+                    NGCCHandler h = new simpleType(this, super._source, $runtime, 464);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
-                        NGCCHandler h = new complexType(this, super._source, $runtime, 506);
+                        NGCCHandler h = new complexType(this, super._source, $runtime, 465);
                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                     }
                     else {
@@ -235,49 +247,37 @@
                 }
             }
             break;
-        case 48:
+        case 40:
             {
-                if(((($ai = $runtime.getAttributeIndex("","default"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","block"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","fixed"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","abstract"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","form"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","name"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || (($ai = $runtime.getAttributeIndex("","final"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))))))))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 555, fa);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
-        case 13:
-            {
-                if(($ai = $runtime.getAttributeIndex("","substitutionGroup"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 11;
+                    $_ngcc_current_state = 36;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 40:
+        case 23:
             {
-                if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 36;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 24:
+        case 44:
             {
-                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 23;
+                    $_ngcc_current_state = 40;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
@@ -296,11 +296,29 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 24:
+            {
+                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                }
+                else {
+                    $_ngcc_current_state = 23;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                }
+            }
+            break;
         case 0:
             {
                 revertToParentFromLeaveElement(makeResult(), super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 11:
+            {
+                $_ngcc_current_state = 3;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 17:
             {
                 if(($ai = $runtime.getAttributeIndex("","nillable"))>=0) {
@@ -325,62 +343,56 @@
                 }
             }
             break;
-        case 32:
+        case 1:
             {
-                if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                $_ngcc_current_state = 0;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 48:
+            {
+                if((($ai = $runtime.getAttributeIndex("","block"))>=0 || (($ai = $runtime.getAttributeIndex("","default"))>=0 || (($ai = $runtime.getAttributeIndex("","fixed"))>=0 || (($ai = $runtime.getAttributeIndex("","abstract"))>=0 || (($ai = $runtime.getAttributeIndex("","final"))>=0 || (($ai = $runtime.getAttributeIndex("","form"))>=0 || ($ai = $runtime.getAttributeIndex("","name"))>=0))))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 514, fa);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 28;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedLeaveElement($__qname);
                 }
             }
             break;
-        case 44:
+        case 28:
             {
-                if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 40;
+                    $_ngcc_current_state = 24;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 28:
+        case 32:
             {
-                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 24;
+                    $_ngcc_current_state = 28;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 11:
+        case 13:
             {
-                $_ngcc_current_state = 3;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 1:
-            {
-                $_ngcc_current_state = 0;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 23:
-            {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","substitutionGroup"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    unexpectedLeaveElement($__qname);
+                    $_ngcc_current_state = 11;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
@@ -396,49 +408,37 @@
                 }
             }
             break;
-        case 48:
+        case 40:
             {
-                if((($ai = $runtime.getAttributeIndex("","default"))>=0 || (($ai = $runtime.getAttributeIndex("","block"))>=0 || (($ai = $runtime.getAttributeIndex("","fixed"))>=0 || (($ai = $runtime.getAttributeIndex("","abstract"))>=0 || (($ai = $runtime.getAttributeIndex("","form"))>=0 || (($ai = $runtime.getAttributeIndex("","name"))>=0 || ($ai = $runtime.getAttributeIndex("","final"))>=0))))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 555, fa);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
-            }
-            break;
-        case 13:
-            {
-                if(($ai = $runtime.getAttributeIndex("","substitutionGroup"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 11;
+                    $_ngcc_current_state = 36;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 40:
+        case 23:
             {
-                if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 36;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedLeaveElement($__qname);
                 }
             }
             break;
-        case 24:
+        case 44:
             {
-                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 23;
+                    $_ngcc_current_state = 40;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
@@ -457,11 +457,28 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 24:
+            {
+                if(($__uri.equals("") && $__local.equals("form"))) {
+                    $_ngcc_current_state = 26;
+                }
+                else {
+                    $_ngcc_current_state = 23;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                }
+            }
+            break;
         case 0:
             {
                 revertToParentFromEnterAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 11:
+            {
+                $_ngcc_current_state = 3;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 17:
             {
                 if(($__uri.equals("") && $__local.equals("nillable"))) {
@@ -484,25 +501,20 @@
                 }
             }
             break;
-        case 32:
+        case 1:
             {
-                if(($__uri.equals("") && $__local.equals("default"))) {
-                    $_ngcc_current_state = 34;
-                }
-                else {
-                    $_ngcc_current_state = 28;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-                }
+                $_ngcc_current_state = 0;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 44:
+        case 48:
             {
-                if(($__uri.equals("") && $__local.equals("abstract"))) {
-                    $_ngcc_current_state = 46;
+                if((($__uri.equals("") && $__local.equals("block")) || (($__uri.equals("") && $__local.equals("default")) || (($__uri.equals("") && $__local.equals("fixed")) || (($__uri.equals("") && $__local.equals("abstract")) || (($__uri.equals("") && $__local.equals("final")) || (($__uri.equals("") && $__local.equals("form")) || ($__uri.equals("") && $__local.equals("name"))))))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 514, fa);
+                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 40;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedEnterAttribute($__qname);
                 }
             }
             break;
@@ -517,25 +529,25 @@
                 }
             }
             break;
-        case 11:
+        case 32:
             {
-                $_ngcc_current_state = 3;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("default"))) {
+                    $_ngcc_current_state = 34;
+                }
+                else {
+                    $_ngcc_current_state = 28;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                }
             }
             break;
-        case 1:
+        case 13:
             {
-                $_ngcc_current_state = 0;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 23:
-            {
-                if(($__uri.equals("") && $__local.equals("name"))) {
-                    $_ngcc_current_state = 22;
+                if(($__uri.equals("") && $__local.equals("substitutionGroup"))) {
+                    $_ngcc_current_state = 15;
                 }
                 else {
-                    unexpectedEnterAttribute($__qname);
+                    $_ngcc_current_state = 11;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
@@ -550,46 +562,34 @@
                 }
             }
             break;
-        case 48:
+        case 40:
             {
-                if((($__uri.equals("") && $__local.equals("default")) || (($__uri.equals("") && $__local.equals("block")) || (($__uri.equals("") && $__local.equals("fixed")) || (($__uri.equals("") && $__local.equals("abstract")) || (($__uri.equals("") && $__local.equals("form")) || (($__uri.equals("") && $__local.equals("name")) || ($__uri.equals("") && $__local.equals("final"))))))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 555, fa);
-                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("block"))) {
+                    $_ngcc_current_state = 42;
                 }
                 else {
-                    unexpectedEnterAttribute($__qname);
-                }
-            }
-            break;
-        case 13:
-            {
-                if(($__uri.equals("") && $__local.equals("substitutionGroup"))) {
-                    $_ngcc_current_state = 15;
-                }
-                else {
-                    $_ngcc_current_state = 11;
+                    $_ngcc_current_state = 36;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 40:
+        case 23:
             {
-                if(($__uri.equals("") && $__local.equals("block"))) {
-                    $_ngcc_current_state = 42;
+                if(($__uri.equals("") && $__local.equals("name"))) {
+                    $_ngcc_current_state = 22;
                 }
                 else {
-                    $_ngcc_current_state = 36;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                    unexpectedEnterAttribute($__qname);
                 }
             }
             break;
-        case 24:
+        case 44:
             {
-                if(($__uri.equals("") && $__local.equals("form"))) {
-                    $_ngcc_current_state = 26;
+                if(($__uri.equals("") && $__local.equals("abstract"))) {
+                    $_ngcc_current_state = 46;
                 }
                 else {
-                    $_ngcc_current_state = 23;
+                    $_ngcc_current_state = 40;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
@@ -608,27 +608,37 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 17:
+        case 24:
             {
-                $_ngcc_current_state = 13;
+                $_ngcc_current_state = 23;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 0:
+        case 45:
             {
-                revertToParentFromLeaveAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("abstract"))) {
+                    $_ngcc_current_state = 40;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
-        case 36:
+        case 29:
             {
-                $_ngcc_current_state = 32;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("fixed"))) {
+                    $_ngcc_current_state = 24;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
-        case 25:
+        case 5:
             {
-                if(($__uri.equals("") && $__local.equals("form"))) {
-                    $_ngcc_current_state = 23;
+                if(($__uri.equals("") && $__local.equals("type"))) {
+                    $_ngcc_current_state = 1;
+                    action1();
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -635,22 +645,34 @@
                 }
             }
             break;
-        case 44:
+        case 21:
             {
-                $_ngcc_current_state = 40;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("name"))) {
+                    $_ngcc_current_state = 17;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
-        case 32:
+        case 18:
             {
-                $_ngcc_current_state = 28;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("nillable"))) {
+                    $_ngcc_current_state = 13;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
-        case 28:
+        case 25:
             {
-                $_ngcc_current_state = 24;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("form"))) {
+                    $_ngcc_current_state = 23;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
         case 11:
@@ -659,20 +681,21 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 1:
+        case 0:
             {
-                $_ngcc_current_state = 0;
+                revertToParentFromLeaveAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 17:
+            {
+                $_ngcc_current_state = 13;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 18:
+        case 1:
             {
-                if(($__uri.equals("") && $__local.equals("nillable"))) {
-                    $_ngcc_current_state = 13;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                $_ngcc_current_state = 0;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
         case 37:
@@ -685,21 +708,16 @@
                 }
             }
             break;
-        case 21:
+        case 36:
             {
-                if(($__uri.equals("") && $__local.equals("name"))) {
-                    $_ngcc_current_state = 17;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                $_ngcc_current_state = 32;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 5:
+        case 14:
             {
-                if(($__uri.equals("") && $__local.equals("type"))) {
-                    $_ngcc_current_state = 1;
-                    action1();
+                if(($__uri.equals("") && $__local.equals("substitutionGroup"))) {
+                    $_ngcc_current_state = 11;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -706,10 +724,16 @@
                 }
             }
             break;
-        case 29:
+        case 28:
             {
-                if(($__uri.equals("") && $__local.equals("fixed"))) {
-                    $_ngcc_current_state = 24;
+                $_ngcc_current_state = 24;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 41:
+            {
+                if(($__uri.equals("") && $__local.equals("block"))) {
+                    $_ngcc_current_state = 36;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -716,12 +740,6 @@
                 }
             }
             break;
-        case 3:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 33:
             {
                 if(($__uri.equals("") && $__local.equals("default"))) {
@@ -732,14 +750,10 @@
                 }
             }
             break;
-        case 14:
+        case 32:
             {
-                if(($__uri.equals("") && $__local.equals("substitutionGroup"))) {
-                    $_ngcc_current_state = 11;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                $_ngcc_current_state = 28;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
         case 13:
@@ -748,19 +762,15 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 45:
+        case 3:
             {
-                if(($__uri.equals("") && $__local.equals("abstract"))) {
-                    $_ngcc_current_state = 40;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 24:
+        case 44:
             {
-                $_ngcc_current_state = 23;
+                $_ngcc_current_state = 40;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -770,16 +780,6 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 41:
-            {
-                if(($__uri.equals("") && $__local.equals("block"))) {
-                    $_ngcc_current_state = 36;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -791,59 +791,24 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 17:
+        case 24:
             {
-                if(($ai = $runtime.getAttributeIndex("","nillable"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    $_ngcc_current_state = 13;
+                    $_ngcc_current_state = 23;
                     $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
-        case 0:
+        case 19:
             {
-                revertToParentFromText(makeResult(), super._cookie, $value);
+                nillable = $value;
+                $_ngcc_current_state = 18;
             }
             break;
-        case 36:
-            {
-                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 32;
-                    $runtime.sendText(super._cookie, $value);
-                }
-            }
-            break;
-        case 44:
-            {
-                if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 40;
-                    $runtime.sendText(super._cookie, $value);
-                }
-            }
-            break;
-        case 32:
-            {
-                if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 28;
-                    $runtime.sendText(super._cookie, $value);
-                }
-            }
-            break;
         case 46:
             {
                 abstractValue = $value;
@@ -850,34 +815,21 @@
                 $_ngcc_current_state = 45;
             }
             break;
-        case 30:
-            {
-                fixedValue = $value;
-                $_ngcc_current_state = 29;
-            }
-            break;
         case 6:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 496);
+                NGCCHandler h = new qname(this, super._source, $runtime, 455);
                 spawnChildFromText(h, $value);
             }
             break;
-        case 28:
+        case 34:
             {
-                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 24;
-                    $runtime.sendText(super._cookie, $value);
-                }
+                defaultValue = $value;
+                $_ngcc_current_state = 33;
             }
             break;
-        case 22:
+        case 0:
             {
-                name = $value;
-                $_ngcc_current_state = 21;
+                revertToParentFromText(makeResult(), super._cookie, $value);
             }
             break;
         case 11:
@@ -889,101 +841,93 @@
         case 26:
             {
                 if($value.equals("unqualified")) {
-                    NGCCHandler h = new qualification(this, super._source, $runtime, 526);
+                    NGCCHandler h = new qualification(this, super._source, $runtime, 485);
                     spawnChildFromText(h, $value);
                 }
                 else {
                     if($value.equals("qualified")) {
-                        NGCCHandler h = new qualification(this, super._source, $runtime, 526);
+                        NGCCHandler h = new qualification(this, super._source, $runtime, 485);
                         spawnChildFromText(h, $value);
                     }
                 }
             }
             break;
-        case 19:
+        case 17:
             {
-                nillable = $value;
-                $_ngcc_current_state = 18;
-            }
-            break;
-        case 1:
-            {
-                $_ngcc_current_state = 0;
-                $runtime.sendText(super._cookie, $value);
-            }
-            break;
-        case 23:
-            {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","nillable"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
+                else {
+                    $_ngcc_current_state = 13;
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
+        case 22:
+            {
+                name = $value;
+                $_ngcc_current_state = 21;
+            }
+            break;
         case 38:
             {
-                NGCCHandler h = new erSet(this, super._source, $runtime, 541);
+                NGCCHandler h = new erSet(this, super._source, $runtime, 500);
                 spawnChildFromText(h, $value);
             }
             break;
-        case 15:
+        case 1:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 513);
-                spawnChildFromText(h, $value);
+                $_ngcc_current_state = 0;
+                $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 3:
+        case 36:
             {
-                if(($ai = $runtime.getAttributeIndex("","type"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    $_ngcc_current_state = 1;
+                    $_ngcc_current_state = 32;
                     $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
-        case 42:
-            {
-                NGCCHandler h = new ersSet(this, super._source, $runtime, 546);
-                spawnChildFromText(h, $value);
-            }
-            break;
         case 48:
             {
-                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 555, fa);
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 514, fa);
                     spawnChildFromText(h, $value);
                 }
                 else {
-                    if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                        NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 555, fa);
+                    if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                        NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 514, fa);
                         spawnChildFromText(h, $value);
                     }
                     else {
-                        if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
-                            NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 555, fa);
+                        if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
+                            NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 514, fa);
                             spawnChildFromText(h, $value);
                         }
                         else {
                             if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
-                                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 555, fa);
+                                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 514, fa);
                                 spawnChildFromText(h, $value);
                             }
                             else {
                                 if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
-                                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 555, fa);
+                                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 514, fa);
                                     spawnChildFromText(h, $value);
                                 }
                                 else {
-                                    if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
-                                        NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 555, fa);
+                                    if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
+                                        NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 514, fa);
                                         spawnChildFromText(h, $value);
                                     }
                                     else {
-                                        if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
-                                            NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 555, fa);
+                                        if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
+                                            NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 514, fa);
                                             spawnChildFromText(h, $value);
                                         }
                                     }
@@ -994,12 +938,30 @@
                 }
             }
             break;
-        case 34:
+        case 28:
             {
-                defaultValue = $value;
-                $_ngcc_current_state = 33;
+                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 24;
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
+        case 32:
+            {
+                if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 28;
+                    $runtime.sendText(super._cookie, $value);
+                }
+            }
+            break;
         case 13:
             {
                 if(($ai = $runtime.getAttributeIndex("","substitutionGroup"))>=0) {
@@ -1012,18 +974,44 @@
                 }
             }
             break;
-        case 24:
+        case 15:
             {
-                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                NGCCHandler h = new qname(this, super._source, $runtime, 472);
+                spawnChildFromText(h, $value);
+            }
+            break;
+        case 3:
+            {
+                if(($ai = $runtime.getAttributeIndex("","type"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    $_ngcc_current_state = 23;
+                    $_ngcc_current_state = 1;
                     $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
+        case 44:
+            {
+                if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 40;
+                    $runtime.sendText(super._cookie, $value);
+                }
+            }
+            break;
+        case 23:
+            {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+            }
+            break;
         case 40:
             {
                 if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
@@ -1036,44 +1024,42 @@
                 }
             }
             break;
-        }
-    }
-
-    public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
-        switch($__cookie__) {
-        case 510:
+        case 42:
             {
-                annotation = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 3;
+                NGCCHandler h = new ersSet(this, super._source, $runtime, 505);
+                spawnChildFromText(h, $value);
             }
             break;
-        case 546:
+        case 30:
             {
-                blockValue = ((Integer)$__result__);
-                $_ngcc_current_state = 41;
+                fixedValue = $value;
+                $_ngcc_current_state = 29;
             }
             break;
-        case 496:
+        }
+    }
+
+    public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
+        switch($__cookie__) {
+        case 455:
             {
                 typeName = ((UName)$__result__);
                 $_ngcc_current_state = 5;
             }
             break;
-        case 492:
+        case 464:
             {
-                idc = ((IdentityConstraintImpl)$__result__);
-                action0();
-                $_ngcc_current_state = 0;
+                type = ((SimpleTypeImpl)$__result__);
+                $_ngcc_current_state = 1;
             }
             break;
-        case 526:
+        case 465:
             {
-                form = ((Boolean)$__result__).booleanValue();
-                action3();
-                $_ngcc_current_state = 25;
+                type = ((ComplexTypeImpl)$__result__);
+                $_ngcc_current_state = 1;
             }
             break;
-        case 493:
+        case 451:
             {
                 idc = ((IdentityConstraintImpl)$__result__);
                 action0();
@@ -1080,42 +1066,56 @@
                 $_ngcc_current_state = 0;
             }
             break;
-        case 541:
+        case 469:
             {
+                annotation = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 3;
+            }
+            break;
+        case 500:
+            {
                 finalValue = ((Integer)$__result__);
                 $_ngcc_current_state = 37;
             }
             break;
-        case 513:
+        case 505:
             {
-                substRef = ((UName)$__result__);
-                action2();
-                $_ngcc_current_state = 14;
+                blockValue = ((Integer)$__result__);
+                $_ngcc_current_state = 41;
             }
             break;
-        case 505:
+        case 485:
             {
-                type = ((SimpleTypeImpl)$__result__);
-                $_ngcc_current_state = 1;
+                form = ((Boolean)$__result__).booleanValue();
+                action3();
+                $_ngcc_current_state = 25;
             }
             break;
-        case 506:
+        case 452:
             {
-                type = ((ComplexTypeImpl)$__result__);
-                $_ngcc_current_state = 1;
+                idc = ((IdentityConstraintImpl)$__result__);
+                action0();
+                $_ngcc_current_state = 0;
             }
             break;
-        case 555:
+        case 514:
             {
                 fa = ((ForeignAttributesImpl)$__result__);
                 $_ngcc_current_state = 44;
             }
             break;
+        case 472:
+            {
+                substRef = ((UName)$__result__);
+                action2();
+                $_ngcc_current_state = 14;
+            }
+            break;
         }
     }
 
     public boolean accepted() {
-        return((($_ngcc_current_state == 13) || (($_ngcc_current_state == 17) || (($_ngcc_current_state == 3) || (($_ngcc_current_state == 1) || (($_ngcc_current_state == 0) || ($_ngcc_current_state == 11)))))));
+        return((($_ngcc_current_state == 1) || (($_ngcc_current_state == 17) || (($_ngcc_current_state == 11) || (($_ngcc_current_state == 0) || (($_ngcc_current_state == 3) || ($_ngcc_current_state == 13)))))));
     }
 
 
@@ -1161,6 +1161,7 @@
             $runtime.createXmlString(fixedValue),
             $runtime.parseBoolean(nillable),
             $runtime.parseBoolean(abstractValue),
+            (java.lang.Boolean)(formSpecified ? form : null),
             type,
             substHeadRef,
             blockValue.intValue(),
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/erSet.java	Tue Aug  4 10:09:27 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/erSet.java	Tue Aug  4 10:09:27 2009
@@ -141,6 +141,11 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
+        case 0:
+            {
+                revertToParentFromText(makeResult(), super._cookie, $value);
+            }
+            break;
         case 1:
             {
                 v = $value;
@@ -147,11 +152,6 @@
                 $_ngcc_current_state = 0;
             }
             break;
-        case 0:
-            {
-                revertToParentFromText(makeResult(), super._cookie, $value);
-            }
-            break;
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/facet.java	Tue Aug  4 10:09:29 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/facet.java	Tue Aug  4 10:09:29 2009
@@ -95,17 +95,6 @@
                 }
             }
             break;
-        case 4:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 577, fa);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
         case 11:
             {
                 if(($ai = $runtime.getAttributeIndex("","value"))>=0) {
@@ -117,15 +106,14 @@
                 }
             }
             break;
-        case 2:
+        case 4:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 575, null,AnnotationContext.SIMPLETYPE_DECL);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 562, fa);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 1;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
@@ -146,6 +134,18 @@
                 revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
+        case 2:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 560, null,AnnotationContext.SIMPLETYPE_DECL);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 1;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+            }
+            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -160,6 +160,18 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 1:
+            {
+                if((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern")))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 0;
+                    action0();
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
+            }
+            break;
         case 5:
             {
                 if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
@@ -172,11 +184,11 @@
                 }
             }
             break;
-        case 4:
+        case 11:
             {
-                if((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern")))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 577, fa);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                if(($ai = $runtime.getAttributeIndex("","value"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -183,11 +195,11 @@
                 }
             }
             break;
-        case 11:
+        case 4:
             {
-                if(($ai = $runtime.getAttributeIndex("","value"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern")))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 562, fa);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -194,27 +206,15 @@
                 }
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 0:
             {
                 revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 1:
+        case 2:
             {
-                if((((((((((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minExclusive")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxExclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxInclusive"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("totalDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("fractionDigits"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("length"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("maxLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("minLength"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("enumeration"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("whiteSpace"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("pattern")))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 0;
-                    action0();
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
         default:
@@ -252,6 +252,11 @@
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 2:
             {
                 $_ngcc_current_state = 1;
@@ -258,11 +263,6 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 0:
-            {
-                revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -277,23 +277,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 5:
-            {
-                $_ngcc_current_state = 4;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 0:
-            {
-                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 9:
             {
                 if(($__uri.equals("") && $__local.equals("value"))) {
@@ -304,6 +287,12 @@
                 }
             }
             break;
+        case 5:
+            {
+                $_ngcc_current_state = 4;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 6:
             {
                 if(($__uri.equals("") && $__local.equals("fixed"))) {
@@ -314,6 +303,17 @@
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 2:
+            {
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -357,6 +357,11 @@
                 $_ngcc_current_state = 6;
             }
             break;
+        case 0:
+            {
+                revertToParentFromText(result, super._cookie, $value);
+            }
+            break;
         case 2:
             {
                 $_ngcc_current_state = 1;
@@ -363,26 +368,21 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 0:
-            {
-                revertToParentFromText(result, super._cookie, $value);
-            }
-            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 577:
+        case 560:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 2;
+                annotation = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 1;
             }
             break;
-        case 575:
+        case 562:
             {
-                annotation = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 1;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 2;
             }
             break;
         }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/group.java	Tue Aug  4 10:09:32 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/group.java	Tue Aug  4 10:09:32 2009
@@ -93,39 +93,34 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 11:
             {
-                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 10:
-            {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","ID"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 10;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 6:
+        case 5:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 233, null,AnnotationContext.MODELGROUP_DECL);
+                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 315, null);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 5;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 3:
+        case 10:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))))))) {
-                    NGCCHandler h = new modelGroupBody(this, super._source, $runtime, 229, mloc,compositorName);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -132,12 +127,11 @@
                 }
             }
             break;
-        case 15:
+        case 4:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) {
+                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
                     $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    action2();
-                    $_ngcc_current_state = 11;
+                    $_ngcc_current_state = 3;
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -144,10 +138,10 @@
                 }
             }
             break;
-        case 5:
+        case 3:
             {
-                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 231, null);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))))))) {
+                    NGCCHandler h = new modelGroupBody(this, super._source, $runtime, 313, mloc,compositorName);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -155,11 +149,17 @@
                 }
             }
             break;
-        case 4:
+        case 0:
             {
-                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
+                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
+        case 15:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) {
                     $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    $_ngcc_current_state = 3;
+                    action2();
+                    $_ngcc_current_state = 11;
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -166,14 +166,14 @@
                 }
             }
             break;
-        case 11:
+        case 6:
             {
-                if(($ai = $runtime.getAttributeIndex("","ID"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 317, null,AnnotationContext.MODELGROUP_DECL);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 10;
+                    $_ngcc_current_state = 5;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
@@ -192,33 +192,34 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 2:
             {
-                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
+                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 1;
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
             }
             break;
-        case 10:
+        case 11:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","ID"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    unexpectedLeaveElement($__qname);
+                    $_ngcc_current_state = 10;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 6:
+        case 10:
             {
-                $_ngcc_current_state = 5;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 2:
-            {
-                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 1;
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -228,7 +229,7 @@
         case 3:
             {
                 if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
-                    NGCCHandler h = new modelGroupBody(this, super._source, $runtime, 229, mloc,compositorName);
+                    NGCCHandler h = new modelGroupBody(this, super._source, $runtime, 313, mloc,compositorName);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -248,18 +249,17 @@
                 }
             }
             break;
-        case 11:
+        case 0:
             {
-                if(($ai = $runtime.getAttributeIndex("","ID"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
-                else {
-                    $_ngcc_current_state = 10;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
+                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 6:
+            {
+                $_ngcc_current_state = 5;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedLeaveElement($__qname);
@@ -274,9 +274,15 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 11:
             {
-                revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("ID"))) {
+                    $_ngcc_current_state = 13;
+                }
+                else {
+                    $_ngcc_current_state = 10;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                }
             }
             break;
         case 10:
@@ -289,6 +295,11 @@
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 6:
             {
                 $_ngcc_current_state = 5;
@@ -295,17 +306,6 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 11:
-            {
-                if(($__uri.equals("") && $__local.equals("ID"))) {
-                    $_ngcc_current_state = 13;
-                }
-                else {
-                    $_ngcc_current_state = 10;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -320,11 +320,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
-            {
-                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 12:
             {
                 if(($__uri.equals("") && $__local.equals("ID"))) {
@@ -335,6 +330,12 @@
                 }
             }
             break;
+        case 11:
+            {
+                $_ngcc_current_state = 10;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 8:
             {
                 if(($__uri.equals("") && $__local.equals("name"))) {
@@ -345,15 +346,14 @@
                 }
             }
             break;
-        case 6:
+        case 0:
             {
-                $_ngcc_current_state = 5;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 11:
+        case 6:
             {
-                $_ngcc_current_state = 10;
+                $_ngcc_current_state = 5;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -368,16 +368,18 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 0:
+        case 11:
             {
-                revertToParentFromText(result, super._cookie, $value);
+                if(($ai = $runtime.getAttributeIndex("","ID"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 10;
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
-        case 13:
-            {
-                $_ngcc_current_state = 12;
-            }
-            break;
         case 10:
             {
                 if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
@@ -386,22 +388,14 @@
                 }
             }
             break;
-        case 6:
+        case 13:
             {
-                $_ngcc_current_state = 5;
-                $runtime.sendText(super._cookie, $value);
+                $_ngcc_current_state = 12;
             }
             break;
-        case 11:
+        case 0:
             {
-                if(($ai = $runtime.getAttributeIndex("","ID"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 10;
-                    $runtime.sendText(super._cookie, $value);
-                }
+                revertToParentFromText(result, super._cookie, $value);
             }
             break;
         case 9:
@@ -410,18 +404,30 @@
                 $_ngcc_current_state = 8;
             }
             break;
+        case 6:
+            {
+                $_ngcc_current_state = 5;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 233:
+        case 313:
             {
+                term = ((ModelGroupImpl)$__result__);
+                $_ngcc_current_state = 2;
+            }
+            break;
+        case 317:
+            {
                 annotation = ((AnnotationImpl)$__result__);
                 $_ngcc_current_state = 5;
             }
             break;
-        case 231:
+        case 315:
             {
                 fa = ((ForeignAttributesImpl)$__result__);
                 action1();
@@ -428,12 +434,6 @@
                 $_ngcc_current_state = 4;
             }
             break;
-        case 229:
-            {
-                term = ((ModelGroupImpl)$__result__);
-                $_ngcc_current_state = 2;
-            }
-            break;
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/identityConstraint.java	Tue Aug  4 10:09:35 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/identityConstraint.java	Tue Aug  4 10:09:34 2009
@@ -94,14 +94,15 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 7:
+        case 10:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("selector"))) {
-                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    $_ngcc_current_state = 6;
+                if(($ai = $runtime.getAttributeIndex("","refer"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 8;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
@@ -108,7 +109,7 @@
         case 6:
             {
                 if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
-                    NGCCHandler h = new xpath(this, super._source, $runtime, 251);
+                    NGCCHandler h = new xpath(this, super._source, $runtime, 653);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -116,27 +117,21 @@
                 }
             }
             break;
-        case 10:
+        case 16:
             {
-                if(($ai = $runtime.getAttributeIndex("","refer"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 8;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 0:
+        case 17:
             {
-                revertToParentFromEnterElement(makeResult(), super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 3:
-            {
-                if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
-                    NGCCHandler h = new xpath(this, super._source, $runtime, 247);
+                if((($ai = $runtime.getAttributeIndex("","name"))>=0 && (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("selector"))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 666, null);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -144,11 +139,17 @@
                 }
             }
             break;
-        case 16:
+        case 0:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                revertToParentFromEnterElement(makeResult(), super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
+        case 18:
+            {
+                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) {
+                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                    action2();
+                    $_ngcc_current_state = 17;
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -155,15 +156,14 @@
                 }
             }
             break;
-        case 8:
+        case 1:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 254, null,AnnotationContext.IDENTITY_CONSTRAINT);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("field"))) {
+                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                    $_ngcc_current_state = 3;
                 }
                 else {
-                    $_ngcc_current_state = 7;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
@@ -178,22 +178,22 @@
                 }
             }
             break;
-        case 18:
+        case 8:
             {
-                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) {
-                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    action2();
-                    $_ngcc_current_state = 17;
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 656, null,AnnotationContext.IDENTITY_CONSTRAINT);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 7;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 17:
+        case 3:
             {
-                if((($ai = $runtime.getAttributeIndex("","name"))>=0 && (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("selector")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 264, null);
+                if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
+                    NGCCHandler h = new xpath(this, super._source, $runtime, 649);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -201,11 +201,11 @@
                 }
             }
             break;
-        case 1:
+        case 7:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("field"))) {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("selector"))) {
                     $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    $_ngcc_current_state = 3;
+                    $_ngcc_current_state = 6;
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -226,11 +226,11 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 6:
+        case 2:
             {
-                if((($ai = $runtime.getAttributeIndex("","xpath"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("selector")))) {
-                    NGCCHandler h = new xpath(this, super._source, $runtime, 251);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("field"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 1;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -237,11 +237,11 @@
                 }
             }
             break;
-        case 2:
+        case 5:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("field"))) {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("selector"))) {
                     $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 1;
+                    $_ngcc_current_state = 4;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -260,15 +260,10 @@
                 }
             }
             break;
-        case 0:
+        case 6:
             {
-                revertToParentFromLeaveElement(makeResult(), super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 3:
-            {
-                if((($ai = $runtime.getAttributeIndex("","xpath"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("field")))) {
-                    NGCCHandler h = new xpath(this, super._source, $runtime, 247);
+                if((($ai = $runtime.getAttributeIndex("","xpath"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("selector")))) {
+                    NGCCHandler h = new xpath(this, super._source, $runtime, 653);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -287,16 +282,10 @@
                 }
             }
             break;
-        case 8:
-            {
-                $_ngcc_current_state = 7;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 17:
             {
                 if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 264, null);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 666, null);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -304,11 +293,16 @@
                 }
             }
             break;
-        case 5:
+        case 0:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("selector"))) {
+                revertToParentFromLeaveElement(makeResult(), super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 1:
+            {
+                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) {
                     $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 4;
+                    $_ngcc_current_state = 0;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -315,11 +309,17 @@
                 }
             }
             break;
-        case 1:
+        case 8:
             {
-                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 0;
+                $_ngcc_current_state = 7;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 3:
+            {
+                if((($ai = $runtime.getAttributeIndex("","xpath"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("field")))) {
+                    NGCCHandler h = new xpath(this, super._source, $runtime, 649);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -340,17 +340,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 6:
-            {
-                if(($__uri.equals("") && $__local.equals("xpath"))) {
-                    NGCCHandler h = new xpath(this, super._source, $runtime, 251);
-                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedEnterAttribute($__qname);
-                }
-            }
-            break;
         case 10:
             {
                 if(($__uri.equals("") && $__local.equals("refer"))) {
@@ -362,15 +351,10 @@
                 }
             }
             break;
-        case 0:
+        case 6:
             {
-                revertToParentFromEnterAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 3:
-            {
                 if(($__uri.equals("") && $__local.equals("xpath"))) {
-                    NGCCHandler h = new xpath(this, super._source, $runtime, 247);
+                    NGCCHandler h = new xpath(this, super._source, $runtime, 653);
                     spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -388,6 +372,22 @@
                 }
             }
             break;
+        case 17:
+            {
+                if(($__uri.equals("") && $__local.equals("name"))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 666, null);
+                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedEnterAttribute($__qname);
+                }
+            }
+            break;
+        case 0:
+            {
+                revertToParentFromEnterAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 8:
             {
                 $_ngcc_current_state = 7;
@@ -394,10 +394,10 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 17:
+        case 3:
             {
-                if(($__uri.equals("") && $__local.equals("name"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 264, null);
+                if(($__uri.equals("") && $__local.equals("xpath"))) {
+                    NGCCHandler h = new xpath(this, super._source, $runtime, 649);
                     spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -430,10 +430,14 @@
                 revertToParentFromLeaveAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 8:
+        case 14:
             {
-                $_ngcc_current_state = 7;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("name"))) {
+                    $_ngcc_current_state = 10;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
         case 11:
@@ -446,14 +450,10 @@
                 }
             }
             break;
-        case 14:
+        case 8:
             {
-                if(($__uri.equals("") && $__local.equals("name"))) {
-                    $_ngcc_current_state = 10;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                $_ngcc_current_state = 7;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
         default:
@@ -467,12 +467,10 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 6:
+        case 12:
             {
-                if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
-                    NGCCHandler h = new xpath(this, super._source, $runtime, 251);
-                    spawnChildFromText(h, $value);
-                }
+                NGCCHandler h = new qname(this, super._source, $runtime, 659);
+                spawnChildFromText(h, $value);
             }
             break;
         case 10:
@@ -487,11 +485,6 @@
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromText(makeResult(), super._cookie, $value);
-            }
-            break;
         case 15:
             {
                 name = $value;
@@ -498,20 +491,14 @@
                 $_ngcc_current_state = 14;
             }
             break;
-        case 3:
+        case 6:
             {
                 if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
-                    NGCCHandler h = new xpath(this, super._source, $runtime, 247);
+                    NGCCHandler h = new xpath(this, super._source, $runtime, 653);
                     spawnChildFromText(h, $value);
                 }
             }
             break;
-        case 12:
-            {
-                NGCCHandler h = new qname(this, super._source, $runtime, 257);
-                spawnChildFromText(h, $value);
-            }
-            break;
         case 16:
             {
                 if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
@@ -520,6 +507,19 @@
                 }
             }
             break;
+        case 17:
+            {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 666, null);
+                    spawnChildFromText(h, $value);
+                }
+            }
+            break;
+        case 0:
+            {
+                revertToParentFromText(makeResult(), super._cookie, $value);
+            }
+            break;
         case 8:
             {
                 $_ngcc_current_state = 7;
@@ -526,10 +526,10 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 17:
+        case 3:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 264, null);
+                if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
+                    NGCCHandler h = new xpath(this, super._source, $runtime, 649);
                     spawnChildFromText(h, $value);
                 }
             }
@@ -539,26 +539,32 @@
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 251:
+        case 666:
             {
-                selector = ((XPathImpl)$__result__);
-                $_ngcc_current_state = 5;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 16;
             }
             break;
-        case 257:
+        case 656:
             {
+                ann = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 7;
+            }
+            break;
+        case 659:
+            {
                 ref = ((UName)$__result__);
                 action1();
                 $_ngcc_current_state = 11;
             }
             break;
-        case 264:
+        case 653:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 16;
+                selector = ((XPathImpl)$__result__);
+                $_ngcc_current_state = 5;
             }
             break;
-        case 247:
+        case 649:
             {
                 field = ((XPathImpl)$__result__);
                 action0();
@@ -565,12 +571,6 @@
                 $_ngcc_current_state = 2;
             }
             break;
-        case 254:
-            {
-                ann = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 7;
-            }
-            break;
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/importDecl.java	Tue Aug  4 10:09:37 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/importDecl.java	Tue Aug  4 10:09:37 2009
@@ -76,14 +76,25 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 8:
+        case 12:
             {
-                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("import"))) {
+                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                    $_ngcc_current_state = 8;
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
+            }
+            break;
+        case 4:
+            {
+                if(($ai = $runtime.getAttributeIndex("","schemaLocation"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 4;
+                    $_ngcc_current_state = 2;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
@@ -91,7 +102,7 @@
         case 2:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 589, null,AnnotationContext.SCHEMA);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 3, null,AnnotationContext.SCHEMA);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -100,14 +111,14 @@
                 }
             }
             break;
-        case 4:
+        case 8:
             {
-                if(($ai = $runtime.getAttributeIndex("","schemaLocation"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 2;
+                    $_ngcc_current_state = 4;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
@@ -117,17 +128,6 @@
                 revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
-        case 12:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("import"))) {
-                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    $_ngcc_current_state = 8;
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -142,30 +142,18 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 8:
+        case 4:
             {
-                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","schemaLocation"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 4;
+                    $_ngcc_current_state = 2;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 1:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("import"))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 0;
-                    action0();
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
-            }
-            break;
         case 2:
             {
                 $_ngcc_current_state = 1;
@@ -172,18 +160,30 @@
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 4:
+        case 8:
             {
-                if(($ai = $runtime.getAttributeIndex("","schemaLocation"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 2;
+                    $_ngcc_current_state = 4;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
+        case 1:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("import"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 0;
+                    action0();
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
+            }
+            break;
         case 0:
             {
                 revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
@@ -203,13 +203,13 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 8:
+        case 4:
             {
-                if(($__uri.equals("") && $__local.equals("namespace"))) {
-                    $_ngcc_current_state = 10;
+                if(($__uri.equals("") && $__local.equals("schemaLocation"))) {
+                    $_ngcc_current_state = 6;
                 }
                 else {
-                    $_ngcc_current_state = 4;
+                    $_ngcc_current_state = 2;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
@@ -220,13 +220,13 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 4:
+        case 8:
             {
-                if(($__uri.equals("") && $__local.equals("schemaLocation"))) {
-                    $_ngcc_current_state = 6;
+                if(($__uri.equals("") && $__local.equals("namespace"))) {
+                    $_ngcc_current_state = 10;
                 }
                 else {
-                    $_ngcc_current_state = 2;
+                    $_ngcc_current_state = 4;
                     $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
                 }
             }
@@ -250,18 +250,16 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 8:
+        case 9:
             {
-                $_ngcc_current_state = 4;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("namespace"))) {
+                    $_ngcc_current_state = 4;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 4:
             {
                 $_ngcc_current_state = 2;
@@ -268,19 +266,16 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 0:
+        case 2:
             {
-                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 9:
+        case 8:
             {
-                if(($__uri.equals("") && $__local.equals("namespace"))) {
-                    $_ngcc_current_state = 4;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                $_ngcc_current_state = 4;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
         case 5:
@@ -293,6 +288,11 @@
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -304,18 +304,30 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 8:
+        case 10:
             {
-                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                ns = $value;
+                $_ngcc_current_state = 9;
+            }
+            break;
+        case 4:
+            {
+                if(($ai = $runtime.getAttributeIndex("","schemaLocation"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    $_ngcc_current_state = 4;
+                    $_ngcc_current_state = 2;
                     $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
+        case 6:
+            {
+                schemaLocation = $value;
+                $_ngcc_current_state = 5;
+            }
+            break;
         case 2:
             {
                 $_ngcc_current_state = 1;
@@ -322,14 +334,14 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 4:
+        case 8:
             {
-                if(($ai = $runtime.getAttributeIndex("","schemaLocation"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    $_ngcc_current_state = 2;
+                    $_ngcc_current_state = 4;
                     $runtime.sendText(super._cookie, $value);
                 }
             }
@@ -339,24 +351,12 @@
                 revertToParentFromText(this, super._cookie, $value);
             }
             break;
-        case 6:
-            {
-                schemaLocation = $value;
-                $_ngcc_current_state = 5;
-            }
-            break;
-        case 10:
-            {
-                ns = $value;
-                $_ngcc_current_state = 9;
-            }
-            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 589:
+        case 3:
             {
                 $_ngcc_current_state = 1;
             }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/includeDecl.java	Tue Aug  4 10:09:39 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/includeDecl.java	Tue Aug  4 10:09:39 2009
@@ -77,18 +77,6 @@
                 revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
-        case 2:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 268, null,AnnotationContext.SCHEMA);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    $_ngcc_current_state = 1;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-            }
-            break;
         case 6:
             {
                 if(($ai = $runtime.getAttributeIndex("","schemaLocation"))>=0) {
@@ -111,6 +99,18 @@
                 }
             }
             break;
+        case 2:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 521, null,AnnotationContext.SCHEMA);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 1;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+            }
+            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -130,12 +130,6 @@
                 revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 1:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("include"))) {
@@ -159,6 +153,12 @@
                 }
             }
             break;
+        case 2:
+            {
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedLeaveElement($__qname);
@@ -178,12 +178,6 @@
                 revertToParentFromEnterAttribute(this, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 6:
             {
                 if(($__uri.equals("") && $__local.equals("schemaLocation"))) {
@@ -194,6 +188,12 @@
                 }
             }
             break;
+        case 2:
+            {
+                $_ngcc_current_state = 1;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -208,6 +208,11 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 0:
+            {
+                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 4:
             {
                 if(($__uri.equals("") && $__local.equals("schemaLocation"))) {
@@ -218,11 +223,6 @@
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 2:
             {
                 $_ngcc_current_state = 1;
@@ -245,10 +245,12 @@
                 revertToParentFromText(this, super._cookie, $value);
             }
             break;
-        case 2:
+        case 6:
             {
-                $_ngcc_current_state = 1;
-                $runtime.sendText(super._cookie, $value);
+                if(($ai = $runtime.getAttributeIndex("","schemaLocation"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
         case 5:
@@ -257,12 +259,10 @@
                 $_ngcc_current_state = 4;
             }
             break;
-        case 6:
+        case 2:
             {
-                if(($ai = $runtime.getAttributeIndex("","schemaLocation"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
+                $_ngcc_current_state = 1;
+                $runtime.sendText(super._cookie, $value);
             }
             break;
         }
@@ -270,7 +270,7 @@
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 268:
+        case 521:
             {
                 $_ngcc_current_state = 1;
             }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/modelGroupBody.java	Tue Aug  4 10:09:42 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/modelGroupBody.java	Tue Aug  4 10:09:41 2009
@@ -95,32 +95,39 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 2:
             {
-                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
+                if((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")))))) {
+                    NGCCHandler h = new particle(this, super._source, $runtime, 179);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 1;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
             }
             break;
-        case 1:
+        case 6:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")))))) {
-                    NGCCHandler h = new particle(this, super._source, $runtime, 31);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 184, null);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    action0();
-                    $_ngcc_current_state = 0;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 184, null);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 2:
+        case 1:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")))))) {
-                    NGCCHandler h = new particle(this, super._source, $runtime, 32);
+                if((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")))))) {
+                    NGCCHandler h = new particle(this, super._source, $runtime, 178);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 1;
+                    action0();
+                    $_ngcc_current_state = 0;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
@@ -128,7 +135,7 @@
         case 4:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 35, null,AnnotationContext.MODELGROUP);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 182, null,AnnotationContext.MODELGROUP);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -137,16 +144,9 @@
                 }
             }
             break;
-        case 6:
+        case 0:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 37, null);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 37, null);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
+                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
         default:
@@ -163,11 +163,18 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 2:
             {
-                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 6:
+            {
+                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 184, null);
+                spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+            }
+            break;
         case 1:
             {
                 action0();
@@ -175,12 +182,6 @@
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 4:
             {
                 $_ngcc_current_state = 2;
@@ -187,10 +188,9 @@
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 6:
+        case 0:
             {
-                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 37, null);
-                spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
         default:
@@ -207,11 +207,18 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 2:
             {
-                revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
+                $_ngcc_current_state = 1;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 6:
+            {
+                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 184, null);
+                spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+            }
+            break;
         case 1:
             {
                 action0();
@@ -219,12 +226,6 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 4:
             {
                 $_ngcc_current_state = 2;
@@ -231,10 +232,9 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 6:
+        case 0:
             {
-                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 37, null);
-                spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+                revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
         default:
@@ -251,11 +251,18 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 2:
             {
-                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 6:
+            {
+                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 184, null);
+                spawnChildFromLeaveAttribute(h, $__uri, $__local, $__qname);
+            }
+            break;
         case 1:
             {
                 action0();
@@ -263,12 +270,6 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 4:
             {
                 $_ngcc_current_state = 2;
@@ -275,10 +276,9 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 6:
+        case 0:
             {
-                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 37, null);
-                spawnChildFromLeaveAttribute(h, $__uri, $__local, $__qname);
+                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
         default:
@@ -292,11 +292,18 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 0:
+        case 2:
             {
-                revertToParentFromText(result, super._cookie, $value);
+                $_ngcc_current_state = 1;
+                $runtime.sendText(super._cookie, $value);
             }
             break;
+        case 6:
+            {
+                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 184, null);
+                spawnChildFromText(h, $value);
+            }
+            break;
         case 1:
             {
                 action0();
@@ -304,12 +311,6 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendText(super._cookie, $value);
-            }
-            break;
         case 4:
             {
                 $_ngcc_current_state = 2;
@@ -316,10 +317,9 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
-        case 6:
+        case 0:
             {
-                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 37, null);
-                spawnChildFromText(h, $value);
+                revertToParentFromText(result, super._cookie, $value);
             }
             break;
         }
@@ -327,7 +327,7 @@
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 31:
+        case 179:
             {
                 childParticle = ((ParticleImpl)$__result__);
                 action1();
@@ -334,21 +334,21 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 32:
+        case 184:
             {
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 4;
+            }
+            break;
+        case 178:
+            {
                 childParticle = ((ParticleImpl)$__result__);
                 action1();
                 $_ngcc_current_state = 1;
             }
             break;
-        case 37:
+        case 182:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 4;
-            }
-            break;
-        case 35:
-            {
                 annotation = ((AnnotationImpl)$__result__);
                 $_ngcc_current_state = 2;
             }
@@ -357,7 +357,7 @@
     }
 
     public boolean accepted() {
-        return((($_ngcc_current_state == 4) || (($_ngcc_current_state == 2) || (($_ngcc_current_state == 1) || ($_ngcc_current_state == 0)))));
+        return((($_ngcc_current_state == 0) || (($_ngcc_current_state == 4) || (($_ngcc_current_state == 1) || ($_ngcc_current_state == 2)))));
     }
 
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/notation.java	Tue Aug  4 10:09:44 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/notation.java	Tue Aug  4 10:09:44 2009
@@ -76,16 +76,11 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 10:
             {
-                revertToParentFromEnterElement(makeResult(), super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 14:
-            {
-                if((($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 571, null);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","public"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -95,7 +90,7 @@
         case 2:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 558, null,AnnotationContext.NOTATION);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 386, null,AnnotationContext.NOTATION);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -104,25 +99,13 @@
                 }
             }
             break;
-        case 4:
+        case 13:
             {
-                if(($ai = $runtime.getAttributeIndex("","system"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 2;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-            }
-            break;
-        case 10:
-            {
-                if(($ai = $runtime.getAttributeIndex("","public"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
                     unexpectedEnterElement($__qname);
                 }
             }
@@ -139,13 +122,30 @@
                 }
             }
             break;
-        case 13:
+        case 0:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                revertToParentFromEnterElement(makeResult(), super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
+        case 4:
+            {
+                if(($ai = $runtime.getAttributeIndex("","system"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
+                    $_ngcc_current_state = 2;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+            }
+            break;
+        case 14:
+            {
+                if((($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 399, null);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
                     unexpectedEnterElement($__qname);
                 }
             }
@@ -164,16 +164,11 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 10:
             {
-                revertToParentFromLeaveElement(makeResult(), super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 14:
-            {
-                if((($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("notation")))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 571, null);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                if(($ai = $runtime.getAttributeIndex("","public"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -180,11 +175,17 @@
                 }
             }
             break;
-        case 1:
+        case 2:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("notation"))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 0;
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 13:
+            {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -191,10 +192,9 @@
                 }
             }
             break;
-        case 2:
+        case 0:
             {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                revertToParentFromLeaveElement(makeResult(), super._cookie, $__uri, $__local, $__qname);
             }
             break;
         case 4:
@@ -209,11 +209,11 @@
                 }
             }
             break;
-        case 10:
+        case 14:
             {
-                if(($ai = $runtime.getAttributeIndex("","public"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if((($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("notation")))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 399, null);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -220,11 +220,11 @@
                 }
             }
             break;
-        case 13:
+        case 1:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("notation"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 0;
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -245,16 +245,26 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 10:
             {
-                revertToParentFromEnterAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("public"))) {
+                    $_ngcc_current_state = 9;
+                }
+                else {
+                    unexpectedEnterAttribute($__qname);
+                }
             }
             break;
-        case 14:
+        case 2:
             {
+                $_ngcc_current_state = 1;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 13:
+            {
                 if(($__uri.equals("") && $__local.equals("name"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 571, null);
-                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+                    $_ngcc_current_state = 12;
                 }
                 else {
                     unexpectedEnterAttribute($__qname);
@@ -261,10 +271,9 @@
                 }
             }
             break;
-        case 2:
+        case 0:
             {
-                $_ngcc_current_state = 1;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                revertToParentFromEnterAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
             }
             break;
         case 4:
@@ -278,20 +287,11 @@
                 }
             }
             break;
-        case 10:
+        case 14:
             {
-                if(($__uri.equals("") && $__local.equals("public"))) {
-                    $_ngcc_current_state = 9;
-                }
-                else {
-                    unexpectedEnterAttribute($__qname);
-                }
-            }
-            break;
-        case 13:
-            {
                 if(($__uri.equals("") && $__local.equals("name"))) {
-                    $_ngcc_current_state = 12;
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 399, null);
+                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedEnterAttribute($__qname);
@@ -312,15 +312,16 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 2:
             {
-                revertToParentFromLeaveAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 5:
+        case 8:
             {
-                if(($__uri.equals("") && $__local.equals("system"))) {
-                    $_ngcc_current_state = 2;
+                if(($__uri.equals("") && $__local.equals("public"))) {
+                    $_ngcc_current_state = 4;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -327,18 +328,6 @@
                 }
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 4:
-            {
-                $_ngcc_current_state = 2;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 11:
             {
                 if(($__uri.equals("") && $__local.equals("name"))) {
@@ -349,10 +338,10 @@
                 }
             }
             break;
-        case 8:
+        case 5:
             {
-                if(($__uri.equals("") && $__local.equals("public"))) {
-                    $_ngcc_current_state = 4;
+                if(($__uri.equals("") && $__local.equals("system"))) {
+                    $_ngcc_current_state = 2;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -359,6 +348,17 @@
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromLeaveAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 4:
+            {
+                $_ngcc_current_state = 2;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -370,19 +370,12 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 0:
+        case 9:
             {
-                revertToParentFromText(makeResult(), super._cookie, $value);
+                pub = $value;
+                $_ngcc_current_state = 8;
             }
             break;
-        case 14:
-            {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 571, null);
-                    spawnChildFromText(h, $value);
-                }
-            }
-            break;
         case 6:
             {
                 sys = $value;
@@ -389,22 +382,12 @@
                 $_ngcc_current_state = 5;
             }
             break;
-        case 2:
+        case 10:
             {
-                $_ngcc_current_state = 1;
-                $runtime.sendText(super._cookie, $value);
-            }
-            break;
-        case 4:
-            {
-                if(($ai = $runtime.getAttributeIndex("","system"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","public"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
-                else {
-                    $_ngcc_current_state = 2;
-                    $runtime.sendText(super._cookie, $value);
-                }
             }
             break;
         case 12:
@@ -413,43 +396,60 @@
                 $_ngcc_current_state = 11;
             }
             break;
-        case 10:
+        case 2:
             {
-                if(($ai = $runtime.getAttributeIndex("","public"))>=0) {
+                $_ngcc_current_state = 1;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
+        case 13:
+            {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
-        case 9:
+        case 0:
             {
-                pub = $value;
-                $_ngcc_current_state = 8;
+                revertToParentFromText(makeResult(), super._cookie, $value);
             }
             break;
-        case 13:
+        case 4:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","system"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendText(super._cookie, $value);
                 }
+                else {
+                    $_ngcc_current_state = 2;
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
+        case 14:
+            {
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 399, null);
+                    spawnChildFromText(h, $value);
+                }
+            }
+            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 571:
+        case 386:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 13;
+                ann = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 1;
             }
             break;
-        case 558:
+        case 399:
             {
-                ann = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 1;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 13;
             }
             break;
         }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/occurs.java	Tue Aug  4 10:09:47 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/occurs.java	Tue Aug  4 10:09:46 2009
@@ -80,35 +80,35 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 1:
+        case 5:
             {
-                if(($ai = $runtime.getAttributeIndex("","minOccurs"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 0;
+                    $_ngcc_current_state = 1;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 0:
+        case 1:
             {
-                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 5:
-            {
-                if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","minOccurs"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 1;
+                    $_ngcc_current_state = 0;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -123,35 +123,35 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 1:
+        case 5:
             {
-                if(($ai = $runtime.getAttributeIndex("","minOccurs"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 0;
+                    $_ngcc_current_state = 1;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
-        case 0:
+        case 1:
             {
-                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 5:
-            {
-                if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
+                if(($ai = $runtime.getAttributeIndex("","minOccurs"))>=0) {
                     $runtime.consumeAttribute($ai);
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    $_ngcc_current_state = 1;
+                    $_ngcc_current_state = 0;
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedLeaveElement($__qname);
@@ -166,6 +166,17 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 5:
+            {
+                if(($__uri.equals("") && $__local.equals("maxOccurs"))) {
+                    $_ngcc_current_state = 7;
+                }
+                else {
+                    $_ngcc_current_state = 1;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                }
+            }
+            break;
         case 1:
             {
                 if(($__uri.equals("") && $__local.equals("minOccurs"))) {
@@ -182,17 +193,6 @@
                 revertToParentFromEnterAttribute(this, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 5:
-            {
-                if(($__uri.equals("") && $__local.equals("maxOccurs"))) {
-                    $_ngcc_current_state = 7;
-                }
-                else {
-                    $_ngcc_current_state = 1;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -207,10 +207,16 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 2:
+        case 5:
             {
-                if(($__uri.equals("") && $__local.equals("minOccurs"))) {
-                    $_ngcc_current_state = 0;
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 6:
+            {
+                if(($__uri.equals("") && $__local.equals("maxOccurs"))) {
+                    $_ngcc_current_state = 1;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -217,10 +223,10 @@
                 }
             }
             break;
-        case 6:
+        case 2:
             {
-                if(($__uri.equals("") && $__local.equals("maxOccurs"))) {
-                    $_ngcc_current_state = 1;
+                if(($__uri.equals("") && $__local.equals("minOccurs"))) {
+                    $_ngcc_current_state = 0;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -238,12 +244,6 @@
                 revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 5:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -255,16 +255,15 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 7:
+        case 5:
             {
-                if($value.equals("unbounded")) {
-                    $_ngcc_current_state = 6;
-                    action1();
+                if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    v = $value;
-                    $_ngcc_current_state = 6;
-                    action2();
+                    $_ngcc_current_state = 1;
+                    $runtime.sendText(super._cookie, $value);
                 }
             }
             break;
@@ -280,9 +279,17 @@
                 }
             }
             break;
-        case 0:
+        case 7:
             {
-                revertToParentFromText(this, super._cookie, $value);
+                if($value.equals("unbounded")) {
+                    $_ngcc_current_state = 6;
+                    action1();
+                }
+                else {
+                    v = $value;
+                    $_ngcc_current_state = 6;
+                    action2();
+                }
             }
             break;
         case 3:
@@ -292,16 +299,9 @@
                 action0();
             }
             break;
-        case 5:
+        case 0:
             {
-                if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 1;
-                    $runtime.sendText(super._cookie, $value);
-                }
+                revertToParentFromText(this, super._cookie, $value);
             }
             break;
         }
@@ -313,7 +313,7 @@
     }
 
     public boolean accepted() {
-        return((($_ngcc_current_state == 5) || (($_ngcc_current_state == 0) || ($_ngcc_current_state == 1))));
+        return((($_ngcc_current_state == 0) || (($_ngcc_current_state == 1) || ($_ngcc_current_state == 5))));
     }
 
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/particle.java	Tue Aug  4 10:09:49 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/particle.java	Tue Aug  4 10:09:49 2009
@@ -129,10 +129,10 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 3:
+        case 26:
             {
-                if((($ai = $runtime.getAttributeIndex("","namespace"))>=0 || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ($ai = $runtime.getAttributeIndex("","processContents"))>=0))) {
-                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 416, wloc);
+                if(((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || (($ai = $runtime.getAttributeIndex("","ref"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 599);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -140,16 +140,26 @@
                 }
             }
             break;
-        case 10:
+        case 4:
             {
-                action3();
-                $_ngcc_current_state = 7;
-                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(((($ai = $runtime.getAttributeIndex("","processContents"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || (($ai = $runtime.getAttributeIndex("","namespace"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))))))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 574);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
             }
             break;
-        case 0:
+        case 25:
             {
-                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
             }
             break;
         case 20:
@@ -159,6 +169,17 @@
                 $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
+        case 16:
+            {
+                if(((($ai = $runtime.getAttributeIndex("","default"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","block"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","fixed"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","form"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","final"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","abstract"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","ref"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || (($ai = $runtime.getAttributeIndex("","name"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))))))))))))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 588);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
+            }
+            break;
         case 1:
             {
                 if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
@@ -192,45 +213,40 @@
                 }
             }
             break;
-        case 4:
+        case 21:
             {
-                if(((($ai = $runtime.getAttributeIndex("","namespace"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || (($ai = $runtime.getAttributeIndex("","processContents"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))))))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 417);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 594, null,AnnotationContext.PARTICLE);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 20;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 11:
+        case 29:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 425, null,AnnotationContext.PARTICLE);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))))))) {
+                    NGCCHandler h = new modelGroupBody(this, super._source, $runtime, 603, loc,compositorName);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 10;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 21:
+        case 10:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 437, null,AnnotationContext.PARTICLE);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    $_ngcc_current_state = 20;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
+                action3();
+                $_ngcc_current_state = 7;
+                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
-        case 16:
+        case 30:
             {
-                if(((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","default"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","block"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","ref"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","fixed"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","name"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","form"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","abstract"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || (($ai = $runtime.getAttributeIndex("","final"))>=0 && (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("key")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("keyref"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("unique")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))))))))))))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || ((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))))))))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 604);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -245,8 +261,8 @@
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    if((($ai = $runtime.getAttributeIndex("","default"))>=0 || (($ai = $runtime.getAttributeIndex("","block"))>=0 || (($ai = $runtime.getAttributeIndex("","fixed"))>=0 || (($ai = $runtime.getAttributeIndex("","name"))>=0 || (($ai = $runtime.getAttributeIndex("","form"))>=0 || (($ai = $runtime.getAttributeIndex("","abstract"))>=0 || ($ai = $runtime.getAttributeIndex("","final"))>=0))))))) {
-                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 422, loc,false);
+                    if((($ai = $runtime.getAttributeIndex("","default"))>=0 || (($ai = $runtime.getAttributeIndex("","block"))>=0 || (($ai = $runtime.getAttributeIndex("","fixed"))>=0 || (($ai = $runtime.getAttributeIndex("","form"))>=0 || (($ai = $runtime.getAttributeIndex("","final"))>=0 || (($ai = $runtime.getAttributeIndex("","abstract"))>=0 || ($ai = $runtime.getAttributeIndex("","name"))>=0))))))) {
+                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 579, loc,false);
                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                     }
                     else {
@@ -255,21 +271,15 @@
                 }
             }
             break;
-        case 29:
+        case 0:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))))))) {
-                    NGCCHandler h = new modelGroupBody(this, super._source, $runtime, 446, loc,compositorName);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
+                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
-        case 26:
+        case 3:
             {
-                if(((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) || (($ai = $runtime.getAttributeIndex("","ref"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 442);
+                if((($ai = $runtime.getAttributeIndex("","processContents"))>=0 || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ($ai = $runtime.getAttributeIndex("","namespace"))>=0))) {
+                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 573, wloc);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -277,26 +287,16 @@
                 }
             }
             break;
-        case 30:
+        case 11:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || ((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")) || ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || (((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))))))))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 447);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 582, null,AnnotationContext.PARTICLE);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
-        case 25:
-            {
-                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
-                    $runtime.consumeAttribute($ai);
+                    $_ngcc_current_state = 10;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
             }
             break;
         default:
@@ -313,9 +313,20 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 19:
+        case 26:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) {
+                if(((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) || (($ai = $runtime.getAttributeIndex("","ref"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")))))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 599);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
+            }
+            break;
+        case 28:
+            {
+                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
                     $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
                     $_ngcc_current_state = 0;
                 }
@@ -324,10 +335,10 @@
                 }
             }
             break;
-        case 3:
+        case 4:
             {
-                if(((($ai = $runtime.getAttributeIndex("","namespace"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ((($ai = $runtime.getAttributeIndex("","processContents"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))))) {
-                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 416, wloc);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || ((($ai = $runtime.getAttributeIndex("","processContents"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || (($ai = $runtime.getAttributeIndex("","namespace"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")))))))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 574);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -335,16 +346,26 @@
                 }
             }
             break;
-        case 10:
+        case 2:
             {
-                action3();
-                $_ngcc_current_state = 7;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 0;
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
             }
             break;
-        case 0:
+        case 25:
             {
-                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
+                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
             }
             break;
         case 20:
@@ -354,10 +375,10 @@
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 4:
+        case 16:
             {
-                if(((($ai = $runtime.getAttributeIndex("","namespace"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ((($ai = $runtime.getAttributeIndex("","processContents"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))))))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 417);
+                if(((($ai = $runtime.getAttributeIndex("","default"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","block"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","fixed"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","form"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","final"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","abstract"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","ref"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || (($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))))))))))))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -365,12 +386,6 @@
                 }
             }
             break;
-        case 11:
-            {
-                $_ngcc_current_state = 10;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 21:
             {
                 $_ngcc_current_state = 20;
@@ -377,9 +392,9 @@
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 2:
+        case 19:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) {
                     $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
                     $_ngcc_current_state = 0;
                 }
@@ -388,10 +403,10 @@
                 }
             }
             break;
-        case 16:
+        case 29:
             {
-                if(((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","default"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","block"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","ref"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","fixed"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","form"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","abstract"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || (($ai = $runtime.getAttributeIndex("","final"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))))))))))))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
+                    NGCCHandler h = new modelGroupBody(this, super._source, $runtime, 603, loc,compositorName);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -399,6 +414,24 @@
                 }
             }
             break;
+        case 10:
+            {
+                action3();
+                $_ngcc_current_state = 7;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 30:
+            {
+                if((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || ((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) || (($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))))))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 604);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
+            }
+            break;
         case 7:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) {
@@ -417,8 +450,8 @@
                     $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
-                    if(((($ai = $runtime.getAttributeIndex("","default"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","block"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","fixed"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","form"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","abstract"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || (($ai = $runtime.getAttributeIndex("","final"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")))))))))) {
-                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 422, loc,false);
+                    if(((($ai = $runtime.getAttributeIndex("","default"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","block"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","fixed"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","form"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","final"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || ((($ai = $runtime.getAttributeIndex("","abstract"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element"))) || (($ai = $runtime.getAttributeIndex("","name"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("element")))))))))) {
+                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 579, loc,false);
                         spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                     }
                     else {
@@ -427,21 +460,15 @@
                 }
             }
             break;
-        case 29:
+        case 0:
             {
-                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
-                    NGCCHandler h = new modelGroupBody(this, super._source, $runtime, 446, loc,compositorName);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
+                revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 26:
+        case 3:
             {
-                if(((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) || ((($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) || (($ai = $runtime.getAttributeIndex("","ref"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group")))))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 442);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")) || ((($ai = $runtime.getAttributeIndex("","processContents"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any"))) || (($ai = $runtime.getAttributeIndex("","namespace"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("any")))))) {
+                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 573, wloc);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -449,39 +476,12 @@
                 }
             }
             break;
-        case 28:
+        case 11:
             {
-                if(((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 0;
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
+                $_ngcc_current_state = 10;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 30:
-            {
-                if((((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))) || ((($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0 && ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence")))) || (($ai = $runtime.getAttributeIndex("","minOccurs"))>=0 && ((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("all")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("choice"))) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("sequence"))))))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 447);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
-            }
-            break;
-        case 25:
-            {
-                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedLeaveElement($__qname);
@@ -498,8 +498,8 @@
         switch($_ngcc_current_state) {
         case 4:
             {
-                if((($__uri.equals("") && $__local.equals("namespace")) || (($__uri.equals("") && $__local.equals("maxOccurs")) || (($__uri.equals("") && $__local.equals("minOccurs")) || ($__uri.equals("") && $__local.equals("processContents")))))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 417);
+                if((($__uri.equals("") && $__local.equals("processContents")) || (($__uri.equals("") && $__local.equals("maxOccurs")) || (($__uri.equals("") && $__local.equals("minOccurs")) || ($__uri.equals("") && $__local.equals("namespace")))))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 574);
                     spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -507,22 +507,28 @@
                 }
             }
             break;
-        case 11:
+        case 26:
             {
-                $_ngcc_current_state = 10;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                if((($__uri.equals("") && $__local.equals("maxOccurs")) || (($__uri.equals("") && $__local.equals("minOccurs")) || ($__uri.equals("") && $__local.equals("ref"))))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 599);
+                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+                }
+                else {
+                    unexpectedEnterAttribute($__qname);
+                }
             }
             break;
-        case 21:
+        case 10:
             {
-                $_ngcc_current_state = 20;
+                action3();
+                $_ngcc_current_state = 7;
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 16:
+        case 30:
             {
-                if((($__uri.equals("") && $__local.equals("maxOccurs")) || (($__uri.equals("") && $__local.equals("minOccurs")) || (($__uri.equals("") && $__local.equals("default")) || (($__uri.equals("") && $__local.equals("block")) || (($__uri.equals("") && $__local.equals("ref")) || (($__uri.equals("") && $__local.equals("fixed")) || (($__uri.equals("") && $__local.equals("name")) || (($__uri.equals("") && $__local.equals("form")) || (($__uri.equals("") && $__local.equals("abstract")) || ($__uri.equals("") && $__local.equals("final")))))))))))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                if((($__uri.equals("") && $__local.equals("maxOccurs")) || ($__uri.equals("") && $__local.equals("minOccurs")))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 604);
                     spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -530,6 +536,23 @@
                 }
             }
             break;
+        case 20:
+            {
+                action5();
+                $_ngcc_current_state = 19;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 25:
+            {
+                if(($__uri.equals("") && $__local.equals("ref"))) {
+                    $_ngcc_current_state = 24;
+                }
+                else {
+                    unexpectedEnterAttribute($__qname);
+                }
+            }
+            break;
         case 8:
             {
                 if(($__uri.equals("") && $__local.equals("ref"))) {
@@ -536,8 +559,8 @@
                     $_ngcc_current_state = 14;
                 }
                 else {
-                    if((($__uri.equals("") && $__local.equals("default")) || (($__uri.equals("") && $__local.equals("block")) || (($__uri.equals("") && $__local.equals("fixed")) || (($__uri.equals("") && $__local.equals("name")) || (($__uri.equals("") && $__local.equals("form")) || (($__uri.equals("") && $__local.equals("abstract")) || ($__uri.equals("") && $__local.equals("final"))))))))) {
-                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 422, loc,false);
+                    if((($__uri.equals("") && $__local.equals("default")) || (($__uri.equals("") && $__local.equals("block")) || (($__uri.equals("") && $__local.equals("fixed")) || (($__uri.equals("") && $__local.equals("form")) || (($__uri.equals("") && $__local.equals("final")) || (($__uri.equals("") && $__local.equals("abstract")) || ($__uri.equals("") && $__local.equals("name"))))))))) {
+                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 579, loc,false);
                         spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                     }
                     else {
@@ -546,40 +569,15 @@
                 }
             }
             break;
-        case 3:
-            {
-                if((($__uri.equals("") && $__local.equals("namespace")) || ($__uri.equals("") && $__local.equals("processContents")))) {
-                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 416, wloc);
-                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
-                }
-                else {
-                    unexpectedEnterAttribute($__qname);
-                }
-            }
-            break;
-        case 10:
-            {
-                action3();
-                $_ngcc_current_state = 7;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 0:
             {
                 revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 20:
+        case 16:
             {
-                action5();
-                $_ngcc_current_state = 19;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 26:
-            {
-                if((($__uri.equals("") && $__local.equals("maxOccurs")) || (($__uri.equals("") && $__local.equals("minOccurs")) || ($__uri.equals("") && $__local.equals("ref"))))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 442);
+                if((($__uri.equals("") && $__local.equals("default")) || (($__uri.equals("") && $__local.equals("block")) || (($__uri.equals("") && $__local.equals("fixed")) || (($__uri.equals("") && $__local.equals("maxOccurs")) || (($__uri.equals("") && $__local.equals("minOccurs")) || (($__uri.equals("") && $__local.equals("form")) || (($__uri.equals("") && $__local.equals("final")) || (($__uri.equals("") && $__local.equals("abstract")) || (($__uri.equals("") && $__local.equals("ref")) || ($__uri.equals("") && $__local.equals("name")))))))))))) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                     spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -587,10 +585,10 @@
                 }
             }
             break;
-        case 30:
+        case 3:
             {
-                if((($__uri.equals("") && $__local.equals("maxOccurs")) || ($__uri.equals("") && $__local.equals("minOccurs")))) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 447);
+                if((($__uri.equals("") && $__local.equals("processContents")) || ($__uri.equals("") && $__local.equals("namespace")))) {
+                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 573, wloc);
                     spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
@@ -598,16 +596,18 @@
                 }
             }
             break;
-        case 25:
+        case 21:
             {
-                if(($__uri.equals("") && $__local.equals("ref"))) {
-                    $_ngcc_current_state = 24;
-                }
-                else {
-                    unexpectedEnterAttribute($__qname);
-                }
+                $_ngcc_current_state = 20;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 11:
+            {
+                $_ngcc_current_state = 10;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -622,10 +622,10 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 13:
+        case 23:
             {
                 if(($__uri.equals("") && $__local.equals("ref"))) {
-                    $_ngcc_current_state = 11;
+                    $_ngcc_current_state = 21;
                 }
                 else {
                     unexpectedLeaveAttribute($__qname);
@@ -632,45 +632,45 @@
                 }
             }
             break;
-        case 11:
+        case 10:
             {
-                $_ngcc_current_state = 10;
+                action3();
+                $_ngcc_current_state = 7;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 21:
+        case 20:
             {
-                $_ngcc_current_state = 20;
+                action5();
+                $_ngcc_current_state = 19;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 23:
+        case 0:
             {
-                if(($__uri.equals("") && $__local.equals("ref"))) {
-                    $_ngcc_current_state = 21;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
+                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 10:
+        case 21:
             {
-                action3();
-                $_ngcc_current_state = 7;
+                $_ngcc_current_state = 20;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 0:
+        case 11:
             {
-                revertToParentFromLeaveAttribute(result, super._cookie, $__uri, $__local, $__qname);
+                $_ngcc_current_state = 10;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 20:
+        case 13:
             {
-                action5();
-                $_ngcc_current_state = 19;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("ref"))) {
+                    $_ngcc_current_state = 11;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
         default:
@@ -684,70 +684,45 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 24:
+        case 26:
             {
-                NGCCHandler h = new qname(this, super._source, $runtime, 440);
-                spawnChildFromText(h, $value);
-            }
-            break;
-        case 3:
-            {
-                if(($ai = $runtime.getAttributeIndex("","processContents"))>=0) {
-                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 416, wloc);
+                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 599);
                     spawnChildFromText(h, $value);
                 }
                 else {
-                    if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
-                        NGCCHandler h = new wildcardBody(this, super._source, $runtime, 416, wloc);
+                    if(($ai = $runtime.getAttributeIndex("","minOccurs"))>=0) {
+                        NGCCHandler h = new occurs(this, super._source, $runtime, 599);
                         spawnChildFromText(h, $value);
                     }
+                    else {
+                        if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
+                            NGCCHandler h = new occurs(this, super._source, $runtime, 599);
+                            spawnChildFromText(h, $value);
+                        }
+                    }
                 }
             }
             break;
-        case 10:
-            {
-                action3();
-                $_ngcc_current_state = 7;
-                $runtime.sendText(super._cookie, $value);
-            }
-            break;
-        case 0:
-            {
-                revertToParentFromText(result, super._cookie, $value);
-            }
-            break;
-        case 20:
-            {
-                action5();
-                $_ngcc_current_state = 19;
-                $runtime.sendText(super._cookie, $value);
-            }
-            break;
-        case 14:
-            {
-                NGCCHandler h = new qname(this, super._source, $runtime, 428);
-                spawnChildFromText(h, $value);
-            }
-            break;
         case 4:
             {
-                if(($ai = $runtime.getAttributeIndex("","processContents"))>=0) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 417);
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 574);
                     spawnChildFromText(h, $value);
                 }
                 else {
                     if(($ai = $runtime.getAttributeIndex("","minOccurs"))>=0) {
-                        NGCCHandler h = new occurs(this, super._source, $runtime, 417);
+                        NGCCHandler h = new occurs(this, super._source, $runtime, 574);
                         spawnChildFromText(h, $value);
                     }
                     else {
                         if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
-                            NGCCHandler h = new occurs(this, super._source, $runtime, 417);
+                            NGCCHandler h = new occurs(this, super._source, $runtime, 574);
                             spawnChildFromText(h, $value);
                         }
                         else {
-                            if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
-                                NGCCHandler h = new occurs(this, super._source, $runtime, 417);
+                            if(($ai = $runtime.getAttributeIndex("","processContents"))>=0) {
+                                NGCCHandler h = new occurs(this, super._source, $runtime, 574);
                                 spawnChildFromText(h, $value);
                             }
                         }
@@ -755,67 +730,70 @@
                 }
             }
             break;
-        case 11:
+        case 25:
             {
-                $_ngcc_current_state = 10;
-                $runtime.sendText(super._cookie, $value);
+                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
             }
             break;
-        case 21:
+        case 20:
             {
-                $_ngcc_current_state = 20;
+                action5();
+                $_ngcc_current_state = 19;
                 $runtime.sendText(super._cookie, $value);
             }
             break;
         case 16:
             {
-                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                     spawnChildFromText(h, $value);
                 }
                 else {
-                    if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
-                        NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                    if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
+                        NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                         spawnChildFromText(h, $value);
                     }
                     else {
-                        if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
-                            NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                        if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
+                            NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                             spawnChildFromText(h, $value);
                         }
                         else {
-                            if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                                NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                            if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
+                                NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                                 spawnChildFromText(h, $value);
                             }
                             else {
-                                if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
-                                    NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                                    NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                                     spawnChildFromText(h, $value);
                                 }
                                 else {
-                                    if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
-                                        NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                                    if(($ai = $runtime.getAttributeIndex("","minOccurs"))>=0) {
+                                        NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                                         spawnChildFromText(h, $value);
                                     }
                                     else {
-                                        if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
-                                            NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                                        if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
+                                            NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                                             spawnChildFromText(h, $value);
                                         }
                                         else {
-                                            if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
-                                                NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                                            if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
+                                                NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                                                 spawnChildFromText(h, $value);
                                             }
                                             else {
-                                                if(($ai = $runtime.getAttributeIndex("","minOccurs"))>=0) {
-                                                    NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                                                if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
+                                                    NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                                                     spawnChildFromText(h, $value);
                                                 }
                                                 else {
-                                                    if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
-                                                        NGCCHandler h = new occurs(this, super._source, $runtime, 431);
+                                                    if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
+                                                        NGCCHandler h = new occurs(this, super._source, $runtime, 588);
                                                         spawnChildFromText(h, $value);
                                                     }
                                                 }
@@ -829,6 +807,39 @@
                 }
             }
             break;
+        case 21:
+            {
+                $_ngcc_current_state = 20;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
+        case 10:
+            {
+                action3();
+                $_ngcc_current_state = 7;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
+        case 14:
+            {
+                NGCCHandler h = new qname(this, super._source, $runtime, 585);
+                spawnChildFromText(h, $value);
+            }
+            break;
+        case 30:
+            {
+                if(($ai = $runtime.getAttributeIndex("","minOccurs"))>=0) {
+                    NGCCHandler h = new occurs(this, super._source, $runtime, 604);
+                    spawnChildFromText(h, $value);
+                }
+                else {
+                    if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
+                        NGCCHandler h = new occurs(this, super._source, $runtime, 604);
+                        spawnChildFromText(h, $value);
+                    }
+                }
+            }
+            break;
         case 8:
             {
                 if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
@@ -836,38 +847,38 @@
                     $runtime.sendText(super._cookie, $value);
                 }
                 else {
-                    if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
-                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 422, loc,false);
+                    if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 579, loc,false);
                         spawnChildFromText(h, $value);
                     }
                     else {
                         if(($ai = $runtime.getAttributeIndex("","abstract"))>=0) {
-                            NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 422, loc,false);
+                            NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 579, loc,false);
                             spawnChildFromText(h, $value);
                         }
                         else {
-                            if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
-                                NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 422, loc,false);
+                            if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
+                                NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 579, loc,false);
                                 spawnChildFromText(h, $value);
                             }
                             else {
-                                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 422, loc,false);
+                                if(($ai = $runtime.getAttributeIndex("","form"))>=0) {
+                                    NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 579, loc,false);
                                     spawnChildFromText(h, $value);
                                 }
                                 else {
                                     if(($ai = $runtime.getAttributeIndex("","fixed"))>=0) {
-                                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 422, loc,false);
+                                        NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 579, loc,false);
                                         spawnChildFromText(h, $value);
                                     }
                                     else {
                                         if(($ai = $runtime.getAttributeIndex("","block"))>=0) {
-                                            NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 422, loc,false);
+                                            NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 579, loc,false);
                                             spawnChildFromText(h, $value);
                                         }
                                         else {
                                             if(($ai = $runtime.getAttributeIndex("","default"))>=0) {
-                                                NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 422, loc,false);
+                                                NGCCHandler h = new elementDeclBody(this, super._source, $runtime, 579, loc,false);
                                                 spawnChildFromText(h, $value);
                                             }
                                         }
@@ -879,120 +890,109 @@
                 }
             }
             break;
-        case 26:
+        case 0:
             {
-                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 442);
-                    spawnChildFromText(h, $value);
-                }
-                else {
-                    if(($ai = $runtime.getAttributeIndex("","minOccurs"))>=0) {
-                        NGCCHandler h = new occurs(this, super._source, $runtime, 442);
-                        spawnChildFromText(h, $value);
-                    }
-                    else {
-                        if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
-                            NGCCHandler h = new occurs(this, super._source, $runtime, 442);
-                            spawnChildFromText(h, $value);
-                        }
-                    }
-                }
+                revertToParentFromText(result, super._cookie, $value);
             }
             break;
-        case 30:
+        case 3:
             {
-                if(($ai = $runtime.getAttributeIndex("","minOccurs"))>=0) {
-                    NGCCHandler h = new occurs(this, super._source, $runtime, 447);
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                    NGCCHandler h = new wildcardBody(this, super._source, $runtime, 573, wloc);
                     spawnChildFromText(h, $value);
                 }
                 else {
-                    if(($ai = $runtime.getAttributeIndex("","maxOccurs"))>=0) {
-                        NGCCHandler h = new occurs(this, super._source, $runtime, 447);
+                    if(($ai = $runtime.getAttributeIndex("","processContents"))>=0) {
+                        NGCCHandler h = new wildcardBody(this, super._source, $runtime, 573, wloc);
                         spawnChildFromText(h, $value);
                     }
                 }
             }
             break;
-        case 25:
+        case 24:
             {
-                if(($ai = $runtime.getAttributeIndex("","ref"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
+                NGCCHandler h = new qname(this, super._source, $runtime, 597);
+                spawnChildFromText(h, $value);
             }
             break;
+        case 11:
+            {
+                $_ngcc_current_state = 10;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 440:
+        case 599:
             {
-                groupName = ((UName)$__result__);
-                $_ngcc_current_state = 23;
+                occurs = ((occurs)$__result__);
+                $_ngcc_current_state = 25;
             }
             break;
-        case 416:
+        case 579:
             {
+                anonymousElementDecl = ((ElementDecl)$__result__);
+                action2();
+                $_ngcc_current_state = 7;
+            }
+            break;
+        case 573:
+            {
                 wcBody = ((WildcardImpl)$__result__);
                 action0();
                 $_ngcc_current_state = 2;
             }
             break;
-        case 428:
+        case 597:
             {
-                elementTypeName = ((UName)$__result__);
-                $_ngcc_current_state = 13;
+                groupName = ((UName)$__result__);
+                $_ngcc_current_state = 23;
             }
             break;
-        case 425:
+        case 582:
             {
                 annotation = ((AnnotationImpl)$__result__);
                 $_ngcc_current_state = 10;
             }
             break;
-        case 422:
+        case 574:
             {
-                anonymousElementDecl = ((ElementDecl)$__result__);
-                action2();
-                $_ngcc_current_state = 7;
+                occurs = ((occurs)$__result__);
+                $_ngcc_current_state = 3;
             }
             break;
-        case 446:
+        case 588:
             {
-                term = ((ModelGroupImpl)$__result__);
-                action7();
-                $_ngcc_current_state = 28;
-            }
-            break;
-        case 442:
-            {
                 occurs = ((occurs)$__result__);
-                $_ngcc_current_state = 25;
+                $_ngcc_current_state = 8;
             }
             break;
-        case 447:
+        case 594:
             {
-                occurs = ((occurs)$__result__);
-                $_ngcc_current_state = 29;
+                annotation = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 20;
             }
             break;
-        case 417:
+        case 603:
             {
-                occurs = ((occurs)$__result__);
-                $_ngcc_current_state = 3;
+                term = ((ModelGroupImpl)$__result__);
+                action7();
+                $_ngcc_current_state = 28;
             }
             break;
-        case 437:
+        case 585:
             {
-                annotation = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 20;
+                elementTypeName = ((UName)$__result__);
+                $_ngcc_current_state = 13;
             }
             break;
-        case 431:
+        case 604:
             {
                 occurs = ((occurs)$__result__);
-                $_ngcc_current_state = 8;
+                $_ngcc_current_state = 29;
             }
             break;
         }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/qname.java	Tue Aug  4 10:09:52 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/qname.java	Tue Aug  4 10:09:52 2009
@@ -141,11 +141,6 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 0:
-            {
-                revertToParentFromText($runtime.parseUName(qvalue), super._cookie, $value);
-            }
-            break;
         case 1:
             {
                 qvalue = $value;
@@ -152,6 +147,11 @@
                 $_ngcc_current_state = 0;
             }
             break;
+        case 0:
+            {
+                revertToParentFromText($runtime.parseUName(qvalue), super._cookie, $value);
+            }
+            break;
         }
     }
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/redefine.java	Tue Aug  4 10:09:55 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/redefine.java	Tue Aug  4 10:09:55 2009
@@ -116,41 +116,30 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 15:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("redefine"))) {
-                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
-                    $_ngcc_current_state = 14;
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
         case 1:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 476, null,AnnotationContext.SCHEMA);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 369, null,AnnotationContext.SCHEMA);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                        NGCCHandler h = new simpleType(this, super._source, $runtime, 477);
+                        NGCCHandler h = new simpleType(this, super._source, $runtime, 370);
                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                     }
                     else {
                         if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
-                            NGCCHandler h = new complexType(this, super._source, $runtime, 478);
+                            NGCCHandler h = new complexType(this, super._source, $runtime, 371);
                             spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                         }
                         else {
                             if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) {
-                                NGCCHandler h = new group(this, super._source, $runtime, 479);
+                                NGCCHandler h = new group(this, super._source, $runtime, 372);
                                 spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                             }
                             else {
                                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
-                                    NGCCHandler h = new attributeGroupDecl(this, super._source, $runtime, 480);
+                                    NGCCHandler h = new attributeGroupDecl(this, super._source, $runtime, 373);
                                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                 }
                                 else {
@@ -162,46 +151,30 @@
                 }
             }
             break;
-        case 0:
-            {
-                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 14:
-            {
-                if(($ai = $runtime.getAttributeIndex("","schemaLocation"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    unexpectedEnterElement($__qname);
-                }
-            }
-            break;
         case 2:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 481, null,AnnotationContext.SCHEMA);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 374, null,AnnotationContext.SCHEMA);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                        NGCCHandler h = new simpleType(this, super._source, $runtime, 482);
+                        NGCCHandler h = new simpleType(this, super._source, $runtime, 375);
                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                     }
                     else {
                         if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("complexType"))) {
-                            NGCCHandler h = new complexType(this, super._source, $runtime, 483);
+                            NGCCHandler h = new complexType(this, super._source, $runtime, 376);
                             spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                         }
                         else {
                             if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("group"))) {
-                                NGCCHandler h = new group(this, super._source, $runtime, 484);
+                                NGCCHandler h = new group(this, super._source, $runtime, 377);
                                 spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                             }
                             else {
                                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("attributeGroup"))) {
-                                    NGCCHandler h = new attributeGroupDecl(this, super._source, $runtime, 485);
+                                    NGCCHandler h = new attributeGroupDecl(this, super._source, $runtime, 378);
                                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                                 }
                                 else {
@@ -214,6 +187,33 @@
                 }
             }
             break;
+        case 15:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("redefine"))) {
+                    $runtime.onEnterElementConsumed($__uri, $__local, $__qname, $attrs);
+                    $_ngcc_current_state = 14;
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
+            }
+            break;
+        case 14:
+            {
+                if(($ai = $runtime.getAttributeIndex("","schemaLocation"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    unexpectedEnterElement($__qname);
+                }
+            }
+            break;
+        case 0:
+            {
+                revertToParentFromEnterElement(this, super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -239,9 +239,10 @@
                 }
             }
             break;
-        case 0:
+        case 2:
             {
-                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
+                $_ngcc_current_state = 1;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
         case 14:
@@ -255,10 +256,9 @@
                 }
             }
             break;
-        case 2:
+        case 0:
             {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                revertToParentFromLeaveElement(this, super._cookie, $__uri, $__local, $__qname);
             }
             break;
         default:
@@ -275,9 +275,10 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 2:
             {
-                revertToParentFromEnterAttribute(this, super._cookie, $__uri, $__local, $__qname);
+                $_ngcc_current_state = 1;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
         case 14:
@@ -290,10 +291,9 @@
                 }
             }
             break;
-        case 2:
+        case 0:
             {
-                $_ngcc_current_state = 1;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                revertToParentFromEnterAttribute(this, super._cookie, $__uri, $__local, $__qname);
             }
             break;
         default:
@@ -310,11 +310,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
-            {
-                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 2:
             {
                 $_ngcc_current_state = 1;
@@ -331,6 +326,11 @@
                 }
             }
             break;
+        case 0:
+            {
+                revertToParentFromLeaveAttribute(this, super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -342,9 +342,10 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 0:
+        case 2:
             {
-                revertToParentFromText(this, super._cookie, $value);
+                $_ngcc_current_state = 1;
+                $runtime.sendText(super._cookie, $value);
             }
             break;
         case 14:
@@ -355,12 +356,6 @@
                 }
             }
             break;
-        case 2:
-            {
-                $_ngcc_current_state = 1;
-                $runtime.sendText(super._cookie, $value);
-            }
-            break;
         case 13:
             {
                 schemaLocation = $value;
@@ -368,17 +363,22 @@
                 action4();
             }
             break;
+        case 0:
+            {
+                revertToParentFromText(this, super._cookie, $value);
+            }
+            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 476:
+        case 374:
             {
                 $_ngcc_current_state = 1;
             }
             break;
-        case 477:
+        case 375:
             {
                 newSt = ((SimpleTypeImpl)$__result__);
                 action3();
@@ -385,7 +385,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 478:
+        case 376:
             {
                 newCt = ((ComplexTypeImpl)$__result__);
                 action2();
@@ -392,7 +392,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 479:
+        case 377:
             {
                 newGrp = ((ModelGroupDeclImpl)$__result__);
                 action1();
@@ -399,7 +399,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 480:
+        case 378:
             {
                 newAg = ((AttGroupDeclImpl)$__result__);
                 action0();
@@ -406,12 +406,12 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 481:
+        case 369:
             {
                 $_ngcc_current_state = 1;
             }
             break;
-        case 482:
+        case 370:
             {
                 newSt = ((SimpleTypeImpl)$__result__);
                 action3();
@@ -418,7 +418,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 483:
+        case 371:
             {
                 newCt = ((ComplexTypeImpl)$__result__);
                 action2();
@@ -425,7 +425,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 484:
+        case 372:
             {
                 newGrp = ((ModelGroupDeclImpl)$__result__);
                 action1();
@@ -432,7 +432,7 @@
                 $_ngcc_current_state = 1;
             }
             break;
-        case 485:
+        case 373:
             {
                 newAg = ((AttGroupDeclImpl)$__result__);
                 action0();
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/simpleType.java	Tue Aug  4 10:09:58 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/simpleType.java	Tue Aug  4 10:09:57 2009
@@ -79,14 +79,14 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 11:
+        case 8:
             {
-                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 632, null,AnnotationContext.SIMPLETYPE_DECL);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 10;
+                    $_ngcc_current_state = 7;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
@@ -103,43 +103,56 @@
                 }
             }
             break;
-        case 10:
+        case 11:
             {
-                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("list")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("union")))))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 71, fa);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    unexpectedEnterElement($__qname);
+                    $_ngcc_current_state = 10;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
-        case 8:
+        case 0:
             {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 69, null,AnnotationContext.SIMPLETYPE_DECL);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
+        case 15:
+            {
+                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 7;
+                    $_ngcc_current_state = 11;
                     $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
             }
             break;
+        case 7:
+            {
+                action0();
+                $_ngcc_current_state = 2;
+                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
         case 2:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction"))) {
-                    NGCCHandler h = new SimpleType_Restriction(this, super._source, $runtime, 65, annotation,locator,fa,name,finalSet);
+                    NGCCHandler h = new SimpleType_Restriction(this, super._source, $runtime, 628, annotation,locator,fa,name,finalSet);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("list"))) {
-                        NGCCHandler h = new SimpleType_List(this, super._source, $runtime, 66, annotation,locator,fa,name,finalSet);
+                        NGCCHandler h = new SimpleType_List(this, super._source, $runtime, 629, annotation,locator,fa,name,finalSet);
                         spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                     }
                     else {
                         if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("union"))) {
-                            NGCCHandler h = new SimpleType_Union(this, super._source, $runtime, 60, annotation,locator,fa,name,finalSet);
+                            NGCCHandler h = new SimpleType_Union(this, super._source, $runtime, 623, annotation,locator,fa,name,finalSet);
                             spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                         }
                         else {
@@ -149,30 +162,17 @@
                 }
             }
             break;
-        case 0:
+        case 10:
             {
-                revertToParentFromEnterElement(result, super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 15:
-            {
-                if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                if((($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("restriction")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")) || (($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("union")) || ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("list")))))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 634, fa);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    $_ngcc_current_state = 11;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                    unexpectedEnterElement($__qname);
                 }
             }
             break;
-        case 7:
-            {
-                action0();
-                $_ngcc_current_state = 2;
-                $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -187,6 +187,12 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 8:
+            {
+                $_ngcc_current_state = 7;
+                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 11:
             {
                 if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
@@ -199,28 +205,11 @@
                 }
             }
             break;
-        case 8:
-            {
-                $_ngcc_current_state = 7;
-                $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 0:
             {
                 revertToParentFromLeaveElement(result, super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 1:
-            {
-                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
-                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
-                    $_ngcc_current_state = 0;
-                }
-                else {
-                    unexpectedLeaveElement($__qname);
-                }
-            }
-            break;
         case 15:
             {
                 if(($ai = $runtime.getAttributeIndex("","final"))>=0) {
@@ -233,6 +222,17 @@
                 }
             }
             break;
+        case 1:
+            {
+                if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("simpleType"))) {
+                    $runtime.onLeaveElementConsumed($__uri, $__local, $__qname);
+                    $_ngcc_current_state = 0;
+                }
+                else {
+                    unexpectedLeaveElement($__qname);
+                }
+            }
+            break;
         case 7:
             {
                 action0();
@@ -254,6 +254,12 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 8:
+            {
+                $_ngcc_current_state = 7;
+                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 11:
             {
                 if(($__uri.equals("") && $__local.equals("name"))) {
@@ -265,12 +271,6 @@
                 }
             }
             break;
-        case 8:
-            {
-                $_ngcc_current_state = 7;
-                $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         case 0:
             {
                 revertToParentFromEnterAttribute(result, super._cookie, $__uri, $__local, $__qname);
@@ -308,19 +308,9 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 16:
+        case 8:
             {
-                if(($__uri.equals("") && $__local.equals("final"))) {
-                    $_ngcc_current_state = 11;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
-            }
-            break;
-        case 11:
-            {
-                $_ngcc_current_state = 10;
+                $_ngcc_current_state = 7;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -334,9 +324,9 @@
                 }
             }
             break;
-        case 8:
+        case 11:
             {
-                $_ngcc_current_state = 7;
+                $_ngcc_current_state = 10;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -351,6 +341,16 @@
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 16:
+            {
+                if(($__uri.equals("") && $__local.equals("final"))) {
+                    $_ngcc_current_state = 11;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
+            }
+            break;
         case 7:
             {
                 action0();
@@ -369,6 +369,12 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
+        case 8:
+            {
+                $_ngcc_current_state = 7;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
         case 11:
             {
                 if(($ai = $runtime.getAttributeIndex("","name"))>=0) {
@@ -381,18 +387,6 @@
                 }
             }
             break;
-        case 17:
-            {
-                finalValue = $value;
-                $_ngcc_current_state = 16;
-            }
-            break;
-        case 8:
-            {
-                $_ngcc_current_state = 7;
-                $runtime.sendText(super._cookie, $value);
-            }
-            break;
         case 0:
             {
                 revertToParentFromText(result, super._cookie, $value);
@@ -423,36 +417,42 @@
                 $runtime.sendText(super._cookie, $value);
             }
             break;
+        case 17:
+            {
+                finalValue = $value;
+                $_ngcc_current_state = 16;
+            }
+            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 71:
+        case 634:
             {
                 fa = ((ForeignAttributesImpl)$__result__);
                 $_ngcc_current_state = 8;
             }
             break;
-        case 69:
+        case 632:
             {
                 annotation = ((AnnotationImpl)$__result__);
                 $_ngcc_current_state = 7;
             }
             break;
-        case 65:
+        case 628:
             {
                 result = ((RestrictionSimpleTypeImpl)$__result__);
                 $_ngcc_current_state = 1;
             }
             break;
-        case 66:
+        case 629:
             {
                 result = ((ListSimpleTypeImpl)$__result__);
                 $_ngcc_current_state = 1;
             }
             break;
-        case 60:
+        case 623:
             {
                 result = ((UnionSimpleTypeImpl)$__result__);
                 $_ngcc_current_state = 1;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/wildcardBody.java	Tue Aug  4 10:10:00 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/wildcardBody.java	Tue Aug  4 10:10:00 2009
@@ -78,7 +78,7 @@
         case 10:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 204, null,AnnotationContext.WILDCARD);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 556, null,AnnotationContext.WILDCARD);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -92,14 +92,26 @@
                 revertToParentFromEnterElement(makeResult(), super._cookie, $__uri, $__local, $__qname, $attrs);
             }
             break;
+        case 1:
+            {
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+                else {
+                    $_ngcc_current_state = 0;
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                }
+            }
+            break;
         case 9:
             {
-                if((($ai = $runtime.getAttributeIndex("","namespace"))>=0 || ($ai = $runtime.getAttributeIndex("","processContents"))>=0)) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 202, null);
+                if((($ai = $runtime.getAttributeIndex("","processContents"))>=0 || ($ai = $runtime.getAttributeIndex("","namespace"))>=0)) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 554, null);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 202, null);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 554, null);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
             }
@@ -116,18 +128,6 @@
                 }
             }
             break;
-        case 1:
-            {
-                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-                else {
-                    $_ngcc_current_state = 0;
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
-                }
-            }
-            break;
         default:
             {
                 unexpectedEnterElement($__qname);
@@ -153,14 +153,26 @@
                 revertToParentFromLeaveElement(makeResult(), super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 1:
+            {
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                }
+                else {
+                    $_ngcc_current_state = 0;
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                }
+            }
+            break;
         case 9:
             {
-                if((($ai = $runtime.getAttributeIndex("","namespace"))>=0 || ($ai = $runtime.getAttributeIndex("","processContents"))>=0)) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 202, null);
+                if((($ai = $runtime.getAttributeIndex("","processContents"))>=0 || ($ai = $runtime.getAttributeIndex("","namespace"))>=0)) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 554, null);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 202, null);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 554, null);
                     spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
             }
@@ -177,18 +189,6 @@
                 }
             }
             break;
-        case 1:
-            {
-                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
-                else {
-                    $_ngcc_current_state = 0;
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedLeaveElement($__qname);
@@ -214,14 +214,25 @@
                 revertToParentFromEnterAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
             }
             break;
+        case 1:
+            {
+                if(($__uri.equals("") && $__local.equals("namespace"))) {
+                    $_ngcc_current_state = 3;
+                }
+                else {
+                    $_ngcc_current_state = 0;
+                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
+                }
+            }
+            break;
         case 9:
             {
-                if((($__uri.equals("") && $__local.equals("namespace")) || ($__uri.equals("") && $__local.equals("processContents")))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 202, null);
+                if((($__uri.equals("") && $__local.equals("processContents")) || ($__uri.equals("") && $__local.equals("namespace")))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 554, null);
                     spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 202, null);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 554, null);
                     spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
             }
@@ -237,17 +248,6 @@
                 }
             }
             break;
-        case 1:
-            {
-                if(($__uri.equals("") && $__local.equals("namespace"))) {
-                    $_ngcc_current_state = 3;
-                }
-                else {
-                    $_ngcc_current_state = 0;
-                    $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
-                }
-            }
-            break;
         default:
             {
                 unexpectedEnterAttribute($__qname);
@@ -262,16 +262,6 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 6:
-            {
-                if(($__uri.equals("") && $__local.equals("processContents"))) {
-                    $_ngcc_current_state = 1;
-                }
-                else {
-                    unexpectedLeaveAttribute($__qname);
-                }
-            }
-            break;
         case 10:
             {
                 $_ngcc_current_state = 9;
@@ -283,18 +273,28 @@
                 revertToParentFromLeaveAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 9:
+        case 1:
             {
-                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 202, null);
-                spawnChildFromLeaveAttribute(h, $__uri, $__local, $__qname);
+                $_ngcc_current_state = 0;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 5:
+        case 6:
             {
-                $_ngcc_current_state = 1;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+                if(($__uri.equals("") && $__local.equals("processContents"))) {
+                    $_ngcc_current_state = 1;
+                }
+                else {
+                    unexpectedLeaveAttribute($__qname);
+                }
             }
             break;
+        case 9:
+            {
+                NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 554, null);
+                spawnChildFromLeaveAttribute(h, $__uri, $__local, $__qname);
+            }
+            break;
         case 2:
             {
                 if(($__uri.equals("") && $__local.equals("namespace"))) {
@@ -305,9 +305,9 @@
                 }
             }
             break;
-        case 1:
+        case 5:
             {
-                $_ngcc_current_state = 0;
+                $_ngcc_current_state = 1;
                 $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
@@ -322,12 +322,6 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
-        case 7:
-            {
-                modeValue = $value;
-                $_ngcc_current_state = 6;
-            }
-            break;
         case 10:
             {
                 $_ngcc_current_state = 9;
@@ -339,24 +333,48 @@
                 revertToParentFromText(makeResult(), super._cookie, $value);
             }
             break;
+        case 1:
+            {
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+                else {
+                    $_ngcc_current_state = 0;
+                    $runtime.sendText(super._cookie, $value);
+                }
+            }
+            break;
+        case 3:
+            {
+                ns = $value;
+                $_ngcc_current_state = 2;
+            }
+            break;
         case 9:
             {
-                if(($ai = $runtime.getAttributeIndex("","processContents"))>=0) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 202, null);
+                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 554, null);
                     spawnChildFromText(h, $value);
                 }
                 else {
-                    if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
-                        NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 202, null);
+                    if(($ai = $runtime.getAttributeIndex("","processContents"))>=0) {
+                        NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 554, null);
                         spawnChildFromText(h, $value);
                     }
                     else {
-                        NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 202, null);
+                        NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 554, null);
                         spawnChildFromText(h, $value);
                     }
                 }
             }
             break;
+        case 7:
+            {
+                modeValue = $value;
+                $_ngcc_current_state = 6;
+            }
+            break;
         case 5:
             {
                 if(($ai = $runtime.getAttributeIndex("","processContents"))>=0) {
@@ -369,36 +387,18 @@
                 }
             }
             break;
-        case 1:
-            {
-                if(($ai = $runtime.getAttributeIndex("","namespace"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-                else {
-                    $_ngcc_current_state = 0;
-                    $runtime.sendText(super._cookie, $value);
-                }
-            }
-            break;
-        case 3:
-            {
-                ns = $value;
-                $_ngcc_current_state = 2;
-            }
-            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 204:
+        case 556:
             {
                 annotation = ((AnnotationImpl)$__result__);
                 $_ngcc_current_state = 9;
             }
             break;
-        case 202:
+        case 554:
             {
                 fa = ((ForeignAttributesImpl)$__result__);
                 $_ngcc_current_state = 5;
@@ -408,7 +408,7 @@
     }
 
     public boolean accepted() {
-        return((($_ngcc_current_state == 1) || (($_ngcc_current_state == 5) || ($_ngcc_current_state == 0))));
+        return((($_ngcc_current_state == 5) || (($_ngcc_current_state == 1) || ($_ngcc_current_state == 0))));
     }
 
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/xpath.java	Tue Aug  4 10:10:03 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/parser/state/xpath.java	Tue Aug  4 10:10:02 2009
@@ -70,16 +70,11 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 5:
             {
-                revertToParentFromEnterElement(makeResult(), super._cookie, $__uri, $__local, $__qname, $attrs);
-            }
-            break;
-        case 6:
-            {
-                if((($ai = $runtime.getAttributeIndex("","xpath"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 657, null);
-                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
+                if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -89,7 +84,7 @@
         case 1:
             {
                 if(($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation"))) {
-                    NGCCHandler h = new annotation(this, super._source, $runtime, 652, null,AnnotationContext.XPATH);
+                    NGCCHandler h = new annotation(this, super._source, $runtime, 158, null,AnnotationContext.XPATH);
                     spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
@@ -98,11 +93,16 @@
                 }
             }
             break;
-        case 5:
+        case 0:
             {
-                if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendEnterElement(super._cookie, $__uri, $__local, $__qname, $attrs);
+                revertToParentFromEnterElement(makeResult(), super._cookie, $__uri, $__local, $__qname, $attrs);
+            }
+            break;
+        case 6:
+            {
+                if((($ai = $runtime.getAttributeIndex("","xpath"))>=0 && ($__uri.equals("http://www.w3.org/2001/XMLSchema") && $__local.equals("annotation")))) {
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 163, null);
+                    spawnChildFromEnterElement(h, $__uri, $__local, $__qname, $attrs);
                 }
                 else {
                     unexpectedEnterElement($__qname);
@@ -123,16 +123,11 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 5:
             {
-                revertToParentFromLeaveElement(makeResult(), super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 6:
-            {
                 if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 657, null);
-                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -145,11 +140,16 @@
                 $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 5:
+        case 0:
             {
+                revertToParentFromLeaveElement(makeResult(), super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 6:
+            {
                 if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendLeaveElement(super._cookie, $__uri, $__local, $__qname);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 163, null);
+                    spawnChildFromLeaveElement(h, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedLeaveElement($__qname);
@@ -170,16 +170,10 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
-        case 0:
+        case 5:
             {
-                revertToParentFromEnterAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
-        case 6:
-            {
                 if(($__uri.equals("") && $__local.equals("xpath"))) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 657, null);
-                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
+                    $_ngcc_current_state = 4;
                 }
                 else {
                     unexpectedEnterAttribute($__qname);
@@ -192,10 +186,16 @@
                 $runtime.sendEnterAttribute(super._cookie, $__uri, $__local, $__qname);
             }
             break;
-        case 5:
+        case 0:
             {
+                revertToParentFromEnterAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
+        case 6:
+            {
                 if(($__uri.equals("") && $__local.equals("xpath"))) {
-                    $_ngcc_current_state = 4;
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 163, null);
+                    spawnChildFromEnterAttribute(h, $__uri, $__local, $__qname);
                 }
                 else {
                     unexpectedEnterAttribute($__qname);
@@ -216,6 +216,12 @@
         $localName = $__local;
         $qname = $__qname;
         switch($_ngcc_current_state) {
+        case 1:
+            {
+                $_ngcc_current_state = 0;
+                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
+            }
+            break;
         case 0:
             {
                 revertToParentFromLeaveAttribute(makeResult(), super._cookie, $__uri, $__local, $__qname);
@@ -231,12 +237,6 @@
                 }
             }
             break;
-        case 1:
-            {
-                $_ngcc_current_state = 0;
-                $runtime.sendLeaveAttribute(super._cookie, $__uri, $__local, $__qname);
-            }
-            break;
         default:
             {
                 unexpectedLeaveAttribute($__qname);
@@ -248,6 +248,20 @@
     public void text(String $value) throws SAXException {
         int $ai;
         switch($_ngcc_current_state) {
+        case 5:
+            {
+                if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
+                    $runtime.consumeAttribute($ai);
+                    $runtime.sendText(super._cookie, $value);
+                }
+            }
+            break;
+        case 1:
+            {
+                $_ngcc_current_state = 0;
+                $runtime.sendText(super._cookie, $value);
+            }
+            break;
         case 4:
             {
                 xpath = $value;
@@ -262,40 +276,26 @@
         case 6:
             {
                 if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
-                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 657, null);
+                    NGCCHandler h = new foreignAttributes(this, super._source, $runtime, 163, null);
                     spawnChildFromText(h, $value);
                 }
             }
             break;
-        case 1:
-            {
-                $_ngcc_current_state = 0;
-                $runtime.sendText(super._cookie, $value);
-            }
-            break;
-        case 5:
-            {
-                if(($ai = $runtime.getAttributeIndex("","xpath"))>=0) {
-                    $runtime.consumeAttribute($ai);
-                    $runtime.sendText(super._cookie, $value);
-                }
-            }
-            break;
         }
     }
 
     public void onChildCompleted(Object $__result__, int $__cookie__, boolean $__needAttCheck__)throws SAXException {
         switch($__cookie__) {
-        case 657:
+        case 158:
             {
-                fa = ((ForeignAttributesImpl)$__result__);
-                $_ngcc_current_state = 5;
+                ann = ((AnnotationImpl)$__result__);
+                $_ngcc_current_state = 0;
             }
             break;
-        case 652:
+        case 163:
             {
-                ann = ((AnnotationImpl)$__result__);
-                $_ngcc_current_state = 0;
+                fa = ((ForeignAttributesImpl)$__result__);
+                $_ngcc_current_state = 5;
             }
             break;
         }
@@ -302,7 +302,7 @@
     }
 
     public boolean accepted() {
-        return((($_ngcc_current_state == 1) || ($_ngcc_current_state == 0)));
+        return((($_ngcc_current_state == 0) || ($_ngcc_current_state == 1)));
     }
 
 
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/scd/AbstractAxisImpl.java	Tue Aug  4 10:10:05 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/scd/AbstractAxisImpl.java	Tue Aug  4 10:10:05 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl.scd;
 
 import com.sun.xml.internal.xsom.XSAnnotation;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/scd/Axis.java	Tue Aug  4 10:10:08 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/scd/Axis.java	Tue Aug  4 10:10:07 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl.scd;
 
 import com.sun.xml.internal.xsom.XSAttContainer;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/scd/Iterators.java	Tue Aug  4 10:10:10 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/scd/Iterators.java	Tue Aug  4 10:10:10 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl.scd;
 
 import java.util.Iterator;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/scd/ParseException.java	Tue Aug  4 10:10:13 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/scd/ParseException.java	Tue Aug  4 10:10:12 2009
@@ -25,6 +25,8 @@
 /* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
 package com.sun.xml.internal.xsom.impl.scd;
 
+import java.util.List;
+
 /**
  * This exception is thrown when parse errors are encountered.
  * You can explicitly create objects of this exception type by
@@ -50,7 +52,7 @@
    */
   public ParseException(Token currentTokenVal,
                         int[][] expectedTokenSequencesVal,
-                        String[] tokenImageVal
+                        List<String> tokenImageVal
                        )
   {
     super("");
@@ -106,7 +108,7 @@
    * parser within which the parse error occurred.  This array is
    * defined in the generated ...Constants interface.
    */
-  public String[] tokenImage;
+  public List<String> tokenImage;
 
   /**
    * This method has the standard behavior when this object has been
@@ -129,7 +131,7 @@
         maxSize = expectedTokenSequences[i].length;
       }
       for (int j = 0; j < expectedTokenSequences[i].length; j++) {
-        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(" ");
+        expected.append(tokenImage.get(expectedTokenSequences[i][j])).append(" ");
       }
       if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
         expected.append("...");
@@ -141,7 +143,7 @@
     for (int i = 0; i < maxSize; i++) {
       if (i != 0) retval += " ";
       if (tok.kind == 0) {
-        retval += tokenImage[0];
+        retval += tokenImage.get(0);
         break;
       }
       retval += add_escapes(tok.image);
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/scd/SCDImpl.java	Tue Aug  4 10:10:15 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/scd/SCDImpl.java	Tue Aug  4 10:10:15 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl.scd;
 
 import com.sun.xml.internal.xsom.SCD;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/scd/SCDParserConstants.java	Tue Aug  4 10:10:18 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/scd/SCDParserConstants.java	Tue Aug  4 10:10:17 2009
@@ -25,6 +25,10 @@
 /* Generated By:JavaCC: Do not edit this line. SCDParserConstants.java */
 package com.sun.xml.internal.xsom.impl.scd;
 
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
 public interface SCDParserConstants {
 
   int EOF = 0;
@@ -40,54 +44,55 @@
 
   int DEFAULT = 0;
 
-  String[] tokenImage = {
-    "<EOF>",
-    "\" \"",
-    "\"\\t\"",
-    "\"\\n\"",
-    "\"\\r\"",
-    "\"\\f\"",
-    "<Letter>",
-    "<BaseChar>",
-    "<Ideographic>",
-    "<CombiningChar>",
-    "<UnicodeDigit>",
-    "<Extender>",
-    "<NCNAME>",
-    "<NUMBER>",
-    "<FACETNAME>",
-    "\":\"",
-    "\"/\"",
-    "\"//\"",
-    "\"attribute::\"",
-    "\"@\"",
-    "\"element::\"",
-    "\"substitutionGroup::\"",
-    "\"type::\"",
-    "\"~\"",
-    "\"baseType::\"",
-    "\"primitiveType::\"",
-    "\"itemType::\"",
-    "\"memberType::\"",
-    "\"scope::\"",
-    "\"attributeGroup::\"",
-    "\"group::\"",
-    "\"identityContraint::\"",
-    "\"key::\"",
-    "\"notation::\"",
-    "\"model::sequence\"",
-    "\"model::choice\"",
-    "\"model::all\"",
-    "\"model::*\"",
-    "\"any::*\"",
-    "\"anyAttribute::*\"",
-    "\"facet::*\"",
-    "\"facet::\"",
-    "\"component::*\"",
-    "\"x-schema::\"",
-    "\"x-schema::*\"",
-    "\"*\"",
-    "\"0\"",
-  };
+  static final List<String> tokenImage = Collections.unmodifiableList(Arrays.asList(
 
-}
+       new String[] {
+         "<EOF>",
+         "\" \"",
+         "\"\\t\"",
+         "\"\\n\"",
+         "\"\\r\"",
+         "\"\\f\"",
+         "<Letter>",
+         "<BaseChar>",
+         "<Ideographic>",
+         "<CombiningChar>",
+         "<UnicodeDigit>",
+         "<Extender>",
+         "<NCNAME>",
+         "<NUMBER>",
+         "<FACETNAME>",
+         "\":\"",
+         "\"/\"",
+         "\"//\"",
+         "\"attribute::\"",
+         "\"@\"",
+         "\"element::\"",
+         "\"substitutionGroup::\"",
+         "\"type::\"",
+         "\"~\"",
+         "\"baseType::\"",
+         "\"primitiveType::\"",
+         "\"itemType::\"",
+         "\"memberType::\"",
+         "\"scope::\"",
+         "\"attributeGroup::\"",
+         "\"group::\"",
+         "\"identityContraint::\"",
+         "\"key::\"",
+         "\"notation::\"",
+         "\"model::sequence\"",
+         "\"model::choice\"",
+         "\"model::all\"",
+         "\"model::*\"",
+         "\"any::*\"",
+         "\"anyAttribute::*\"",
+         "\"facet::*\"",
+         "\"facet::\"",
+         "\"component::*\"",
+         "\"x-schema::\"",
+         "\"x-schema::*\"",
+         "\"*\"",
+         "\"0\"",
+       }));
+  }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/scd/Step.java	Tue Aug  4 10:10:20 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/scd/Step.java	Tue Aug  4 10:10:19 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl.scd;
 
 import com.sun.xml.internal.xsom.XSComponent;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/util/DraconianErrorHandler.java	Tue Aug  4 10:10:22 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/util/DraconianErrorHandler.java	Tue Aug  4 10:10:22 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl.util;
 
 import org.xml.sax.ErrorHandler;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/util/ResourceEntityResolver.java	Tue Aug  4 10:10:24 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/util/ResourceEntityResolver.java	Tue Aug  4 10:10:24 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl.util;
 
 import org.xml.sax.EntityResolver;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/util/SchemaTreeTraverser.java	Tue Aug  4 10:10:27 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/util/SchemaTreeTraverser.java	Tue Aug  4 10:10:27 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.impl.util;
 
 import com.sun.xml.internal.xsom.XSAnnotation;
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/util/SchemaWriter.java	Tue Aug  4 10:10:30 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/util/SchemaWriter.java	Tue Aug  4 10:10:29 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.impl.util;
 
 import com.sun.xml.internal.xsom.XSAnnotation;
@@ -46,10 +48,14 @@
 import com.sun.xml.internal.xsom.XSUnionSimpleType;
 import com.sun.xml.internal.xsom.XSWildcard;
 import com.sun.xml.internal.xsom.XSXPath;
+import com.sun.xml.internal.xsom.XSWildcard.Any;
+import com.sun.xml.internal.xsom.XSWildcard.Other;
+import com.sun.xml.internal.xsom.XSWildcard.Union;
 import com.sun.xml.internal.xsom.impl.Const;
 import com.sun.xml.internal.xsom.visitor.XSSimpleTypeVisitor;
 import com.sun.xml.internal.xsom.visitor.XSTermVisitor;
 import com.sun.xml.internal.xsom.visitor.XSVisitor;
+import com.sun.xml.internal.xsom.visitor.XSWildcardFunction;
 
 import java.io.IOException;
 import java.io.Writer;
@@ -124,10 +130,7 @@
         if(s.getTargetNamespace().equals(Const.schemaNamespace))
             return;
 
-        println(MessageFormat.format("<schema targetNamespace=\"{0}\">",
-            new Object[]{
-                s.getTargetNamespace(),
-            }));
+        println(MessageFormat.format("<schema targetNamespace=\"{0}\">", s.getTargetNamespace()));
         indent++;
 
         Iterator itr;
@@ -163,8 +166,7 @@
     public void attGroupDecl( XSAttGroupDecl decl ) {
         Iterator itr;
 
-        println(MessageFormat.format("<attGroup name=\"{0}\">",
-            new Object[]{ decl.getName() }));
+        println(MessageFormat.format("<attGroup name=\"{0}\">", decl.getName()));
         indent++;
 
         // TODO: wildcard
@@ -182,8 +184,7 @@
     }
 
     public void dumpRef( XSAttGroupDecl decl ) {
-        println(MessageFormat.format("<attGroup ref=\"'{'{0}'}'{1}\"/>",
-            new Object[]{ decl.getTargetNamespace(), decl.getName() }));
+        println(MessageFormat.format("<attGroup ref=\"'{'{0}'}'{1}\"/>", decl.getTargetNamespace(), decl.getName()));
     }
 
     public void attributeUse( XSAttributeUse use ) {
@@ -204,8 +205,7 @@
         } else {
             // reference to a global one
             println(MessageFormat.format("<attribute ref=\"'{'{0}'}'{1}{2}\"/>",
-                new Object[]{ decl.getTargetNamespace(), decl.getName(),
-                    additionalAtts }));
+                decl.getTargetNamespace(), decl.getName(), additionalAtts));
         }
     }
 
@@ -217,21 +217,15 @@
         XSSimpleType type=decl.getType();
 
         println(MessageFormat.format("<attribute name=\"{0}\"{1}{2}{3}{4}{5}>",
-            new Object[]{
-                decl.getName(),
-                additionalAtts,
-                type.isLocal()?"":
-                MessageFormat.format(" type=\"'{'{0}'}'{1}\"",
-                new Object[]{
-                    type.getTargetNamespace(),
-                    type.getName()
-                }),
-                decl.getFixedValue()==null ?
-                    "":" fixed=\""+decl.getFixedValue()+'\"',
-                decl.getDefaultValue()==null ?
-                    "":" default=\""+decl.getDefaultValue()+'\"',
-                type.isLocal()?"":" /"
-            }));
+            decl.getName(),
+            additionalAtts,
+            type.isLocal()?"":
+                MessageFormat.format(" type=\"'{'{0}'}'{1}\"", type.getTargetNamespace(), type.getName()),
+            decl.getFixedValue()==null ?
+                "":" fixed=\""+decl.getFixedValue()+'\"',
+            decl.getDefaultValue()==null ?
+                "":" default=\""+decl.getDefaultValue()+'\"',
+            type.isLocal()?"":" /"));
 
         if(type.isLocal()) {
             indent++;
@@ -242,10 +236,7 @@
     }
 
     public void simpleType( XSSimpleType type ) {
-        println(MessageFormat.format("<simpleType{0}>",
-            new Object[]{
-                type.isLocal()?"":" name=\""+type.getName()+'\"'
-            }));
+        println(MessageFormat.format("<simpleType{0}>", type.isLocal()?"":" name=\""+type.getName()+'\"'));
         indent++;
 
         type.visit((XSSimpleTypeVisitor)this);
@@ -266,10 +257,7 @@
         } else {
             // global type
             println(MessageFormat.format("<list itemType=\"'{'{0}'}'{1}\" />",
-                new Object[]{
-                    itemType.getTargetNamespace(),
-                    itemType.getName()
-                }));
+                itemType.getTargetNamespace(), itemType.getName()));
         }
     }
 
@@ -280,8 +268,7 @@
         for( int i=0; i<len; i++ ) {
             XSSimpleType member = type.getMember(i);
             if(member.isGlobal())
-                ref.append(MessageFormat.format(" '{'{0}'}'{1}",
-                    new Object[]{member.getTargetNamespace(),member.getName()}));
+                ref.append(MessageFormat.format(" '{'{0}'}'{1}", member.getTargetNamespace(),member.getName()));
         }
 
         if(ref.length()==0)
@@ -313,11 +300,9 @@
         XSSimpleType baseType = type.getSimpleBaseType();
 
         println(MessageFormat.format("<restriction{0}>",
-            new Object[]{
-                baseType.isLocal()?"":" base=\"{"+
-                baseType.getTargetNamespace()+'}'+
-                baseType.getName()+'\"'
-            }));
+            baseType.isLocal()?"":" base=\"{"+
+            baseType.getTargetNamespace()+'}'+
+            baseType.getName()+'\"'));
         indent++;
 
         if(baseType.isLocal())
@@ -333,17 +318,12 @@
 
     public void facet( XSFacet facet ) {
         println(MessageFormat.format("<{0} value=\"{1}\"/>",
-            new Object[]{
-                facet.getName(), facet.getValue(),
-            }));
+            facet.getName(), facet.getValue()));
     }
 
     public void notation( XSNotation notation ) {
         println(MessageFormat.format("<notation name='\"0}\" public =\"{1}\" system=\"{2}\" />",
-            new Object[] {
-                notation.getName(),
-                notation.getPublicId(),
-                notation.getSystemId() } ));
+            notation.getName(), notation.getPublicId(), notation.getSystemId()));
     }
 
 
@@ -350,9 +330,7 @@
 
     public void complexType( XSComplexType type ) {
         println(MessageFormat.format("<complexType{0}>",
-            new Object[]{
-                type.isLocal()?"":" name=\""+type.getName()+'\"'
-            }));
+            type.isLocal()?"":" name=\""+type.getName()+'\"'));
         indent++;
 
         // TODO: wildcard
@@ -367,9 +345,7 @@
             if(type.getDerivationMethod()==XSType.RESTRICTION) {
                 // restriction
                 println(MessageFormat.format("<restriction base=\"<{0}>{1}\">",
-                    new Object[]{
-                        baseType.getTargetNamespace(),
-                        baseType.getName() }));
+                    baseType.getTargetNamespace(), baseType.getName()));
                 indent++;
 
                 dumpComplexTypeAttribute(type);
@@ -379,9 +355,7 @@
             } else {
                 // extension
                 println(MessageFormat.format("<extension base=\"<{0}>{1}\">",
-                    new Object[]{
-                        baseType.getTargetNamespace(),
-                        baseType.getName() }));
+                    baseType.getTargetNamespace(), baseType.getName()));
 
                 // check if have redefine tag - Kirill
                 if( type.isGlobal()
@@ -416,9 +390,7 @@
             if(type.getDerivationMethod()==XSType.RESTRICTION) {
                 // restriction
                 println(MessageFormat.format("<restriction base=\"'{'{0}'}'{1}\">",
-                    new Object[]{
-                        baseType.getTargetNamespace(),
-                        baseType.getName() }));
+                    baseType.getTargetNamespace(), baseType.getName()));
                 indent++;
 
                 type.getContentType().visit(this);
@@ -429,9 +401,7 @@
             } else {
                 // extension
                 println(MessageFormat.format("<extension base=\"'{'{0}'}'{1}\">",
-                    new Object[]{
-                        baseType.getTargetNamespace(),
-                        baseType.getName() }));
+                    baseType.getTargetNamespace(), baseType.getName()));
 
                 // check if have redefine - Kirill
                 if( type.isGlobal()
@@ -473,6 +443,10 @@
         itr = type.iterateDeclaredAttributeUses();
         while(itr.hasNext())
             attributeUse( (XSAttributeUse)itr.next() );
+
+        XSWildcard awc = type.getAttributeWildcard();
+        if(awc!=null)
+            wildcard("anyAttribute",awc,"");
     }
 
     public void elementDecl( XSElementDecl decl ) {
@@ -483,15 +457,18 @@
 
         // TODO: various other attributes
 
+        // qualified attr; Issue
+        if(decl.getForm() != null) {
+            extraAtts += " form=\"" + (decl.getForm() ? "qualified" : "unqualified" ) + "\"";
+        }
+
         println(MessageFormat.format("<element name=\"{0}\"{1}{2}{3}>",
-            new Object[]{
-                decl.getName(),
-                type.isLocal()?"":" type=\"{"+
-                    type.getTargetNamespace()+'}'+
-                    type.getName()+'\"',
-                extraAtts,
-                type.isLocal()?"":"/"
-            }));
+            decl.getName(),
+            type.isLocal()?"":" type=\"{"+
+            type.getTargetNamespace()+'}'+
+            type.getName()+'\"',
+            extraAtts,
+            type.isLocal()?"":"/"));
 
         if(type.isLocal()) {
             indent++;
@@ -504,10 +481,7 @@
     }
 
     public void modelGroupDecl( XSModelGroupDecl decl ) {
-        println(MessageFormat.format("<group name=\"{0}\">",
-            new Object[]{
-                decl.getName()
-            }));
+        println(MessageFormat.format("<group name=\"{0}\">", decl.getName()));
         indent++;
 
         modelGroup(decl.getModelGroup());
@@ -520,8 +494,7 @@
         modelGroup(group,"");
     }
     private void modelGroup( XSModelGroup group, String extraAtts ) {
-        println(MessageFormat.format("<{0}{1}>",
-            new Object[]{ group.getCompositor(), extraAtts }));
+        println(MessageFormat.format("<{0}{1}>", group.getCompositor(), extraAtts));
         indent++;
 
         final int len = group.getSize();
@@ -529,8 +502,7 @@
             particle(group.getChild(i));
 
         indent--;
-        println(MessageFormat.format("</{0}>",
-            new Object[]{ group.getCompositor() }));
+        println(MessageFormat.format("</{0}>", group.getCompositor()));
     }
 
     public void particle( XSParticle part ) {
@@ -542,11 +514,11 @@
         if(i==XSParticle.UNBOUNDED)
             buf.append(" maxOccurs=\"unbounded\"");
         else if(i!=1)
-            buf.append(" maxOccurs=\""+i+'\"');
+            buf.append(" maxOccurs=\"").append(i).append('\"');
 
         i = part.getMinOccurs();
         if(i!=1)
-            buf.append(" minOccurs=\""+i+'\"');
+            buf.append(" minOccurs=\"").append(i).append('\"');
 
         final String extraAtts = buf.toString();
 
@@ -557,40 +529,68 @@
                 else {
                     // reference
                     println(MessageFormat.format("<element ref=\"'{'{0}'}'{1}\"{2}/>",
-                        new Object[]{
-                            decl.getTargetNamespace(),
-                            decl.getName(),
-                            extraAtts
-                        }));
+                        decl.getTargetNamespace(),
+                        decl.getName(),
+                        extraAtts));
                 }
             }
             public void modelGroupDecl( XSModelGroupDecl decl ) {
                 // reference
                 println(MessageFormat.format("<group ref=\"'{'{0}'}'{1}\"{2}/>",
-                    new Object[]{
-                        decl.getTargetNamespace(),
-                        decl.getName(),
-                        extraAtts
-                    }));
+                    decl.getTargetNamespace(),
+                    decl.getName(),
+                    extraAtts));
             }
             public void modelGroup( XSModelGroup group ) {
                 SchemaWriter.this.modelGroup(group,extraAtts);
             }
             public void wildcard( XSWildcard wc ) {
-                SchemaWriter.this.wildcard(wc,extraAtts);
+                SchemaWriter.this.wildcard("any",wc,extraAtts);
             }
         });
     }
 
     public void wildcard( XSWildcard wc ) {
-        wildcard(wc,"");
+        wildcard("any",wc,"");
     }
 
-    private void wildcard( XSWildcard wc, String extraAtts ) {
-        // TODO
-        println(MessageFormat.format("<any/>", new Object[]{extraAtts}));
+    private void wildcard( String tagName, XSWildcard wc, String extraAtts ) {
+        final String proessContents;
+        switch(wc.getMode()) {
+        case XSWildcard.LAX:
+            proessContents = " processContents='lax'";break;
+        case XSWildcard.STRTICT:
+            proessContents = "";break;
+        case XSWildcard.SKIP:
+            proessContents = " processContents='skip'";break;
+        default:
+            throw new AssertionError();
+        }
+
+        println(MessageFormat.format("<{0}{1}{2}{3}/>",tagName, proessContents, wc.apply(WILDCARD_NS), extraAtts));
     }
 
+    private static final XSWildcardFunction<String> WILDCARD_NS = new XSWildcardFunction<String>() {
+        public String any(Any wc) {
+            return ""; // default
+        }
+
+        public String other(Other wc) {
+            return " namespace='##other'";
+        }
+
+        public String union(Union wc) {
+            StringBuffer buf = new StringBuffer(" namespace='");
+            boolean first = true;
+            for (String s : wc.getNamespaces()) {
+                if(first)   first=false;
+                else        buf.append(' ');
+                buf.append(s);
+            }
+            return buf.append('\'').toString();
+        }
+    };
+
     public void annotation( XSAnnotation ann ) {
         // TODO: it would be nice even if we just put <xs:documentation>
     }
--- old/src/share/classes/com/sun/xml/internal/xsom/impl/util/Uri.java	Tue Aug  4 10:10:32 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/impl/util/Uri.java	Tue Aug  4 10:10:32 2009
@@ -1,28 +1,4 @@
 /*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-/*
 Copyright (c) 2001, 2002 Thai Open Source Software Center Ltd
 All rights reserved.
 
--- old/src/share/classes/com/sun/xml/internal/xsom/parser/AnnotationContext.java	Tue Aug  4 10:10:35 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/parser/AnnotationContext.java	Tue Aug  4 10:10:35 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.parser;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/parser/AnnotationParser.java	Tue Aug  4 10:10:38 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/parser/AnnotationParser.java	Tue Aug  4 10:10:38 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.parser;
 
 import org.xml.sax.ContentHandler;
--- old/src/share/classes/com/sun/xml/internal/xsom/parser/AnnotationParserFactory.java	Tue Aug  4 10:10:40 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/parser/AnnotationParserFactory.java	Tue Aug  4 10:10:40 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.parser;
 
 /**
--- old/src/share/classes/com/sun/xml/internal/xsom/parser/JAXPParser.java	Tue Aug  4 10:10:43 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/parser/JAXPParser.java	Tue Aug  4 10:10:42 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.parser;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/xsom/parser/SchemaDocument.java	Tue Aug  4 10:10:45 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/parser/SchemaDocument.java	Tue Aug  4 10:10:45 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.parser;
 
 import com.sun.xml.internal.xsom.XSSchema;
--- old/src/share/classes/com/sun/xml/internal/xsom/parser/XMLParser.java	Tue Aug  4 10:10:48 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/parser/XMLParser.java	Tue Aug  4 10:10:48 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.parser;
 
 import java.io.IOException;
--- old/src/share/classes/com/sun/xml/internal/xsom/parser/XSOMParser.java	Tue Aug  4 10:10:50 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/parser/XSOMParser.java	Tue Aug  4 10:10:50 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.parser;
 
 import java.io.File;
--- old/src/share/classes/com/sun/xml/internal/xsom/parser/package.html	Tue Aug  4 10:10:54 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/parser/package.html	Tue Aug  4 10:10:53 2009
@@ -23,5 +23,5 @@
  have any questions.
 -->
 <html><body>
-Classes to parse XML Schema documents into objects of <code>com.sun.xml.xsom</code> package.
+Classes to parse XML Schema documents into objects of <code>com.sun.xml.internal.xsom</code> package.
 </body></html>
--- old/src/share/classes/com/sun/xml/internal/xsom/util/ComponentNameFunction.java	Tue Aug  4 10:10:57 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/util/ComponentNameFunction.java	Tue Aug  4 10:10:57 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.util;
 
 import com.sun.xml.internal.xsom.XSAnnotation;
@@ -47,7 +48,6 @@
  * Extract the name of the components.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.4 $
  */
 public class ComponentNameFunction implements XSFunction<String> {
 
--- old/src/share/classes/com/sun/xml/internal/xsom/util/DeferedCollection.java	Tue Aug  4 10:11:00 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/util/DeferedCollection.java	Tue Aug  4 10:10:59 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.util;
 
 import java.util.ArrayList;
--- old/src/share/classes/com/sun/xml/internal/xsom/util/DomAnnotationParserFactory.java	Tue Aug  4 10:11:02 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/util/DomAnnotationParserFactory.java	Tue Aug  4 10:11:02 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.util;
 
 import com.sun.xml.internal.xsom.XSAnnotation;
--- old/src/share/classes/com/sun/xml/internal/xsom/util/NameGetter.java	Tue Aug  4 10:11:06 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/util/NameGetter.java	Tue Aug  4 10:11:05 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.util;
 
 import java.util.Locale;
--- old/src/share/classes/com/sun/xml/internal/xsom/util/NameGetter.properties	Tue Aug  4 10:11:09 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/util/NameGetter.properties	Tue Aug  4 10:11:09 2009
@@ -23,21 +23,20 @@
 # have any questions.
 #
 
-annotation		= annotation
-attGroupDecl	= attribute group declaration
-attributeDecl	= attribute declaration
-attributeUse	= attribute use
-complexType		= complex type
-schema			= schema
-facet			= facet
-simpleType		= simple type
-particle		= particle
-empty			= empty content model
-wildcard		= wildcard
-modelGroupDecl	= model group declaration
-modelGroup		= model group
-elementDecl		= element declaration
-notation		= notation declaration
+annotation              = annotation
+attGroupDecl    = attribute group declaration
+attributeDecl   = attribute declaration
+attributeUse    = attribute use
+complexType             = complex type
+schema                  = schema
+facet                   = facet
+simpleType              = simple type
+particle                = particle
+empty                   = empty content model
+wildcard                = wildcard
+modelGroupDecl  = model group declaration
+modelGroup              = model group
+elementDecl             = element declaration
+notation                = notation declaration
 idConstraint    = identity constraint
 xpath           = xpath
- 
--- old/src/share/classes/com/sun/xml/internal/xsom/util/SimpleTypeSet.java	Tue Aug  4 10:11:13 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/util/SimpleTypeSet.java	Tue Aug  4 10:11:12 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.util;
 
 import java.util.Set;
--- old/src/share/classes/com/sun/xml/internal/xsom/util/TypeClosure.java	Tue Aug  4 10:11:16 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/util/TypeClosure.java	Tue Aug  4 10:11:15 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.util;
 
 import com.sun.xml.internal.xsom.XSType;
--- old/src/share/classes/com/sun/xml/internal/xsom/util/TypeSet.java	Tue Aug  4 10:11:18 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/util/TypeSet.java	Tue Aug  4 10:11:18 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.util;
 
 import com.sun.xml.internal.xsom.XSType;
--- old/src/share/classes/com/sun/xml/internal/xsom/util/XSFinder.java	Tue Aug  4 10:11:21 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/util/XSFinder.java	Tue Aug  4 10:11:20 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.util;
 
 import com.sun.xml.internal.xsom.XSAnnotation;
--- old/src/share/classes/com/sun/xml/internal/xsom/util/XSFunctionFilter.java	Tue Aug  4 10:11:23 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/util/XSFunctionFilter.java	Tue Aug  4 10:11:23 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.util;
 
 import com.sun.xml.internal.xsom.XSAnnotation;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/XSContentTypeFunction.java	Tue Aug  4 10:11:26 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/XSContentTypeFunction.java	Tue Aug  4 10:11:25 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.visitor;
 
 import com.sun.xml.internal.xsom.XSContentType;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/XSContentTypeVisitor.java	Tue Aug  4 10:11:28 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/XSContentTypeVisitor.java	Tue Aug  4 10:11:28 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.visitor;
 
 import com.sun.xml.internal.xsom.XSContentType;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/XSFunction.java	Tue Aug  4 10:11:30 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/XSFunction.java	Tue Aug  4 10:11:30 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.visitor;
 
 import com.sun.xml.internal.xsom.XSAnnotation;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/XSSimpleTypeFunction.java	Tue Aug  4 10:11:33 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/XSSimpleTypeFunction.java	Tue Aug  4 10:11:32 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.visitor;
 
 import com.sun.xml.internal.xsom.XSListSimpleType;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/XSSimpleTypeVisitor.java	Tue Aug  4 10:11:35 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/XSSimpleTypeVisitor.java	Tue Aug  4 10:11:35 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.visitor;
 
 import com.sun.xml.internal.xsom.XSListSimpleType;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/XSTermFunction.java	Tue Aug  4 10:11:37 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/XSTermFunction.java	Tue Aug  4 10:11:37 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.visitor;
 
 import com.sun.xml.internal.xsom.XSElementDecl;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/XSTermFunctionWithParam.java	Tue Aug  4 10:11:40 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/XSTermFunctionWithParam.java	Tue Aug  4 10:11:39 2009
@@ -22,6 +22,7 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
 package com.sun.xml.internal.xsom.visitor;
 
 import com.sun.xml.internal.xsom.XSWildcard;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/XSTermVisitor.java	Tue Aug  4 10:11:42 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/XSTermVisitor.java	Tue Aug  4 10:11:42 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.visitor;
 
 import com.sun.xml.internal.xsom.XSElementDecl;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/XSVisitor.java	Tue Aug  4 10:11:45 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/XSVisitor.java	Tue Aug  4 10:11:44 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.visitor;
 
 import com.sun.xml.internal.xsom.XSAnnotation;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/XSWildcardFunction.java	Tue Aug  4 10:11:47 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/XSWildcardFunction.java	Tue Aug  4 10:11:47 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.visitor;
 
 import com.sun.xml.internal.xsom.XSWildcard;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/XSWildcardVisitor.java	Tue Aug  4 10:11:49 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/XSWildcardVisitor.java	Tue Aug  4 10:11:49 2009
@@ -22,6 +22,8 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+
+
 package com.sun.xml.internal.xsom.visitor;
 
 import com.sun.xml.internal.xsom.XSWildcard;
--- old/src/share/classes/com/sun/xml/internal/xsom/visitor/package.html	Tue Aug  4 10:11:52 2009
+++ new/src/share/classes/com/sun/xml/internal/xsom/visitor/package.html	Tue Aug  4 10:11:51 2009
@@ -23,5 +23,5 @@
  have any questions.
 -->
 <html><body>
-Visitor pattern support for the <code>com.sun.xml.xsom</code> interfaces.
+Visitor pattern support for the <code>com.sun.xml.internal.xsom</code> interfaces.
 </body></html>
--- old/src/share/classes/javax/xml/bind/ContextFinder.java	Tue Aug  4 10:11:54 2009
+++ new/src/share/classes/javax/xml/bind/ContextFinder.java	Tue Aug  4 10:11:54 2009
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -53,7 +53,7 @@
  * This code is designed to implement the JAXB 1.0 spec pluggability feature
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision$
+ * @version $Revision: 1.27.2.1 $
  * @see JAXBContext
  */
 class ContextFinder {
@@ -484,26 +484,29 @@
      * Loads the class, provided that the calling thread has an access to the class being loaded.
      */
     private static Class safeLoadClass(String className, ClassLoader classLoader) throws ClassNotFoundException {
-        logger.fine("Trying to load "+className);
-        try {
-            // make sure that the current thread has an access to the package of the given name.
-            SecurityManager s = System.getSecurityManager();
-            if (s != null) {
-                int i = className.lastIndexOf('.');
-                if (i != -1) {
-                    s.checkPackageAccess(className.substring(0,i));
-                }
-            }
+       logger.fine("Trying to load "+className);
+       try {
+          // make sure that the current thread has an access to the package of the given name.
+          SecurityManager s = System.getSecurityManager();
+          if (s != null) {
+              int i = className.lastIndexOf('.');
+              if (i != -1) {
+                  s.checkPackageAccess(className.substring(0,i));
+              }
+          }
 
-            if (classLoader == null)
-                return Class.forName(className);
-            else
-                return classLoader.loadClass(className);
-        } catch (SecurityException se) {
-            // anyone can access the platform default factory class without permission
-            if (PLATFORM_DEFAULT_FACTORY_CLASS.equals(className))
-                return Class.forName(className);
-            throw se;
-        }
+          if (classLoader == null) {
+              return Class.forName(className);
+          } else {
+              return classLoader.loadClass(className);
+          }
+       } catch (SecurityException se) {
+           // anyone can access the platform default factory class without permission
+           if (PLATFORM_DEFAULT_FACTORY_CLASS.equals(className)) {
+              return Class.forName(className);
+           }
+           throw se;
+       }
     }
+
 }
--- old/src/share/classes/javax/xml/bind/DatatypeConverter.java	Tue Aug  4 10:11:56 2009
+++ new/src/share/classes/javax/xml/bind/DatatypeConverter.java	Tue Aug  4 10:11:56 2009
@@ -85,7 +85,7 @@
  * </p>
  *
  * @author <ul><li>Sekhar Vajjhala, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Ryan Shoemaker,Sun Microsystems Inc.</li></ul>
- * @version $Revision$
+ * @version $Revision: 1.4 $
  * @see DatatypeConverterInterface
  * @see ParseConversionEvent
  * @see PrintConversionEvent
--- old/src/share/classes/javax/xml/bind/DatatypeConverterImpl.java	Tue Aug  4 10:11:59 2009
+++ new/src/share/classes/javax/xml/bind/DatatypeConverterImpl.java	Tue Aug  4 10:11:58 2009
@@ -47,7 +47,7 @@
  * This class is responsible for whitespace normalization.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision$
+ * @version $Revision: 1.1 $
  * @since JAXB2.1
  */
 final class DatatypeConverterImpl implements DatatypeConverterInterface {
--- old/src/share/classes/javax/xml/bind/DatatypeConverterInterface.java	Tue Aug  4 10:12:02 2009
+++ new/src/share/classes/javax/xml/bind/DatatypeConverterInterface.java	Tue Aug  4 10:12:02 2009
@@ -75,7 +75,7 @@
  *
  * <p>
  * @author <ul><li>Sekhar Vajjhala, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Ryan Shoemaker,Sun Microsystems Inc.</li></ul>
- * @version $Revision: 1.4 $
+ * @version $Revision: 1.5 $
  * @see DatatypeConverter
  * @see ParseConversionEvent
  * @see PrintConversionEvent
--- old/src/share/classes/javax/xml/bind/Element.java	Tue Aug  4 10:12:05 2009
+++ new/src/share/classes/javax/xml/bind/Element.java	Tue Aug  4 10:12:05 2009
@@ -35,7 +35,7 @@
  * and 5.7.1 "Bind to Java Element Interface" of the specification.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @since JAXB1.0
  */
 
--- old/src/share/classes/javax/xml/bind/JAXBContext.java	Tue Aug  4 10:12:07 2009
+++ new/src/share/classes/javax/xml/bind/JAXBContext.java	Tue Aug  4 10:12:07 2009
@@ -217,7 +217,7 @@
  * </blockquote>
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.23 $ $Date: 2005/08/31 20:57:57 $
+ * @version $Revision: 1.24 $ $Date: 2006/03/08 17:05:01 $
  * @see Marshaller
  * @see Unmarshaller
  * @see <a href="http://java.sun.com/docs/books/jls">S 7.4.1.1 "Package Annotations" in Java Language Specification, 3rd Edition</a>
--- old/src/share/classes/javax/xml/bind/JAXBException.java	Tue Aug  4 10:12:10 2009
+++ new/src/share/classes/javax/xml/bind/JAXBException.java	Tue Aug  4 10:12:10 2009
@@ -31,7 +31,7 @@
  * This is the root exception class for all JAXB exceptions.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.3 $ $Date: 2004/10/22 15:46:02 $
+ * @version $Revision: 1.1 $ $Date: 2004/12/14 21:50:39 $
  * @see JAXBContext
  * @see Marshaller
  * @see Unmarshaller
--- old/src/share/classes/javax/xml/bind/MarshalException.java	Tue Aug  4 10:12:13 2009
+++ new/src/share/classes/javax/xml/bind/MarshalException.java	Tue Aug  4 10:12:12 2009
@@ -36,7 +36,7 @@
  * ValidationEventHandler.handleEvent(ValidationEvent)}.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see JAXBException
  * @see Marshaller
  * @since JAXB1.0
--- old/src/share/classes/javax/xml/bind/Marshaller.java	Tue Aug  4 10:12:17 2009
+++ new/src/share/classes/javax/xml/bind/Marshaller.java	Tue Aug  4 10:12:16 2009
@@ -310,7 +310,7 @@
  * </blockquote>
  *
  * @author <ul><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision$ $Date$
+ * @version $Revision: 1.21 $ $Date: 2006/08/28 17:56:41 $
  * @see JAXBContext
  * @see Validator
  * @see Unmarshaller
--- old/src/share/classes/javax/xml/bind/Messages.properties	Tue Aug  4 10:12:20 2009
+++ new/src/share/classes/javax/xml/bind/Messages.properties	Tue Aug  4 10:12:19 2009
@@ -24,28 +24,28 @@
 #
 
 ContextFinder.ProviderNotFound = \
-	Provider {0} not found
-	
+        Provider {0} not found
+
 ContextFinder.CouldNotInstantiate = \
-	Provider {0} could not be instantiated: {1}	
+        Provider {0} could not be instantiated: {1}
 
 ContextFinder.CantFindPropertiesFile = \
-	Unable to locate jaxb.properties for package {0}
-	
+        Unable to locate jaxb.properties for package {0}
+
 ContextFinder.CantMixProviders = \
-	You may not mix JAXB Providers on the context path
-	
+        You may not mix JAXB Providers on the context path
+
 ContextFinder.MissingProperty = \
-	jaxb.properties in package {0} does not contain the {1} property.
+        jaxb.properties in package {0} does not contain the {1} property.
 
 ContextFinder.NoPackageInContextPath = \
     No package name is given
 
 PropertyException.NameValue = \
-	name: {0} value: {1}
-	
+        name: {0} value: {1}
+
 DatatypeConverter.ConverterMustNotBeNull = \
-	The DatatypeConverterInterface parameter must not be null
-	
+        The DatatypeConverterInterface parameter must not be null
+
 JAXBContext.IllegalCast = \
- 
+    ClassCastException: attempting to cast {0} to {1}.  Please make sure that you are specifying the proper ClassLoader.
--- old/src/share/classes/javax/xml/bind/NotIdentifiableEvent.java	Tue Aug  4 10:12:22 2009
+++ new/src/share/classes/javax/xml/bind/NotIdentifiableEvent.java	Tue Aug  4 10:12:22 2009
@@ -30,7 +30,7 @@
  *
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see Validator
  * @see ValidationEventHandler
  * @since JAXB1.0
--- old/src/share/classes/javax/xml/bind/ParseConversionEvent.java	Tue Aug  4 10:12:25 2009
+++ new/src/share/classes/javax/xml/bind/ParseConversionEvent.java	Tue Aug  4 10:12:24 2009
@@ -30,7 +30,7 @@
  * string from the XML data into a value of the target Java data type.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see ValidationEvent
  * @see ValidationEventHandler
  * @see Unmarshaller
--- old/src/share/classes/javax/xml/bind/PrintConversionEvent.java	Tue Aug  4 10:12:27 2009
+++ new/src/share/classes/javax/xml/bind/PrintConversionEvent.java	Tue Aug  4 10:12:27 2009
@@ -30,7 +30,7 @@
  * from the Java content tree into its lexical representation.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see ValidationEvent
  * @see ValidationEventHandler
  * @see Marshaller
--- old/src/share/classes/javax/xml/bind/PropertyException.java	Tue Aug  4 10:12:31 2009
+++ new/src/share/classes/javax/xml/bind/PropertyException.java	Tue Aug  4 10:12:30 2009
@@ -32,7 +32,7 @@
  * setting a property.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $ $Date: 2004/06/14 21:23:04 $
+ * @version $Revision: 1.1 $ $Date: 2004/12/14 21:50:40 $
  * @see JAXBContext
  * @see Validator
  * @see Unmarshaller
--- old/src/share/classes/javax/xml/bind/TypeConstraintException.java	Tue Aug  4 10:12:35 2009
+++ new/src/share/classes/javax/xml/bind/TypeConstraintException.java	Tue Aug  4 10:12:34 2009
@@ -41,7 +41,7 @@
  * called.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see ValidationEvent
  * @since JAXB1.0
  */
--- old/src/share/classes/javax/xml/bind/UnmarshalException.java	Tue Aug  4 10:12:39 2009
+++ new/src/share/classes/javax/xml/bind/UnmarshalException.java	Tue Aug  4 10:12:38 2009
@@ -37,7 +37,7 @@
  * ValidationEventHandler.handleEvent(ValidationEvent)}.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see JAXBException
  * @see Unmarshaller
  * @see ValidationEventHandler
--- old/src/share/classes/javax/xml/bind/Unmarshaller.java	Tue Aug  4 10:12:42 2009
+++ new/src/share/classes/javax/xml/bind/Unmarshaller.java	Tue Aug  4 10:12:41 2009
@@ -402,7 +402,7 @@
  * </blockquote>
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.31 $ $Date: 2005/08/15 20:54:42 $
+ * @version $Revision: 1.32 $ $Date: 2005/08/18 15:18:26 $
  * @see JAXBContext
  * @see Marshaller
  * @see Validator
--- old/src/share/classes/javax/xml/bind/UnmarshallerHandler.java	Tue Aug  4 10:12:45 2009
+++ new/src/share/classes/javax/xml/bind/UnmarshallerHandler.java	Tue Aug  4 10:12:44 2009
@@ -55,7 +55,7 @@
  * an object, s/he can still start a new round of unmarshalling.
  *
  * @author <ul><li>Kohsuke KAWAGUCHI, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.1 $ $Date: 2004/12/14 21:50:41 $
+ * @version $Revision: 1.2 $ $Date: 2006/03/08 16:55:17 $
  * @see Unmarshaller#getUnmarshallerHandler()
  * @since JAXB1.0
  */
--- old/src/share/classes/javax/xml/bind/ValidationEvent.java	Tue Aug  4 10:12:48 2009
+++ new/src/share/classes/javax/xml/bind/ValidationEvent.java	Tue Aug  4 10:12:47 2009
@@ -32,7 +32,7 @@
  * Java content tree back to XML data.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see Validator
  * @see ValidationEventHandler
  * @since JAXB1.0
--- old/src/share/classes/javax/xml/bind/ValidationEventHandler.java	Tue Aug  4 10:12:51 2009
+++ new/src/share/classes/javax/xml/bind/ValidationEventHandler.java	Tue Aug  4 10:12:51 2009
@@ -60,7 +60,7 @@
  * </blockquote>
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see Unmarshaller
  * @see Validator
  * @see Marshaller
--- old/src/share/classes/javax/xml/bind/ValidationEventLocator.java	Tue Aug  4 10:12:54 2009
+++ new/src/share/classes/javax/xml/bind/ValidationEventLocator.java	Tue Aug  4 10:12:53 2009
@@ -38,7 +38,7 @@
  * source of the XML data (file, url, Node, etc).
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see Validator
  * @see ValidationEvent
  * @since JAXB1.0
--- old/src/share/classes/javax/xml/bind/ValidationException.java	Tue Aug  4 10:12:56 2009
+++ new/src/share/classes/javax/xml/bind/ValidationException.java	Tue Aug  4 10:12:56 2009
@@ -36,7 +36,7 @@
  * ValidationEventHandler.handleEvent(ValidationEvent)}.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see JAXBException
  * @see Validator
  * @since JAXB1.0
--- old/src/share/classes/javax/xml/bind/Validator.java	Tue Aug  4 10:12:58 2009
+++ new/src/share/classes/javax/xml/bind/Validator.java	Tue Aug  4 10:12:58 2009
@@ -149,7 +149,7 @@
  *
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.3 $ $Date: 2005/06/06 15:04:03 $
+ * @version $Revision: 1.4 $ $Date: 2005/07/29 20:56:02 $
  * @see JAXBContext
  * @see Unmarshaller
  * @see ValidationEventHandler
--- old/src/share/classes/javax/xml/bind/annotation/XmlAccessOrder.java	Tue Aug  4 10:13:01 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlAccessOrder.java	Tue Aug  4 10:13:01 2009
@@ -31,7 +31,7 @@
  *
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @since JAXB2.0
- * @version $Revision: 1.3 $
+ * @version $Revision: 1.1 $
  * @see XmlAccessorOrder
  */
 
--- old/src/share/classes/javax/xml/bind/annotation/XmlAccessType.java	Tue Aug  4 10:13:04 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlAccessType.java	Tue Aug  4 10:13:03 2009
@@ -33,7 +33,7 @@
  *
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @since JAXB2.0
- * @version $Revision: 1.10 $
+ * @version $Revision: 1.1 $
  * @see XmlAccessorType
  */
 
--- old/src/share/classes/javax/xml/bind/annotation/XmlAccessorOrder.java	Tue Aug  4 10:13:06 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlAccessorOrder.java	Tue Aug  4 10:13:06 2009
@@ -71,7 +71,7 @@
  *
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @since JAXB2.0
- * @version  $Revision: 1.11 $
+ * @version  $Revision: 1.12 $
  * @see XmlAccessOrder
  */
 
--- old/src/share/classes/javax/xml/bind/annotation/XmlAccessorType.java	Tue Aug  4 10:13:09 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlAccessorType.java	Tue Aug  4 10:13:08 2009
@@ -86,7 +86,7 @@
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @since JAXB2.0
  * @see XmlAccessType
- * @version  $Revision: 1.8 $
+ * @version  $Revision: 1.9 $
  */
 
 @Inherited @Retention(RUNTIME) @Target({PACKAGE, TYPE})
--- old/src/share/classes/javax/xml/bind/annotation/XmlAttribute.java	Tue Aug  4 10:13:11 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlAttribute.java	Tue Aug  4 10:13:11 2009
@@ -121,7 +121,7 @@
  *
  * </pre>
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
- * @version $Revision: 1.13 $
+ * @version $Revision: 1.14 $
  * @see XmlType
  * @since JAXB2.0
  */
--- old/src/share/classes/javax/xml/bind/annotation/XmlElement.java	Tue Aug  4 10:13:14 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlElement.java	Tue Aug  4 10:13:14 2009
@@ -134,7 +134,7 @@
  * <p>
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @since JAXB2.0
- * @version $Revision: 1.18 $
+ * @version $Revision: 1.19 $
  */
 
 @Retention(RUNTIME) @Target({FIELD, METHOD})
--- old/src/share/classes/javax/xml/bind/annotation/XmlID.java	Tue Aug  4 10:13:17 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlID.java	Tue Aug  4 10:13:16 2009
@@ -88,7 +88,7 @@
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @see XmlIDREF
  * @since JAXB2.0
- * @version $Revision: 1.4 $
+ * @version $Revision: 1.5 $
  */
 
 @Retention(RUNTIME) @Target({FIELD, METHOD})
--- old/src/share/classes/javax/xml/bind/annotation/XmlIDREF.java	Tue Aug  4 10:13:19 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlIDREF.java	Tue Aug  4 10:13:19 2009
@@ -244,7 +244,7 @@
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @see XmlID
  * @since JAXB2.0
- * @version $Revision: 1.11 $
+ * @version $Revision: 1.12 $
  */
 
 @Retention(RUNTIME) @Target({FIELD, METHOD})
--- old/src/share/classes/javax/xml/bind/annotation/XmlNs.java	Tue Aug  4 10:13:21 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlNs.java	Tue Aug  4 10:13:21 2009
@@ -43,7 +43,7 @@
  * <p><b>Example:</b>See <tt>XmlSchema</tt> annotation type for an example.
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @since JAXB2.0
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.3 $
  */
 
 @Retention(RUNTIME) @Target({})
--- old/src/share/classes/javax/xml/bind/annotation/XmlNsForm.java	Tue Aug  4 10:13:24 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlNsForm.java	Tue Aug  4 10:13:23 2009
@@ -62,6 +62,6 @@
  *
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @since JAXB2.0
- * @version $Revision: 1.1 $
+ * @version $Revision: 1.2 $
  */
 public enum XmlNsForm {UNQUALIFIED, QUALIFIED, UNSET}
--- old/src/share/classes/javax/xml/bind/annotation/XmlSchema.java	Tue Aug  4 10:13:26 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlSchema.java	Tue Aug  4 10:13:26 2009
@@ -115,7 +115,7 @@
 
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @since JAXB2.0
- * @version $Revision: 1.9 $
+ * @version $Revision: 1.10 $
  */
 
 @Retention(RUNTIME) @Target(PACKAGE)
--- old/src/share/classes/javax/xml/bind/annotation/XmlSeeAlso.java	Tue Aug  4 10:13:29 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlSeeAlso.java	Tue Aug  4 10:13:29 2009
@@ -70,7 +70,7 @@
  *
  * @author Kohsuke Kawaguchi
  * @since JAXB2.1
- * @version $Revision: $
+ * @version $Revision: 1.1 $
  */
 @Target({ElementType.TYPE})
 @Retention(RUNTIME)
--- old/src/share/classes/javax/xml/bind/annotation/XmlTransient.java	Tue Aug  4 10:13:31 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlTransient.java	Tue Aug  4 10:13:31 2009
@@ -89,7 +89,7 @@
  *
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @since JAXB2.0
- * @version $Revision$
+ * @version $Revision: 1.10 $
  */
 
 @Retention(RUNTIME) @Target({FIELD, METHOD, TYPE})
--- old/src/share/classes/javax/xml/bind/annotation/XmlType.java	Tue Aug  4 10:13:34 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlType.java	Tue Aug  4 10:13:33 2009
@@ -380,7 +380,7 @@
  * @see XmlValue
  * @see XmlSchema
  * @since JAXB2.0
- * @version $Revision: 1.19 $
+ * @version $Revision: 1.20 $
  */
 
 @Retention(RUNTIME) @Target({TYPE})
--- old/src/share/classes/javax/xml/bind/annotation/XmlValue.java	Tue Aug  4 10:13:37 2009
+++ new/src/share/classes/javax/xml/bind/annotation/XmlValue.java	Tue Aug  4 10:13:36 2009
@@ -125,7 +125,7 @@
  * @author Sekhar Vajjhala, Sun Microsystems, Inc.
  * @see XmlType
  * @since JAXB2.0
- * @version $Revision: 1.5 $
+ * @version $Revision: 1.6 $
  */
 
 @Retention(RUNTIME) @Target({FIELD, METHOD})
--- old/src/share/classes/javax/xml/bind/annotation/adapters/XmlJavaTypeAdapter.java	Tue Aug  4 10:13:39 2009
+++ new/src/share/classes/javax/xml/bind/annotation/adapters/XmlJavaTypeAdapter.java	Tue Aug  4 10:13:38 2009
@@ -88,7 +88,7 @@
  * @author <ul><li>Sekhar Vajjhala, Sun Microsystems Inc.</li> <li> Kohsuke Kawaguchi, Sun Microsystems Inc.</li></ul>
  * @since JAXB2.0
  * @see XmlAdapter
- * @version $Revision: 1.9 $
+ * @version $Revision: 1.10 $
  */
 
 @Retention(RUNTIME) @Target({PACKAGE,FIELD,METHOD,TYPE,PARAMETER})
--- old/src/share/classes/javax/xml/bind/annotation/adapters/package.html	Tue Aug  4 10:13:41 2009
+++ new/src/share/classes/javax/xml/bind/annotation/adapters/package.html	Tue Aug  4 10:13:41 2009
@@ -25,7 +25,7 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <html>
     <head>
-        
+
     </head>
 
     <body>
@@ -53,5 +53,3 @@
 
     </body>
 </html>
-
-
--- old/src/share/classes/javax/xml/bind/annotation/package.html	Tue Aug  4 10:13:44 2009
+++ new/src/share/classes/javax/xml/bind/annotation/package.html	Tue Aug  4 10:13:43 2009
@@ -25,7 +25,7 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <html>
     <head>
-        
+
     </head>
 
     <body bgcolor="white">
@@ -37,7 +37,7 @@
         <p>The following table shows the JAXB mapping annotations
            that can be associated with each program element. </p>
 
-        <table border="1" cellpadding="4" cellspacing="3"> 
+        <table border="1" cellpadding="4" cellspacing="3">
           <tbody>
             <tr>
               <td><b>Program Element</td>
@@ -75,7 +75,7 @@
             <tr valign="top">
               <td><b>Class</td>
               <td>
-                <table> 
+                <table>
                   <tr valign="top">
                     <td><b><a HREF="../../../../javax/xml/bind/annotation/XmlAccessorOrder.html">XmlAccessorOrder</b></td>
                   </tr>
@@ -101,7 +101,7 @@
             <tr valign="top">
               <td><b>Enum type</td>
               <td>
-                <table> 
+                <table>
                   <tr valign="top">
                     <td><b><a HREF="../../../../javax/xml/bind/annotation/XmlEnum.html">XmlEnum</b></td>
                   </tr>
@@ -124,7 +124,7 @@
             <tr valign="top">
               <td><b>JavaBean Property/field</td>
               <td>
-                <table> 
+                <table>
                   <tr valign="top">
                     <td><b><a HREF="../../../../javax/xml/bind/annotation/XmlElement.html">XmlElement</b></td>
                   </tr>
@@ -189,7 +189,7 @@
             <tr valign="top">
               <td><b>Parameter</td>
               <td>
-                <table> 
+                <table>
                   <tr valign="top">
                     <td><b><a HREF="../../../../javax/xml/bind/annotation/XmlList.html">XmlList</b></td>
                   </tr>
@@ -208,7 +208,7 @@
 
           </tbody>
         </table>
-        <h3>Terminology</h3> 
+        <h3>Terminology</h3>
           <p>
           <b>JavaBean property and field:</b> For the purposes of
           mapping, there is no semantic difference between a field and
@@ -237,19 +237,19 @@
           <ul>
             <li> For a property, a given annotation can be applied to
                  either read or write property but not both. </li>
-    
+
             <li> A property name must be different from any other
                  property name in any of the super classes of the
                  class being mapped. </li>
- 
+
             <li> A mapped field name or the decapitalized name of a
                  mapped property must be unique within a class. </li>
           </ul>
          <h3>Notations</h3>
-         <b>Namespace prefixes</b> 
+         <b>Namespace prefixes</b>
          <p>The following namespace prefixes are used in the XML Schema
            fragments in this package.<p>
-    
+
         <table border="1" cellpadding="4" cellspacing="3">
           <tbody>
             <tr>
@@ -257,7 +257,7 @@
               <td><b>Namespace</b></td>
               <td><b>Notes</b></td>
            </tr>
- 
+
            <tr valign="top">
              <td>xs</td>
              <td>http://www.w3.org/2001/XMLSchema</td>
@@ -280,5 +280,3 @@
         @since JAXB 2.0
     </body>
 </html>
-
-
--- old/src/share/classes/javax/xml/bind/attachment/package.html	Tue Aug  4 10:13:46 2009
+++ new/src/share/classes/javax/xml/bind/attachment/package.html	Tue Aug  4 10:13:46 2009
@@ -25,27 +25,27 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <html>
     <head>
-        
+
     </head>
 
     <body bgcolor="white">
 
         <p>
-	This package is implemented by a MIME-based package processor that 
-        enables the interpretation and creation of optimized binary data 
+        This package is implemented by a MIME-based package processor that
+        enables the interpretation and creation of optimized binary data
         within an MIME-based package format.
 
         <p>
-        Soap MTOM[1], XOP([2][3]) and WS-I AP[4] standardize approaches to 
+        Soap MTOM[1], XOP([2][3]) and WS-I AP[4] standardize approaches to
         optimized transmission of binary datatypes as an attachment.
-        To optimally support these standards within a message passing 
-        environment, this package enables an integrated solution between 
+        To optimally support these standards within a message passing
+        environment, this package enables an integrated solution between
         a MIME-based package processor and JAXB unmarshall/marshal processes.
 
         <h2>Package Specification</h2>
 
         <ul>
-            <li><a href="http://java.sun.com/xml/downloads/jaxb.html">JAXB 
+            <li><a href="http://java.sun.com/xml/downloads/jaxb.html">JAXB
                 Specification</a>
         </ul>
 
@@ -52,7 +52,7 @@
         <h2>Related Standards</h2>
 
         <ul>
-	  <li><a href="http://www.w3.org/TR/2004/WD-soap12-mtom-20040608/">[1]SOAP Message Transmission Optimization Mechanism</a> </li>
+          <li><a href="http://www.w3.org/TR/2004/WD-soap12-mtom-20040608/">[1]SOAP Message Transmission Optimization Mechanism</a> </li>
           <li><a href="http://www.w3.org/TR/2005/REC-xop10-20050125/">[2]XML-binary Optimized Packaging</a></li>
           <li><a href="http://www.ws-i.org/Profiles/AttachmentsProfile-1.0-2004-08-24.html">[3]WS-I Attachments Profile Version 1.0.</a></li>
            <li><a href="http://www.w3.org/TR/xml-media-types/">[4]Describing Media Content of Binary Data in XML</a></li>
@@ -62,5 +62,3 @@
         @since JAXB 2.0
     </body>
 </html>
-
-
--- old/src/share/classes/javax/xml/bind/helpers/AbstractMarshallerImpl.java	Tue Aug  4 10:13:49 2009
+++ new/src/share/classes/javax/xml/bind/helpers/AbstractMarshallerImpl.java	Tue Aug  4 10:13:48 2009
@@ -60,7 +60,7 @@
  * {@link Marshaller#marshal(Object, javax.xml.transform.Result) marshal(Object, javax.xml.stream.XMLEventWriter)}.
  *
  * @author <ul><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li></ul>
- * @version $Revision$ $Date$
+ * @version $Revision: 1.8 $ $Date: 2006/08/28 17:56:38 $
  * @see javax.xml.bind.Marshaller
  * @since JAXB1.0
  */
--- old/src/share/classes/javax/xml/bind/helpers/AbstractUnmarshallerImpl.java	Tue Aug  4 10:13:53 2009
+++ new/src/share/classes/javax/xml/bind/helpers/AbstractUnmarshallerImpl.java	Tue Aug  4 10:13:52 2009
@@ -66,7 +66,7 @@
  * @author <ul>
  *         <li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li>
  *         </ul>
- * @version $Revision: 1.13 $ $Date: 2005/07/28 22:18:12 $
+ * @version $Revision: 1.14 $ $Date: 2006/03/08 17:01:00 $
  * @see javax.xml.bind.Unmarshaller
  * @since JAXB1.0
  */
--- old/src/share/classes/javax/xml/bind/helpers/DefaultValidationEventHandler.java	Tue Aug  4 10:13:55 2009
+++ new/src/share/classes/javax/xml/bind/helpers/DefaultValidationEventHandler.java	Tue Aug  4 10:13:55 2009
@@ -48,7 +48,7 @@
  * {@link javax.xml.bind.Marshaller}.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.4 $
+ * @version $Revision: 1.5 $
  * @see javax.xml.bind.Unmarshaller
  * @see javax.xml.bind.Validator
  * @see javax.xml.bind.ValidationEventHandler
--- old/src/share/classes/javax/xml/bind/helpers/Messages.properties	Tue Aug  4 10:13:57 2009
+++ new/src/share/classes/javax/xml/bind/helpers/Messages.properties	Tue Aug  4 10:13:57 2009
@@ -24,38 +24,36 @@
 #
 
 AbstractUnmarshallerImpl.ISNotNull = \
-	InputStream can not be null
+        InputStream can not be null
 
 AbstractMarshallerImpl.MustBeBoolean = \
-	{0} must be boolean
-	 
+        {0} must be boolean
+
 AbstractMarshallerImpl.MustBeString = \
-	{0} must be a String
-	
+        {0} must be a String
 
+
 DefaultValidationEventHandler.SeverityMessage = \
-	DefaultValidationEventHandler: {0} {1} \n\
+        DefaultValidationEventHandler: {0} {1} \n\
 \ \ \ \ \ Location: {2}
 
 DefaultValidationEventHandler.LocationUnavailable = \
-	unavailable
-	
+        unavailable
+
 DefaultValidationEventHandler.UnrecognizedSeverity = \
-	Unrecognized event severity field "{0}"
+        Unrecognized event severity field "{0}"
 
 DefaultValidationEventHandler.Warning = \
-	[WARNING]:
+        [WARNING]:
 
 DefaultValidationEventHandler.Error = \
-	[ERROR]:
+        [ERROR]:
 
 DefaultValidationEventHandler.FatalError = \
-	[FATAL_ERROR]:
-	
+        [FATAL_ERROR]:
+
 ValidationEventImpl.IllegalSeverity = \
-	Illegal severity
-	
+        Illegal severity
+
 Shared.MustNotBeNull = \
-	{0} parameter must not be null
-	
- 
+        {0} parameter must not be null
--- old/src/share/classes/javax/xml/bind/helpers/NotIdentifiableEventImpl.java	Tue Aug  4 10:14:00 2009
+++ new/src/share/classes/javax/xml/bind/helpers/NotIdentifiableEventImpl.java	Tue Aug  4 10:13:59 2009
@@ -36,7 +36,7 @@
  * convenience.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see javax.xml.bind.NotIdentifiableEvent
  * @see javax.xml.bind.Validator
  * @see javax.xml.bind.ValidationEventHandler
--- old/src/share/classes/javax/xml/bind/helpers/ParseConversionEventImpl.java	Tue Aug  4 10:14:02 2009
+++ new/src/share/classes/javax/xml/bind/helpers/ParseConversionEventImpl.java	Tue Aug  4 10:14:01 2009
@@ -37,7 +37,7 @@
  * convenience.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see javax.xml.bind.ParseConversionEvent
  * @see javax.xml.bind.Validator
  * @see javax.xml.bind.ValidationEventHandler
--- old/src/share/classes/javax/xml/bind/helpers/PrintConversionEventImpl.java	Tue Aug  4 10:14:04 2009
+++ new/src/share/classes/javax/xml/bind/helpers/PrintConversionEventImpl.java	Tue Aug  4 10:14:04 2009
@@ -37,7 +37,7 @@
  * convenience.
  *
  * @author <ul><li>Ryan Shoemaker, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see javax.xml.bind.PrintConversionEvent
  * @see javax.xml.bind.Validator
  * @see javax.xml.bind.ValidationEventHandler
--- old/src/share/classes/javax/xml/bind/helpers/ValidationEventImpl.java	Tue Aug  4 10:14:07 2009
+++ new/src/share/classes/javax/xml/bind/helpers/ValidationEventImpl.java	Tue Aug  4 10:14:06 2009
@@ -38,7 +38,7 @@
  * convenience.
  *
  * @author <ul><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.2 $
+ * @version $Revision: 1.1 $
  * @see javax.xml.bind.Validator
  * @see javax.xml.bind.ValidationEventHandler
  * @see javax.xml.bind.ValidationEvent
--- old/src/share/classes/javax/xml/bind/helpers/ValidationEventLocatorImpl.java	Tue Aug  4 10:14:09 2009
+++ new/src/share/classes/javax/xml/bind/helpers/ValidationEventLocatorImpl.java	Tue Aug  4 10:14:09 2009
@@ -42,7 +42,7 @@
  * convenience.
  *
  * @author <ul><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li></ul>
- * @version $Revision: 1.1 $
+ * @version $Revision: 1.2 $
  * @see javax.xml.bind.Validator
  * @see javax.xml.bind.ValidationEventHandler
  * @see javax.xml.bind.ValidationEvent
--- old/src/share/classes/javax/xml/bind/helpers/package.html	Tue Aug  4 10:14:13 2009
+++ new/src/share/classes/javax/xml/bind/helpers/package.html	Tue Aug  4 10:14:12 2009
@@ -25,32 +25,32 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <html>
     <head>
-        
+
     </head>
 
     <body bgcolor="white">
 
         <p>
-        <B>JAXB Provider Use Only:</b> Provides partial default implementations for 
+        <B>JAXB Provider Use Only:</b> Provides partial default implementations for
         some of the <tt>javax.xml.bind</tt> interfaces.
 
         <p>
-        JAXB Providers can extend these classes and implement the abstract 
+        JAXB Providers can extend these classes and implement the abstract
         methods.
- 
+
         <h2>Package Specification</h2>
 
         <ul>
-            <li><a href="http://java.sun.com/xml/downloads/jaxb.html">JAXB 
+            <li><a href="http://java.sun.com/xml/downloads/jaxb.html">JAXB
                 Specification</a>
         </ul>
 
         <h2>Related Documentation</h2>
 
-        For overviews, tutorials, examples, guides, and tool documentation, 
+        For overviews, tutorials, examples, guides, and tool documentation,
         please see:
         <ul>
-            <li>The <a href="http://java.sun.com/xml/jaxb/index.html">JAXB 
+            <li>The <a href="http://java.sun.com/xml/jaxb/index.html">JAXB
             Website</a>
         </ul>
 
@@ -58,5 +58,3 @@
 
     </body>
 </html>
-
-
--- old/src/share/classes/javax/xml/bind/package.html	Tue Aug  4 10:14:15 2009
+++ new/src/share/classes/javax/xml/bind/package.html	Tue Aug  4 10:14:15 2009
@@ -25,7 +25,7 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <html>
     <head>
-        
+
     </head>
 
     <body bgcolor="white">
@@ -42,16 +42,16 @@
         <h2>Package Specification</h2>
 
         <ul>
-            <li><a href="http://java.sun.com/xml/downloads/jaxb.html">JAXB 
+            <li><a href="http://java.sun.com/xml/downloads/jaxb.html">JAXB
                 Specification</a>
         </ul>
 
         <h2>Related Documentation</h2>
 
-        For overviews, tutorials, examples, guides, and tool documentation, 
+        For overviews, tutorials, examples, guides, and tool documentation,
         please see:
         <ul>
-            <li>The <a href="http://java.sun.com/xml/jaxb/index.html">JAXB 
+            <li>The <a href="http://java.sun.com/xml/jaxb/index.html">JAXB
             Website</a>
         </ul>
 
@@ -59,5 +59,3 @@
 
     </body>
 </html>
-
-
--- old/src/share/classes/javax/xml/bind/util/Messages.properties	Tue Aug  4 10:14:17 2009
+++ new/src/share/classes/javax/xml/bind/util/Messages.properties	Tue Aug  4 10:14:17 2009
@@ -24,20 +24,19 @@
 #
 
 ValidationEventCollector.UnrecognizedSeverity = \
-	Unrecognized event severity field "{0}"
-	
+        Unrecognized event severity field "{0}"
+
 JAXBResult.NullContext = \
-	JAXBContext can not be null
-	
+        JAXBContext can not be null
+
 JAXBResult.NullUnmarshaller = \
-	Unmarshaller can not be null
-	
+        Unmarshaller can not be null
+
 JAXBSource.NullContext = \
-	JAXBContext can not be null
-	
+        JAXBContext can not be null
+
 JAXBSource.NullContent = \
-	Content object can not be null
-	
+        Content object can not be null
+
 JAXBSource.NullMarshaller = \
-	Marshaller can not be null
- 
+        Marshaller can not be null
--- old/src/share/classes/javax/xml/bind/util/ValidationEventCollector.java	Tue Aug  4 10:14:20 2009
+++ new/src/share/classes/javax/xml/bind/util/ValidationEventCollector.java	Tue Aug  4 10:14:19 2009
@@ -40,7 +40,7 @@
  * the reported errors and warnings.
  *
  * @author <ul><li>Kohsuke Kawaguchi, Sun Microsystems, Inc.</li><li>Ryan Shoemaker, Sun Microsystems, Inc.</li><li>Joe Fialli, Sun Microsystems, Inc.</li></ul>
- * @version $Revision$
+ * @version $Revision: 1.3 $
  * @see javax.xml.bind.Validator
  * @see javax.xml.bind.ValidationEventHandler
  * @see javax.xml.bind.ValidationEvent
--- old/src/share/classes/javax/xml/bind/util/package.html	Tue Aug  4 10:14:22 2009
+++ new/src/share/classes/javax/xml/bind/util/package.html	Tue Aug  4 10:14:21 2009
@@ -25,7 +25,7 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <html>
     <head>
-        
+
     </head>
 
     <body bgcolor="white">
@@ -36,16 +36,16 @@
         <h2>Package Specification</h2>
 
         <ul>
-            <li><a href="http://java.sun.com/xml/downloads/jaxb.html">JAXB 
+            <li><a href="http://java.sun.com/xml/downloads/jaxb.html">JAXB
                 Specification</a>
         </ul>
 
         <h2>Related Documentation</h2>
 
-        For overviews, tutorials, examples, guides, and tool documentation, 
+        For overviews, tutorials, examples, guides, and tool documentation,
         please see:
         <ul>
-            <li>The <a href="http://java.sun.com/xml/jaxb/index.html">JAXB 
+            <li>The <a href="http://java.sun.com/xml/jaxb/index.html">JAXB
             Website</a>
         </ul>
 
@@ -53,5 +53,3 @@
 
     </body>
 </html>
-
-
--- old/src/share/classes/javax/xml/soap/AttachmentPart.java	Tue Aug  4 10:14:24 2009
+++ new/src/share/classes/javax/xml/soap/AttachmentPart.java	Tue Aug  4 10:14:24 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: AttachmentPart.java,v 1.12 2005/09/08 14:19:50 vj135062 Exp $
- * $Revision: 1.12 $
- * $Date: 2005/09/08 14:19:50 $
+ * $Id: AttachmentPart.java,v 1.13 2006/03/30 00:59:38 ofung Exp $
+ * $Revision: 1.13 $
+ * $Date: 2006/03/30 00:59:38 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/Detail.java	Tue Aug  4 10:14:29 2009
+++ new/src/share/classes/javax/xml/soap/Detail.java	Tue Aug  4 10:14:28 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: Detail.java,v 1.8 2005/04/05 20:34:16 mk125090 Exp $
- * $Revision: 1.8 $
- * $Date: 2005/04/05 20:34:16 $
+ * $Id: Detail.java,v 1.9 2006/03/30 00:59:38 ofung Exp $
+ * $Revision: 1.9 $
+ * $Date: 2006/03/30 00:59:38 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/DetailEntry.java	Tue Aug  4 10:14:31 2009
+++ new/src/share/classes/javax/xml/soap/DetailEntry.java	Tue Aug  4 10:14:31 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: DetailEntry.java,v 1.3 2005/04/05 20:34:16 mk125090 Exp $
- * $Revision: 1.3 $
- * $Date: 2005/04/05 20:34:16 $
+ * $Id: DetailEntry.java,v 1.4 2006/03/30 00:59:38 ofung Exp $
+ * $Revision: 1.4 $
+ * $Date: 2006/03/30 00:59:38 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/FactoryFinder.java	Tue Aug  4 10:14:34 2009
+++ new/src/share/classes/javax/xml/soap/FactoryFinder.java	Tue Aug  4 10:14:33 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: FactoryFinder.java,v 1.6 2005/04/05 22:28:12 mk125090 Exp $
- * $Revision: 1.6 $
- * $Date: 2005/04/05 22:28:12 $
+ * $Id: FactoryFinder.java,v 1.7 2006/03/30 00:59:38 ofung Exp $
+ * $Revision: 1.7 $
+ * $Date: 2006/03/30 00:59:38 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/MessageFactory.java	Tue Aug  4 10:14:36 2009
+++ new/src/share/classes/javax/xml/soap/MessageFactory.java	Tue Aug  4 10:14:36 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: MessageFactory.java,v 1.10 2005/04/05 22:28:13 mk125090 Exp $
- * $Revision: 1.10 $
- * $Date: 2005/04/05 22:28:13 $
+ * $Id: MessageFactory.java,v 1.11 2006/03/30 00:59:38 ofung Exp $
+ * $Revision: 1.11 $
+ * $Date: 2006/03/30 00:59:38 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/MimeHeader.java	Tue Aug  4 10:14:39 2009
+++ new/src/share/classes/javax/xml/soap/MimeHeader.java	Tue Aug  4 10:14:38 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: MimeHeader.java,v 1.3 2005/04/05 20:49:48 mk125090 Exp $
- * $Revision: 1.3 $
- * $Date: 2005/04/05 20:49:48 $
+ * $Id: MimeHeader.java,v 1.4 2006/03/30 00:59:38 ofung Exp $
+ * $Revision: 1.4 $
+ * $Date: 2006/03/30 00:59:38 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/MimeHeaders.java	Tue Aug  4 10:14:41 2009
+++ new/src/share/classes/javax/xml/soap/MimeHeaders.java	Tue Aug  4 10:14:41 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: MimeHeaders.java,v 1.5 2005/04/05 20:49:49 mk125090 Exp $
- * $Revision: 1.5 $
- * $Date: 2005/04/05 20:49:49 $
+ * $Id: MimeHeaders.java,v 1.6 2006/03/30 00:59:38 ofung Exp $
+ * $Revision: 1.6 $
+ * $Date: 2006/03/30 00:59:38 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/Name.java	Tue Aug  4 10:14:44 2009
+++ new/src/share/classes/javax/xml/soap/Name.java	Tue Aug  4 10:14:44 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: Name.java,v 1.4 2005/04/05 20:49:49 mk125090 Exp $
- * $Revision: 1.4 $
- * $Date: 2005/04/05 20:49:49 $
+ * $Id: Name.java,v 1.5 2006/03/30 00:59:39 ofung Exp $
+ * $Revision: 1.5 $
+ * $Date: 2006/03/30 00:59:39 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/Node.java	Tue Aug  4 10:14:47 2009
+++ new/src/share/classes/javax/xml/soap/Node.java	Tue Aug  4 10:14:46 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: Node.java,v 1.13 2005/04/05 20:49:49 mk125090 Exp $
- * $Revision: 1.13 $
- * $Date: 2005/04/05 20:49:49 $
+ * $Id: Node.java,v 1.14 2006/03/30 00:59:39 ofung Exp $
+ * $Revision: 1.14 $
+ * $Date: 2006/03/30 00:59:39 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SAAJMetaFactory.java	Tue Aug  4 10:14:49 2009
+++ new/src/share/classes/javax/xml/soap/SAAJMetaFactory.java	Tue Aug  4 10:14:49 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SAAJMetaFactory.java,v 1.4 2006/03/30 00:59:39 ofung Exp $
- * $Revision: 1.4 $
- * $Date: 2006/03/30 00:59:39 $
+ * $Id: SAAJMetaFactory.java,v 1.5 2007/07/05 06:49:47 vj135062 Exp $
+ * $Revision: 1.5 $
+ * $Date: 2007/07/05 06:49:47 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SAAJResult.java	Tue Aug  4 10:14:52 2009
+++ new/src/share/classes/javax/xml/soap/SAAJResult.java	Tue Aug  4 10:14:52 2009
@@ -23,7 +23,7 @@
  * have any questions.
  */
 /*
- * $Id: SAAJResult.java,v 1.4 2006/03/24 13:05:43 vj135062 Exp $
+ * $Id: SAAJResult.java,v 1.5 2006/03/30 00:59:39 ofung Exp $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPBody.java	Tue Aug  4 10:14:55 2009
+++ new/src/share/classes/javax/xml/soap/SOAPBody.java	Tue Aug  4 10:14:54 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPBody.java,v 1.17 2005/06/22 10:24:11 vj135062 Exp $
- * $Revision: 1.17 $
- * $Date: 2005/06/22 10:24:11 $
+ * $Id: SOAPBody.java,v 1.18 2006/03/30 00:59:39 ofung Exp $
+ * $Revision: 1.18 $
+ * $Date: 2006/03/30 00:59:39 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPBodyElement.java	Tue Aug  4 10:14:57 2009
+++ new/src/share/classes/javax/xml/soap/SOAPBodyElement.java	Tue Aug  4 10:14:57 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPBodyElement.java,v 1.3 2005/04/05 22:28:13 mk125090 Exp $
- * $Revision: 1.3 $
- * $Date: 2005/04/05 22:28:13 $
+ * $Id: SOAPBodyElement.java,v 1.4 2006/03/30 00:59:40 ofung Exp $
+ * $Revision: 1.4 $
+ * $Date: 2006/03/30 00:59:40 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPConnection.java	Tue Aug  4 10:15:00 2009
+++ new/src/share/classes/javax/xml/soap/SOAPConnection.java	Tue Aug  4 10:14:59 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPConnection.java,v 1.12 2005/04/05 21:03:23 mk125090 Exp $
- * $Revision: 1.12 $
- * $Date: 2005/04/05 21:03:23 $
+ * $Id: SOAPConnection.java,v 1.13 2006/03/30 00:59:40 ofung Exp $
+ * $Revision: 1.13 $
+ * $Date: 2006/03/30 00:59:40 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPConnectionFactory.java	Tue Aug  4 10:15:02 2009
+++ new/src/share/classes/javax/xml/soap/SOAPConnectionFactory.java	Tue Aug  4 10:15:01 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPConnectionFactory.java,v 1.5 2005/04/05 21:03:23 mk125090 Exp $
- * $Revision: 1.5 $
- * $Date: 2005/04/05 21:03:23 $
+ * $Id: SOAPConnectionFactory.java,v 1.6 2006/03/30 00:59:40 ofung Exp $
+ * $Revision: 1.6 $
+ * $Date: 2006/03/30 00:59:40 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPConstants.java	Tue Aug  4 10:15:04 2009
+++ new/src/share/classes/javax/xml/soap/SOAPConstants.java	Tue Aug  4 10:15:04 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPConstants.java,v 1.12 2005/04/05 22:28:13 mk125090 Exp $
- * $Revision: 1.12 $
- * $Date: 2005/04/05 22:28:13 $
+ * $Id: SOAPConstants.java,v 1.13 2006/03/30 00:59:40 ofung Exp $
+ * $Revision: 1.13 $
+ * $Date: 2006/03/30 00:59:40 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPElement.java	Tue Aug  4 10:15:06 2009
+++ new/src/share/classes/javax/xml/soap/SOAPElement.java	Tue Aug  4 10:15:06 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPElement.java,v 1.19 2005/12/13 09:20:25 vj135062 Exp $
- * $Revision: 1.19 $
- * $Date: 2005/12/13 09:20:25 $
+ * $Id: SOAPElement.java,v 1.20 2006/03/30 00:59:40 ofung Exp $
+ * $Revision: 1.20 $
+ * $Date: 2006/03/30 00:59:40 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPElementFactory.java	Tue Aug  4 10:15:08 2009
+++ new/src/share/classes/javax/xml/soap/SOAPElementFactory.java	Tue Aug  4 10:15:08 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPElementFactory.java,v 1.11 2005/04/05 22:42:05 mk125090 Exp $
- * $Revision: 1.11 $
- * $Date: 2005/04/05 22:42:05 $
+ * $Id: SOAPElementFactory.java,v 1.12 2006/03/30 00:59:41 ofung Exp $
+ * $Revision: 1.12 $
+ * $Date: 2006/03/30 00:59:41 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPEnvelope.java	Tue Aug  4 10:15:11 2009
+++ new/src/share/classes/javax/xml/soap/SOAPEnvelope.java	Tue Aug  4 10:15:10 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPEnvelope.java,v 1.6 2005/04/05 22:42:05 mk125090 Exp $
- * $Revision: 1.6 $
- * $Date: 2005/04/05 22:42:05 $
+ * $Id: SOAPEnvelope.java,v 1.7 2006/03/30 00:59:41 ofung Exp $
+ * $Revision: 1.7 $
+ * $Date: 2006/03/30 00:59:41 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPException.java	Tue Aug  4 10:15:13 2009
+++ new/src/share/classes/javax/xml/soap/SOAPException.java	Tue Aug  4 10:15:12 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPException.java,v 1.6 2005/04/05 21:03:23 mk125090 Exp $
- * $Revision: 1.6 $
- * $Date: 2005/04/05 21:03:23 $
+ * $Id: SOAPException.java,v 1.7 2006/03/30 00:59:41 ofung Exp $
+ * $Revision: 1.7 $
+ * $Date: 2006/03/30 00:59:41 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPFactory.java	Tue Aug  4 10:15:15 2009
+++ new/src/share/classes/javax/xml/soap/SOAPFactory.java	Tue Aug  4 10:15:15 2009
@@ -23,8 +23,8 @@
  * have any questions.
  */
 /*
- * $Id: SOAPFactory.java,v 1.13 2005/06/22 10:24:11 vj135062 Exp $
- * $Revision: 1.13 $
+ * $Id: SOAPFactory.java,v 1.14 2006/03/30 00:59:41 ofung Exp $
+ * $Revision: 1.14 $
  * $Datae$
  */
 
--- old/src/share/classes/javax/xml/soap/SOAPFault.java	Tue Aug  4 10:15:17 2009
+++ new/src/share/classes/javax/xml/soap/SOAPFault.java	Tue Aug  4 10:15:17 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPFault.java,v 1.20 2006/02/14 04:40:57 vj135062 Exp $
- * $Revision: 1.20 $
- * $Date: 2006/02/14 04:40:57 $
+ * $Id: SOAPFault.java,v 1.21 2006/03/30 00:59:41 ofung Exp $
+ * $Revision: 1.21 $
+ * $Date: 2006/03/30 00:59:41 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPFaultElement.java	Tue Aug  4 10:15:19 2009
+++ new/src/share/classes/javax/xml/soap/SOAPFaultElement.java	Tue Aug  4 10:15:19 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPFaultElement.java,v 1.4 2005/04/05 20:53:20 mk125090 Exp $
- * $Revision: 1.4 $
- * $Date: 2005/04/05 20:53:20 $
+ * $Id: SOAPFaultElement.java,v 1.5 2006/03/30 00:59:41 ofung Exp $
+ * $Revision: 1.5 $
+ * $Date: 2006/03/30 00:59:41 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPHeader.java	Tue Aug  4 10:15:22 2009
+++ new/src/share/classes/javax/xml/soap/SOAPHeader.java	Tue Aug  4 10:15:21 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPHeader.java,v 1.14 2005/04/05 22:46:27 mk125090 Exp $
- * $Revision: 1.14 $
- * $Date: 2005/04/05 22:46:27 $
+ * $Id: SOAPHeader.java,v 1.15 2006/03/30 00:59:41 ofung Exp $
+ * $Revision: 1.15 $
+ * $Date: 2006/03/30 00:59:41 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPHeaderElement.java	Tue Aug  4 10:15:24 2009
+++ new/src/share/classes/javax/xml/soap/SOAPHeaderElement.java	Tue Aug  4 10:15:24 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPHeaderElement.java,v 1.9 2005/04/05 22:46:27 mk125090 Exp $
- * $Revision: 1.9 $
- * $Date: 2005/04/05 22:46:27 $
+ * $Id: SOAPHeaderElement.java,v 1.10 2006/03/30 00:59:42 ofung Exp $
+ * $Revision: 1.10 $
+ * $Date: 2006/03/30 00:59:42 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPMessage.java	Tue Aug  4 10:15:26 2009
+++ new/src/share/classes/javax/xml/soap/SOAPMessage.java	Tue Aug  4 10:15:26 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPMessage.java,v 1.22 2005/08/17 08:13:01 vj135062 Exp $
- * $Revision: 1.22 $
- * $Date: 2005/08/17 08:13:01 $
+ * $Id: SOAPMessage.java,v 1.23 2006/03/30 00:59:42 ofung Exp $
+ * $Revision: 1.23 $
+ * $Date: 2006/03/30 00:59:42 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/SOAPPart.java	Tue Aug  4 10:15:29 2009
+++ new/src/share/classes/javax/xml/soap/SOAPPart.java	Tue Aug  4 10:15:28 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: SOAPPart.java,v 1.9 2005/06/21 17:32:45 mk125090 Exp $
- * $Revision: 1.9 $
- * $Date: 2005/06/21 17:32:45 $
+ * $Id: SOAPPart.java,v 1.10 2006/03/30 00:59:42 ofung Exp $
+ * $Revision: 1.10 $
+ * $Date: 2006/03/30 00:59:42 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/Text.java	Tue Aug  4 10:15:31 2009
+++ new/src/share/classes/javax/xml/soap/Text.java	Tue Aug  4 10:15:31 2009
@@ -23,9 +23,9 @@
  * have any questions.
  */
 /*
- * $Id: Text.java,v 1.3 2005/04/05 20:34:16 mk125090 Exp $
- * $Revision: 1.3 $
- * $Date: 2005/04/05 20:34:16 $
+ * $Id: Text.java,v 1.4 2006/03/30 00:59:42 ofung Exp $
+ * $Revision: 1.4 $
+ * $Date: 2006/03/30 00:59:42 $
  */
 
 
--- old/src/share/classes/javax/xml/soap/package.html	Tue Aug  4 10:15:33 2009
+++ new/src/share/classes/javax/xml/soap/package.html	Tue Aug  4 10:15:33 2009
@@ -25,7 +25,7 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <html>
 <head>
-   
+
   <title></title>
 
 </head>
@@ -53,11 +53,11 @@
 <p>   <!-- <h2>Package Specification</h2> -->  <!-- The SAAJ 1.1 specification gives an overview of the  -->
  <!-- <code>javax.xml.soap</code> package and --> <!-- explains how its classes and interfaces work. -->
  <!-- <ul> --> <!--   <li><a href="http://java.sun.com/xml/downloads/jaxm.html"> -->
- <!-- 	SAAJ 1.1 Specification</a> --> <!-- </ul> -->  <!-- <h2>Related Documentation</h2> -->
- <!-- 	For overviews, tutorials, examples, guides, and tool documentation, please see: -->
- <!-- 	<ul> --> <!-- 	  <li><a href="../../../../tutorial/doc/JAXM.html">JAXM Tutorial</a> -->
- <!-- 	  <li><a href="../../../../jaxm/index.html">JAXM Reference Implementation (RI) -->
- <!-- 			  Documentation</a> --> <!-- 	</ul> -->  </p>
+ <!--   SAAJ 1.1 Specification</a> --> <!-- </ul> -->  <!-- <h2>Related Documentation</h2> -->
+ <!--   For overviews, tutorials, examples, guides, and tool documentation, please see: -->
+ <!--   <ul> --> <!--     <li><a href="../../../../tutorial/doc/JAXM.html">JAXM Tutorial</a> -->
+ <!--     <li><a href="../../../../jaxm/index.html">JAXM Reference Implementation (RI) -->
+ <!--                     Documentation</a> --> <!--    </ul> -->  </p>
 In addition the APIs in the <code>javax.xml.soap</code> package extend
 their  counterparts in the <code>org.w3c.dom</code> package. This means that
 the  <code>SOAPPart</code> of a <code>SOAPMessage</code> is also a DOM Level
--- old/src/share/classes/javax/xml/ws/spi/FactoryFinder.java	Tue Aug  4 10:15:37 2009
+++ new/src/share/classes/javax/xml/ws/spi/FactoryFinder.java	Tue Aug  4 10:15:36 2009
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -148,7 +148,6 @@
         return newInstance(fallbackClassName, classLoader);
     }
 
-
     private static final String PLATFORM_DEFAULT_FACTORY_CLASS = "com.sun.xml.internal.ws.spi.ProviderImpl";
 
     /**
@@ -161,7 +160,7 @@
             if (s != null) {
                 int i = className.lastIndexOf('.');
                 if (i != -1) {
-                    s.checkPackageAccess(className.substring(0,i));
+                    s.checkPackageAccess(className.substring(0, i));
                 }
             }
 
@@ -176,4 +175,5 @@
             throw se;
         }
     }
+
 }
--- old/src/share/classes/javax/xml/ws/wsaddressing/W3CEndpointReference.java	Tue Aug  4 10:15:39 2009
+++ new/src/share/classes/javax/xml/ws/wsaddressing/W3CEndpointReference.java	Tue Aug  4 10:15:38 2009
@@ -93,6 +93,8 @@
             this.address = epr.address;
             this.metadata = epr.metadata;
             this.referenceParameters = epr.referenceParameters;
+            this.attributes = epr.attributes;
+            this.elements = epr.elements;
         } catch (JAXBException e) {
             throw new WebServiceException("Error unmarshalling W3CEndpointReference " ,e);
         } catch (ClassCastException e) {
@@ -106,7 +108,6 @@
     public void writeTo(Result result){
         try {
             Marshaller marshaller = w3cjc.createMarshaller();
-            marshaller.setProperty(Marshaller.JAXB_FRAGMENT, true);
             marshaller.marshal(this, result);
         } catch (JAXBException e) {
             throw new WebServiceException("Error marshalling W3CEndpointReference. ", e);
--- old/src/share/classes/org/relaxng/datatype/Datatype.java	Tue Aug  4 10:15:42 2009
+++ new/src/share/classes/org/relaxng/datatype/Datatype.java	Tue Aug  4 10:15:41 2009
@@ -22,7 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-
 package org.relaxng.datatype;
 
 /**
--- old/src/share/classes/org/relaxng/datatype/DatatypeBuilder.java	Tue Aug  4 10:15:44 2009
+++ new/src/share/classes/org/relaxng/datatype/DatatypeBuilder.java	Tue Aug  4 10:15:44 2009
@@ -22,7 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-
 package org.relaxng.datatype;
 
 /**
--- old/src/share/classes/org/relaxng/datatype/DatatypeException.java	Tue Aug  4 10:15:47 2009
+++ new/src/share/classes/org/relaxng/datatype/DatatypeException.java	Tue Aug  4 10:15:46 2009
@@ -22,7 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-
 package org.relaxng.datatype;
 
 /**
--- old/src/share/classes/org/relaxng/datatype/DatatypeLibrary.java	Tue Aug  4 10:15:50 2009
+++ new/src/share/classes/org/relaxng/datatype/DatatypeLibrary.java	Tue Aug  4 10:15:50 2009
@@ -22,7 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-
 package org.relaxng.datatype;
 
 /**
--- old/src/share/classes/org/relaxng/datatype/DatatypeLibraryFactory.java	Tue Aug  4 10:15:53 2009
+++ new/src/share/classes/org/relaxng/datatype/DatatypeLibraryFactory.java	Tue Aug  4 10:15:52 2009
@@ -22,7 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-
 package org.relaxng.datatype;
 
 /**
--- old/src/share/classes/org/relaxng/datatype/DatatypeStreamingValidator.java	Tue Aug  4 10:15:57 2009
+++ new/src/share/classes/org/relaxng/datatype/DatatypeStreamingValidator.java	Tue Aug  4 10:15:57 2009
@@ -22,7 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-
 package org.relaxng.datatype;
 
 /**
--- old/src/share/classes/org/relaxng/datatype/ValidationContext.java	Tue Aug  4 10:16:00 2009
+++ new/src/share/classes/org/relaxng/datatype/ValidationContext.java	Tue Aug  4 10:15:59 2009
@@ -22,7 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-
 package org.relaxng.datatype;
 
 /**
--- old/src/share/classes/org/relaxng/datatype/helpers/DatatypeLibraryLoader.java	Tue Aug  4 10:16:04 2009
+++ new/src/share/classes/org/relaxng/datatype/helpers/DatatypeLibraryLoader.java	Tue Aug  4 10:16:04 2009
@@ -148,8 +148,7 @@
 
             Enumeration getResources(String resName) {
               try {
-                    return cl.getResources(resName);
-
+                return cl.getResources(resName);
               }
               catch (IOException e) {
                 return new Singleton(null);
--- old/src/share/classes/org/relaxng/datatype/helpers/ParameterlessDatatypeBuilder.java	Tue Aug  4 10:16:08 2009
+++ new/src/share/classes/org/relaxng/datatype/helpers/ParameterlessDatatypeBuilder.java	Tue Aug  4 10:16:08 2009
@@ -22,7 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-
 package org.relaxng.datatype.helpers;
 
 import org.relaxng.datatype.*;
--- old/src/share/classes/org/relaxng/datatype/helpers/StreamingValidatorImpl.java	Tue Aug  4 10:16:12 2009
+++ new/src/share/classes/org/relaxng/datatype/helpers/StreamingValidatorImpl.java	Tue Aug  4 10:16:12 2009
@@ -22,7 +22,6 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
-
 package org.relaxng.datatype.helpers;
 
 import org.relaxng.datatype.*;
--- /dev/null	Tue Aug  4 10:16:16 2009
+++ new/src/share/classes/com/sun/istack/internal/Builder.java	Tue Aug  4 10:16:15 2009
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.istack.internal;
+
+/**
+ *
+ * @author Martin Grebac
+ */
+public interface Builder<T> {
+    T build();
+}
--- /dev/null	Tue Aug  4 10:16:18 2009
+++ new/src/share/classes/com/sun/istack/internal/localization/Localizable.java	Tue Aug  4 10:16:17 2009
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.istack.internal.localization;
+
+/**
+ * Localizable message.
+ *
+ * @author WS Development Team
+ */
+public interface Localizable {
+    /**
+     * Gets the key in the resource bundle.
+     *
+     * @return
+     *      if this method returns {@link #NOT_LOCALIZABLE},
+     *      that means the message is not localizable, and
+     *      the first item of {@link #getArguments()} array
+     *      holds a String.
+     */
+    public String getKey();
+
+    /**
+     * Returns the arguments for message formatting.
+     *
+     * @return
+     *      can be an array of length 0 but never be null.
+     */
+    public Object[] getArguments();
+    public String getResourceBundleName();
+
+
+    /**
+     * Special constant that represents a message that
+     * is not localizable.
+     *
+     * <p>
+     * Use of "new" is to create an unique instance.
+     */
+    public static final String NOT_LOCALIZABLE = new String("\u0000");
+}
--- /dev/null	Tue Aug  4 10:16:20 2009
+++ new/src/share/classes/com/sun/istack/internal/localization/LocalizableMessage.java	Tue Aug  4 10:16:19 2009
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.istack.internal.localization;
+
+/**
+ * @author WS Development Team
+ */
+public final class LocalizableMessage implements Localizable {
+
+    private final String _bundlename;
+    private final String _key;
+    private final Object[] _args;
+
+    public LocalizableMessage(String bundlename, String key, Object... args) {
+        _bundlename = bundlename;
+        _key = key;
+        if(args==null)
+            args = new Object[0];
+        _args = args;
+    }
+
+    public String getKey() {
+        return _key;
+    }
+
+    public Object[] getArguments() {
+        return _args;
+    }
+
+    public String getResourceBundleName() {
+        return _bundlename;
+    }
+}
--- /dev/null	Tue Aug  4 10:16:22 2009
+++ new/src/share/classes/com/sun/istack/internal/localization/LocalizableMessageFactory.java	Tue Aug  4 10:16:21 2009
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.istack.internal.localization;
+
+/**
+ * @author WS Development Team
+ */
+public class LocalizableMessageFactory {
+
+    private final String _bundlename;
+
+    public LocalizableMessageFactory(String bundlename) {
+        _bundlename = bundlename;
+    }
+
+    public Localizable getMessage(String key, Object... args) {
+        return new LocalizableMessage(_bundlename, key, args);
+    }
+
+}
--- /dev/null	Tue Aug  4 10:16:24 2009
+++ new/src/share/classes/com/sun/istack/internal/localization/Localizer.java	Tue Aug  4 10:16:24 2009
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.istack.internal.localization;
+
+import java.text.MessageFormat;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.MissingResourceException;
+import java.util.ResourceBundle;
+
+/**
+ * Localizes the {@link Localizable} into a message
+ * by using a configured {@link Locale}.
+ *
+ * @author WS Development Team
+ */
+public class Localizer {
+
+    private final Locale _locale;
+    private final HashMap _resourceBundles;
+
+    public Localizer() {
+        this(Locale.getDefault());
+    }
+
+    public Localizer(Locale l) {
+        _locale = l;
+        _resourceBundles = new HashMap();
+    }
+
+    public Locale getLocale() {
+        return _locale;
+    }
+
+    public String localize(Localizable l) {
+        String key = l.getKey();
+        if (key == Localizable.NOT_LOCALIZABLE) {
+            // this message is not localizable
+            return (String) l.getArguments()[0];
+        }
+        String bundlename = l.getResourceBundleName();
+
+        try {
+            ResourceBundle bundle =
+                (ResourceBundle) _resourceBundles.get(bundlename);
+
+            if (bundle == null) {
+                try {
+                    bundle = ResourceBundle.getBundle(bundlename, _locale);
+                } catch (MissingResourceException e) {
+                    // work around a bug in the com.sun.enterprise.deployment.WebBundleArchivist:
+                    //   all files with an extension different from .class (hence all the .properties files)
+                    //   get copied to the top level directory instead of being in the package where they
+                    //   are defined
+                    // so, since we can't find the bundle under its proper name, we look for it under
+                    //   the top-level package
+
+                    int i = bundlename.lastIndexOf('.');
+                    if (i != -1) {
+                        String alternateBundleName =
+                            bundlename.substring(i + 1);
+                        try {
+                            bundle =
+                                ResourceBundle.getBundle(
+                                    alternateBundleName,
+                                    _locale);
+                        } catch (MissingResourceException e2) {
+                            // give up
+                            return getDefaultMessage(l);
+                        }
+                    }
+                }
+
+                _resourceBundles.put(bundlename, bundle);
+            }
+
+            if (bundle == null) {
+                return getDefaultMessage(l);
+            }
+
+            if (key == null)
+                key = "undefined";
+
+            String msg;
+            try {
+                msg = bundle.getString(key);
+            } catch (MissingResourceException e) {
+                // notice that this may throw a MissingResourceException of its own (caught below)
+                msg = bundle.getString("undefined");
+            }
+
+            // localize all arguments to the given localizable object
+            Object[] args = l.getArguments();
+            for (int i = 0; i < args.length; ++i) {
+                if (args[i] instanceof Localizable)
+                    args[i] = localize((Localizable) args[i]);
+            }
+
+            String message = MessageFormat.format(msg, args);
+            return message;
+
+        } catch (MissingResourceException e) {
+            return getDefaultMessage(l);
+        }
+
+    }
+
+    private String getDefaultMessage(Localizable l) {
+        String key = l.getKey();
+        Object[] args = l.getArguments();
+        StringBuilder sb = new StringBuilder();
+        sb.append("[failed to localize] ");
+        sb.append(key);
+        if (args != null) {
+            sb.append('(');
+            for (int i = 0; i < args.length; ++i) {
+                if (i != 0)
+                    sb.append(", ");
+                sb.append(String.valueOf(args[i]));
+            }
+            sb.append(')');
+        }
+        return sb.toString();
+    }
+
+}
--- /dev/null	Tue Aug  4 10:16:26 2009
+++ new/src/share/classes/com/sun/tools/internal/jxc/SchemaGeneratorFacade.java	Tue Aug  4 10:16:26 2009
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.tools.internal.jxc;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * CLI entry point to schemagen that checks for JDK 5.0
+ * @author Kohsuke Kawaguchi
+ */
+public class SchemaGeneratorFacade {
+
+    public static void main(String[] args) throws Throwable {
+        try {
+            ClassLoader cl = SchemaGeneratorFacade.class.getClassLoader();
+            if(cl==null)    cl = ClassLoader.getSystemClassLoader();
+
+            Class driver = cl.loadClass("com.sun.tools.internal.jxc.SchemaGenerator");
+            Method mainMethod = driver.getDeclaredMethod("main", new Class[]{String[].class});
+            try {
+                mainMethod.invoke(null,new Object[]{args});
+            } catch (IllegalAccessException e) {
+                throw e;
+            } catch (InvocationTargetException e) {
+                if(e.getTargetException()!=null)
+                    throw e.getTargetException();
+            }
+        } catch (UnsupportedClassVersionError e) {
+            System.err.println("schemagen requires JDK 5.0 or later. Please download it from http://java.sun.com/j2se/1.5/");
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:16:28 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/api/WsgenExtension.java	Tue Aug  4 10:16:28 2009
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.ws.api;
+
+/**
+ * Allows to customize wsgen behaviour using this extension.
+ * The extension implementations are found using service
+ * discovery mechanism i.e. JAX-WS tooltime locates
+ * {@link WsgenExtension}s through the
+ * <tt>META-INF/services/com.sun.tools.internal.ws.api.WsgenExtension</tt>
+ * files.
+ *
+ * {@link WsgenProtocol} annotation can be specified on the
+ * extensions to extend -wsdl[:protocol] behaviour.
+ *
+ * @author Jitendra Kotamraju
+ * @since JAX-WS RI 2.1.6
+ * @see WsgenProtocol
+ */
+public abstract class WsgenExtension {
+}
--- /dev/null	Tue Aug  4 10:16:30 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/api/WsgenProtocol.java	Tue Aug  4 10:16:30 2009
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.ws.api;
+
+import java.lang.annotation.*;
+
+/**
+ * Allows to extend protocol for wsgen's wsdl[:protocol] switch.
+ * This annotation must be specified on {@link WsgenExtension}
+ * implementations.
+ *
+ * @author Jitendra Kotamraju
+ * @since JAX-WS RI 2.1.6
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+public @interface WsgenProtocol {
+    /**
+     * Token for wsgen -wsdl[:protocol]
+     * @return
+     */
+    String token();
+
+    /**
+     * The corresponding lexical string used to create BindingID
+     * @return
+     */
+    String lexical();
+}
--- /dev/null	Tue Aug  4 10:16:32 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/AuthInfo.java	Tue Aug  4 10:16:32 2009
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.ws.wscompile;
+
+import com.sun.istack.internal.NotNull;
+
+import java.net.URL;
+
+/**
+ * Represents authorization information needed by {@link com.sun.tools.internal.ws.wscompile.DefaultAuthenticator} to
+ * authenticate wsimport to access the wsdl.
+ *
+ * @author Vivek Pandey
+ */
+
+public final class AuthInfo {
+    private final String user;
+    private final String password;
+    private final URL url;
+
+    public AuthInfo(@NotNull URL url, @NotNull String user, @NotNull String password){
+        this.url = url;
+        this.user = user;
+        this.password = password;
+    }
+
+    public String getUser() {
+        return user;
+    }
+
+    public String getPassword() {
+        return password;
+    }
+
+    /**
+     * Returns if the requesting host and port are associated with this {@link AuthInfo}
+     */
+    public boolean matchingHost(@NotNull URL requestingURL) {
+        return requestingURL.equals(url);
+    }
+
+}
--- /dev/null	Tue Aug  4 10:16:34 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/DefaultAuthTester.java	Tue Aug  4 10:16:34 2009
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.ws.wscompile;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.tools.internal.ws.processor.modeler.wsdl.ConsoleErrorReporter;
+
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.PasswordAuthentication;
+import java.net.URL;
+import java.util.Arrays;
+
+/**
+ * @author Vivek Pandey
+ */
+public class DefaultAuthTester {
+    public static void main(String[] args) throws BadCommandLineException {
+        DefaultAuthenticator da = new MyAuthenticator(new ConsoleErrorReporter(System.out), new File("c:\\Users\\vivekp\\.metro\\auth"));
+
+        PasswordAuthentication pa = da.getPasswordAuthentication();
+        if(pa!= null && pa.getUserName().equals("vivek") && Arrays.equals(pa.getPassword(), "test".toCharArray()))
+            System.out.println("Success!");
+        else
+            System.out.println("Failiure!");
+
+    }
+
+    private static class MyAuthenticator extends DefaultAuthenticator{
+
+        public MyAuthenticator(@NotNull ErrorReceiver receiver, @NotNull File authfile) throws BadCommandLineException {
+            super(receiver, authfile);
+        }
+
+        protected URL getRequestingURL() {
+            try {
+                return new URL("http://foo.com/myservice?wsdl");
+            } catch (MalformedURLException e) {
+                e.printStackTrace();
+            }
+            return null;
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:16:36 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wscompile/DefaultAuthenticator.java	Tue Aug  4 10:16:36 2009
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.ws.wscompile;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.tools.internal.ws.resources.WscompileMessages;
+import org.xml.sax.SAXParseException;
+import org.xml.sax.helpers.LocatorImpl;
+
+import java.io.*;
+import java.net.Authenticator;
+import java.net.PasswordAuthentication;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author Vivek Pandey
+ */
+public class DefaultAuthenticator extends Authenticator {
+
+    private final List<AuthInfo> authInfo = new ArrayList<AuthInfo>();
+    private final ErrorReceiver errReceiver;
+    private final String proxyUser;
+    private final String proxyPasswd;
+
+    //can user.home value be null?
+    public static final String defaultAuthfile = System.getProperty("user.home")+ System.getProperty("file.separator")+".metro"+System.getProperty("file.separator")+"auth";
+    private File authFile = new File(defaultAuthfile);
+    private boolean giveError;
+
+    public DefaultAuthenticator(@NotNull ErrorReceiver receiver, @NotNull File authfile) throws BadCommandLineException {
+        this.errReceiver = receiver;
+        this.proxyUser = System.getProperty("http.proxyUser");
+        this.proxyPasswd = System.getProperty("http.proxyPassword");
+
+        if(authfile != null){
+            this.authFile = authfile;
+            this.giveError = true;
+        }
+
+        if(!authFile.exists()){
+            try {
+                error(new SAXParseException(WscompileMessages.WSIMPORT_AUTH_FILE_NOT_FOUND(authFile.getCanonicalPath(), defaultAuthfile), null));
+            } catch (IOException e) {
+                error(new SAXParseException(WscompileMessages.WSIMPORT_FAILED_TO_PARSE(authFile,e.getMessage()), null));
+            }
+            return;
+        }
+
+        if(!authFile.canRead()){
+            error(new SAXParseException("Authorization file: "+authFile + " does not have read permission!", null));
+            return;
+        }
+        parseAuth();
+    }
+
+    protected PasswordAuthentication getPasswordAuthentication() {
+        //If user sets proxy user and passwd and the RequestType is from proxy server then create
+        // PasswordAuthentication using proxyUser and proxyClass;
+        if((getRequestorType() == RequestorType.PROXY) && proxyUser != null && proxyPasswd != null){
+            return new PasswordAuthentication(proxyUser, proxyPasswd.toCharArray());
+        }
+        for(AuthInfo auth:authInfo){
+            if(auth.matchingHost(getRequestingURL())){
+                return new PasswordAuthentication(auth.getUser(), auth.getPassword().toCharArray());
+            }
+        }
+        return null;
+    }
+
+    private void parseAuth() {
+        errReceiver.info(new SAXParseException(WscompileMessages.WSIMPORT_READING_AUTH_FILE(authFile), null));
+
+        BufferedReader in;
+        try {
+            in = new BufferedReader(new InputStreamReader(new FileInputStream(authFile), "UTF-8"));
+        } catch (UnsupportedEncodingException e) {
+            error(new SAXParseException(e.getMessage(), null));
+            return;
+        } catch (FileNotFoundException e) {
+            error(new SAXParseException(WscompileMessages.WSIMPORT_AUTH_FILE_NOT_FOUND(authFile, defaultAuthfile), null, e));
+            return;
+        }
+        String text;
+        LocatorImpl locator = new LocatorImpl();
+        try {
+            int lineno = 1;
+
+            locator.setSystemId(authFile.getCanonicalPath());
+
+            while ((text = in.readLine()) != null) {
+                locator.setLineNumber(lineno++);
+                try {
+                    URL url = new URL(text);
+                    String authinfo = url.getUserInfo();
+
+                    if (authinfo != null) {
+                        int i = authinfo.indexOf(':');
+
+                        if (i >= 0) {
+                            String user = authinfo.substring(0, i);
+                            String password = authinfo.substring(i + 1);
+                            authInfo.add(new AuthInfo(new URL(text), user, password));
+                        } else {
+                            error(new SAXParseException(WscompileMessages.WSIMPORT_ILLEGAL_AUTH_INFO(url), locator));
+                        }
+                    } else {
+                        error(new SAXParseException(WscompileMessages.WSIMPORT_ILLEGAL_AUTH_INFO(url), locator));
+                    }
+
+                } catch (NumberFormatException e) {
+                    error(new SAXParseException(WscompileMessages.WSIMPORT_ILLEGAL_AUTH_INFO(text), locator));
+                }
+            }
+            in.close();
+        } catch (IOException e) {
+            error(new SAXParseException(WscompileMessages.WSIMPORT_FAILED_TO_PARSE(authFile,e.getMessage()), locator));
+        }
+    }
+
+    /**
+     * When user provides authfile explicitly using -Xauthfile we throw error otherwise show the mesage by default with -Xdebug flag
+     */
+    private void error(SAXParseException e){
+        if(giveError){
+            errReceiver.error(e);
+        } else{
+            errReceiver.debug(e);
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:16:38 2009
+++ new/src/share/classes/com/sun/tools/internal/ws/wsdl/parser/DOMForestParser.java	Tue Aug  4 10:16:38 2009
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.ws.wsdl.parser;
+
+import org.w3c.dom.Document;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.EntityResolver;
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import java.io.IOException;
+
+import com.sun.xml.internal.xsom.parser.XMLParser;
+
+/**
+ * {@link XMLParser} implementation that
+ * parses XML from a DOM forest instead of parsing it from
+ * its original location.
+ *
+ * @author Kohsuke Kawaguchi (kohsuke.kawaguchi@sun.com)
+ * @author Vivek Pandey
+ */
+public class DOMForestParser implements XMLParser {
+
+    /**
+     * DOM forest to be "parsed".
+     */
+    private final DOMForest forest;
+
+    /**
+     * Scanner object will do the actual SAX events generation.
+     */
+    private final DOMForestScanner scanner;
+
+    private final XMLParser fallbackParser;
+
+    /**
+     * @param fallbackParser This parser will be used when DOMForestParser needs to parse
+     *                       documents that are not in the forest.
+     */
+    public DOMForestParser(DOMForest forest, XMLParser fallbackParser) {
+        this.forest = forest;
+        this.scanner = new DOMForestScanner(forest);
+        this.fallbackParser = fallbackParser;
+    }
+
+
+    public void parse(InputSource source, ContentHandler handler,  EntityResolver entityResolver, ErrorHandler errHandler) throws SAXException, IOException {
+
+    }
+
+    public void parse(InputSource source, ContentHandler handler, ErrorHandler errorHandler, EntityResolver entityResolver)
+
+            throws SAXException, IOException {
+        String systemId = source.getSystemId();
+        Document dom = forest.get(systemId);
+
+        if (dom == null) {
+            // if no DOM tree is built for it,
+            // let the fall back parser parse the original document.
+            //
+            // for example, XSOM parses datatypes.xsd (XML Schema part 2)
+            // but this will never be built into the forest.
+            fallbackParser.parse(source, handler, errorHandler, entityResolver);
+            return;
+        }
+
+        scanner.scan(dom, handler);
+
+    }
+}
--- /dev/null	Tue Aug  4 10:16:40 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/ClassLoaderBuilder.java	Tue Aug  4 10:16:40 2009
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.tools.internal.xjc;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import javax.xml.bind.JAXBContext;
+
+import com.sun.istack.internal.tools.MaskingClassLoader;
+import com.sun.istack.internal.tools.ParallelWorldClassLoader;
+
+/**
+ * Creates a class loader configured to run XJC 1.0/2.0 safely without
+ * interference with JAXB 2.0 API in Mustang.
+ *
+ * @author Kohsuke Kawaguchi
+ */
+class ClassLoaderBuilder {
+
+    /**
+     * Creates a new class loader that eventually delegates to the given {@link ClassLoader}
+     * such that XJC can be loaded by using this classloader.
+     *
+     * @param v
+     *      Either "1.0" or "2.0", indicating the version of the -source value.
+     */
+    protected static ClassLoader createProtectiveClassLoader(ClassLoader cl, String v) throws ClassNotFoundException, MalformedURLException {
+        if(noHack)  return cl;  // provide an escape hatch
+
+        boolean mustang = false;
+
+        if(JAXBContext.class.getClassLoader()==null) {
+            // JAXB API is loaded from the bootstrap. We need to override one with ours
+            mustang = true;
+
+            List mask = new ArrayList(Arrays.asList(maskedPackages));
+            mask.add("javax.xml.bind.");
+
+            cl = new MaskingClassLoader(cl,mask);
+
+            URL apiUrl = cl.getResource("javax/xml/bind/annotation/XmlSeeAlso.class");
+            if(apiUrl==null)
+                throw new ClassNotFoundException("There's no JAXB 2.1 API in the classpath");
+
+            cl = new URLClassLoader(new URL[]{ParallelWorldClassLoader.toJarUrl(apiUrl)},cl);
+        }
+
+        //Leave XJC2 in the publicly visible place
+        // and then isolate XJC1 in a child class loader,
+        // then use a MaskingClassLoader
+        // so that the XJC2 classes in the parent class loader
+        //  won't interfere with loading XJC1 classes in a child class loader
+
+        if (v.equals("1.0")) {
+            if(!mustang)
+                // if we haven't used Masking ClassLoader, do so now.
+                cl = new MaskingClassLoader(cl,toolPackages);
+            cl = new ParallelWorldClassLoader(cl,"1.0/");
+        } else {
+            if(mustang)
+                // the whole RI needs to be loaded in a separate class loader
+                cl = new ParallelWorldClassLoader(cl,"");
+        }
+
+        return cl;
+    }
+
+
+    /**
+     * The list of package prefixes we want the
+     * {@link MaskingClassLoader} to prevent the parent
+     * classLoader from loading
+     */
+    private static String[] maskedPackages = new String[]{
+        // toolPackages + alpha
+        "com.sun.tools.",
+        "com.sun.codemodel.internal.",
+        "com.sun.relaxng.",
+        "com.sun.xml.internal.xsom.",
+        "com.sun.xml.internal.bind.",
+    };
+
+    private static String[] toolPackages = new String[]{
+        "com.sun.tools.",
+        "com.sun.codemodel.internal.",
+        "com.sun.relaxng.",
+        "com.sun.xml.internal.xsom."
+    };
+
+    /**
+     * Escape hatch in case this class loader hack breaks.
+     */
+    public static final boolean noHack = Boolean.getBoolean(XJCFacade.class.getName()+".nohack");
+}
--- /dev/null	Tue Aug  4 10:16:42 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/XJCFacade.java	Tue Aug  4 10:16:42 2009
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.tools.internal.xjc;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * A shabby driver to invoke XJC1 or XJC2 depending on the command line switch.
+ *
+ * <p>
+ * This class is compiled with -source 1.2 so that we can report a nice user-friendly
+ * "you require Tiger" error message.
+ *
+ * @author Kohsuke Kawaguchi
+ */
+public class XJCFacade {
+
+    public static void main(String[] args) throws Throwable {
+        String v = "2.0";      // by default, we go 2.0
+
+        for( int i=0; i<args.length; i++ ) {
+            if(args[i].equals("-source")) {
+                if(i+1<args.length) {
+                    v = parseVersion(args[i+1]);
+                }
+            }
+        }
+
+        try {
+            ClassLoader cl = ClassLoaderBuilder.createProtectiveClassLoader(XJCFacade.class.getClassLoader(), v);
+
+            Class driver = cl.loadClass("com.sun.tools.internal.xjc.Driver");
+            Method mainMethod = driver.getDeclaredMethod("main", new Class[]{String[].class});
+            try {
+                mainMethod.invoke(null,new Object[]{args});
+            } catch (IllegalAccessException e) {
+                throw e;
+            } catch (InvocationTargetException e) {
+                if(e.getTargetException()!=null)
+                    throw e.getTargetException();
+            }
+        } catch (UnsupportedClassVersionError e) {
+            System.err.println("XJC requires JDK 5.0 or later. Please download it from http://java.sun.com/j2se/1.5/");
+        }
+    }
+
+    private static String parseVersion(String version) {
+        if(version.equals("1.0"))
+            return version;
+        // if we don't recognize the version number, we'll go to 2.0 RI
+        // anyway. It's easier to report an error message there,
+        // than in here.
+        return "2.0";
+    }
+}
--- /dev/null	Tue Aug  4 10:16:44 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/annotation/ri/OverrideAnnotationOfWriter.java	Tue Aug  4 10:16:44 2009
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.xjc.generator.annotation.ri;
+
+import com.sun.codemodel.internal.JAnnotationWriter;
+import com.sun.xml.internal.bind.annotation.OverrideAnnotationOf;
+
+public interface OverrideAnnotationOfWriter
+    extends JAnnotationWriter<OverrideAnnotationOf>
+{
+
+
+    OverrideAnnotationOfWriter value(String value);
+
+}
--- /dev/null	Tue Aug  4 10:16:46 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/ContentListField.java	Tue Aug  4 10:16:46 2009
@@ -0,0 +1,176 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.xjc.generator.bean.field;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.sun.codemodel.internal.JBlock;
+import com.sun.codemodel.internal.JClass;
+import com.sun.codemodel.internal.JExpr;
+import com.sun.codemodel.internal.JExpression;
+import com.sun.codemodel.internal.JMethod;
+import com.sun.codemodel.internal.JType;
+import com.sun.codemodel.internal.JVar;
+import com.sun.tools.internal.xjc.generator.bean.ClassOutlineImpl;
+import com.sun.tools.internal.xjc.generator.bean.MethodWriter;
+import com.sun.tools.internal.xjc.model.CPropertyInfo;
+import com.sun.tools.internal.xjc.outline.Aspect;
+import com.sun.xml.internal.bind.api.impl.NameConverter;
+import java.io.Serializable;
+
+/**
+ * Realizes a property as an untyped {@link List}.
+ *
+ * <pre>
+ * List getXXX();
+ * </pre>
+ *
+ * <h2>Default value handling</h2>
+ * <p>
+ * Since unmarshaller just adds new values into the storage,
+ * we can't fill the storage by default values at the time of
+ * instanciation. (or oherwise values found in the document will
+ * be appended to default values, where it should overwrite them.)
+ * <p>
+ * Therefore, when the object is created, the storage will be empty.
+ * When the getXXX method is called, we'll check if the storage is
+ * modified in anyway. If it is modified, it must mean that the values
+ * are found in the document, so we just return it.
+ *
+ * Otherwise we will fill in default values and return it to the user.
+ *
+ * <p>
+ * When a list has default values, its dirty flag is set to true.
+ * Marshaller will check this and treat it appropriately.
+ *
+ *
+ * @author
+ *     Kohsuke Kawaguchi (kohsuke.kawaguchi@sun.com)
+ */
+public class ContentListField extends AbstractListField {
+
+    /**
+     * A concrete class that implements the List interface.
+     * An instance of this class will be used to store data
+     * for this field.
+     */
+    private final JClass coreList;
+
+    /** List getFIELD() method. */
+    private JMethod $get;
+
+    /**
+     * @param coreList
+     *      A concrete class that implements the List interface.
+     *      An instance of this class will be used to store data
+     *      for this field.
+     */
+    protected ContentListField(ClassOutlineImpl context, CPropertyInfo prop, JClass coreList) {
+        // the JAXB runtime picks ArrayList if the signature is List,
+        // so don't do eager allocation if it's ArrayList.
+        // otherwise we need to do eager allocation so that the collection type specified by the user
+        // will be used.
+        super(context, prop, false);
+        this.coreList = coreList;
+        generate();
+    }
+
+    protected final JClass getCoreListType() {
+        return coreList;
+    }
+
+    @Override
+    public void generateAccessors() {
+        final MethodWriter writer = outline.createMethodWriter();
+        final Accessor acc = create(JExpr._this());
+
+        // [RESULT]
+        // List getXXX() {
+        //     return <ref>;
+        // }
+        $get = writer.declareMethod(listT,"get"+prop.getName(true));
+        writer.javadoc().append(prop.javadoc);
+        JBlock block = $get.body();
+        fixNullRef(block);  // avoid using an internal getter
+        block._return(acc.ref(true));
+
+        String pname = NameConverter.standard.toVariableName(prop.getName(true));
+        writer.javadoc().append(
+            "Gets the value of the "+pname+" property.\n\n"+
+            "<p>\n" +
+            "This accessor method returns a reference to the live list,\n" +
+            "not a snapshot. Therefore any modification you make to the\n" +
+            "returned list will be present inside the JAXB object.\n" +
+            "This is why there is not a <CODE>set</CODE> method for the " +pname+ " property.\n" +
+            "\n"+
+            "<p>\n" +
+            "For example, to add a new item, do as follows:\n"+
+            "<pre>\n"+
+            "   get"+prop.getName(true)+"().add(newItem);\n"+
+            "</pre>\n"+
+            "\n\n"
+        );
+
+        writer.javadoc().append(
+            "<p>\n" +
+            "Objects of the following type(s) are allowed in the list\n")
+            .append(listPossibleTypes(prop));
+    }
+
+    public Accessor create(JExpression targetObject) {
+        return new Accessor(targetObject);
+    }
+
+    class Accessor extends AbstractListField.Accessor {
+        protected Accessor( JExpression $target ) {
+            super($target);
+        }
+
+        public void toRawValue(JBlock block, JVar $var) {
+            // [RESULT]
+            // $<var>.addAll(bean.getLIST());
+            // list.toArray( array );
+            block.assign($var,JExpr._new(codeModel.ref(ArrayList.class).narrow(exposedType.boxify())).arg(
+                $target.invoke($get)
+            ));
+        }
+
+        public void fromRawValue(JBlock block, String uniqueName, JExpression $var) {
+            // [RESULT]
+            // bean.getLIST().addAll($<var>);
+            JVar $list = block.decl(listT,uniqueName+'l',$target.invoke($get));
+            block.invoke($list,"addAll").arg($var);
+        }
+    }
+
+    @Override
+    protected JType getType(final Aspect aspect) {
+        if (Aspect.IMPLEMENTATION.equals(aspect)) {
+            return super.getType(aspect);
+        }
+        return codeModel.ref(Serializable.class);
+    }
+}
--- /dev/null	Tue Aug  4 10:16:48 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/DummyListField.java	Tue Aug  4 10:16:48 2009
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.xjc.generator.bean.field;
+
+import com.sun.codemodel.internal.JAnnotatable;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.sun.codemodel.internal.JBlock;
+import com.sun.codemodel.internal.JClass;
+import com.sun.codemodel.internal.JExpr;
+import com.sun.codemodel.internal.JExpression;
+import com.sun.codemodel.internal.JMethod;
+import com.sun.codemodel.internal.JVar;
+import com.sun.tools.internal.xjc.generator.bean.ClassOutlineImpl;
+import com.sun.tools.internal.xjc.model.CPropertyInfo;
+import com.sun.tools.internal.xjc.model.CReferencePropertyInfo;
+import com.sun.xml.internal.bind.annotation.OverrideAnnotationOf;
+
+/**
+ * Realizes a property as an untyped {@link List}.
+ *
+ * <pre>
+ * List getXXX();
+ * </pre>
+ *
+ * <h2>Default value handling</h2>
+ * <p>
+ * Since unmarshaller just adds new values into the storage,
+ * we can't fill the storage by default values at the time of
+ * instanciation. (or oherwise values found in the document will
+ * be appended to default values, where it should overwrite them.)
+ * <p>
+ * Therefore, when the object is created, the storage will be empty.
+ * When the getXXX method is called, we'll check if the storage is
+ * modified in anyway. If it is modified, it must mean that the values
+ * are found in the document, so we just return it.
+ *
+ * Otherwise we will fill in default values and return it to the user.
+ *
+ * <p>
+ * When a list has default values, its dirty flag is set to true.
+ * Marshaller will check this and treat it appropriately.
+ *
+ *
+ * @author
+ *     Kohsuke Kawaguchi (kohsuke.kawaguchi@sun.com)
+ */
+public class DummyListField extends AbstractListField {
+
+    /**
+     * A concrete class that imp    lements the List interface.
+     * An instance of this class will be used to store data
+     * for this field.
+     */
+    private final JClass coreList;
+
+
+    /** List getFIELD() method. */
+    private JMethod $get;
+
+    /**
+     * @param coreList
+     *      A concrete class that implements the List interface.
+     *      An instance of this class will be used to store data
+     *      for this field.
+     */
+    protected DummyListField(ClassOutlineImpl context, CPropertyInfo prop, JClass coreList) {
+        // the JAXB runtime picks ArrayList if the signature is List,
+        // so don't do eager allocation if it's ArrayList.
+        // otherwise we need to do eager allocation so that the collection type specified by the user
+        // will be used.
+        super(context, prop, !coreList.fullName().equals("java.util.ArrayList"));
+        this.coreList = coreList.narrow(exposedType.boxify());
+        generate();
+    }
+
+    /**
+     * Annotate the field according to the recipes given as {@link CPropertyInfo}.
+     */
+    @Override
+    protected void annotate( JAnnotatable field ) {
+        super.annotate(field);
+
+        if (prop instanceof CReferencePropertyInfo) {
+            CReferencePropertyInfo pref = (CReferencePropertyInfo)prop;
+            if (pref.isDummy()) {
+                annotateDummy(field);
+            }
+        }
+
+    }
+
+    private void annotateDummy(JAnnotatable field) {
+        field.annotate(OverrideAnnotationOf.class);
+    }
+
+    protected final JClass getCoreListType() {
+        return coreList;
+    }
+
+    @Override
+    public void generateAccessors() { }
+
+    public Accessor create(JExpression targetObject) {
+        return new Accessor(targetObject);
+    }
+
+    class Accessor extends AbstractListField.Accessor {
+        protected Accessor( JExpression $target ) {
+            super($target);
+        }
+
+        public void toRawValue(JBlock block, JVar $var) {
+            // [RESULT]
+            // $<var>.addAll(bean.getLIST());
+            // list.toArray( array );
+            block.assign($var,JExpr._new(codeModel.ref(ArrayList.class).narrow(exposedType.boxify())).arg(
+                $target.invoke($get)
+            ));
+        }
+
+        public void fromRawValue(JBlock block, String uniqueName, JExpression $var) {
+            // [RESULT]
+            // bean.getLIST().addAll($<var>);
+            JVar $list = block.decl(listT,uniqueName+'l',$target.invoke($get));
+            block.invoke($list,"addAll").arg($var);
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:16:50 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/generator/bean/field/NoExtendedContentField.java	Tue Aug  4 10:16:50 2009
@@ -0,0 +1,187 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.xjc.generator.bean.field;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.sun.codemodel.internal.JBlock;
+import com.sun.codemodel.internal.JClass;
+import com.sun.codemodel.internal.JExpr;
+import com.sun.codemodel.internal.JExpression;
+import com.sun.codemodel.internal.JMethod;
+import com.sun.codemodel.internal.JType;
+import com.sun.codemodel.internal.JVar;
+import com.sun.tools.internal.xjc.generator.bean.ClassOutlineImpl;
+import com.sun.tools.internal.xjc.generator.bean.MethodWriter;
+import com.sun.tools.internal.xjc.model.CElement;
+import com.sun.tools.internal.xjc.model.CPropertyInfo;
+import com.sun.tools.internal.xjc.model.CReferencePropertyInfo;
+import com.sun.tools.internal.xjc.outline.Aspect;
+import com.sun.xml.internal.bind.api.impl.NameConverter;
+import java.io.Serializable;
+import java.util.Set;
+
+/**
+ * Realizes a property as an untyped {@link List}.
+ *
+ * <pre>
+ * List getXXX();
+ * </pre>
+ *
+ * <h2>Default value handling</h2>
+ * <p>
+ * Since unmarshaller just adds new values into the storage,
+ * we can't fill the storage by default values at the time of
+ * instanciation. (or oherwise values found in the document will
+ * be appended to default values, where it should overwrite them.)
+ * <p>
+ * Therefore, when the object is created, the storage will be empty.
+ * When the getXXX method is called, we'll check if the storage is
+ * modified in anyway. If it is modified, it must mean that the values
+ * are found in the document, so we just return it.
+ *
+ * Otherwise we will fill in default values and return it to the user.
+ *
+ * <p>
+ * When a list has default values, its dirty flag is set to true.
+ * Marshaller will check this and treat it appropriately.
+ *
+ *
+ * @author
+ *     Kohsuke Kawaguchi (kohsuke.kawaguchi@sun.com)
+ */
+public class NoExtendedContentField extends AbstractListField {
+
+    /**
+     * A concrete class that implements the List interface.
+     * An instance of this class will be used to store data
+     * for this field.
+     */
+    private final JClass coreList;
+
+    /** List getFIELD() method. */
+    private JMethod $get;
+
+    /**
+     * @param coreList
+     *      A concrete class that implements the List interface.
+     *      An instance of this class will be used to store data
+     *      for this field.
+     */
+    protected NoExtendedContentField(ClassOutlineImpl context, CPropertyInfo prop, JClass coreList) {
+        // the JAXB runtime picks ArrayList if the signature is List,
+        // so don't do eager allocation if it's ArrayList.
+        // otherwise we need to do eager allocation so that the collection type specified by the user
+        // will be used.
+        super(context, prop, false);
+        this.coreList = coreList;
+        generate();
+    }
+
+    protected final JClass getCoreListType() {
+        return coreList;
+    }
+
+    @Override
+    public void generateAccessors() {
+        final MethodWriter writer = outline.createMethodWriter();
+        final Accessor acc = create(JExpr._this());
+
+        // [RESULT]
+        // List getXXX() {
+        //     return <ref>;
+        // }
+        $get = writer.declareMethod(listT,"get"+prop.getName(true));
+        writer.javadoc().append(prop.javadoc);
+        JBlock block = $get.body();
+        fixNullRef(block);  // avoid using an internal getter
+        block._return(acc.ref(true));
+
+        String pname = NameConverter.standard.toVariableName(prop.getName(true));
+        writer.javadoc().append(
+            "Gets the value of the "+pname+" property.\n\n"+
+            "<p>\n" +
+            "This accessor method returns a reference to the live list,\n" +
+            "not a snapshot. Therefore any modification you make to the\n" +
+            "returned list will be present inside the JAXB object.\n" +
+            "This is why there is not a <CODE>set</CODE> method for the " +pname+ " property.\n" +
+            "\n"+
+            "<p>\n" +
+            "For example, to add a new item, do as follows:\n"+
+            "<pre>\n"+
+            "   get"+prop.getName(true)+"().add(newItem);\n"+
+            "</pre>\n"+
+            "\n\n"
+        );
+
+        writer.javadoc().append(
+            "<p>\n" +
+            "Objects of the following type(s) are allowed in the list\n")
+            .append(listPossibleTypes(prop));
+    }
+
+    public Accessor create(JExpression targetObject) {
+        return new Accessor(targetObject);
+    }
+
+    class Accessor extends AbstractListField.Accessor {
+        protected Accessor( JExpression $target ) {
+            super($target);
+        }
+
+        public void toRawValue(JBlock block, JVar $var) {
+            // [RESULT]
+            // $<var>.addAll(bean.getLIST());
+            // list.toArray( array );
+            block.assign($var,JExpr._new(codeModel.ref(ArrayList.class).narrow(getType(Aspect.EXPOSED).boxify())).arg(
+                $target.invoke($get)
+            ));
+        }
+
+        public void fromRawValue(JBlock block, String uniqueName, JExpression $var) {
+            // [RESULT]
+            // bean.getLIST().addAll($<var>);
+            JVar $list = block.decl(listT,uniqueName+'l',$target.invoke($get));
+            block.invoke($list,"addAll").arg($var);
+        }
+    }
+
+    @Override
+    protected JType getType(final Aspect aspect) {
+        if (Aspect.IMPLEMENTATION.equals(aspect)) {
+            return super.getType(aspect);
+        }
+
+        if (prop instanceof CReferencePropertyInfo) {
+            Set<CElement> elements = ((CReferencePropertyInfo)prop).getElements();
+            if ((elements != null) && (elements.size() > 0)) {
+                return codeModel.ref(Serializable.class);
+            }
+        }
+
+        return codeModel.ref(String.class);
+    }
+}
--- /dev/null	Tue Aug  4 10:16:52 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIFactoryMethod.java	Tue Aug  4 10:16:52 2009
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
+
+import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.namespace.QName;
+
+import com.sun.xml.internal.xsom.XSComponent;
+import com.sun.tools.internal.xjc.model.CPropertyInfo;
+import com.sun.tools.internal.xjc.reader.Ring;
+import com.sun.tools.internal.xjc.reader.Const;
+import com.sun.tools.internal.xjc.reader.xmlschema.BGMBuilder;
+
+/**
+ * Controls the <tt>ObjectFactory</tt> method name.
+ *
+ * @author Kohsuke Kawaguchi
+ */
+@XmlRootElement(name="factoryMethod")
+public class BIFactoryMethod extends AbstractDeclarationImpl {
+    @XmlAttribute
+    public String name;
+
+    /**
+     * If the given component has {@link BIInlineBinaryData} customization,
+     * reflect that to the specified property.
+     */
+    public static void handle(XSComponent source, CPropertyInfo prop) {
+        BIInlineBinaryData inline = Ring.get(BGMBuilder.class).getBindInfo(source).get(BIInlineBinaryData.class);
+        if(inline!=null) {
+            prop.inlineBinaryData = true;
+            inline.markAsAcknowledged();
+        }
+    }
+
+
+    public final QName getName() { return NAME; }
+
+    /** Name of the declaration. */
+    public static final QName NAME = new QName(Const.JAXB_NSURI,"factoryMethod");
+}
--- /dev/null	Tue Aug  4 10:16:54 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/bindinfo/BIInlineBinaryData.java	Tue Aug  4 10:16:54 2009
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.xjc.reader.xmlschema.bindinfo;
+
+import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.bind.annotation.XmlInlineBinaryData;
+import javax.xml.namespace.QName;
+
+import com.sun.tools.internal.xjc.reader.Const;
+import com.sun.tools.internal.xjc.reader.Ring;
+import com.sun.tools.internal.xjc.reader.xmlschema.BGMBuilder;
+import com.sun.tools.internal.xjc.model.CPropertyInfo;
+import com.sun.xml.internal.xsom.XSComponent;
+
+/**
+ * Generates {@link @XmlInlineBinaryData}.
+ *
+ * @author Kohsuke Kawaguchi
+ */
+@XmlRootElement(name="inlineBinaryData")
+public class BIInlineBinaryData extends AbstractDeclarationImpl {
+
+    /**
+     * If the given component has {@link BIInlineBinaryData} customization,
+     * reflect that to the specified property.
+     */
+    public static void handle(XSComponent source, CPropertyInfo prop) {
+        BIInlineBinaryData inline = Ring.get(BGMBuilder.class).getBindInfo(source).get(BIInlineBinaryData.class);
+        if(inline!=null) {
+            prop.inlineBinaryData = true;
+            inline.markAsAcknowledged();
+        }
+    }
+
+
+    public final QName getName() { return NAME; }
+
+    /** Name of the declaration. */
+    public static final QName NAME = new QName(Const.JAXB_NSURI,"inlineBinaryData");
+}
--- /dev/null	Tue Aug  4 10:16:56 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/AbstractExtendedComplexTypeBuilder.java	Tue Aug  4 10:16:56 2009
@@ -0,0 +1,221 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.tools.internal.xjc.reader.xmlschema.ct;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import com.sun.tools.internal.xjc.reader.xmlschema.WildcardNameClassBuilder;
+import com.sun.xml.internal.xsom.XSAttributeUse;
+import com.sun.xml.internal.xsom.XSComplexType;
+import com.sun.xml.internal.xsom.XSContentType;
+import com.sun.xml.internal.xsom.XSDeclaration;
+import com.sun.xml.internal.xsom.XSElementDecl;
+import com.sun.xml.internal.xsom.XSModelGroup;
+import com.sun.xml.internal.xsom.XSModelGroupDecl;
+import com.sun.xml.internal.xsom.XSParticle;
+import com.sun.xml.internal.xsom.XSType;
+import com.sun.xml.internal.xsom.XSWildcard;
+import com.sun.xml.internal.xsom.visitor.XSTermFunction;
+
+import com.sun.xml.internal.rngom.nc.ChoiceNameClass;
+import com.sun.xml.internal.rngom.nc.NameClass;
+import com.sun.xml.internal.rngom.nc.SimpleNameClass;
+
+/**
+ * Binds a complex type derived from another complex type by extension.
+ *
+ * @author
+ *     Kohsuke Kawaguchi (kohsuke.kawaguchi@sun.com)
+ */
+abstract class AbstractExtendedComplexTypeBuilder extends CTBuilder {
+
+    /**
+     * Map from {@link XSComplexType} to {@link NameClass}[2] that
+     * represents the names used in its child elements [0] and
+     * attributes [1].
+     */
+    protected final Map<XSComplexType, NameClass[]> characteristicNameClasses = new HashMap<XSComplexType, NameClass[]>();
+
+    /**
+     * Computes a name class that represents everything in a given content model.
+     */
+    protected final XSTermFunction<NameClass> contentModelNameClassBuilder = new XSTermFunction<NameClass>() {
+        public NameClass wildcard(XSWildcard wc) {
+            return WildcardNameClassBuilder.build(wc);
+        }
+
+        public NameClass modelGroupDecl(XSModelGroupDecl decl) {
+            return modelGroup(decl.getModelGroup());
+        }
+
+        public NameClass modelGroup(XSModelGroup group) {
+            NameClass nc = NameClass.NULL;
+            for( int i=0; i<group.getSize(); i++ )
+                nc = new ChoiceNameClass(nc, group.getChild(i).getTerm().apply(this));
+            return nc;
+        }
+
+        public NameClass elementDecl(XSElementDecl decl) {
+            return getNameClass(decl);
+        }
+    };
+
+    /**
+     * Checks if the particles/attributes defined in the type parameter
+     * collides with the name classes of anc/enc.
+     *
+     * @return true if there's a collision.
+     */
+    protected boolean checkCollision(NameClass anc, NameClass enc, XSComplexType type) {
+        NameClass[] chnc = characteristicNameClasses.get(type);
+        if (chnc == null) {
+            chnc = new NameClass[2];
+            chnc[0] = getNameClass(type.getContentType());
+
+            // build attribute name classes
+            NameClass nc = NameClass.NULL;
+            Iterator itr = type.iterateAttributeUses();
+            while( itr.hasNext() )
+                anc = new ChoiceNameClass(anc, getNameClass(((XSAttributeUse) itr.next()).getDecl()));
+            XSWildcard wc = type.getAttributeWildcard();
+            if(wc!=null)
+                nc = new ChoiceNameClass(nc, WildcardNameClassBuilder.build(wc));
+            chnc[1] = nc;
+
+            characteristicNameClasses.put(type, chnc);
+        }
+
+        return chnc[0].hasOverlapWith(enc) || chnc[1].hasOverlapWith(anc);
+    }
+
+    /**
+     * Looks for the derivation chain t_1 > t_2 > ... > t
+     * and find t_i such that t_i derives by restriction but
+     * for every j>i, t_j derives by extension.
+     *
+     * @return null
+     *      If there's no such t_i or if t_i is any type.
+     */
+    protected XSComplexType getLastRestrictedType(XSComplexType t) {
+        if (t.getBaseType() == schemas.getAnyType()) {
+            return null;   // we don't count the restriction from anyType
+        }
+        if (t.getDerivationMethod() == XSType.RESTRICTION) {
+            return t;
+        }
+
+        XSComplexType baseType = t.getBaseType().asComplexType();
+        if (baseType != null) {
+            return getLastRestrictedType(baseType);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Checks if this new extension is safe.
+     *
+     * UGLY.
+     * <p>
+     * If you have ctA extending ctB and ctB restricting ctC, our
+     * Java classes will look like CtAImpl extending CtBImpl
+     * extending CtCImpl.
+     *
+     * <p>
+     * Since a derived class unmarshaller uses the base class unmarshaller,
+     * this could potentially result in incorrect unmarshalling.
+     * We used to just reject such a case, but then we found that
+     * there are schemas that are using it.
+     *
+     * <p>
+     * One generalized observation that we reached is that if the extension
+     * is only adding new elements/attributes which has never been used
+     * in any of its base class (IOW, if none of the particle / attribute use /
+     * attribute wildcard can match the name of newly added elements/attributes)
+     * then it is safe to add them.
+     *
+     * <p>
+     * This function checks if the derivation chain to this type is
+     * not using restriction, and if it is, then checks if it is safe
+     * according to the above condition.
+     *
+     * @return false
+     *      If this complex type needs to be rejected.
+     */
+    protected boolean checkIfExtensionSafe(XSComplexType baseType, XSComplexType thisType) {
+        XSComplexType lastType = getLastRestrictedType(baseType);
+
+        if (lastType == null) {
+            return true;    // no restriction in derivation chain
+        }
+        NameClass anc = NameClass.NULL;
+        // build name class for attributes in new complex type
+        Iterator itr = thisType.iterateDeclaredAttributeUses();
+        while (itr.hasNext()) {
+            anc = new ChoiceNameClass(anc, getNameClass(((XSAttributeUse) itr.next()).getDecl()));
+        }
+        // TODO: attribute wildcard
+
+        NameClass enc = getNameClass(thisType.getExplicitContent());
+
+        // check against every base type ... except the root anyType
+        while (lastType != lastType.getBaseType()) {
+            if (checkCollision(anc, enc, lastType)) {
+                return false;
+            }
+
+            if (lastType.getBaseType().isSimpleType()) // if the base type is a simple type, there won't be
+            // any further name collision.
+            {
+                return true;
+            }
+
+            lastType = lastType.getBaseType().asComplexType();
+        }
+
+        return true;    // OK
+    }
+
+    /**
+     * Gets a {@link NameClass} that represents all the terms in the given content type.
+     * If t is not a particle, just return an empty name class.
+     */
+    private NameClass getNameClass(XSContentType t) {
+        if(t==null) return NameClass.NULL;
+        XSParticle p = t.asParticle();
+        if(p==null) return NameClass.NULL;
+        else        return p.getTerm().apply(contentModelNameClassBuilder);
+    }
+
+    /**
+     * Gets a {@link SimpleNameClass} from the name of a {@link XSDeclaration}.
+     */
+    private NameClass getNameClass(XSDeclaration decl) {
+        return new SimpleNameClass(decl.getTargetNamespace(), decl.getName());
+    }
+
+}
--- /dev/null	Tue Aug  4 10:16:58 2009
+++ new/src/share/classes/com/sun/tools/internal/xjc/reader/xmlschema/ct/MixedExtendedComplexTypeBuilder.java	Tue Aug  4 10:16:58 2009
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.tools.internal.xjc.reader.xmlschema.ct;
+
+import com.sun.tools.internal.xjc.model.CClass;
+import com.sun.tools.internal.xjc.model.CPropertyInfo;
+import com.sun.tools.internal.xjc.reader.RawTypeSet;
+import com.sun.tools.internal.xjc.reader.xmlschema.RawTypeSetBuilder;
+import com.sun.tools.internal.xjc.reader.xmlschema.bindinfo.BIGlobalBinding;
+import com.sun.tools.internal.xjc.reader.xmlschema.bindinfo.BIProperty;
+import com.sun.xml.internal.xsom.XSComplexType;
+import com.sun.xml.internal.xsom.XSContentType;
+import com.sun.xml.internal.xsom.XSType;
+
+/**
+ * @author Kohsuke Kawaguchi
+ */
+final class MixedExtendedComplexTypeBuilder extends AbstractExtendedComplexTypeBuilder {
+
+    public boolean isApplicable(XSComplexType ct) {
+
+        if (!bgmBuilder.isGenerateMixedExtensions()) return false;
+
+        XSType bt = ct.getBaseType();
+        if (bt.isComplexType() &&
+            bt.asComplexType().isMixed() &&
+            ct.isMixed() &&
+            ct.getDerivationMethod()==XSType.EXTENSION &&
+            ct.getContentType().asParticle() != null &&
+            ct.getExplicitContent().asEmpty() == null
+            )  {
+                return true;
+        }
+
+        return false;
+    }
+
+    public void build(XSComplexType ct) {
+        XSComplexType baseType = ct.getBaseType().asComplexType();
+
+        // build the base class
+        CClass baseClass = selector.bindToType(baseType, ct, true);
+        assert baseClass != null;   // global complex type must map to a class
+
+        if (!checkIfExtensionSafe(baseType, ct)) {
+            // error. We can't handle any further extension
+            errorReceiver.error(ct.getLocator(),
+                    Messages.ERR_NO_FURTHER_EXTENSION.format(
+                    baseType.getName(), ct.getName() )
+            );
+            return;
+        }
+
+        selector.getCurrentBean().setBaseClass(baseClass);
+        builder.recordBindingMode(ct, ComplexTypeBindingMode.FALLBACK_EXTENSION);
+
+        BIProperty prop = BIProperty.getCustomization(ct);
+        CPropertyInfo p;
+
+        RawTypeSet ts = RawTypeSetBuilder.build(ct.getContentType().asParticle(), false);
+        p = prop.createDummyExtendedMixedReferenceProperty("contentOverrideFor" + ct.getName(), ct, ts);
+
+        selector.getCurrentBean().addProperty(p);
+
+        // adds attributes and we are through.
+        green.attContainer(ct);
+    }
+
+}
--- /dev/null	Tue Aug  4 10:17:00 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/annotation/OverrideAnnotationOf.java	Tue Aug  4 10:17:00 2009
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.bind.annotation;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Designates an annotation from base class which shall be overriden by annotation placed together with this.
+ *
+ * @author Martin Grebac
+ */
+@Retention(RUNTIME)
+@Target({FIELD})
+public @interface OverrideAnnotationOf {
+    String value() default "content";
+}
--- /dev/null	Tue Aug  4 10:17:03 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/Messages.java	Tue Aug  4 10:17:02 2009
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+
+package com.sun.xml.internal.bind.api;
+
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+
+/**
+ * Formats error messages.
+ *
+ * @since JAXB2.1.10
+ */
+
+enum Messages {
+    // TypeReference
+    ARGUMENT_CANT_BE_NULL
+    ;
+
+    private static final ResourceBundle rb = ResourceBundle.getBundle(Messages.class.getName());
+
+    @Override
+    public String toString() {
+        return format();
+    }
+
+    public String format( Object... args ) {
+        return MessageFormat.format( rb.getString(name()), args );
+    }
+}
--- /dev/null	Tue Aug  4 10:17:05 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/api/Messages.properties	Tue Aug  4 10:17:04 2009
@@ -0,0 +1,27 @@
+#
+# Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Sun designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Sun in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+# CA 95054 USA or visit www.sun.com if you need additional information or
+# have any questions.
+#
+
+ARGUMENT_CANT_BE_NULL = \
+    Argument(s) "{0}" can''t be null.
--- /dev/null	Tue Aug  4 10:17:07 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/annotation/XmlSchemaTypeQuick.java	Tue Aug  4 10:17:06 2009
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.bind.v2.model.annotation;
+
+import java.lang.annotation.Annotation;
+import javax.xml.bind.annotation.XmlSchemaType;
+
+final class XmlSchemaTypeQuick
+    extends Quick
+    implements XmlSchemaType
+{
+
+    private final XmlSchemaType core;
+
+    public XmlSchemaTypeQuick(Locatable upstream, XmlSchemaType core) {
+        super(upstream);
+        this.core = core;
+    }
+
+    protected Annotation getAnnotation() {
+        return core;
+    }
+
+    protected Quick newInstance(Locatable upstream, Annotation core) {
+        return new XmlSchemaTypeQuick(upstream, ((XmlSchemaType) core));
+    }
+
+    public Class<XmlSchemaType> annotationType() {
+        return XmlSchemaType.class;
+    }
+
+    public String name() {
+        return core.name();
+    }
+
+    public Class type() {
+        return core.type();
+    }
+
+    public String namespace() {
+        return core.namespace();
+    }
+
+}
--- /dev/null	Tue Aug  4 10:17:09 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/model/impl/DummyPropertyInfo.java	Tue Aug  4 10:17:08 2009
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.bind.v2.model.impl;
+
+/**
+ * {@link PropertyInfo} that allows to add additional elements to the collection.
+ *
+ * @author Martin Grebac
+ */
+public interface DummyPropertyInfo<T, C, F, M> {
+    void addType(PropertyInfoImpl<T, C, F, M> info);
+}
--- /dev/null	Tue Aug  4 10:17:11 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/AttributeAccessor.java	Tue Aug  4 10:17:10 2009
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.bind.v2.runtime;
+
+/**
+ *
+ * @author snajper
+ */
+public interface AttributeAccessor<BeanT> {
+
+    public boolean isNilIncluded();
+}
--- /dev/null	Tue Aug  4 10:17:13 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/output/StAXExStreamWriterOutput.java	Tue Aug  4 10:17:12 2009
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.bind.v2.runtime.output;
+
+import javax.xml.stream.XMLStreamException;
+
+import com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data;
+
+import com.sun.xml.internal.org.jvnet.staxex.XMLStreamWriterEx;
+
+/**
+ * {@link XmlOutput} for {@link XMLStreamWriterEx}.
+ *
+ * @author Paul Sandoz.
+ */
+public final class StAXExStreamWriterOutput extends XMLStreamWriterOutput {
+    private final XMLStreamWriterEx out;
+
+    public StAXExStreamWriterOutput(XMLStreamWriterEx out) {
+        super(out);
+        this.out = out;
+    }
+
+    public void text(Pcdata value, boolean needsSeparatingWhitespace) throws XMLStreamException {
+        if(needsSeparatingWhitespace) {
+            out.writeCharacters(" ");
+        }
+
+        if (!(value instanceof Base64Data)) {
+            out.writeCharacters(value.toString());
+        } else {
+            Base64Data v = (Base64Data)value;
+            out.writeBinary(v.getDataHandler());
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:17:15 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StAXExConnector.java	Tue Aug  4 10:17:14 2009
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.bind.v2.runtime.unmarshaller;
+
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+
+import com.sun.xml.internal.org.jvnet.staxex.XMLStreamReaderEx;
+import org.xml.sax.SAXException;
+
+/**
+ * Reads XML from StAX {@link XMLStreamReader} and
+ * feeds events to {@link XmlVisitor}.
+ *
+ * @author Ryan.Shoemaker@Sun.COM
+ * @author Kohsuke Kawaguchi
+ * @version JAXB 2.0
+ */
+final class StAXExConnector extends StAXStreamConnector {
+
+    // StAX event source
+    private final XMLStreamReaderEx in;
+
+    public StAXExConnector(XMLStreamReaderEx in, XmlVisitor visitor) {
+        super(in,visitor);
+        this.in = in;
+    }
+
+    @Override
+    protected void handleCharacters() throws XMLStreamException, SAXException {
+        if( predictor.expectText() ) {
+            CharSequence pcdata = in.getPCDATA();
+            if(pcdata instanceof com.sun.xml.internal.org.jvnet.staxex.Base64Data) {
+                com.sun.xml.internal.org.jvnet.staxex.Base64Data bd = (com.sun.xml.internal.org.jvnet.staxex.Base64Data) pcdata;
+                Base64Data binary = new Base64Data();
+                if(!bd.hasData())
+                    binary.set(bd.getDataHandler());
+                else
+                    binary.set( bd.get(), bd.getDataLen(), bd.getMimeType() );
+                // we make an assumption here that the binary data shows up on its own
+                // not adjacent to other text. So it's OK to fire it off right now.
+                visitor.text(binary);
+                textReported = true;
+            } else {
+                buffer.append(pcdata);
+            }
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:17:17 2009
+++ new/src/share/classes/com/sun/xml/internal/bind/v2/util/StackRecorder.java	Tue Aug  4 10:17:16 2009
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.bind.v2.util;
+
+/**
+ * Created to record the caller stack trace in logging.
+ *
+ * @author Kohsuke Kawaguchi
+ */
+public class StackRecorder extends Throwable {
+}
--- /dev/null	Tue Aug  4 10:17:19 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/Chunk.java	Tue Aug  4 10:17:18 2009
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.nio.ByteBuffer;
+
+/**
+ * @author Kohsuke Kawaguchi
+ */
+final class Chunk {
+    volatile Chunk next;
+    volatile Data data;
+
+    public Chunk(Data data) {
+        this.data = data;
+    }
+
+    /**
+     * Creates a new chunk and adds to linked list.
+     *
+     * @param dataHead of the linked list
+     * @param buf MIME part partial data
+     * @return created chunk
+     */
+    public Chunk createNext(DataHead dataHead, ByteBuffer buf) {
+        return next = new Chunk(data.createNext(dataHead, buf));
+    }
+}
--- /dev/null	Tue Aug  4 10:17:21 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/ChunkInputStream.java	Tue Aug  4 10:17:20 2009
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.io.InputStream;
+import java.io.IOException;
+
+/**
+ * Constructs a InputStream from a linked list of {@link Chunk}s.
+ *
+ * @author Kohsuke Kawaguchi
+ * @author Jitendra Kotamraju
+ */
+final class ChunkInputStream extends InputStream {
+    Chunk current;
+    int offset;
+    int len;
+    final MIMEMessage msg;
+    final MIMEPart part;
+    byte[] buf;
+
+    public ChunkInputStream(MIMEMessage msg, MIMEPart part, Chunk startPos) {
+        this.current = startPos;
+        len = current.data.size();
+        buf = current.data.read();
+        this.msg = msg;
+        this.part = part;
+    }
+
+    @Override
+    public int read(byte b[], int off, int sz) throws IOException {
+        if(!fetch())    return -1;
+
+        sz = Math.min(sz, len-offset);
+        System.arraycopy(buf,offset,b,off,sz);
+        return sz;
+    }
+
+    public int read() throws IOException {
+        if(!fetch()) return -1;
+        return (buf[offset++] & 0xff);
+    }
+
+    /**
+     * Gets to the next chunk if we are done with the current one.
+     * @return
+     */
+    private boolean fetch() {
+        if (current == null) {
+            throw new IllegalStateException("Stream already closed");
+        }
+        while(offset==len) {
+            while(!part.parsed && current.next == null) {
+                msg.makeProgress();
+            }
+            current = current.next;
+
+            if (current == null) {
+                return false;
+            }
+            this.offset = 0;
+            this.buf = current.data.read();
+            this.len = current.data.size();
+        }
+        return true;
+    }
+
+    public void close() throws IOException {
+        super.close();
+        current = null;
+    }
+}
--- /dev/null	Tue Aug  4 10:17:23 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/Data.java	Tue Aug  4 10:17:22 2009
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.nio.ByteBuffer;
+
+/**
+ * @author Kohsuke Kawaguchi
+ * @author Jitendra Kotamraju
+ */
+interface Data {
+
+    /**
+     * size of the chunk given by the parser
+     *
+     * @return size of the chunk
+     */
+    int size();
+
+    /**
+     * TODO: should the return type be ByteBuffer ??
+     * Return part's partial data. The data is read only.
+     *
+     * @return a byte array which contains {#size()} bytes. The returned
+     *         array may be larger than {#size()} bytes and contains data
+     *         from offset 0.
+     */
+    byte[] read();
+
+    /**
+     * Write this partial data to a file
+     *
+     * @param file to which the data needs to be written
+     * @return file pointer before the write operation(at which the data is
+     *         written from)
+     */
+    long writeTo(DataFile file);
+
+    /**
+     * Factory method to create a Data. The implementation could
+     * be file based one or memory based one.
+     *
+     * @param dataHead start of the linked list of data objects
+     * @param buf contains partial content for a part
+     * @return Data
+     */
+    Data createNext(DataHead dataHead, ByteBuffer buf);
+}
--- /dev/null	Tue Aug  4 10:17:25 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/DataFile.java	Tue Aug  4 10:17:24 2009
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.io.*;
+
+/**
+ * Use {@link RandomAccessFile} for concurrent access of read
+ * and write partial part's content.
+ *
+ * @author Kohsuke Kawaguchi
+ * @author Jitendra Kotamraju
+ */
+final class DataFile {
+    private WeakDataFile weak;
+    private long writePointer;
+
+    DataFile(File file) {
+        writePointer=0;
+        weak = new WeakDataFile(this, file);
+    }
+
+    /**
+     *
+     */
+    void close() {
+        weak.close();
+    }
+
+    /**
+     * Read data from the given file pointer position.
+     *
+     * @param pointer read position
+     * @param buf that needs to be filled
+     * @param offset the start offset of the data.
+     * @param length of data that needs to be read
+     */
+    synchronized void read(long pointer, byte[] buf, int offset, int length ) {
+        weak.read(pointer, buf, offset, length);
+    }
+
+    void renameTo(File f) {
+        weak.renameTo(f);
+    }
+
+    /**
+     * Write data to the file
+     *
+     * @param data that needs to written to a file
+     * @param offset start offset in the data
+     * @param length no bytes to write
+     * @return file pointer before the write operation(or at which the
+     *         data is written)
+     */
+    synchronized long writeTo(byte[] data, int offset, int length) {
+        long temp = writePointer;
+        writePointer = weak.writeTo(writePointer, data, offset, length);
+        return temp;
+    }
+
+}
--- /dev/null	Tue Aug  4 10:17:27 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/DataHead.java	Tue Aug  4 10:17:26 2009
@@ -0,0 +1,258 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.io.*;
+import java.nio.ByteBuffer;
+
+/**
+ * Represents an attachment part in a MIME message. MIME message parsing is done
+ * lazily using a pull parser, so the part may not have all the data. {@link #read}
+ * and {@link #readOnce} may trigger the actual parsing the message. In fact,
+ * parsing of an attachment part may be triggered by calling {@link #read} methods
+ * on some other attachemnt parts. All this happens behind the scenes so the
+ * application developer need not worry about these details.
+ *
+ * @author Jitendra Kotamraju
+ */
+final class DataHead {
+
+    /**
+     * Linked list to keep the part's content
+     */
+    volatile Chunk head, tail;
+
+    /**
+     * If the part is stored in a file, non-null.
+     */
+    DataFile dataFile;
+
+    private final MIMEPart part;
+
+    boolean readOnce;
+    volatile long inMemory;
+
+    /**
+     * Used only for debugging. This records where readOnce() is called.
+     */
+    private Throwable consumedAt;
+
+    DataHead(MIMEPart part) {
+        this.part = part;
+    }
+
+    void addBody(ByteBuffer buf) {
+        synchronized(this) {
+            inMemory += buf.limit();
+        }
+        if (tail != null) {
+            tail = tail.createNext(this, buf);
+        } else {
+            head = tail = new Chunk(new MemoryData(buf, part.msg.config));
+        }
+    }
+
+    void doneParsing() {
+    }
+
+    void moveTo(File f) {
+        if (dataFile != null) {
+            dataFile.renameTo(f);
+        } else {
+            try {
+                OutputStream os = new FileOutputStream(f);
+                InputStream in = readOnce();
+                byte[] buf = new byte[8192];
+                int len;
+                while((len=in.read(buf)) != -1) {
+                    os.write(buf, 0, len);
+                }
+                os.close();
+            } catch(IOException ioe) {
+                throw new MIMEParsingException(ioe);
+            }
+        }
+    }
+
+    void close() {
+        if (dataFile != null) {
+            head = tail = null;
+            dataFile.close();
+        }
+    }
+
+
+    /**
+     * Can get the attachment part's content multiple times. That means
+     * the full content needs to be there in memory or on the file system.
+     * Calling this method would trigger parsing for the part's data. So
+     * do not call this unless it is required(otherwise, just wrap MIMEPart
+     * into a object that returns InputStream for e.g DataHandler)
+     *
+     * @return data for the part's content
+     */
+    public InputStream read() {
+        if (readOnce) {
+            throw new IllegalStateException("readOnce() is called before, read() cannot be called later.");
+        }
+
+        // Trigger parsing for the part
+        while(tail == null) {
+            if (!part.msg.makeProgress()) {
+                throw new IllegalStateException("No such MIME Part: "+part);
+            }
+        }
+
+        if (head == null) {
+            throw new IllegalStateException("Already read. Probably readOnce() is called before.");
+        }
+        return new ReadMultiStream();
+    }
+
+    /**
+     * Used for an assertion. Returns true when readOnce() is not already called.
+     * or otherwise throw an exception.
+     *
+     * <p>
+     * Calling this method also marks the stream as 'consumed'
+     *
+     * @return true if readOnce() is not called before
+     */
+    private boolean unconsumed() {
+        if (consumedAt != null) {
+            AssertionError error = new AssertionError("readOnce() is already called before. See the nested exception from where it's called.");
+            error.initCause(consumedAt);
+            throw error;
+        }
+        consumedAt = new Exception().fillInStackTrace();
+        return true;
+    }
+
+    /**
+     * Can get the attachment part's content only once. The content
+     * will be lost after the method. Content data is not be stored
+     * on the file system or is not kept in the memory for the
+     * following case:
+     *   - Attachement parts contents are accessed sequentially
+     *
+     * In general, take advantage of this when the data is used only
+     * once.
+     *
+     * @return data for the part's content
+     */
+    public InputStream readOnce() {
+        assert unconsumed();
+        if (readOnce) {
+            throw new IllegalStateException("readOnce() is called before. It can only be called once.");
+        }
+        readOnce = true;
+        // Trigger parsing for the part
+        while(tail == null) {
+            if (!part.msg.makeProgress() && tail == null) {
+                throw new IllegalStateException("No such Part: "+part);
+            }
+        }
+        InputStream in = new ReadOnceStream();
+        head = null;
+        return in;
+    }
+
+    class ReadMultiStream extends InputStream {
+        Chunk current;
+        int offset;
+        int len;
+        byte[] buf;
+
+        public ReadMultiStream() {
+            this.current = head;
+            len = current.data.size();
+            buf = current.data.read();
+        }
+
+        @Override
+        public int read(byte b[], int off, int sz) throws IOException {
+            if(!fetch())    return -1;
+
+            sz = Math.min(sz, len-offset);
+            System.arraycopy(buf,offset,b,off,sz);
+            offset += sz;
+            return sz;
+        }
+
+        public int read() throws IOException {
+            if (!fetch()) {
+                return -1;
+            }
+            return (buf[offset++] & 0xff);
+        }
+
+        void adjustInMemoryUsage() {
+            // Nothing to do in this case.
+        }
+
+        /**
+         * Gets to the next chunk if we are done with the current one.
+         * @return
+         */
+        private boolean fetch() {
+            if (current == null) {
+                throw new IllegalStateException("Stream already closed");
+            }
+            while(offset==len) {
+                while(!part.parsed && current.next == null) {
+                    part.msg.makeProgress();
+                }
+                current = current.next;
+
+                if (current == null) {
+                    return false;
+                }
+                adjustInMemoryUsage();
+                this.offset = 0;
+                this.buf = current.data.read();
+                this.len = current.data.size();
+            }
+            return true;
+        }
+
+        public void close() throws IOException {
+            super.close();
+            current = null;
+        }
+    }
+
+    final class ReadOnceStream extends ReadMultiStream {
+
+        @Override
+        void adjustInMemoryUsage() {
+            synchronized(DataHead.this) {
+                inMemory -= current.data.size();    // adjust current memory usage
+            }
+        }
+
+    }
+
+
+}
--- /dev/null	Tue Aug  4 10:17:29 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/FileData.java	Tue Aug  4 10:17:28 2009
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Keeps the Part's partial content data in a file.
+ *
+ * @author Kohsuke Kawaguchi
+ * @author Jitendra Kotamraju
+ */
+final class FileData implements Data {
+    private final DataFile file;
+    private final long pointer;         // read position
+    private final int length;
+
+    FileData(DataFile file, ByteBuffer buf) {
+        this(file, file.writeTo(buf.array(), 0, buf.limit()), buf.limit());
+    }
+
+    FileData(DataFile file, long pointer, int length) {
+        this.file = file;
+        this.pointer = pointer;
+        this.length = length;
+    }
+
+    public byte[] read() {
+        byte[] buf = new byte[length];
+        file.read(pointer, buf, 0, length);
+        return buf;
+    }
+
+    /*
+     * This shouldn't be called
+     */
+    public long writeTo(DataFile file) {
+        throw new IllegalStateException();
+    }
+
+    public int size() {
+        return length;
+    }
+
+    /*
+     * Always create FileData
+     */
+    public Data createNext(DataHead dataHead, ByteBuffer buf) {
+        return new FileData(file, buf);
+    }
+}
--- /dev/null	Tue Aug  4 10:17:31 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/FinalArrayList.java	Tue Aug  4 10:17:30 2009
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * {@link java.util.ArrayList} with the final keyword.
+ *
+ * <p>
+ * This gives HotSpot a better hint that all methods can be inlined.
+ *
+ * @author Kohsuke Kawaguchi
+ */
+final class FinalArrayList<T> extends ArrayList<T> {
+    public FinalArrayList(int initialCapacity) {
+        super(initialCapacity);
+    }
+
+    public FinalArrayList() {
+    }
+
+    public FinalArrayList(Collection<? extends T> ts) {
+        super(ts);
+    }
+}
--- /dev/null	Tue Aug  4 10:17:33 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/Header.java	Tue Aug  4 10:17:32 2009
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+/**
+ * The Header class stores a name/value pair to represent headers.
+ *
+ * @author John Mani
+ */
+
+public interface Header {
+
+    /**
+     * Returns the name of this header.
+     *
+     * @return          name of the header
+     */
+    String getName();
+
+    /**
+     * Returns the value of this header.
+     *
+     * @return          value of the header
+     */
+    String getValue();
+}
--- /dev/null	Tue Aug  4 10:17:35 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/InternetHeaders.java	Tue Aug  4 10:17:34 2009
@@ -0,0 +1,238 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.io.IOException;
+import java.util.NoSuchElementException;
+import java.util.List;
+
+/**
+ * InternetHeaders is a utility class that manages RFC822 style
+ * headers. Given an RFC822 format message stream, it reads lines
+ * until the blank line that indicates end of header. The input stream
+ * is positioned at the start of the body. The lines are stored
+ * within the object and can be extracted as either Strings or
+ * {@link Header} objects. <p>
+ * <p/>
+ * This class is mostly intended for service providers. MimeMessage
+ * and MimeBody use this class for holding their headers. <p>
+ * <p/>
+ * <hr> <strong>A note on RFC822 and MIME headers</strong><p>
+ * <p/>
+ * RFC822 and MIME header fields <strong>must</strong> contain only
+ * US-ASCII characters. If a header contains non US-ASCII characters,
+ * it must be encoded as per the rules in RFC 2047. The MimeUtility
+ * class provided in this package can be used to to achieve this.
+ * Callers of the <code>setHeader</code>, <code>addHeader</code>, and
+ * <code>addHeaderLine</code> methods are responsible for enforcing
+ * the MIME requirements for the specified headers.  In addition, these
+ * header fields must be folded (wrapped) before being sent if they
+ * exceed the line length limitation for the transport (1000 bytes for
+ * SMTP).  Received headers may have been folded.  The application is
+ * responsible for folding and unfolding headers as appropriate. <p>
+ *
+ * @author John Mani
+ * @author Bill Shannon
+ */
+final class InternetHeaders {
+
+    private final FinalArrayList<hdr> headers = new FinalArrayList<hdr>();
+
+    /**
+     * Read and parse the given RFC822 message stream till the
+     * blank line separating the header from the body. Store the
+     * header lines inside this InternetHeaders object. <p>
+     * <p/>
+     * Note that the header lines are added into this InternetHeaders
+     * object, so any existing headers in this object will not be
+     * affected.
+     *
+     * @param   lis RFC822 input stream
+     */
+    InternetHeaders(MIMEParser.LineInputStream lis) {
+        // Read header lines until a blank line. It is valid
+        // to have BodyParts with no header lines.
+        String line;
+        String prevline = null; // the previous header line, as a string
+        // a buffer to accumulate the header in, when we know it's needed
+        StringBuffer lineBuffer = new StringBuffer();
+
+        try {
+            //while ((line = lis.readLine()) != null) {
+            do {
+                line = lis.readLine();
+                if (line != null &&
+                        (line.startsWith(" ") || line.startsWith("\t"))) {
+                    // continuation of header
+                    if (prevline != null) {
+                        lineBuffer.append(prevline);
+                        prevline = null;
+                    }
+                    lineBuffer.append("\r\n");
+                    lineBuffer.append(line);
+                } else {
+                    // new header
+                    if (prevline != null)
+                        addHeaderLine(prevline);
+                    else if (lineBuffer.length() > 0) {
+                        // store previous header first
+                        addHeaderLine(lineBuffer.toString());
+                        lineBuffer.setLength(0);
+                    }
+                    prevline = line;
+                }
+            } while (line != null && line.length() > 0);
+        } catch (IOException ioex) {
+            throw new MIMEParsingException("Error in input stream", ioex);
+        }
+    }
+
+    /**
+     * Return all the values for the specified header. The
+     * values are String objects.  Returns <code>null</code>
+     * if no headers with the specified name exist.
+     *
+     * @param   name header name
+     * @return          array of header values, or null if none
+     */
+    List<String> getHeader(String name) {
+        // XXX - should we just step through in index order?
+        FinalArrayList<String> v = new FinalArrayList<String>(); // accumulate return values
+
+        int len = headers.size();
+        for( int i=0; i<len; i++ ) {
+            hdr h = (hdr) headers.get(i);
+            if (name.equalsIgnoreCase(h.name)) {
+                v.add(h.getValue());
+            }
+        }
+        return (v.size() == 0) ? null : v;
+    }
+
+    /**
+     * Return all the headers as an Enumeration of
+     * {@link Header} objects.
+     *
+     * @return  Header objects
+     */
+    FinalArrayList<? extends Header> getAllHeaders() {
+        return headers; // conceptually it should be read-only, but for performance reason I'm not wrapping it here
+    }
+
+    /**
+     * Add an RFC822 header line to the header store.
+     * If the line starts with a space or tab (a continuation line),
+     * add it to the last header line in the list. <p>
+     * <p/>
+     * Note that RFC822 headers can only contain US-ASCII characters
+     *
+     * @param   line    raw RFC822 header line
+     */
+    void addHeaderLine(String line) {
+        try {
+            char c = line.charAt(0);
+            if (c == ' ' || c == '\t') {
+                hdr h = (hdr) headers.get(headers.size() - 1);
+                h.line += "\r\n" + line;
+            } else
+                headers.add(new hdr(line));
+        } catch (StringIndexOutOfBoundsException e) {
+            // line is empty, ignore it
+            return;
+        } catch (NoSuchElementException e) {
+            // XXX - vector is empty?
+        }
+    }
+
+}
+
+/*
+ * A private utility class to represent an individual header.
+ */
+
+class hdr implements Header {
+
+    String name;    // the canonicalized (trimmed) name of this header
+    // XXX - should name be stored in lower case?
+    String line;    // the entire RFC822 header "line"
+
+    /*
+     * Constructor that takes a line and splits out
+     * the header name.
+     */
+    hdr(String l) {
+        int i = l.indexOf(':');
+        if (i < 0) {
+            // should never happen
+            name = l.trim();
+        } else {
+            name = l.substring(0, i).trim();
+        }
+        line = l;
+    }
+
+    /*
+     * Constructor that takes a header name and value.
+     */
+    hdr(String n, String v) {
+        name = n;
+        line = n + ": " + v;
+    }
+
+    /*
+     * Return the "name" part of the header line.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /*
+     * Return the "value" part of the header line.
+     */
+    public String getValue() {
+        int i = line.indexOf(':');
+        if (i < 0)
+            return line;
+
+        int j;
+        if (name.equalsIgnoreCase("Content-Description")) {
+            // Content-Description should retain the folded whitespace after header unfolding -
+            // rf. RFC2822 section 2.2.3, rf. RFC2822 section 3.2.3
+            for (j = i + 1; j < line.length(); j++) {
+                char c = line.charAt(j);
+                if (!(/*c == ' ' ||*/c == '\t' || c == '\r' || c == '\n'))
+                    break;
+            }
+        } else {
+            // skip whitespace after ':'
+            for (j = i + 1; j < line.length(); j++) {
+                char c = line.charAt(j);
+                if (!(c == ' ' || c == '\t' || c == '\r' || c == '\n'))
+                    break;
+            }
+        }
+        return line.substring(j);
+    }
+}
--- /dev/null	Tue Aug  4 10:17:37 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/MIMEConfig.java	Tue Aug  4 10:17:36 2009
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Configuration for MIME message parsing and storing.
+ *
+ * @author Jitendra Kotamraju
+ */
+public class MIMEConfig {
+
+    private static final int DEFAULT_CHUNK_SIZE = 8192;
+    private static final long DEFAULT_MEMORY_THRESHOLD = 1048576L;
+    private static final String DEFAULT_FILE_PREFIX = "MIME";
+
+    // Parses the entire message eagerly
+    boolean parseEagerly;
+
+    // Approximate Chunk size
+    int chunkSize;
+
+    // Maximum in-memory data per attachment
+    long memoryThreshold;
+
+    // Do not store to disk
+    boolean onlyMemory;
+
+    // temp Dir to store large files
+    File tempDir;
+    String prefix;
+    String suffix;
+
+
+    private MIMEConfig(boolean parseEagerly, int chunkSize,
+                       long inMemoryThreshold, String dir, String prefix, String suffix) {
+        this.parseEagerly = parseEagerly;
+        this.chunkSize = chunkSize;
+        this.memoryThreshold = inMemoryThreshold;
+        this.prefix = prefix;
+        this.suffix = suffix;
+        setDir(dir);
+    }
+
+    public MIMEConfig() {
+        this(false, DEFAULT_CHUNK_SIZE, DEFAULT_MEMORY_THRESHOLD, null,
+                DEFAULT_FILE_PREFIX, null);
+    }
+
+    boolean isParseEagerly() {
+        return parseEagerly;
+    }
+
+    public void setParseEagerly(boolean parseEagerly) {
+        this.parseEagerly = parseEagerly;
+    }
+
+    int getChunkSize() {
+        return chunkSize;
+    }
+
+    void setChunkSize(int chunkSize) {
+        this.chunkSize = chunkSize;
+    }
+
+    long getMemoryThreshold() {
+        return memoryThreshold;
+    }
+
+    /**
+     * If the attachment is greater than the threshold, it is
+     * written to the disk.
+     *
+     * @param memoryThreshold no of bytes per attachment
+     *        if -1, then the whole attachment is kept in memory
+     */
+    public void setMemoryThreshold(long memoryThreshold) {
+        this.memoryThreshold = memoryThreshold;
+    }
+
+    boolean isOnlyMemory() {
+        return memoryThreshold == -1L;
+    }
+
+    File getTempDir() {
+        return tempDir;
+    }
+
+    String getTempFilePrefix() {
+        return prefix;
+    }
+
+    String getTempFileSuffix() {
+        return suffix;
+    }
+
+    /**
+     * @param dir
+     */
+    public void setDir(String dir) {
+        if (tempDir == null && dir != null && !dir.equals("")) {
+            tempDir = new File(dir);
+        }
+    }
+
+    /**
+     * Validates if it can create temporary files. Otherwise, it stores
+     * attachment contents in memory.
+     */
+    public void validate() {
+        if (!isOnlyMemory()) {
+            try {
+                File tempFile = (tempDir == null)
+                        ? File.createTempFile(prefix, suffix)
+                        : File.createTempFile(prefix, suffix, tempDir);
+                tempFile.delete();
+            } catch(Exception ioe) {
+                memoryThreshold = -1L;      // whole attachment will be in-memory
+            }
+        }
+    }
+
+}
--- /dev/null	Tue Aug  4 10:17:39 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/MIMEEvent.java	Tue Aug  4 10:17:38 2009
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.nio.ByteBuffer;
+
+/**
+ * @author Jitendra Kotamraju
+ */
+abstract class MIMEEvent {
+
+    enum EVENT_TYPE {START_MESSAGE, START_PART, HEADERS, CONTENT, END_PART, END_MESSAGE}
+
+    /**
+     * Returns a event for parser's current cursor location in the MIME message.
+     *
+     * <p>
+     * {@link EVENT_TYPE#START_MESSAGE} and {@link EVENT_TYPE#START_MESSAGE} events
+     * are generated only once.
+     *
+     * <p>
+     * {@link EVENT_TYPE#START_PART}, {@link EVENT_TYPE#END_PART}, {@link EVENT_TYPE#HEADERS}
+     * events are generated only once for each attachment part.
+     *
+     * <p>
+     * {@link EVENT_TYPE#CONTENT} event may be generated more than once for an attachment
+     * part.
+     *
+     * @return event type
+     */
+    abstract EVENT_TYPE getEventType();
+
+    static final StartMessage START_MESSAGE = new StartMessage();
+    static final StartPart START_PART = new StartPart();
+    static final EndPart END_PART = new EndPart();
+    static final EndMessage END_MESSAGE = new EndMessage();
+
+    static final class StartMessage extends MIMEEvent {
+        EVENT_TYPE getEventType() {
+            return EVENT_TYPE.START_MESSAGE;
+        }
+    }
+
+    static final class StartPart extends MIMEEvent {
+        EVENT_TYPE getEventType() {
+            return EVENT_TYPE.START_PART;
+        }
+    }
+
+    static final class EndPart extends MIMEEvent {
+        EVENT_TYPE getEventType () {
+            return EVENT_TYPE.END_PART;
+        }
+    }
+
+    static final class Headers extends MIMEEvent {
+        InternetHeaders ih;
+
+        Headers(InternetHeaders ih) {
+            this.ih = ih;
+        }
+
+        EVENT_TYPE getEventType() {
+            return EVENT_TYPE.HEADERS;
+        }
+
+        InternetHeaders getHeaders() {
+            return ih;
+        }
+    }
+
+    static final class Content extends MIMEEvent {
+        private final ByteBuffer buf;
+
+        Content(ByteBuffer buf) {
+            this.buf = buf;
+        }
+
+        EVENT_TYPE getEventType() {
+            return EVENT_TYPE.CONTENT;
+        }
+
+        ByteBuffer getData() {
+            return buf;
+        }
+    }
+
+    static final class EndMessage extends MIMEEvent {
+        EVENT_TYPE getEventType() {
+            return EVENT_TYPE.END_MESSAGE;
+        }
+    }
+
+}
--- /dev/null	Tue Aug  4 10:17:41 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/MIMEMessage.java	Tue Aug  4 10:17:40 2009
@@ -0,0 +1,248 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.nio.ByteBuffer;
+import java.util.*;
+import java.util.logging.Logger;
+
+/**
+ * Represents MIME message. MIME message parsing is done lazily using a
+ * pull parser.
+ *
+ * @author Jitendra Kotamraju
+ */
+public class MIMEMessage {
+    private static final Logger LOGGER = Logger.getLogger(MIMEMessage.class.getName());
+
+    MIMEConfig config;
+
+    private final InputStream in;
+    private final List<MIMEPart> partsList;
+    private final Map<String, MIMEPart> partsMap;
+    private final Iterator<MIMEEvent> it;
+    private boolean parsed;     // true when entire message is parsed
+    private MIMEPart currentPart;
+    private int currentIndex;
+
+    /**
+     * @see MIMEMessage(InputStream, String, MIMEConfig)
+     */
+    public MIMEMessage(InputStream in, String boundary) {
+        this(in, boundary, new MIMEConfig());
+    }
+
+    /**
+     * Creates a MIME message from the content's stream. The content stream
+     * is closed when EOF is reached.
+     *
+     * @param in MIME message stream
+     * @param boundary the separator for parts(pass it without --)
+     * @param config various configuration parameters
+     */
+    public MIMEMessage(InputStream in, String boundary, MIMEConfig config) {
+        this.in = in;
+        this.config = config;
+        MIMEParser parser = new MIMEParser(in, boundary, config);
+        it = parser.iterator();
+
+        partsList = new ArrayList<MIMEPart>();
+        partsMap = new HashMap<String, MIMEPart>();
+        if (config.isParseEagerly()) {
+            parseAll();
+        }
+    }
+
+    /**
+     * Gets all the attachments by parsing the entire MIME message. Avoid
+     * this if possible since it is an expensive operation.
+     *
+     * @return list of attachments.
+     */
+    public List<MIMEPart> getAttachments() {
+        if (!parsed) {
+            parseAll();
+        }
+        return partsList;
+    }
+
+    /**
+     * Creates nth attachment lazily. It doesn't validate
+     * if the message has so many attachments. To
+     * do the validation, the message needs to be parsed.
+     * The parsing of the message is done lazily and is done
+     * while reading the bytes of the part.
+     *
+     * @param index sequential order of the part. starts with zero.
+     * @return attachemnt part
+     */
+    public MIMEPart getPart(int index) {
+        LOGGER.fine("index="+index);
+        MIMEPart part = (index < partsList.size()) ? partsList.get(index) : null;
+        if (parsed && part == null) {
+            throw new MIMEParsingException("There is no "+index+" attachment part ");
+        }
+        if (part == null) {
+            // Parsing will done lazily and will be driven by reading the part
+            part = new MIMEPart(this);
+            partsList.add(index, part);
+        }
+        LOGGER.fine("Got attachment at index="+index+" attachment="+part);
+        return part;
+    }
+
+    /**
+     * Creates a lazy attachment for a given Content-ID. It doesn't validate
+     * if the message contains an attachment with the given Content-ID. To
+     * do the validation, the message needs to be parsed. The parsing of the
+     * message is done lazily and is done while reading the bytes of the part.
+     *
+     * @param contentId Content-ID of the part, expects Content-ID without <, >
+     * @return attachemnt part
+     */
+    public MIMEPart getPart(String contentId) {
+        LOGGER.fine("Content-ID="+contentId);
+        MIMEPart part = getDecodedCidPart(contentId);
+        if (parsed && part == null) {
+            throw new MIMEParsingException("There is no attachment part with Content-ID = "+contentId);
+        }
+        if (part == null) {
+            // Parsing is done lazily and is driven by reading the part
+            part = new MIMEPart(this, contentId);
+            partsMap.put(contentId, part);
+        }
+        LOGGER.fine("Got attachment for Content-ID="+contentId+" attachment="+part);
+        return part;
+    }
+
+    // this is required for Indigo interop, it writes content-id without escaping
+    private MIMEPart getDecodedCidPart(String cid) {
+        MIMEPart part = partsMap.get(cid);
+        if (part == null) {
+            if (cid.indexOf('%') != -1) {
+                try {
+                    String tempCid = URLDecoder.decode(cid, "utf-8");
+                    part = partsMap.get(tempCid);
+                } catch(UnsupportedEncodingException ue) {
+                    // Ignore it
+                }
+            }
+        }
+        return part;
+    }
+
+
+    /**
+     * Parses the whole MIME message eagerly
+     */
+    public void parseAll() {
+        while(makeProgress()) {
+            // Nothing to do
+        }
+    }
+
+
+    /**
+     * Parses the MIME message in a pull fashion.
+     *
+     * @return
+     *      false if the parsing is completed.
+     */
+    public synchronized boolean makeProgress() {
+        if (!it.hasNext()) {
+            return false;
+        }
+
+        MIMEEvent event = it.next();
+
+        switch(event.getEventType()) {
+            case START_MESSAGE :
+                LOGGER.fine("MIMEEvent="+MIMEEvent.EVENT_TYPE.START_MESSAGE);
+                break;
+
+            case START_PART :
+                LOGGER.fine("MIMEEvent="+MIMEEvent.EVENT_TYPE.START_PART);
+                break;
+
+            case HEADERS :
+                LOGGER.fine("MIMEEvent="+MIMEEvent.EVENT_TYPE.HEADERS);
+                MIMEEvent.Headers headers = (MIMEEvent.Headers)event;
+                InternetHeaders ih = headers.getHeaders();
+                List<String> cids = ih.getHeader("content-id");
+                String cid = (cids != null) ? cids.get(0) : currentIndex+"";
+                if (cid.length() > 2 && cid.charAt(0)=='<') {
+                    cid = cid.substring(1,cid.length()-1);
+                }
+                MIMEPart listPart = (currentIndex < partsList.size()) ? partsList.get(currentIndex) : null;
+                MIMEPart mapPart = getDecodedCidPart(cid);
+                if (listPart == null && mapPart == null) {
+                    currentPart = getPart(cid);
+                    partsList.add(currentIndex, currentPart);
+                } else if (listPart == null) {
+                    currentPart = mapPart;
+                    partsList.add(currentIndex, mapPart);
+                } else if (mapPart == null) {
+                    currentPart = listPart;
+                    currentPart.setContentId(cid);
+                    partsMap.put(cid, currentPart);
+                } else if (listPart != mapPart) {
+                    throw new MIMEParsingException("Created two different attachments using Content-ID and index");
+                }
+                currentPart.setHeaders(ih);
+                break;
+
+            case CONTENT :
+                LOGGER.finer("MIMEEvent="+MIMEEvent.EVENT_TYPE.CONTENT);
+                MIMEEvent.Content content = (MIMEEvent.Content)event;
+                ByteBuffer buf = content.getData();
+                currentPart.addBody(buf);
+                break;
+
+            case END_PART :
+                LOGGER.fine("MIMEEvent="+MIMEEvent.EVENT_TYPE.END_PART);
+                currentPart.doneParsing();
+                ++currentIndex;
+                break;
+
+            case END_MESSAGE :
+                LOGGER.fine("MIMEEvent="+MIMEEvent.EVENT_TYPE.END_MESSAGE);
+                parsed = true;
+                try {
+                    in.close();
+                } catch(IOException ioe) {
+                    throw new MIMEParsingException(ioe);
+                }
+                break;
+
+            default :
+                throw new MIMEParsingException("Unknown Parser state = "+event.getEventType());
+        }
+        return true;
+    }
+}
--- /dev/null	Tue Aug  4 10:17:43 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/MIMEParser.java	Tue Aug  4 10:17:42 2009
@@ -0,0 +1,500 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.io.InputStream;
+import java.io.IOException;
+import java.util.*;
+import java.util.logging.Logger;
+import java.nio.ByteBuffer;
+
+/**
+ * Pull parser for the MIME messages. Applications can use pull API to continue
+ * the parsing MIME messages lazily.
+ *
+ * <pre>
+ * for e.g.:
+ * <p>
+ *
+ * MIMEParser parser = ...
+ * Iterator<MIMEEvent> it = parser.iterator();
+ * while(it.hasNext()) {
+ *   MIMEEvent event = it.next();
+ *   ...
+ * }
+ * </pre>
+ *
+ * @author Jitendra Kotamraju
+ */
+class MIMEParser implements Iterable<MIMEEvent> {
+
+    private static final Logger LOGGER = Logger.getLogger(MIMEParser.class.getName());
+
+    // Actually, the grammar doesn't support whitespace characters
+    // after boundary. But the mail implementation checks for it.
+    // We will only check for these many whitespace characters after boundary
+    private static final int NO_LWSP = 1000;
+    private enum STATE {START_MESSAGE, SKIP_PREAMBLE, START_PART, HEADERS, BODY, END_PART, END_MESSAGE}
+    private STATE state = STATE.START_MESSAGE;
+
+    private final InputStream in;
+    private final byte[] bndbytes;
+    private final int bl;
+    private final MIMEConfig config;
+    private final int[] bcs = new int[128]; // BnM algo: Bad Character Shift table
+    private final int[] gss;                // BnM algo : Good Suffix Shift table
+
+    /**
+     * Have we parsed the data from our InputStream yet?
+     */
+    private boolean parsed;
+
+    /*
+     * Read and process body partsList until we see the
+     * terminating boundary line (or EOF).
+     */
+    private boolean done = false;
+
+    private boolean eof;
+    private final int capacity;
+    private byte[] buf;
+    private int len;
+    private boolean bol;        // beginning of the line
+
+    /*
+     * Parses the MIME content. At the EOF, it also closes input stream
+     */
+    MIMEParser(InputStream in, String boundary, MIMEConfig config) {
+        this.in = in;
+        this.bndbytes = getBytes("--"+boundary);
+        bl = bndbytes.length;
+        this.config = config;
+        gss = new int[bl];
+        compileBoundaryPattern();
+
+        // \r\n + boundary + "--\r\n" + lots of LWSP
+        capacity = config.chunkSize+2+bl+4+NO_LWSP;
+        createBuf(capacity);
+    }
+
+    /**
+     * Returns iterator for the parsing events. Use the iterator to advance
+     * the parsing.
+     *
+     * @return iterator for parsing events
+     */
+    public Iterator<MIMEEvent> iterator() {
+        return new MIMEEventIterator();
+    }
+
+    class MIMEEventIterator implements Iterator<MIMEEvent> {
+
+        public boolean hasNext() {
+            return !parsed;
+        }
+
+        public MIMEEvent next() {
+            switch(state) {
+                case START_MESSAGE :
+                    LOGGER.finer("MIMEParser state="+STATE.START_MESSAGE);
+                    state = STATE.SKIP_PREAMBLE;
+                    return MIMEEvent.START_MESSAGE;
+
+                case SKIP_PREAMBLE :
+                    LOGGER.finer("MIMEParser state="+STATE.SKIP_PREAMBLE);
+                    skipPreamble();
+                    // fall through
+                case START_PART :
+                    LOGGER.finer("MIMEParser state="+STATE.START_PART);
+                    state = STATE.HEADERS;
+                    return MIMEEvent.START_PART;
+
+                case HEADERS :
+                    LOGGER.finer("MIMEParser state="+STATE.HEADERS);
+                    InternetHeaders ih = readHeaders();
+                    state = STATE.BODY;
+                    bol = true;
+                    return new MIMEEvent.Headers(ih);
+
+                case BODY :
+                    LOGGER.finer("MIMEParser state="+STATE.BODY);
+                    ByteBuffer buf = readBody();
+                    bol = false;
+                    return new MIMEEvent.Content(buf);
+
+                case END_PART :
+                    LOGGER.finer("MIMEParser state="+STATE.END_PART);
+                    if (done) {
+                        state = STATE.END_MESSAGE;
+                    } else {
+                        state = STATE.START_PART;
+                    }
+                    return MIMEEvent.END_PART;
+
+                case END_MESSAGE :
+                    LOGGER.finer("MIMEParser state="+STATE.END_MESSAGE);
+                    parsed = true;
+                    return MIMEEvent.END_MESSAGE;
+
+                default :
+                    throw new MIMEParsingException("Unknown Parser state = "+state);
+            }
+        }
+
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    /**
+     * Collects the headers for the current part by parsing mesage stream.
+     *
+     * @return headers for the current part
+     */
+    private InternetHeaders readHeaders() {
+        if (!eof) {
+            fillBuf();
+        }
+        return new InternetHeaders(new LineInputStream());
+    }
+
+    /**
+     * Reads and saves the part of the current attachment part's content.
+     * At the end of this method, buf should have the remaining data
+     * at index 0.
+     *
+     * @return a chunk of the part's content
+     *
+     */
+    private ByteBuffer readBody() {
+        if (!eof) {
+            fillBuf();
+        }
+        int start = match(buf, 0, len);     // matches boundary
+        if (start == -1) {
+            // No boundary is found
+            assert eof || len >= config.chunkSize;
+            int chunkSize = eof ? len : config.chunkSize;
+            if (eof) {
+                // Should we throw exception as there is no closing boundary ? But some impl
+                // like SAAJ do not throw excpetion.
+                // throw new MIMEParsingException("Reached EOF, but there is no closing MIME boundary.");
+                done = true;
+                state = STATE.END_PART;
+            }
+            return adjustBuf(chunkSize, len-chunkSize);
+        }
+        // Found boundary.
+        // Is it at the start of a line ?
+        int chunkLen = start;
+        if (bol && start == 0) {
+            // nothing to do
+        } else if (start > 0 && (buf[start-1] == '\n' || buf[start-1] =='\r')) {
+            --chunkLen;
+            if (buf[start-1] == '\n' && start >1 && buf[start-2] == '\r') {
+                --chunkLen;
+            }
+        } else {
+           return adjustBuf(start+1, len-start-1);  // boundary is not at beginning of a line
+        }
+
+        if (start+bl+1 < len && buf[start+bl] == '-' && buf[start+bl+1] == '-') {
+            state = STATE.END_PART;
+            done = true;
+            return adjustBuf(chunkLen, 0);
+        }
+
+        // Consider all the whitespace in boundary+whitespace+"\r\n"
+        int lwsp = 0;
+        for(int i=start+bl; i < len && (buf[i] == ' ' || buf[i] == '\t'); i++) {
+            ++lwsp;
+        }
+
+        // Check for \n or \r\n in boundary+whitespace+"\n" or boundary+whitespace+"\r\n"
+        if (start+bl+lwsp < len && buf[start+bl+lwsp] == '\n') {
+            state = STATE.END_PART;
+            return adjustBuf(chunkLen, len-start-bl-lwsp-1);
+        } else if (start+bl+lwsp+1 < len && buf[start+bl+lwsp] == '\r' && buf[start+bl+lwsp+1] == '\n') {
+            state = STATE.END_PART;
+            return adjustBuf(chunkLen, len-start-bl-lwsp-2);
+        } else if (start+bl+lwsp+1 < len) {
+            return adjustBuf(chunkLen+1, len-chunkLen-1);       // boundary string in a part data
+        } else if (eof) {
+            done = true;
+            state = STATE.END_PART;
+            return adjustBuf(chunkLen, 0);
+            // Should we throw exception as there is no closing boundary ? But some impl
+            // like SAAJ do not throw excpetion.
+            //throw new MIMEParsingException("Reached EOF, but there is no closing MIME boundary.");
+        }
+
+        // Some more data needed to determine if it is indeed a proper boundary
+        return adjustBuf(chunkLen, len-chunkLen);
+    }
+
+    /**
+     * Returns a chunk from the original buffer. A new buffer is
+     * created with the remaining bytes.
+     *
+     * @param chunkSize create a chunk with these many bytes
+     * @param remaining bytes from the end of the buffer that need to be copied to
+     *        the beginning of the new buffer
+     * @return chunk
+     */
+    private ByteBuffer adjustBuf(int chunkSize, int remaining) {
+        assert buf != null;
+        assert chunkSize >= 0;
+        assert remaining >= 0;
+
+        byte[] temp = buf;
+        // create a new buf and adjust it without this chunk
+        createBuf(remaining);
+        System.arraycopy(temp, len-remaining, buf, 0, remaining);
+        len = remaining;
+
+        return ByteBuffer.wrap(temp, 0, chunkSize);
+    }
+
+    private void createBuf(int min) {
+        buf = new byte[min < capacity ? capacity : min];
+    }
+
+    /**
+     * Skips the preamble to find the first attachment part
+     */
+    private void skipPreamble() {
+
+        while(true) {
+            if (!eof) {
+                fillBuf();
+            }
+            int start = match(buf, 0, len);     // matches boundary
+            if (start == -1) {
+                // No boundary is found
+                if (eof) {
+                    throw new MIMEParsingException("Missing start boundary");
+                } else {
+                    adjustBuf(len-bl+1, bl-1);
+                    continue;
+                }
+            }
+
+            if (start > config.chunkSize) {
+                adjustBuf(start, len-start);
+                continue;
+            }
+            // Consider all the whitespace boundary+whitespace+"\r\n"
+            int lwsp = 0;
+            for(int i=start+bl; i < len && (buf[i] == ' ' || buf[i] == '\t'); i++) {
+                ++lwsp;
+            }
+            // Check for \n or \r\n
+            if (start+bl+lwsp < len && (buf[start+bl+lwsp] == '\n' || buf[start+bl+lwsp] == '\r') ) {
+                if (buf[start+bl+lwsp] == '\n') {
+                    adjustBuf(start+bl+lwsp+1, len-start-bl-lwsp-1);
+                    break;
+                } else if (start+bl+lwsp+1 < len && buf[start+bl+lwsp+1] == '\n') {
+                    adjustBuf(start+bl+lwsp+2, len-start-bl-lwsp-2);
+                    break;
+                }
+            }
+            adjustBuf(start+1, len-start-1);
+        }
+        LOGGER.fine("Skipped the preamble. buffer len="+len);
+    }
+
+    private static byte[] getBytes(String s) {
+        char [] chars= s.toCharArray();
+        int size = chars.length;
+        byte[] bytes = new byte[size];
+
+        for (int i = 0; i < size;)
+            bytes[i] = (byte) chars[i++];
+        return bytes;
+    }
+
+        /**
+     * Boyer-Moore search method. Copied from java.util.regex.Pattern.java
+     *
+     * Pre calculates arrays needed to generate the bad character
+     * shift and the good suffix shift. Only the last seven bits
+     * are used to see if chars match; This keeps the tables small
+     * and covers the heavily used ASCII range, but occasionally
+     * results in an aliased match for the bad character shift.
+     */
+    private void compileBoundaryPattern() {
+        int i, j;
+
+        // Precalculate part of the bad character shift
+        // It is a table for where in the pattern each
+        // lower 7-bit value occurs
+        for (i = 0; i < bndbytes.length; i++) {
+            bcs[bndbytes[i]&0x7F] = i + 1;
+        }
+
+        // Precalculate the good suffix shift
+        // i is the shift amount being considered
+NEXT:   for (i = bndbytes.length; i > 0; i--) {
+            // j is the beginning index of suffix being considered
+            for (j = bndbytes.length - 1; j >= i; j--) {
+                // Testing for good suffix
+                if (bndbytes[j] == bndbytes[j-i]) {
+                    // src[j..len] is a good suffix
+                    gss[j-1] = i;
+                } else {
+                    // No match. The array has already been
+                    // filled up with correct values before.
+                    continue NEXT;
+                }
+            }
+            // This fills up the remaining of optoSft
+            // any suffix can not have larger shift amount
+            // then its sub-suffix. Why???
+            while (j > 0) {
+                gss[--j] = i;
+            }
+        }
+        // Set the guard value because of unicode compression
+        gss[bndbytes.length -1] = 1;
+    }
+
+    /**
+     * Finds the boundary in the given buffer using Boyer-Moore algo.
+     * Copied from java.util.regex.Pattern.java
+     *
+     * @param mybuf boundary to be searched in this mybuf
+     * @param off start index in mybuf
+     * @param len number of bytes in mybuf
+     *
+     * @return -1 if there is no match or index where the match starts
+     */
+    private int match(byte[] mybuf, int off, int len) {
+        int last = len - bndbytes.length;
+
+        // Loop over all possible match positions in text
+NEXT:   while (off <= last) {
+            // Loop over pattern from right to left
+            for (int j = bndbytes.length - 1; j >= 0; j--) {
+                byte ch = mybuf[off+j];
+                if (ch != bndbytes[j]) {
+                    // Shift search to the right by the maximum of the
+                    // bad character shift and the good suffix shift
+                    off += Math.max(j + 1 - bcs[ch&0x7F], gss[j]);
+                    continue NEXT;
+                }
+            }
+            // Entire pattern matched starting at off
+            return off;
+        }
+        return -1;
+    }
+
+    /**
+     * Fills the remaining buf to the full capacity
+     */
+    private void fillBuf() {
+        LOGGER.finer("Before fillBuf() buffer len="+len);
+        assert !eof;
+        while(len < buf.length) {
+            int read;
+            try {
+                read = in.read(buf, len, buf.length-len);
+            } catch(IOException ioe) {
+                throw new MIMEParsingException(ioe);
+            }
+            if (read == -1) {
+                eof = true;
+                try {
+                    LOGGER.fine("Closing the input stream.");
+                    in.close();
+                } catch(IOException ioe) {
+                    throw new MIMEParsingException(ioe);
+                }
+                break;
+            } else {
+                len += read;
+            }
+        }
+        LOGGER.finer("After fillBuf() buffer len="+len);
+    }
+
+    private void doubleBuf() {
+        byte[] temp = new byte[2*len];
+        System.arraycopy(buf, 0, temp, 0, len);
+        buf = temp;
+        if (!eof) {
+            fillBuf();
+        }
+    }
+
+    class LineInputStream {
+        private int offset;
+
+        /*
+         * Read a line containing only ASCII characters from the input
+         * stream. A line is terminated by a CR or NL or CR-NL sequence.
+         * A common error is a CR-CR-NL sequence, which will also terminate
+         * a line.
+         * The line terminator is not returned as part of the returned
+         * String. Returns null if no data is available. <p>
+         *
+         * This class is similar to the deprecated
+         * <code>DataInputStream.readLine()</code>
+         */
+        public String readLine() throws IOException {
+
+            int hdrLen = 0;
+            int lwsp = 0;
+            while(offset+hdrLen < len) {
+                if (buf[offset+hdrLen] == '\n') {
+                    lwsp = 1;
+                    break;
+                }
+                if (offset+hdrLen+1 == len) {
+                    doubleBuf();
+                }
+                if (offset+hdrLen+1 >= len) {   // No more data in the stream
+                    assert eof;
+                    return null;
+                }
+                if (buf[offset+hdrLen] == '\r' && buf[offset+hdrLen+1] == '\n') {
+                    lwsp = 2;
+                    break;
+                }
+                ++hdrLen;
+            }
+            if (hdrLen == 0) {
+                adjustBuf(offset+lwsp, len-offset-lwsp);
+                return null;
+            }
+
+            String hdr = new String(buf, offset, hdrLen);
+            offset += hdrLen+lwsp;
+            return hdr;
+        }
+
+    }
+
+}
--- /dev/null	Tue Aug  4 10:17:45 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/MIMEParsingException.java	Tue Aug  4 10:17:44 2009
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+/**
+ * @author Jitendra Kotamraju
+ */
+
+/**
+ * The <code>MIMEParsingException</code> class is the base
+ * exception class for all MIME message parsing exceptions.
+ *
+ */
+
+public class MIMEParsingException extends java.lang.RuntimeException {
+
+    /**
+     * Constructs a new exception with <code>null</code> as its
+     * detail message. The cause is not initialized.
+     */
+    public MIMEParsingException() {
+        super();
+    }
+
+    /**
+     * Constructs a new exception with the specified detail
+     * message.  The cause is not initialized.
+     *
+     * @param message The detail message which is later
+     *                retrieved using the getMessage method
+     */
+    public MIMEParsingException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a new exception with the specified detail
+     * message and cause.
+     *
+     * @param message The detail message which is later retrieved
+     *                using the getMessage method
+     * @param cause   The cause which is saved for the later
+     *                retrieval throw by the getCause method
+     */
+    public MIMEParsingException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    /**
+     * Constructs a new WebServiceException with the specified cause
+     * and a detail message of <tt>(cause==null ? null :
+     * cause.toString())</tt> (which typically contains the
+     * class and detail message of <tt>cause</tt>).
+     *
+     * @param cause The cause which is saved for the later
+     *              retrieval throw by the getCause method.
+     *              (A <tt>null</tt> value is permitted, and
+     *              indicates that the cause is nonexistent or
+     *              unknown.)
+     */
+    public MIMEParsingException(Throwable cause) {
+        super(cause);
+    }
+
+}
--- /dev/null	Tue Aug  4 10:17:47 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/MIMEPart.java	Tue Aug  4 10:17:46 2009
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.io.File;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.List;
+
+/**
+ * Represents an attachment part in a MIME message. MIME message parsing is done
+ * lazily using a pull parser, so the part may not have all the data. {@link #read}
+ * and {@link #readOnce} may trigger the actual parsing the message. In fact,
+ * parsing of an attachment part may be triggered by calling {@link #read} methods
+ * on some other attachemnt parts. All this happens behind the scenes so the
+ * application developer need not worry about these details.
+ *
+ * @author Jitendra Kotamraju
+ */
+public class MIMEPart {
+
+    private volatile InternetHeaders headers;
+    private volatile String contentId;
+    private String contentType;
+    volatile boolean parsed;    // part is parsed or not
+    final MIMEMessage msg;
+    private final DataHead dataHead;
+
+    MIMEPart(MIMEMessage msg) {
+        this.msg = msg;
+        this.dataHead = new DataHead(this);
+    }
+
+    MIMEPart(MIMEMessage msg, String contentId) {
+        this(msg);
+        this.contentId = contentId;
+    }
+
+    /**
+     * Can get the attachment part's content multiple times. That means
+     * the full content needs to be there in memory or on the file system.
+     * Calling this method would trigger parsing for the part's data. So
+     * do not call this unless it is required(otherwise, just wrap MIMEPart
+     * into a object that returns InputStream for e.g DataHandler)
+     *
+     * @return data for the part's content
+     */
+    public InputStream read() {
+        return dataHead.read();
+    }
+
+    /**
+     * Cleans up any resources that are held by this part (for e.g. deletes
+     * the temp file that is used to serve this part's content). After
+     * calling this, one shouldn't call {@link #read()} or {@link #readOnce()}
+     */
+    public void close() {
+        dataHead.close();
+    }
+
+
+    /**
+     * Can get the attachment part's content only once. The content
+     * will be lost after the method. Content data is not be stored
+     * on the file system or is not kept in the memory for the
+     * following case:
+     *   - Attachement parts contents are accessed sequentially
+     *
+     * In general, take advantage of this when the data is used only
+     * once.
+     *
+     * @return data for the part's content
+     */
+    public InputStream readOnce() {
+        return dataHead.readOnce();
+    }
+
+    public void moveTo(File f) {
+        dataHead.moveTo(f);
+    }
+
+    /**
+     * Returns Content-ID MIME header for this attachment part
+     *
+     * @return Content-ID of the part
+     */
+    public String getContentId() {
+        if (contentId == null) {
+            getHeaders();
+        }
+        return contentId;
+    }
+
+    /**
+     * Returns Content-Type MIME header for this attachment part
+     *
+     * @return Content-Type of the part
+     */
+    public String getContentType() {
+        if (contentType == null) {
+            getHeaders();
+        }
+        return contentType;
+    }
+
+    private void getHeaders() {
+        // Trigger parsing for the part headers
+        while(headers == null) {
+            if (!msg.makeProgress()) {
+                if (headers == null) {
+                    throw new IllegalStateException("Internal Error. Didn't get Headers even after complete parsing.");
+                }
+            }
+        }
+    }
+
+    /**
+     * Return all the values for the specified header.
+     * Returns <code>null</code> if no headers with the
+     * specified name exist.
+     *
+     * @param   name header name
+     * @return  list of header values, or null if none
+     */
+    public List<String> getHeader(String name) {
+        getHeaders();
+        assert headers != null;
+        return headers.getHeader(name);
+    }
+
+    /**
+     * Return all the headers
+     *
+     * @return list of Header objects
+     */
+    public List<? extends Header> getAllHeaders() {
+        getHeaders();
+        assert headers != null;
+        return headers.getAllHeaders();
+    }
+
+    /**
+     * Callback to set headers
+     *
+     * @param headers MIME headers for the part
+     */
+    void setHeaders(InternetHeaders headers) {
+        this.headers = headers;
+        List<String> ct = getHeader("Content-Type");
+        this.contentType = (ct == null) ? "application/octet-stream" : ct.get(0);
+    }
+
+    /**
+     * Callback to notify that there is a partial content for the part
+     *
+     * @param buf content data for the part
+     */
+    void addBody(ByteBuffer buf) {
+        dataHead.addBody(buf);
+    }
+
+    /**
+     * Callback to indicate that parsing is done for this part
+     * (no more update events for this part)
+     */
+    void doneParsing() {
+        parsed = true;
+        dataHead.doneParsing();
+    }
+
+    /**
+     * Callback to set Content-ID for this part
+     * @param cid Content-ID of the part
+     */
+    void setContentId(String cid) {
+        this.contentId = cid;
+    }
+
+    @Override
+    public String toString() {
+        return "Part="+contentId;
+    }
+
+}
--- /dev/null	Tue Aug  4 10:17:49 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/MemoryData.java	Tue Aug  4 10:17:48 2009
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.nio.ByteBuffer;
+import java.io.File;
+import java.io.IOException;
+import java.util.logging.Logger;
+
+/**
+ * Keeps the Part's partial content data in memory.
+ *
+ * @author Kohsuke Kawaguchi
+ * @author Jitendra Kotamraju
+ */
+final class MemoryData implements Data {
+    private static final Logger LOGGER = Logger.getLogger(MemoryData.class.getName());
+
+    private final byte[] data;
+    private final int len;
+    private final MIMEConfig config;
+
+    MemoryData(ByteBuffer buf, MIMEConfig config) {
+        data = buf.array();
+        len = buf.limit();
+        this.config = config;
+    }
+
+    // size of the chunk given by the parser
+    public int size() {
+        return len;
+    }
+
+    public byte[] read() {
+        return data;
+    }
+
+    public long writeTo(DataFile file) {
+        return file.writeTo(data, 0, len);
+    }
+
+    /**
+     *
+     * @param dataHead
+     * @param buf
+     * @return
+     */
+    public Data createNext(DataHead dataHead, ByteBuffer buf) {
+        if (!config.isOnlyMemory() && dataHead.inMemory >= config.memoryThreshold) {
+            try {
+                String prefix = config.getTempFilePrefix();
+                String suffix = config.getTempFileSuffix();
+                File dir = config.getTempDir();
+                File tempFile = (dir == null)
+                        ? File.createTempFile(prefix, suffix)
+                        : File.createTempFile(prefix, suffix, dir);
+                LOGGER.fine("Created temp file = "+tempFile);
+                dataHead.dataFile = new DataFile(tempFile);
+            } catch(IOException ioe) {
+                throw new MIMEParsingException(ioe);
+            }
+
+            if (dataHead.head != null) {
+                for(Chunk c=dataHead.head; c != null; c=c.next) {
+                    long pointer = c.data.writeTo(dataHead.dataFile);
+                    c.data = new FileData(dataHead.dataFile, pointer, len);
+                }
+            }
+            return new FileData(dataHead.dataFile, buf);
+        } else {
+            return new MemoryData(buf, config);
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:17:51 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/mimepull/WeakDataFile.java	Tue Aug  4 10:17:50 2009
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.mimepull;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Logger;
+
+/**
+ * Removing files based on this
+ * <a href="http://java.sun.com/developer/technicalArticles/javase/finalization/">article</a>
+ *
+ * @author Jitendra Kotamraju
+ */
+final class WeakDataFile extends WeakReference<DataFile> {
+
+    private static final Logger LOGGER = Logger.getLogger(WeakDataFile.class.getName());
+    private static final int MAX_ITERATIONS = 2;
+    private static ReferenceQueue<DataFile> refQueue = new ReferenceQueue<DataFile>();
+    private static List<WeakDataFile> refList = new ArrayList<WeakDataFile>();
+    private final File file;
+    private final RandomAccessFile raf;
+
+    WeakDataFile(DataFile df, File file) {
+        super(df, refQueue);
+        refList.add(this);
+        this.file = file;
+        try {
+            raf = new RandomAccessFile(file, "rw");
+        } catch(IOException ioe) {
+            throw new MIMEParsingException(ioe);
+        }
+        drainRefQueueBounded();
+    }
+
+    synchronized void read(long pointer, byte[] buf, int offset, int length ) {
+        try {
+            raf.seek(pointer);
+            raf.readFully(buf, offset, length);
+        } catch(IOException ioe) {
+            throw new MIMEParsingException(ioe);
+        }
+    }
+
+    synchronized long writeTo(long pointer, byte[] data, int offset, int length) {
+        try {
+            raf.seek(pointer);
+            raf.write(data, offset, length);
+            return raf.getFilePointer();    // Update pointer for next write
+        } catch(IOException ioe) {
+            throw new MIMEParsingException(ioe);
+        }
+    }
+
+    void close() {
+        LOGGER.fine("Deleting file = "+file.getName());
+        refList.remove(this);
+        try {
+            raf.close();
+            file.delete();
+        } catch(IOException ioe) {
+            throw new MIMEParsingException(ioe);
+        }
+    }
+
+    void renameTo(File f) {
+        LOGGER.fine("Moving file="+file+" to="+f);
+        refList.remove(this);
+        try {
+            raf.close();
+            file.renameTo(f);
+        } catch(IOException ioe) {
+            throw new MIMEParsingException(ioe);
+        }
+
+    }
+
+    static void drainRefQueueBounded() {
+        int iterations = 0;
+        WeakDataFile weak = (WeakDataFile) refQueue.poll();
+        while (weak != null && iterations < MAX_ITERATIONS) {
+            LOGGER.fine("Cleaning file = "+weak.file+" from reference queue.");
+            weak.close();
+            ++iterations;
+            weak = (WeakDataFile) refQueue.poll();
+        }
+    }
+
+}
--- /dev/null	Tue Aug  4 10:17:53 2009
+++ new/src/share/classes/com/sun/xml/internal/org/jvnet/staxex/StreamingDataHandler.java	Tue Aug  4 10:17:52 2009
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.org.jvnet.staxex;
+
+import javax.activation.DataHandler;
+import javax.activation.DataSource;
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+
+/**
+ * {@link DataHandler} extended to offer better buffer management
+ * in a streaming environment.
+ *
+ * <p>
+ * {@link DataHandler} is used commonly as a data format across
+ * multiple systems (such as JAXB/WS.) Unfortunately, {@link DataHandler}
+ * has the semantics of "read as many times as you want", so this makes
+ * it difficult for involving parties to handle a BLOB in a streaming fashion.
+ *
+ * <p>
+ * {@link StreamingDataHandler} solves this problem by offering methods
+ * that enable faster bulk "consume once" read operation.
+ *
+ * @author Jitendra Kotamraju
+ */
+public abstract class StreamingDataHandler extends DataHandler {
+
+    public StreamingDataHandler(Object o, String s) {
+        super(o, s);
+    }
+
+    public StreamingDataHandler(URL url) {
+        super(url);
+    }
+
+    public StreamingDataHandler(DataSource dataSource) {
+        super(dataSource);
+    }
+
+    /**
+     * Works like {@link #getInputStream()} except that this method
+     * can be invoked only once.
+     *
+     * <p>
+     * This is used as a signal from the caller that there will
+     * be no further {@link #getInputStream()} invocation nor
+     * {@link #readOnce()} invocation on this object (which would
+     * result in {@link IOException}.)
+     *
+     * <p>
+     * When {@link DataHandler} is backed by a streaming BLOB
+     * (such as an attachment in a web service read from the network),
+     * this allows the callee to avoid unnecessary buffering.
+     *
+     * <p>
+     * Note that it is legal to call {@link #getInputStream()}
+     * multiple times and then call {@link #readOnce()} afterward.
+     * Streams created such a way can be read in any order &mdash;
+     * there's no requirement that streams created earlier must be read
+     * first.
+     *
+     * @return
+     *      always non-null. Represents the content of this BLOB.
+     *      The returned stream is generally not buffered, so for
+     *      better performance read in a big batch or wrap this into
+     *      {@link BufferedInputStream}.
+     * @throws IOException
+     *      if any i/o error
+     */
+    public abstract InputStream readOnce() throws IOException;
+
+    /**
+     * Obtains the BLOB into a specified file.
+     *
+     * <p>
+     * Semantically, this method is roughly equivalent to the following
+     * code, except that the actual implementation is likely to be a lot faster.
+     *
+     * <pre>
+     * InputStream i = getInputStream();
+     * OutputStream o = new FileOutputStream(dst);
+     * int ch;
+     * while((ch=i.read())!=-1)  o.write(ch);
+     * i.close();
+     * o.close();
+     * </pre>
+     *
+     * <p>
+     * The main motivation behind this method is that often
+     * {@link DataHandler} that reads data from a streaming source
+     * will use a temporary file as a data store to hold data
+     * (think of commons-fileupload.) In such case this method
+     * can be as fast as calling {@link File#renameTo(File)}.
+     *
+     * <p>
+     * This method shouldn't be called when there are any
+     * open streams.
+     *
+     * <p>
+     * After this method is invoked, {@link #readOnce()} and
+     * {@link #getInputStream()} will simply open the destination
+     * file you've specified as an argument. So if you further
+     * move the file or delete this file, those methods will
+     * behave in undefined fashion. For a simliar reason,
+     * calling this method multiple times will cause
+     * undefined behavior.
+     */
+    public abstract void moveTo(File dst) throws IOException;
+
+    /**
+     * Releases any resources associated with this DataHandler.
+     * (such as an attachment in a web service read from a temp
+     * file will be deleted.) After calling this method, it is
+     * illegal to call any other methods.
+     */
+    public abstract void close() throws IOException;
+
+}
--- /dev/null	Tue Aug  4 10:17:55 2009
+++ new/src/share/classes/com/sun/xml/internal/txw2/output/TXWResult.java	Tue Aug  4 10:17:54 2009
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.txw2.output;
+
+import com.sun.xml.internal.txw2.TypedXmlWriter;
+
+import javax.xml.transform.Result;
+
+/**
+ * Allow you to wrap {@link TypedXmlWriter} into a {@link Result}
+ * so that it can be passed to {@link ResultFactory}.
+ *
+ * <p>
+ * This class doesn't extend from known {@link Result} type,
+ * so it won't work elsewhere.
+ *
+ * @author Kohsuke Kawaguchi
+ */
+public class TXWResult implements Result {
+    private String systemId;
+
+    private TypedXmlWriter writer;
+
+    public TXWResult(TypedXmlWriter writer) {
+        this.writer = writer;
+    }
+
+    public TypedXmlWriter getWriter() {
+        return writer;
+    }
+
+    public void setWriter(TypedXmlWriter writer) {
+        this.writer = writer;
+    }
+
+    public String getSystemId() {
+        return systemId;
+    }
+
+    public void setSystemId(String systemId) {
+        this.systemId = systemId;
+    }
+}
--- /dev/null	Tue Aug  4 10:17:57 2009
+++ new/src/share/classes/com/sun/xml/internal/txw2/output/TXWSerializer.java	Tue Aug  4 10:17:56 2009
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.txw2.output;
+
+import com.sun.xml.internal.txw2.TypedXmlWriter;
+import com.sun.xml.internal.txw2.TXW;
+
+/**
+ * Dummpy implementation to pass through {@link TypedXmlWriter}
+ * to {@link TXW}
+ *
+ * @author Kohsuke Kawaguchi
+ */
+public final class TXWSerializer implements XmlSerializer {
+    public final TypedXmlWriter txw;
+
+    public TXWSerializer(TypedXmlWriter txw) {
+        this.txw = txw;
+    }
+
+    public void startDocument() {
+        throw new UnsupportedOperationException();
+    }
+
+    public void endDocument() {
+        throw new UnsupportedOperationException();
+    }
+
+    public void beginStartTag(String uri, String localName, String prefix) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void writeAttribute(String uri, String localName, String prefix, StringBuilder value) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void writeXmlns(String prefix, String uri) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void endStartTag(String uri, String localName, String prefix) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void endTag() {
+        throw new UnsupportedOperationException();
+    }
+
+    public void text(StringBuilder text) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void cdata(StringBuilder text) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void comment(StringBuilder comment) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void flush() {
+        throw new UnsupportedOperationException();
+    }
+}
--- /dev/null	Tue Aug  4 10:17:59 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/W3CWsaClientTube.java	Tue Aug  4 10:17:58 2009
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.addressing;
+
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.pipe.Tube;
+import com.sun.xml.internal.ws.api.pipe.TubeCloner;
+import com.sun.xml.internal.ws.addressing.model.MissingAddressingHeaderException;
+
+/**
+ * @author Rama Pulavarthi
+ */
+public class W3CWsaClientTube extends WsaClientTube {
+    public W3CWsaClientTube(WSDLPort wsdlPort, WSBinding binding, Tube next) {
+        super(wsdlPort, binding, next);
+    }
+
+    public W3CWsaClientTube(WsaClientTube that, TubeCloner cloner) {
+        super(that, cloner);
+    }
+
+    public W3CWsaClientTube copy(TubeCloner cloner) {
+        return new W3CWsaClientTube(this, cloner);
+    }
+
+    @Override
+    protected void checkMandatoryHeaders(Packet packet, boolean foundAction, boolean foundTo, boolean foundReplyTo,
+                                         boolean foundFaultTo, boolean foundMessageID, boolean foundRelatesTo) {
+        super.checkMandatoryHeaders(packet, foundAction, foundTo, foundReplyTo, foundFaultTo, foundMessageID, foundRelatesTo);
+
+        // if it is not one-way, response must contain wsa:RelatesTo
+        // RelatesTo required as per
+        // Table 5-3 of http://www.w3.org/TR/2006/WD-ws-addr-wsdl-20060216/#wsdl11requestresponse
+        if (expectReply && (packet.getMessage() != null) && !foundRelatesTo) {
+            String action = packet.getMessage().getHeaders().getAction(addressingVersion, soapVersion);
+            // Don't check for AddressingFaults as
+            // Faults for requests with duplicate MessageId will have no wsa:RelatesTo
+            if (!packet.getMessage().isFault() || !action.equals(addressingVersion.getDefaultFaultAction())) {
+                throw new MissingAddressingHeaderException(addressingVersion.relatesToTag,packet);
+            }
+        }
+
+    }
+}
--- /dev/null	Tue Aug  4 10:18:01 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/W3CWsaServerTube.java	Tue Aug  4 10:18:00 2009
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.addressing;
+
+import com.sun.xml.internal.ws.api.server.WSEndpoint;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundOperation;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.pipe.Tube;
+import com.sun.xml.internal.ws.api.pipe.TubeCloner;
+import com.sun.xml.internal.ws.addressing.model.MissingAddressingHeaderException;
+import com.sun.istack.internal.NotNull;
+
+/**
+ * @author Rama Pulavarthi
+ */
+public class W3CWsaServerTube extends WsaServerTube{
+    public W3CWsaServerTube(WSEndpoint endpoint, @NotNull WSDLPort wsdlPort, WSBinding binding, Tube next) {
+        super(endpoint, wsdlPort, binding, next);
+    }
+
+    public W3CWsaServerTube(WsaServerTube that, TubeCloner cloner) {
+        super(that, cloner);
+    }
+
+    protected Packet validateInboundHeaders(Packet packet) {
+        return super.validateInboundHeaders(packet);
+    }
+
+    public W3CWsaServerTube copy(TubeCloner cloner) {
+        return new W3CWsaServerTube(this, cloner);
+    }
+
+    @Override
+    protected void checkMandatoryHeaders(
+            Packet packet, boolean foundAction, boolean foundTo, boolean foundReplyTo,
+            boolean foundFaultTo, boolean foundMessageId, boolean foundRelatesTo) {
+        super.checkMandatoryHeaders(packet, foundAction, foundTo, foundReplyTo,
+                foundFaultTo, foundMessageId, foundRelatesTo);
+
+        // find Req/Response or Oneway using WSDLModel(if it is availabe)
+        WSDLBoundOperation wbo = getWSDLBoundOperation(packet);
+        // Taking care of protocol messages as they do not have any corresponding operations
+        if (wbo != null) {
+            // if two-way and no wsa:MessageID is found
+            if (!wbo.getOperation().isOneWay() && !foundMessageId) {
+                throw new MissingAddressingHeaderException(addressingVersion.messageIDTag,packet);
+            }
+        }
+
+    }
+
+}
--- /dev/null	Tue Aug  4 10:18:03 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/WsaPropertyBag.java	Tue Aug  4 10:18:02 2009
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.addressing;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.xml.internal.ws.api.PropertySet;
+import com.sun.xml.internal.ws.api.SOAPVersion;
+import com.sun.xml.internal.ws.api.addressing.AddressingVersion;
+import com.sun.xml.internal.ws.api.addressing.WSEndpointReference;
+import com.sun.xml.internal.ws.api.message.Header;
+import com.sun.xml.internal.ws.api.message.Message;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.developer.JAXWSProperties;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamException;
+
+/**
+ * Provides access to the Addressing headers.
+ *
+ * @author Kohsuke Kawaguchi
+ * @author Rama Pulavarthi
+ * @since 2.1.3
+ */
+public class WsaPropertyBag extends PropertySet {
+    private final @NotNull AddressingVersion addressingVersion;
+    private final @NotNull SOAPVersion soapVersion;
+    /**
+     * We can't store {@link Message} here as those may get replaced as
+     * the packet travels through the pipeline.
+     */
+    private final @NotNull Packet packet;
+
+
+    WsaPropertyBag(AddressingVersion addressingVersion, SOAPVersion soapVersion, Packet packet) {
+        this.addressingVersion = addressingVersion;
+        this.soapVersion = soapVersion;
+        this.packet = packet;
+    }
+
+    /**
+     * Gets the <tt>wsa:To</tt> header.
+     *
+     * @return
+     *      null if the incoming SOAP message didn't have the header.
+     */
+    @Property(JAXWSProperties.ADDRESSING_TO)
+    public String getTo() throws XMLStreamException {
+        Header h = packet.getMessage().getHeaders().get(addressingVersion.toTag, false);
+        if (h == null) return null;
+        return h.getStringContent();
+    }
+
+    /**
+     * Gets the <tt>wsa:From</tt> header.
+     *
+     * @return
+     *      null if the incoming SOAP message didn't have the header.
+     */
+    @Property(JAXWSProperties.ADDRESSING_FROM)
+    public WSEndpointReference getFrom() throws XMLStreamException {
+        return getEPR(addressingVersion.fromTag);
+    }
+
+    /**
+     * Gets the <tt>wsa:Action</tt> header content as String.
+     *
+     * @return
+     *      null if the incoming SOAP message didn't have the header.
+     */
+    @Property(JAXWSProperties.ADDRESSING_ACTION)
+    public String getAction() {
+        Header h = packet.getMessage().getHeaders().get(addressingVersion.actionTag, false);
+        if(h==null) return null;
+        return h.getStringContent();
+    }
+
+    /**
+     * Gets the <tt>wsa:MessageID</tt> header content as String.
+     *
+     * @return
+     *      null if the incoming SOAP message didn't have the header.
+     */
+    // WsaServerTube.REQUEST_MESSAGE_ID is exposed for backward compatibility with 2.1
+    @Property({JAXWSProperties.ADDRESSING_MESSAGEID,WsaServerTube.REQUEST_MESSAGE_ID})
+    public String getMessageID() {
+        return packet.getMessage().getHeaders().getMessageID(addressingVersion,soapVersion);
+    }
+
+    private WSEndpointReference getEPR(QName tag) throws XMLStreamException {
+        Header h = packet.getMessage().getHeaders().get(tag, false);
+        if(h==null) return null;
+        return h.readAsEPR(addressingVersion);
+    }
+
+    protected PropertyMap getPropertyMap() {
+        return model;
+    }
+
+    private static final PropertyMap model;
+    static {
+        model = parse(WsaPropertyBag.class);
+    }
+}
--- /dev/null	Tue Aug  4 10:18:05 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/model/InvalidAddressingHeaderException.java	Tue Aug  4 10:18:04 2009
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.addressing.model;
+
+import com.sun.xml.internal.ws.resources.AddressingMessages;
+
+import javax.xml.ws.WebServiceException;
+import javax.xml.namespace.QName;
+
+/**
+ * This exception captures SOAP Fault information when a WS-Addressing 1.0 Message Addressing
+ * Property is invalid and cannot be processed.
+ *
+ * @author Rama Pulavarthi
+ */
+public class InvalidAddressingHeaderException extends WebServiceException {
+    private QName problemHeader;
+    private QName subsubcode;
+
+    /**
+     * Creates a InvalidAddressingHeader exception capturing information about the invalid
+     * Addressing Message Property and the reason in Subsubcode.
+     * @param problemHeader
+     *      represents the invalid Addressing Header.
+     * @param subsubcode
+     *      represents the reason why the Addressing header in question is invalid.
+     */
+    public InvalidAddressingHeaderException(QName problemHeader, QName subsubcode) {
+        super(AddressingMessages.INVALID_ADDRESSING_HEADER_EXCEPTION(problemHeader,subsubcode));
+        this.problemHeader = problemHeader;
+        this.subsubcode = subsubcode;
+    }
+
+    public QName getProblemHeader() {
+        return problemHeader;
+    }
+
+    public QName getSubsubcode() {
+        return subsubcode;
+    }
+}
--- /dev/null	Tue Aug  4 10:18:07 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/model/MissingAddressingHeaderException.java	Tue Aug  4 10:18:06 2009
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.addressing.model;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.resources.AddressingMessages;
+
+import javax.xml.ws.WebServiceException;
+import javax.xml.namespace.QName;
+
+/**
+ * This exception signals that a particular WS-Addressing header is missing in a SOAP message.
+ *
+ * @author Rama Pulavarthi
+ */
+public class MissingAddressingHeaderException extends WebServiceException {
+    private final QName name;
+    private final Packet packet;
+
+    /**
+     *
+     * @param name QName of the missing WS-Addressing Header
+     */
+    public MissingAddressingHeaderException(@NotNull QName name) {
+        this(name,null);
+    }
+
+    public MissingAddressingHeaderException(@NotNull QName name, @Nullable Packet p) {
+        super(AddressingMessages.MISSING_HEADER_EXCEPTION(name));
+        this.name = name;
+        this.packet = p;
+    }
+
+    /**
+     * Gets the QName of the missing WS-Addressing Header.
+     *
+     * @return
+     *      never null.
+     */
+    public QName getMissingHeaderQName() {
+        return name;
+    }
+
+    /**
+     * The {@link Packet} in which a header was missing.
+     *
+     * <p>
+     * This object can be used to deep-inspect the problematic SOAP message.
+     */
+    public Packet getPacket() {
+        return packet;
+    }
+}
--- /dev/null	Tue Aug  4 10:18:09 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/v200408/MemberSubmissionWsaClientTube.java	Tue Aug  4 10:18:08 2009
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.addressing.v200408;
+
+import com.sun.xml.internal.ws.addressing.WsaClientTube;
+import com.sun.xml.internal.ws.addressing.model.MissingAddressingHeaderException;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.pipe.Tube;
+import com.sun.xml.internal.ws.api.pipe.TubeCloner;
+import com.sun.xml.internal.ws.developer.MemberSubmissionAddressing;
+import com.sun.xml.internal.ws.developer.MemberSubmissionAddressingFeature;
+
+/**
+ * @author Rama Pulavarthi
+ */
+public class MemberSubmissionWsaClientTube extends WsaClientTube {
+    private final MemberSubmissionAddressing.Validation validation;
+
+    public MemberSubmissionWsaClientTube(WSDLPort wsdlPort, WSBinding binding, Tube next) {
+        super(wsdlPort, binding, next);
+        validation = binding.getFeature(MemberSubmissionAddressingFeature.class).getValidation();
+
+    }
+
+    public MemberSubmissionWsaClientTube(MemberSubmissionWsaClientTube that, TubeCloner cloner) {
+        super(that, cloner);
+        this.validation = that.validation;
+
+    }
+    public MemberSubmissionWsaClientTube copy(TubeCloner cloner) {
+        return new MemberSubmissionWsaClientTube(this, cloner);
+    }
+
+    @Override
+    protected void checkMandatoryHeaders(Packet packet, boolean foundAction, boolean foundTo, boolean foundReplyTo,
+                                         boolean foundFaultTo, boolean foundMessageID, boolean foundRelatesTo) {
+        super.checkMandatoryHeaders(packet,foundAction,foundTo,foundReplyTo,foundFaultTo,foundMessageID,foundRelatesTo);
+
+        // if no wsa:To header is found
+        if (!foundTo) {
+            throw new MissingAddressingHeaderException(addressingVersion.toTag,packet);
+        }
+
+        if (!validation.equals(MemberSubmissionAddressing.Validation.LAX)) {
+
+            // if it is not one-way, response must contain wsa:RelatesTo
+            // RelatesTo required as per
+            // Table 5-3 of http://www.w3.org/TR/2006/WD-ws-addr-wsdl-20060216/#wsdl11requestresponse
+            if (expectReply && (packet.getMessage() != null) && !foundRelatesTo) {
+                String action = packet.getMessage().getHeaders().getAction(addressingVersion, soapVersion);
+                // Don't check for AddressingFaults as
+                // Faults for requests with duplicate MessageId will have no wsa:RelatesTo
+                if (!packet.getMessage().isFault() || !action.equals(addressingVersion.getDefaultFaultAction())) {
+                    throw new MissingAddressingHeaderException(addressingVersion.relatesToTag,packet);
+                }
+            }
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:18:11 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/addressing/v200408/MemberSubmissionWsaServerTube.java	Tue Aug  4 10:18:10 2009
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.addressing.v200408;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.xml.internal.ws.addressing.WsaServerTube;
+import com.sun.xml.internal.ws.addressing.model.MissingAddressingHeaderException;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundOperation;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
+import com.sun.xml.internal.ws.api.pipe.Tube;
+import com.sun.xml.internal.ws.api.pipe.TubeCloner;
+import com.sun.xml.internal.ws.api.server.WSEndpoint;
+import com.sun.xml.internal.ws.developer.MemberSubmissionAddressing;
+import com.sun.xml.internal.ws.developer.MemberSubmissionAddressingFeature;
+
+/**
+ * @author Rama Pulavarthi
+ */
+public class MemberSubmissionWsaServerTube extends WsaServerTube {
+    private final MemberSubmissionAddressing.Validation validation;
+    public MemberSubmissionWsaServerTube(WSEndpoint endpoint, @NotNull WSDLPort wsdlPort, WSBinding binding, Tube next) {
+        super(endpoint, wsdlPort, binding, next);
+        validation = binding.getFeature(MemberSubmissionAddressingFeature.class).getValidation();
+    }
+
+    public MemberSubmissionWsaServerTube(MemberSubmissionWsaServerTube that, TubeCloner cloner) {
+        super(that, cloner);
+        this.validation = that.validation;
+    }
+
+    public MemberSubmissionWsaServerTube copy(TubeCloner cloner) {
+        return new MemberSubmissionWsaServerTube(this, cloner);
+    }
+
+    @Override
+    protected void checkMandatoryHeaders(Packet packet, boolean foundAction, boolean foundTo, boolean foundReplyTo,
+            boolean foundFaultTo, boolean foundMessageId, boolean foundRelatesTo) {
+
+        super.checkMandatoryHeaders(packet, foundAction, foundTo, foundReplyTo,
+                foundFaultTo, foundMessageId, foundRelatesTo);
+
+        // if no wsa:To header is found
+        if (!foundTo)
+            throw new MissingAddressingHeaderException(addressingVersion.toTag,packet);
+
+        //we can find Req/Response or Oneway only with WSDLModel
+        if (wsdlPort != null) {
+            WSDLBoundOperation wbo = getWSDLBoundOperation(packet);
+            // if two-way, must contain wsa:ReplyTo
+            // Unlike W3C version, we cannot assume default value as anonymous if not present.
+            // For protocol messages, don't check as they do not have any corresponding wsdl operations
+            if (wbo != null && !wbo.getOperation().isOneWay() && !foundReplyTo) {
+                throw new MissingAddressingHeaderException(addressingVersion.replyToTag,packet);
+            }
+        }
+        if (!validation.equals(MemberSubmissionAddressing.Validation.LAX)) {
+            // wsa:MessageId is required if wsa:ReplyTo is present.
+            if ((foundReplyTo || foundFaultTo) && !foundMessageId)
+                throw new MissingAddressingHeaderException(addressingVersion.messageIDTag,packet);
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:18:13 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/ResourceLoader.java	Tue Aug  4 10:18:12 2009
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.api;
+
+import com.sun.xml.internal.ws.api.server.Container;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+/**
+ * Used to locate resources for jax-ws extensions. Using this, extensions
+ * do not to have to write container specific code to locate resources.
+ *
+ * @author Jitendra Kotamraju
+ */
+public abstract class ResourceLoader {
+
+    /**
+     * Returns the actual location of the resource from the 'resource' arg
+     * that represents a virtual locaion of a file understood by a container.
+     * ResourceLoader impl for a Container knows how to map this
+     * virtual location to actual location.
+     * <p>
+     * Extensions can get hold of this object using {@link Container}.
+     * <p/>
+     * for e.g.:
+     * <pre>
+     * ResourceLoader loader = container.getSPI(ResourceLoader.class);
+     * URL catalog = loader.get("jax-ws-catalog.xml");
+     * </pre>
+     * A ResourceLoader for servlet environment, may do the following.
+     * <pre>
+     * URL getResource(String resource) {
+     *     return servletContext.getResource("/WEB-INF/"+resource);
+     * }
+     * </pre>
+     *
+     * @param resource Designates a path that is understood by the container. The
+     *             implementations must support "jax-ws-catalog.xml" resource.
+     * @return the actual location, if found, or null if not found.
+     * @throws MalformedURLException if there is an error in creating URL
+     */
+    public abstract URL getResource(String resource) throws MalformedURLException;
+
+}
--- /dev/null	Tue Aug  4 10:18:15 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/handler/MessageHandler.java	Tue Aug  4 10:18:14 2009
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.api.handler;
+
+import javax.xml.ws.handler.Handler;
+import javax.xml.namespace.QName;
+import java.util.Set;
+
+
+/**
+ * The <code>MessageHandler</code> class extends <code>Handler</code>
+ * to provide typesafety for the message context parameter and add a method
+ * to obtain access to the headers that may be processed by the handler.
+ * Its provides similar functionality as a SOAPHandler but provides RI's
+ * Message in the MessageContext.
+ *
+ * @author Rama Pulavarthi
+ * @since JAX-WS 2.1.3
+ */
+public interface MessageHandler<C extends MessageHandlerContext> extends Handler<C> {
+
+
+   /** Gets the header blocks that can be processed by this Handler
+   *  instance.
+   *
+   *  @return Set of <code>QNames</code> of header blocks processed by this
+   *           handler instance. <code>QName</code> is the qualified
+   *           name of the outermost element of the Header block.
+  **/
+  Set<QName> getHeaders();
+
+}
--- /dev/null	Tue Aug  4 10:18:17 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/handler/MessageHandlerContext.java	Tue Aug  4 10:18:16 2009
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.api.handler;
+
+import com.sun.istack.internal.Nullable;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.message.Message;
+import com.sun.xml.internal.ws.api.model.SEIModel;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
+
+import javax.xml.ws.handler.MessageContext;
+import java.util.Set;
+
+/**
+ * The <code>MessageHandlerContext</code> interface extends
+ * <code>MessageContext</code> to provide easy access to the contained message.
+ *
+ * This context provides access to RI's <code>Message</code> model for efficient access
+ * to various things like accessing headers etc. It also provides access to
+ * binding information as <code>WSBinding</code>.
+ *
+ * @author Rama Pulavarthi
+ * @since JAX-WS 2.1.3
+ */
+public interface MessageHandlerContext extends MessageContext {
+    /**
+     * Gets the message from this message context
+     *
+     * @return The contained message; returns <code>null</code> if no
+     *         message is present in this message context
+     */
+    public Message getMessage();
+
+
+    /**
+     * Sets the message in this message context
+     */
+    public void setMessage(Message message);
+
+    /**
+     * @see javax.xml.ws.handler.soap.SOAPMessageContext#getRoles()
+     */
+     public Set<String> getRoles();
+
+
+    /**
+     * Provides access to <code>WSBinding</code> which can be used in various ways.
+     * for example: <code>WSBinding#getSOAPVersion</code> to get SOAP version of the binding.
+     *              <code>WSBinding#isFeatureEnabled(AddressingFeature)</code> to check if addressing is enabled
+     */
+    public WSBinding getWSBinding();
+
+    /**
+     * Provides access to <code>SEIModel</code>.
+     */
+    public @Nullable SEIModel getSEIModel();
+
+    /**
+     * Gets the {@link WSDLPort} that represents the port.
+     * @return
+     *      returns the WSDLModel of the port that the client/endpoint binds to.
+     *      null when the Service is not configured with WSDL information.
+     */
+    public @Nullable WSDLPort getPort();
+
+}
--- /dev/null	Tue Aug  4 10:18:19 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/message/FilterMessageImpl.java	Tue Aug  4 10:18:18 2009
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.api.message;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
+import com.sun.xml.internal.bind.api.Bridge;
+import com.sun.xml.internal.ws.api.SOAPVersion;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.addressing.AddressingVersion;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.SAXException;
+
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.namespace.QName;
+import javax.xml.soap.SOAPException;
+import javax.xml.soap.SOAPMessage;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.XMLStreamWriter;
+import javax.xml.transform.Source;
+
+/**
+ * A <code>FilterMessageImpl</code> contains some other Message, which it uses
+ * as its  basic source of message data, possibly transforming the data along
+ * the way or providing  additional functionality.
+ *
+ * <p>
+ * The class <code>FilterMessageImpl</code> itself simply overrides
+ * all the methods of <code>Message</code> and invokes them on
+ * contained Message delegate. Subclasses of <code>FilterMessageImpl</code>
+ * may further override some of  these methods and may also provide
+ * additional methods and fields.
+ *
+ * @author Jitendra Kotamraju
+ */
+public class FilterMessageImpl extends Message {
+    private final Message delegate;
+
+    protected FilterMessageImpl(Message delegate) {
+        this.delegate = delegate;
+    }
+
+    public boolean hasHeaders() {
+        return delegate.hasHeaders();
+    }
+
+    public @NotNull HeaderList getHeaders() {
+        return delegate.getHeaders();
+    }
+
+    public @NotNull AttachmentSet getAttachments() {
+        return delegate.getAttachments();
+    }
+
+    protected boolean hasAttachments() {
+        return delegate.hasAttachments();
+    }
+
+    public boolean isOneWay(@NotNull WSDLPort port) {
+        return delegate.isOneWay(port);
+    }
+
+    public @Nullable String getPayloadLocalPart() {
+        return delegate.getPayloadLocalPart();
+    }
+
+    public String getPayloadNamespaceURI() {
+        return delegate.getPayloadNamespaceURI();
+    }
+
+    public boolean hasPayload() {
+        return delegate.hasPayload();
+    }
+
+    public boolean isFault() {
+        return delegate.isFault();
+    }
+
+    public @Nullable QName getFirstDetailEntryName() {
+        return delegate.getFirstDetailEntryName();
+    }
+
+    public Source readEnvelopeAsSource() {
+        return delegate.readEnvelopeAsSource();
+    }
+
+    public Source readPayloadAsSource() {
+        return delegate.readPayloadAsSource();
+    }
+
+    public SOAPMessage readAsSOAPMessage() throws SOAPException {
+        return delegate.readAsSOAPMessage();
+    }
+
+    public SOAPMessage readAsSOAPMessage(Packet packet, boolean inbound) throws SOAPException {
+        return delegate.readAsSOAPMessage(packet, inbound);
+    }
+
+    public <T> T readPayloadAsJAXB(Unmarshaller unmarshaller) throws JAXBException {
+        return (T)delegate.readPayloadAsJAXB(unmarshaller);
+    }
+
+    public <T> T readPayloadAsJAXB(Bridge<T> bridge) throws JAXBException {
+        return delegate.readPayloadAsJAXB(bridge);
+    }
+
+    public XMLStreamReader readPayload() throws XMLStreamException {
+        return delegate.readPayload();
+    }
+
+    public void consume() {
+        delegate.consume();
+    }
+
+    public void writePayloadTo(XMLStreamWriter sw) throws XMLStreamException {
+        delegate.writePayloadTo(sw);
+    }
+
+    public void writeTo(XMLStreamWriter sw) throws XMLStreamException {
+        delegate.writeTo(sw);
+    }
+
+    public void writeTo(ContentHandler contentHandler, ErrorHandler errorHandler) throws SAXException {
+        delegate.writeTo(contentHandler, errorHandler);
+    }
+
+    public Message copy() {
+        return delegate.copy();
+    }
+
+    public @NotNull String getID(@NotNull WSBinding binding) {
+        return delegate.getID(binding);
+    }
+
+    public @NotNull String getID(AddressingVersion av, SOAPVersion sv) {
+        return delegate.getID(av, sv);
+    }
+}
--- /dev/null	Tue Aug  4 10:18:21 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/model/wsdl/WSDLBoundFault.java	Tue Aug  4 10:18:20 2009
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.api.model.wsdl;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
+
+import javax.xml.namespace.QName;
+
+/**
+ * Abstracts wsdl:binding/wsdl:operation/wsdl:fault
+ *
+ * @author Vivek Pandey
+ */
+public interface WSDLBoundFault extends WSDLObject, WSDLExtensible {
+
+    /**
+     * Gives the wsdl:binding/wsdl:operation/wsdl:fault@name value
+     */
+    public
+    @NotNull
+    String getName();
+
+    /**
+     * Gives the qualified name associated with the fault. the namespace URI of the bounded fault
+     * will be the one derived from wsdl:portType namespace.
+     *
+     * Maybe null if this method is called before the model is completely build (frozen), if a binding fault has no
+     * corresponding fault in abstractwsdl:portType/wsdl:operation then the namespace URI of the fault will be that of
+     * the WSDBoundPortType.
+     */
+    public @Nullable QName getQName();
+
+    /**
+     * Gives the associated abstract fault from
+     * wsdl:portType/wsdl:operation/wsdl:fault. It is only available after
+     * the WSDL parsing is complete and the entire model is frozen.
+     * <p/>
+     * Maybe null if a binding fault has no corresponding fault in abstract
+     * wsdl:portType/wsdl:operation
+     */
+    public
+    @Nullable
+    WSDLFault getFault();
+
+    /**
+     * Gives the owner {@link WSDLBoundOperation}
+     */
+    @NotNull WSDLBoundOperation getBoundOperation();
+}
--- /dev/null	Tue Aug  4 10:18:23 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/server/EndpointComponent.java	Tue Aug  4 10:18:22 2009
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.api.server;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
+
+/**
+ * Interface that allows components around {@link WSEndpoint} to hook up
+ * with each other.
+ *
+ * @author Kohsuke Kawaguchi
+ * @since 2.1.2
+ * @see WSEndpoint#getComponentRegistry()
+ */
+public interface EndpointComponent {
+    /**
+     * Gets the specified SPI.
+     *
+     * <p>
+     * This method works as a kind of directory service
+     * for SPIs, allowing various components to define private contract
+     * and talk to each other.
+     *
+     * @return
+     *      null if such an SPI is not provided by this object.
+     */
+    @Nullable <T> T getSPI(@NotNull Class<T> spiType);
+}
--- /dev/null	Tue Aug  4 10:18:25 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/api/server/HttpEndpoint.java	Tue Aug  4 10:18:24 2009
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.api.server;
+
+import com.sun.istack.internal.NotNull;
+
+/**
+ * Light-weight http server transport for {@link WSEndpoint}.
+ * It provides a way to start the transport at a local http address and
+ * to stop the transport.
+ *
+ * @author Jitendra Kotamraju
+ */
+public abstract class HttpEndpoint {
+
+    /**
+     * Factory to deploy {@link WSEndpoint} on light-weight
+     * http server container.
+     *
+     * @param endpoint that needs to be deployed at http server
+     * @return transport object for the endpoint
+     */
+    public static HttpEndpoint create(@NotNull WSEndpoint endpoint) {
+        return new com.sun.xml.internal.ws.transport.http.server.HttpEndpoint(endpoint, null);
+    }
+
+    /**
+     * Publishes this endpoint at a localhost's http address.
+     *
+     * @param address endpoint's http address
+     *        for e.g http://localhost:8080/ctxt/pattern
+     */
+    public abstract void publish(@NotNull String address);
+
+    /**
+     * Stops the published endpoint
+     */
+    public abstract void stop();
+
+}
--- /dev/null	Tue Aug  4 10:18:27 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/ClientContainer.java	Tue Aug  4 10:18:26 2009
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.client;
+
+import com.sun.xml.internal.ws.api.ResourceLoader;
+import com.sun.xml.internal.ws.api.server.Container;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+/**
+ * @author Jitendra Kotamraju
+ */
+final class ClientContainer extends Container {
+
+    private final ResourceLoader loader = new ResourceLoader() {
+        public URL getResource(String resource) throws MalformedURLException {
+            ClassLoader cl = Thread.currentThread().getContextClassLoader();
+            if (cl == null) {
+                cl = this.getClass().getClassLoader();
+            }
+            return cl.getResource("META-INF/"+resource);
+        }
+    };
+
+    public <T> T getSPI(Class<T> spiType) {
+        if (spiType == ResourceLoader.class) {
+            return spiType.cast(loader);
+        }
+        return null;
+    }
+
+}
--- /dev/null	Tue Aug  4 10:18:29 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/ClientSchemaValidationTube.java	Tue Aug  4 10:18:28 2009
@@ -0,0 +1,163 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.client;
+
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
+import com.sun.xml.internal.ws.api.pipe.Tube;
+import com.sun.xml.internal.ws.api.pipe.TubeCloner;
+import com.sun.xml.internal.ws.api.pipe.helper.AbstractTubeImpl;
+import com.sun.xml.internal.ws.api.server.SDDocument;
+import com.sun.xml.internal.ws.api.server.SDDocumentSource;
+import com.sun.xml.internal.ws.util.MetadataUtil;
+import com.sun.xml.internal.ws.util.pipe.AbstractSchemaValidationTube;
+import com.sun.xml.internal.ws.util.xml.MetadataDocument;
+import org.w3c.dom.Document;
+import org.xml.sax.SAXException;
+
+import javax.xml.XMLConstants;
+import javax.xml.namespace.QName;
+import javax.xml.transform.Source;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+import javax.xml.validation.Validator;
+import javax.xml.ws.WebServiceException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Logger;
+
+/**
+ * {@link Tube} that does the schema validation on the client side.
+ *
+ * @author Jitendra Kotamraju
+ */
+public class ClientSchemaValidationTube extends AbstractSchemaValidationTube {
+
+    private static final Logger LOGGER = Logger.getLogger(ClientSchemaValidationTube.class.getName());
+
+    private final Schema schema;
+    private final Validator validator;
+    private final boolean noValidation;
+    private final WSDLPort port;
+
+    public ClientSchemaValidationTube(WSBinding binding, WSDLPort port, Tube next) {
+        super(binding, next);
+        this.port = port;
+        Source[] sources = null;
+        if (port != null) {
+            String primaryWsdl = port.getOwner().getParent().getLocation().getSystemId();
+            sources = getSchemaSources(primaryWsdl);
+            for(Source source : sources) {
+                LOGGER.fine("Constructing validation Schema from = "+source.getSystemId());
+                //printDOM((DOMSource)source);
+            }
+        }
+        if (sources != null) {
+            noValidation = false;
+            SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
+            try {
+                schema = sf.newSchema(sources);
+            } catch(SAXException e) {
+                throw new WebServiceException(e);
+            }
+            validator = schema.newValidator();
+        } else {
+            noValidation = true;
+            schema = null;
+            validator = null;
+        }
+    }
+
+    private class MetadataResolverImpl implements MetadataUtil.MetadataResolver{
+
+        Map<String, SDDocument> docs = new HashMap<String, SDDocument>();
+
+        public SDDocument resolveEntity(String systemId) {
+            SDDocument sdi = docs.get(systemId);
+            if (sdi == null) {
+                SDDocumentSource sds;
+                try {
+                    sds = SDDocumentSource.create(new URL(systemId));
+                } catch(MalformedURLException e) {
+                    throw new WebServiceException(e);
+                }
+                sdi = MetadataDocument.create(sds, new QName(""), new QName(""));
+                docs.put(systemId, sdi);
+            }
+            return sdi;
+        }
+    }
+
+    private Source[] getSchemaSources(String primary) {
+
+        MetadataUtil.MetadataResolver mdresolver = new MetadataResolverImpl();
+        Map<String, SDDocument> docs = MetadataUtil.getMetadataClosure(primary, mdresolver, true);
+
+        List<Source> list = new ArrayList<Source>();
+        for(Map.Entry<String, SDDocument> entry : docs.entrySet()) {
+            SDDocument doc = entry.getValue();
+            // Add all xsd:schema fragments from all WSDLs. That should form a closure of schemas.
+            if (doc.isWSDL()) {
+                Document dom = createDOM(doc);
+                // Get xsd:schema node from WSDL's DOM
+                addSchemaFragmentSource(dom, doc.getURL().toExternalForm(), list);
+            } else if (doc.isSchema()) {
+                // If there are multiple schemas with the same targetnamespace,
+                // JAXP works only with the first one. Above, all schema fragments may have the same targetnamespace,
+                // and that means it will not include all the schemas. Since we have a list of schemas, just add them.
+                Document dom = createDOM(doc);
+                list.add(new DOMSource(dom, doc.getURL().toExternalForm()));
+            }
+        }
+        //addSchemaSource(list);
+        return list.toArray(new Source[list.size()]) ;
+    }
+
+    protected Validator getValidator() {
+        return validator;
+    }
+
+    protected boolean isNoValidation() {
+        return noValidation;
+    }
+
+    protected ClientSchemaValidationTube(ClientSchemaValidationTube that, TubeCloner cloner) {
+        super(that,cloner);
+        this.port = that.port;
+        this.schema = that.schema;
+        this.validator = schema.newValidator();
+        this.noValidation = that.noValidation;
+    }
+
+    public AbstractTubeImpl copy(TubeCloner cloner) {
+        return new ClientSchemaValidationTube(this,cloner);
+    }
+
+}
--- /dev/null	Tue Aug  4 10:18:31 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/SEIMethodHandler.java	Tue Aug  4 10:18:30 2009
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.client.sei;
+
+import com.sun.xml.internal.ws.api.message.Message;
+import com.sun.xml.internal.ws.model.CheckedExceptionImpl;
+import com.sun.xml.internal.ws.model.JavaMethodImpl;
+import com.sun.xml.internal.ws.model.ParameterImpl;
+import com.sun.xml.internal.ws.model.WrapperParameter;
+
+import javax.xml.namespace.QName;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * {@link com.sun.xml.internal.ws.client.sei.MethodHandler} that handles synchronous method invocations.
+ *
+ * <p>
+ * This class mainly performs the following two tasks:
+ * <ol>
+ *  <li>Accepts Object[] that represents arguments for a Java method,
+ *      and creates {@link com.sun.xml.internal.ws.message.jaxb.JAXBMessage} that represents a request message.
+ *  <li>Takes a {@link com.sun.xml.internal.ws.api.message.Message] that represents a response,
+ *      and extracts the return value (and updates {@link javax.xml.ws.Holder }s.)
+ * </ol>
+ *
+ * <h2>Creating {@link com.sun.xml.internal.ws.message.jaxb.JAXBMessage }</h2>
+ * <p>
+ * At the construction time, we prepare {@link com.sun.xml.internal.ws.client.sei.BodyBuilder} and {@link com.sun.xml.internal.ws.client.sei.MessageFiller}s
+ * that know how to move arguments into a {@link com.sun.xml.internal.ws.api.message.Message }.
+ * Some arguments go to the payload, some go to headers, still others go to attachments.
+ *
+ * @author Kohsuke Kawaguchi
+ * @author Jitendra Kotamraju
+ */
+abstract class SEIMethodHandler extends MethodHandler {
+
+    // these objects together create a message from method parameters
+    private final BodyBuilder bodyBuilder;
+    private final MessageFiller[] inFillers;
+
+    protected final String soapAction;
+
+    protected final boolean isOneWay;
+
+    protected final JavaMethodImpl javaMethod;
+
+    protected final Map<QName, CheckedExceptionImpl> checkedExceptions;
+
+    SEIMethodHandler(SEIStub owner, JavaMethodImpl method) {
+        super(owner);
+
+        //keep all the CheckedException model for the detail qname
+        this.checkedExceptions = new HashMap<QName, CheckedExceptionImpl>();
+        for(CheckedExceptionImpl ce : method.getCheckedExceptions()){
+            checkedExceptions.put(ce.getBridge().getTypeReference().tagName, ce);
+        }
+        //If a non-"" soapAction is specified, wsa:action the SOAPAction
+        if(method.getInputAction() != null && !method.getBinding().getSOAPAction().equals("") ) {
+            this.soapAction = method.getInputAction();
+        } else {
+            this.soapAction = method.getBinding().getSOAPAction();
+        }
+        this.javaMethod = method;
+
+        {// prepare objects for creating messages
+            List<ParameterImpl> rp = method.getRequestParameters();
+
+            BodyBuilder bodyBuilder = null;
+            List<MessageFiller> fillers = new ArrayList<MessageFiller>();
+
+            for (ParameterImpl param : rp) {
+                ValueGetter getter = getValueGetterFactory().get(param);
+
+                switch(param.getInBinding().kind) {
+                case BODY:
+                    if(param.isWrapperStyle()) {
+                        if(param.getParent().getBinding().isRpcLit())
+                            bodyBuilder = new BodyBuilder.RpcLit((WrapperParameter)param, owner.soapVersion, getValueGetterFactory());
+                        else
+                            bodyBuilder = new BodyBuilder.DocLit((WrapperParameter)param, owner.soapVersion, getValueGetterFactory());
+                    } else {
+                        bodyBuilder = new BodyBuilder.Bare(param, owner.soapVersion, getter);
+                    }
+                    break;
+                case HEADER:
+                    fillers.add(new MessageFiller.Header(
+                        param.getIndex(),
+                        param.getBridge(),
+                        getter ));
+                    break;
+                case ATTACHMENT:
+                    fillers.add(MessageFiller.AttachmentFiller.createAttachmentFiller(param, getter));
+                    break;
+                case UNBOUND:
+                    break;
+                default:
+                    throw new AssertionError(); // impossible
+                }
+            }
+
+            if(bodyBuilder==null) {
+                // no parameter binds to body. we create an empty message
+                switch(owner.soapVersion) {
+                case SOAP_11:
+                    bodyBuilder = BodyBuilder.EMPTY_SOAP11;
+                    break;
+                case SOAP_12:
+                    bodyBuilder = BodyBuilder.EMPTY_SOAP12;
+                    break;
+                default:
+                    throw new AssertionError();
+                }
+            }
+
+            this.bodyBuilder = bodyBuilder;
+            this.inFillers = fillers.toArray(new MessageFiller[fillers.size()]);
+        }
+
+        this.isOneWay = method.getMEP().isOneWay();
+    }
+
+    ResponseBuilder buildResponseBuilder(JavaMethodImpl method, ValueSetterFactory setterFactory) {
+        // prepare objects for processing response
+        List<ParameterImpl> rp = method.getResponseParameters();
+        List<ResponseBuilder> builders = new ArrayList<ResponseBuilder>();
+
+        for( ParameterImpl param : rp ) {
+            ValueSetter setter;
+            switch(param.getOutBinding().kind) {
+            case BODY:
+                if(param.isWrapperStyle()) {
+                    if(param.getParent().getBinding().isRpcLit())
+                        builders.add(new ResponseBuilder.RpcLit((WrapperParameter)param, setterFactory));
+                    else
+                        builders.add(new ResponseBuilder.DocLit((WrapperParameter)param, setterFactory));
+                } else {
+                    setter = setterFactory.get(param);
+                    builders.add(new ResponseBuilder.Body(param.getBridge(),setter));
+                }
+                break;
+            case HEADER:
+                setter = setterFactory.get(param);
+                builders.add(new ResponseBuilder.Header(owner.soapVersion, param, setter));
+                break;
+            case ATTACHMENT:
+                setter = setterFactory.get(param);
+                builders.add(ResponseBuilder.AttachmentBuilder.createAttachmentBuilder(param, setter));
+                break;
+            case UNBOUND:
+                setter = setterFactory.get(param);
+                builders.add(new ResponseBuilder.NullSetter(setter,
+                    ResponseBuilder.getVMUninitializedValue(param.getTypeReference().type)));
+                break;
+            default:
+                throw new AssertionError();
+            }
+        }
+        ResponseBuilder rb;
+        switch(builders.size()) {
+        case 0:
+            rb = ResponseBuilder.NONE;
+            break;
+        case 1:
+            rb = builders.get(0);
+            break;
+        default:
+            rb = new ResponseBuilder.Composite(builders);
+        }
+        return rb;
+    }
+
+
+    /**
+     * Creates a request {@link com.sun.xml.internal.ws.message.jaxb.JAXBMessage} from method arguments.
+     * @param args proxy invocation arguments
+     * @return Message for the arguments
+     */
+    Message createRequestMessage(Object[] args) {
+        Message msg = bodyBuilder.createMessage(args);
+
+        for (MessageFiller filler : inFillers)
+            filler.fillIn(args,msg);
+
+        return msg;
+    }
+
+    abstract ValueGetterFactory getValueGetterFactory();
+
+}
--- /dev/null	Tue Aug  4 10:18:33 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/ValueGetterFactory.java	Tue Aug  4 10:18:32 2009
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.client.sei;
+
+import com.sun.xml.internal.ws.model.ParameterImpl;
+
+import javax.jws.WebParam;
+
+/**
+ * {@link ValueGetterFactory} is used to create {@link ValueGetter} objects.
+ *
+ * @author Jitendra Kotamraju
+ */
+abstract class ValueGetterFactory {
+
+    abstract ValueGetter get(ParameterImpl p);
+
+    static final ValueGetterFactory SYNC = new ValueGetterFactory() {
+        ValueGetter get(ParameterImpl p) {
+            return (p.getMode()== WebParam.Mode.IN || p.getIndex() == -1)
+                    ? ValueGetter.PLAIN : ValueGetter.HOLDER;
+        }
+    };
+
+    /**
+     * In case of SEI async signatures, there are no holders. The OUT
+     * parameters go in async bean class
+     */
+    static final ValueGetterFactory ASYNC = new ValueGetterFactory() {
+        ValueGetter get(ParameterImpl p) {
+            return ValueGetter.PLAIN;
+        }
+    };
+
+}
--- /dev/null	Tue Aug  4 10:18:35 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/ValueSetterFactory.java	Tue Aug  4 10:18:34 2009
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.client.sei;
+
+import com.sun.xml.internal.ws.model.ParameterImpl;
+
+import javax.xml.ws.WebServiceException;
+
+/**
+ * {@link ValueSetterFactory} is used to create {@link ValueSetter}.
+ *
+ * @author Jitendra Kotamraju
+ */
+abstract class ValueSetterFactory {
+
+    abstract ValueSetter get(ParameterImpl p);
+
+    static final ValueSetterFactory SYNC = new ValueSetterFactory() {
+        ValueSetter get(ParameterImpl p) {
+            return ValueSetter.getSync(p);
+        }
+    };
+
+    static final ValueSetterFactory NONE = new ValueSetterFactory() {
+        ValueSetter get(ParameterImpl p) {
+            throw new WebServiceException("This shouldn't happen. No response parameters.");
+        }
+    };
+
+    static final ValueSetterFactory SINGLE = new ValueSetterFactory() {
+        ValueSetter get(ParameterImpl p) {
+            return ValueSetter.SINGLE_VALUE;
+        }
+    };
+
+    static final class AsyncBeanValueSetterFactory extends ValueSetterFactory {
+        private Class asyncBean;
+
+        AsyncBeanValueSetterFactory(Class asyncBean) {
+            this.asyncBean = asyncBean;
+        }
+
+        ValueSetter get(ParameterImpl p) {
+            return new ValueSetter.AsyncBeanValueSetter(p, asyncBean);
+        }
+    }
+
+}
--- /dev/null	Tue Aug  4 10:18:37 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/client/sei/pacakge-info.java	Tue Aug  4 10:18:36 2009
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/**
+ * {@link SEIStub} and its supporting code.
+ */
+package com.sun.xml.internal.ws.client.sei;
--- /dev/null	Tue Aug  4 10:18:39 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/BindingTypeFeature.java	Tue Aug  4 10:18:38 2009
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.developer;
+
+import com.sun.xml.internal.ws.api.BindingID;
+
+import javax.xml.ws.WebServiceFeature;
+
+/**
+ * Using this feature, the application could override the binding used by
+ * the runtime(usually determined from WSDL).
+ *
+ * @author Jitendra Kotamraju
+ */
+public final class BindingTypeFeature extends WebServiceFeature {
+
+    public static final String ID = "http://jax-ws.dev.java.net/features/binding";
+
+    private final String bindingId;
+
+    public BindingTypeFeature(String bindingId) {
+        this.bindingId = bindingId;
+    }
+
+    public String getID() {
+        return ID;
+    }
+
+    public String getBindingId() {
+        return bindingId;
+    }
+
+}
--- /dev/null	Tue Aug  4 10:18:41 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/JAXBContextFactory.java	Tue Aug  4 10:18:41 2009
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.developer;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.xml.internal.bind.api.JAXBRIContext;
+import com.sun.xml.internal.bind.api.TypeReference;
+import com.sun.xml.internal.ws.api.model.SEIModel;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import java.util.List;
+
+/**
+ * Factory to create {@link JAXBContext}.
+ *
+ * <p>
+ * JAX-WS uses JAXB to perform databinding when you use the service endpoint interface, and normally
+ * the JAX-WS RI drives JAXB and creates a necessary {@link JAXBContext} automatically.
+ *
+ * <p>
+ * This annotation is a JAX-WS RI vendor-specific feature, which lets applications create {@link JAXBRIContext}
+ * (which is the JAXB RI's {@link JAXBContext} implementation.)
+ * Combined with the JAXB RI vendor extensions defined in {@link JAXBRIContext}, appliation can use this to
+ * fine-tune how the databinding happens, such as by adding more classes to the binding context,
+ * by controlling the namespace mappings, and so on.
+ *
+ * <p>
+ * Applications should either use {@link UsesJAXBContextFeature} or {@link UsesJAXBContext} to instruct
+ * the JAX-WS runtime to use a custom factory.
+ *
+ * @author Kohsuke Kawaguchi
+ * @since 2.1.5
+ */
+public interface JAXBContextFactory {
+    /**
+     * Called by the JAX-WS runtime to create a {@link JAXBRIContext} for the given SEI.
+     *
+     * @param sei
+     *      The {@link SEIModel} object being constructed. This object provides you access to
+     *      what SEI is being processed, and therefore useful if you are writing a generic
+     *      {@link JAXBContextFactory} that can work with arbitrary SEI classes.
+     *
+     * @param classesToBind
+     *      List of classes that needs to be bound by JAXB. This value is computed according to
+     *      the JAX-WS spec and given to you.
+     *
+     *      The calling JAX-WS runtime expects the returned {@link JAXBRIContext} to be capable of
+     *      handling all these classes, but you can add more (which is more common), or remove some
+     *      (if you know what you are doing.)
+     *
+     *      The callee is free to mutate this list.
+     *
+     * @param typeReferences
+     *      List of {@link TypeReference}s, which is also a part of the input to the JAXB RI to control
+     *      how the databinding happens. Most likely this will be just a pass-through to the
+     *      {@link JAXBRIContext#newInstance} method.
+     *
+     * @return
+     *      A non-null valid {@link JAXBRIContext} object.
+     *
+     * @throws JAXBException
+     *      If the callee encounters a fatal problem and wants to abort the JAX-WS runtime processing
+     *      of the given SEI, throw a {@link JAXBException}. This will cause the port instantiation
+     *      to fail (if on client), or the application deployment to fail (if on server.)
+     */
+    @NotNull JAXBRIContext createJAXBContext(@NotNull SEIModel sei, @NotNull List<Class> classesToBind, @NotNull List<TypeReference> typeReferences) throws JAXBException;
+
+    /**
+     * The default implementation that creates {@link JAXBRIContext} according to the standard behavior.
+     */
+    public static final JAXBContextFactory DEFAULT = new JAXBContextFactory() {
+        @NotNull
+        public JAXBRIContext createJAXBContext(@NotNull SEIModel sei, @NotNull List<Class> classesToBind, @NotNull List<TypeReference> typeReferences) throws JAXBException {
+            return JAXBRIContext.newInstance(classesToBind.toArray(new Class[classesToBind.size()]),
+                    typeReferences, null, sei.getTargetNamespace(), false, null);
+        }
+    };
+}
--- /dev/null	Tue Aug  4 10:18:43 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/SchemaValidation.java	Tue Aug  4 10:18:43 2009
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.developer;
+
+import com.sun.xml.internal.ws.server.DraconianValidationErrorHandler;
+
+import javax.jws.WebService;
+import javax.xml.transform.Source;
+import javax.xml.validation.Schema;
+import javax.xml.ws.spi.WebServiceFeatureAnnotation;
+import java.lang.annotation.Documented;
+import static java.lang.annotation.ElementType.TYPE;
+import java.lang.annotation.Retention;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import java.lang.annotation.Target;
+
+/**
+ * Validates all request and response messages payload(SOAP:Body) for a {@link WebService}
+ * against the XML schema. To use this feature, annotate the endpoint class with
+ * this annotation.
+ *
+ * <pre>
+ * for e.g.:
+ *
+ * &#64;WebService
+ * &#64;SchemaValidation
+ * public class HelloImpl {
+ *   ...
+ * }
+ * </pre>
+ *
+ * At present, schema validation works for doc/lit web services only.
+ *
+ * @since JAX-WS 2.1.3
+ * @author Jitendra Kotamraju
+ * @see SchemaValidationFeature
+ */
+@Retention(RUNTIME)
+@Target(TYPE)
+@Documented
+@WebServiceFeatureAnnotation(id = SchemaValidationFeature.ID, bean = SchemaValidationFeature.class)
+public @interface SchemaValidation {
+
+    /**
+     * Configure the validation behaviour w.r.t error handling. The default handler
+     * just rejects any invalid schema intances. If the application want to change
+     * this default behaviour(say just log the errors), it can do so by providing
+     * a custom implementation of {@link ValidationErrorHandler}.
+     */
+    Class<? extends ValidationErrorHandler> handler() default DraconianValidationErrorHandler.class;
+
+    /**
+     * Does validation for bound headers in a SOAP message.
+     *
+    boolean headers() default false;
+     */
+
+    /**
+     * Additional schema documents that are used to create {@link Schema} object. Useful
+     * when the application adds additional SOAP headers to the message. This is a list
+     * of system-ids, that are used to create {@link Source} objects and used in creation
+     * of {@link Schema} object
+     *
+     * for e.g.:
+     * @SchemaValidation(schemaLocations={"http://bar.foo/b.xsd", "http://foo.bar/a.xsd"}
+     *
+    String[] schemaLocations() default {};
+     */
+
+}
--- /dev/null	Tue Aug  4 10:18:45 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/SchemaValidationFeature.java	Tue Aug  4 10:18:45 2009
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.developer;
+
+import com.sun.xml.internal.ws.api.FeatureConstructor;
+import com.sun.xml.internal.ws.server.DraconianValidationErrorHandler;
+
+import javax.xml.ws.WebServiceFeature;
+
+
+/**
+ * {@link WebServiceFeature} for schema validation.
+ *
+ * @since JAX-WS 2.1.3
+ * @author Jitendra Kotamraju
+ * @see SchemaValidation
+ */
+public class SchemaValidationFeature extends WebServiceFeature {
+    /**
+     * Constant value identifying the SchemaValidationFeature
+     */
+    public static final String ID = "http://jax-ws.dev.java.net/features/schema-validation";
+
+    private Class<? extends ValidationErrorHandler> clazz;
+
+    public SchemaValidationFeature() {
+        this(DraconianValidationErrorHandler.class);
+    }
+
+    /**
+     * Create an <code>SchemaValidationFeature</code>.
+     * The instance created will be enabled.
+     */
+    @FeatureConstructor({"handler"})
+    public SchemaValidationFeature(Class<? extends ValidationErrorHandler> clazz) {
+        this.enabled = true;
+        this.clazz = clazz;
+    }
+
+    public String getID() {
+        return ID;
+    }
+
+    /**
+     * Invalid schema instances are rejected, a SOAP fault message is created
+     * for any invalid request and response message. If it is set to false, schema
+     * validation messages are just logged.
+     */
+    public Class<? extends ValidationErrorHandler> getErrorHandler() {
+        return clazz;
+    }
+}
--- /dev/null	Tue Aug  4 10:18:47 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/StreamingAttachment.java	Tue Aug  4 10:18:47 2009
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.developer;
+
+import javax.xml.ws.spi.WebServiceFeatureAnnotation;
+import java.lang.annotation.*;
+import java.io.File;
+
+/**
+ * This feature represents the use of StreamingAttachment attachments with a
+ * web service.
+ *
+ * <p>
+ * for e.g.: To keep all MIME attachments in memory, do the following
+ *
+ * <pre>
+ * &#64;WebService
+ * &#64;MIME(memoryThreshold=-1L)
+ * public class HelloService {
+ * }
+ * </pre>
+ *
+ * @see StreamingAttachmentFeature
+ *
+ * @author Jitendra Kotamraju
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+@Documented
+@WebServiceFeatureAnnotation(id = StreamingAttachmentFeature.ID, bean = StreamingAttachmentFeature.class)
+public @interface StreamingAttachment {
+
+    /**
+     * Directory in which large attachments are stored. {@link File#createTempFile}
+     * methods are used to create temp files for storing attachments. This
+     * value is used in {@link File#createTempFile}, if specified. If a file
+     * cannot be created in this dir, then all the content is kept in memory.
+     */
+    String dir() default "";
+
+    /**
+     * MIME message is parsed eagerly.
+     */
+    boolean parseEagerly() default false;
+
+    /**
+     * After this threshold(no of bytes per attachment), large attachment is
+     * written to file system.
+     *
+     * If the value is -1, then all the attachment content is kept in memory.
+     */
+    long memoryThreshold() default 1048576L;
+
+}
--- /dev/null	Tue Aug  4 10:18:49 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/StreamingAttachmentFeature.java	Tue Aug  4 10:18:49 2009
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.developer;
+
+import com.sun.xml.internal.ws.api.FeatureConstructor;
+import com.sun.istack.internal.Nullable;
+
+import javax.xml.ws.WebServiceFeature;
+
+import com.sun.xml.internal.org.jvnet.mimepull.MIMEConfig;
+
+/**
+ * Proxy needs to be created with this feature to configure StreamingAttachment
+ * attachments behaviour.
+ *
+ * <pre>
+ * for e.g.: To configure all StreamingAttachment attachments to be kept in memory
+ * <p>
+ *
+ * StreamingAttachmentFeature feature = new StreamingAttachmentFeature();
+ * feature.setAllMemory(true);
+ *
+ * proxy = HelloService().getHelloPort(feature);
+ *
+ * </pre>
+ *
+ * @author Jitendra Kotamraju
+ */
+public final class StreamingAttachmentFeature extends WebServiceFeature {
+    /**
+     * Constant value identifying the {@link @StreamingAttachment} feature.
+     */
+    public static final String ID = "http://jax-ws.dev.java.net/features/mime";
+
+    private MIMEConfig config;
+
+    private String dir;
+    private boolean parseEagerly;
+    private long memoryThreshold;
+
+    public StreamingAttachmentFeature() {
+    }
+
+    @FeatureConstructor({"dir","parseEagerly","memoryThreshold"})
+    public StreamingAttachmentFeature(@Nullable String dir, boolean parseEagerly, long memoryThreshold) {
+        this.enabled = true;
+        this.dir = dir;
+        this.parseEagerly = parseEagerly;
+        this.memoryThreshold = memoryThreshold;
+    }
+
+    public String getID() {
+        return ID;
+    }
+
+    /**
+     * Returns the configuration object. Once this is called, you cannot
+     * change the configuration.
+     *
+     * @return
+     */
+    public MIMEConfig getConfig() {
+        if (config == null) {
+            config = new MIMEConfig();
+            config.setDir(dir);
+            config.setParseEagerly(parseEagerly);
+            config.setMemoryThreshold(memoryThreshold);
+            config.validate();
+        }
+        return config;
+    }
+
+    /**
+     * Directory in which large attachments are stored
+     */
+    public void setDir(String dir) {
+        this.dir = dir;
+    }
+
+    /**
+     * StreamingAttachment message is parsed eagerly
+     */
+    public void setParseEagerly(boolean parseEagerly) {
+        this.parseEagerly = parseEagerly;
+    }
+
+    /**
+     * After this threshold(no of bytes), large attachments are
+     * written to file system
+     */
+    public void setMemoryThreshold(int memoryThreshold) {
+        this.memoryThreshold = memoryThreshold;
+    }
+
+}
--- /dev/null	Tue Aug  4 10:18:51 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/StreamingDataHandler.java	Tue Aug  4 10:18:51 2009
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.developer;
+
+import com.sun.xml.internal.org.jvnet.mimepull.MIMEPart;
+
+import javax.activation.DataSource;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.File;
+import java.net.URL;
+
+/**
+ * Implementation of {@link com.sun.xml.internal.org.jvnet.staxex.StreamingDataHandler} to access MIME
+ * attachments efficiently. Applications can use the additional methods and decide
+ * on how to access the attachment data in JAX-WS applications.
+ *
+ * <p>
+ * for e.g.:
+ *
+ * DataHandler dh = proxy.getData();
+ * StreamingDataHandler sdh = (StreamingDataHandler)dh;
+ * // readOnce() doesn't store attachment on the disk in some cases
+ * // for e.g when only one huge attachment after soap envelope part in MIME message
+ * InputStream in = sdh.readOnce();
+ * ...
+ * in.close();
+ * sdh.close();
+ *
+ * @author Jitendra Kotamraju
+ */
+public abstract class StreamingDataHandler extends com.sun.xml.internal.org.jvnet.staxex.StreamingDataHandler {
+
+    public StreamingDataHandler(Object o, String s) {
+        super(o, s);
+    }
+
+    public StreamingDataHandler(URL url) {
+        super(url);
+    }
+
+    public StreamingDataHandler(DataSource dataSource) {
+        super(dataSource);
+    }
+
+}
--- /dev/null	Tue Aug  4 10:18:53 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/UsesJAXBContext.java	Tue Aug  4 10:18:53 2009
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.developer;
+
+import javax.xml.ws.spi.WebServiceFeatureAnnotation;
+import javax.xml.bind.JAXBContext;
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This feature instructs that the specified {@link JAXBContextFactory} be used for performing
+ * data-binding for the SEI.
+ *
+ * <p>
+ * For example,
+ * <pre>
+ * &#64;WebService
+ * &#64;UsesJAXBContext(MyJAXBContextFactory.class)
+ * public class HelloService {
+ *   ...
+ * }
+ * </pre>
+ *
+ * <p>
+ * If your {@link JAXBContextFactory} needs to carry some state from your calling application,
+ * you can use {@link UsesJAXBContextFeature} to pass in an instance of {@link JAXBContextFactory},
+ * instead of using this to specify the type.
+ *
+ * @author Kohsuke Kawaguchi
+ * @since 2.1.5
+ */
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+@WebServiceFeatureAnnotation(id=UsesJAXBContextFeature.ID,bean=UsesJAXBContextFeature.class)
+public @interface UsesJAXBContext {
+    /**
+     * Designates the {@link JAXBContextFactory} to be used to create the {@link JAXBContext} object,
+     * which in turn will be used by the JAX-WS runtime to marshal/unmarshal parameters and return
+     * values to/from XML.
+     */
+    Class<? extends JAXBContextFactory> value();
+}
--- /dev/null	Tue Aug  4 10:18:55 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/UsesJAXBContextFeature.java	Tue Aug  4 10:18:55 2009
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.developer;
+
+import com.sun.xml.internal.ws.api.FeatureConstructor;
+import com.sun.xml.internal.ws.api.model.SEIModel;
+import com.sun.xml.internal.bind.api.JAXBRIContext;
+import com.sun.xml.internal.bind.api.TypeReference;
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
+
+import javax.xml.ws.WebServiceFeature;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import java.lang.reflect.InvocationTargetException;
+import java.util.List;
+
+/**
+ * A {@link WebServiceFeature} that instructs the JAX-WS runtime to use a specific {@link JAXBContextFactory}
+ * instance of creating {@link JAXBContext}.
+ *
+ * @see UsesJAXBContext
+ * @since 2.1.5
+ * @author Kohsuke Kawaguchi
+ */
+public class UsesJAXBContextFeature extends WebServiceFeature {
+    /**
+     * Constant value identifying the {@link UsesJAXBContext} feature.
+     */
+    public static final String ID = "http://jax-ws.dev.java.net/features/uses-jaxb-context";
+
+    private final JAXBContextFactory factory;
+
+    /**
+     * Creates {@link UsesJAXBContextFeature}.
+     *
+     * @param factoryClass
+     *      This class has to have a public no-arg constructor, which will be invoked to create
+     *      a new instance. {@link JAXBContextFactory#createJAXBContext(SEIModel, List, List)} will
+     *      be then called to create {@link JAXBContext}.
+     */
+    @FeatureConstructor("value")
+    public UsesJAXBContextFeature(@NotNull Class<? extends JAXBContextFactory> factoryClass) {
+        try {
+            factory = factoryClass.getConstructor().newInstance();
+        } catch (InstantiationException e) {
+            Error x = new InstantiationError(e.getMessage());
+            x.initCause(e);
+            throw x;
+        } catch (IllegalAccessException e) {
+            Error x = new IllegalAccessError(e.getMessage());
+            x.initCause(e);
+            throw x;
+        } catch (InvocationTargetException e) {
+            Error x = new InstantiationError(e.getMessage());
+            x.initCause(e);
+            throw x;
+        } catch (NoSuchMethodException e) {
+            Error x = new NoSuchMethodError(e.getMessage());
+            x.initCause(e);
+            throw x;
+        }
+    }
+
+    /**
+     * Creates {@link UsesJAXBContextFeature}.
+     * This version allows {@link JAXBContextFactory} to carry application specific state.
+     *
+     * @param factory
+     *      Uses a specific instance of {@link JAXBContextFactory} to create {@link JAXBContext}.
+     */
+    public UsesJAXBContextFeature(@Nullable JAXBContextFactory factory) {
+        this.factory = factory;
+    }
+
+    /**
+     * Creates {@link UsesJAXBContextFeature}.
+     * This version allows you to create {@link JAXBRIContext} upfront and uses it.
+     */
+    public UsesJAXBContextFeature(@Nullable final JAXBRIContext context) {
+        this.factory = new JAXBContextFactory() {
+            @NotNull
+            public JAXBRIContext createJAXBContext(@NotNull SEIModel sei, @NotNull List<Class> classesToBind, @NotNull List<TypeReference> typeReferences) throws JAXBException {
+                return context;
+            }
+        };
+    }
+
+    /**
+     * Gets the {@link JAXBContextFactory} instance to be used for creating {@link JAXBContext} for SEI.
+     *
+     * @return
+     *      null if the default {@link JAXBContext} shall be used.
+     */
+    public @Nullable JAXBContextFactory getFactory() {
+        return factory;
+    }
+
+    public String getID() {
+        return ID;
+    }
+}
--- /dev/null	Tue Aug  4 10:18:57 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/developer/ValidationErrorHandler.java	Tue Aug  4 10:18:57 2009
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.developer;
+
+import com.sun.xml.internal.ws.api.message.Packet;
+import org.xml.sax.ErrorHandler;
+
+import javax.xml.ws.handler.MessageContext;
+import javax.xml.validation.Validator;
+
+/**
+ * An {@link ErrorHandler} to receive errors encountered during the
+ * {@link Validator#validate} method invocation. Specify
+ * a custom handler in {@link SchemaValidation}, {@link SchemaValidationFeature}
+ * to customize the error handling process during validaiton.
+ *
+ * @see SchemaValidation
+ * @author Jitendra Kotamraju
+ */
+public abstract class ValidationErrorHandler implements ErrorHandler {
+    protected Packet packet;
+
+    /**
+     * Use it to communicate validation errors with the application.
+     *
+     * For e.g validation exceptions can be stored in {@link Packet#invocationProperties}
+     * during request processing and can be accessed in the endpoint
+     * via {@link MessageContext}
+     *
+     * @param packet for request or response message
+     */
+    public void setPacket(Packet packet) {
+        this.packet = packet;
+    }
+
+}
--- /dev/null	Tue Aug  4 10:18:59 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/ContentType.java	Tue Aug  4 10:18:59 2009
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+/*
+ * @(#)ContentType.java       1.7 02/03/27
+ */
+
+
+
+package com.sun.xml.internal.ws.encoding;
+
+import javax.xml.ws.WebServiceException;
+
+/**
+ * This class represents a MIME ContentType value. It provides
+ * methods to parse a ContentType string into individual components
+ * and to generate a MIME style ContentType string.
+ *
+ * @version 1.7, 02/03/27
+ * @author  John Mani
+ */
+public final class ContentType {
+
+    private String primaryType; // primary type
+    private String subType;     // subtype
+    private ParameterList list; // parameter list
+
+    /**
+     * Constructor that takes a Content-Type string. The String
+     * is parsed into its constituents: primaryType, subType
+     * and parameters. A ParseException is thrown if the parse fails.
+     *
+     * @param   s       the Content-Type string.
+     * @exception WebServiceException if the parse fails.
+     */
+    public ContentType(String s) throws WebServiceException {
+        HeaderTokenizer h = new HeaderTokenizer(s, HeaderTokenizer.MIME);
+        HeaderTokenizer.Token tk;
+
+        // First "type" ..
+        tk = h.next();
+        if (tk.getType() != HeaderTokenizer.Token.ATOM)
+            throw new WebServiceException();
+        primaryType = tk.getValue();
+
+        // The '/' separator ..
+        tk = h.next();
+        if ((char)tk.getType() != '/')
+            throw new WebServiceException();
+
+        // Then "subType" ..
+        tk = h.next();
+        if (tk.getType() != HeaderTokenizer.Token.ATOM)
+            throw new WebServiceException();
+        subType = tk.getValue();
+
+        // Finally parameters ..
+        String rem = h.getRemainder();
+        if (rem != null)
+            list = new ParameterList(rem);
+    }
+
+
+    /**
+     * Return the primary type.
+     * @return the primary type
+     */
+    public String getPrimaryType() {
+            return primaryType;
+    }
+
+    /**
+     * Return the subType.
+     * @return the subType
+     */
+    public String getSubType() {
+            return subType;
+    }
+
+    /**
+     * Return the MIME type string, without the parameters.
+     * The returned value is basically the concatenation of
+     * the primaryType, the '/' character and the secondaryType.
+     *
+     * @return the type
+     */
+    public String getBaseType() {
+            return primaryType + '/' + subType;
+    }
+
+    /**
+     * Return the specified parameter value. Returns <code>null</code>
+     * if this parameter is absent.
+     *
+     * @param name parameter name
+     * @return  parameter value
+     */
+    public String getParameter(String name) {
+        if (list == null)
+            return null;
+
+        return list.get(name);
+    }
+
+    /**
+     * Return a ParameterList object that holds all the available
+     * parameters. Returns null if no parameters are available.
+     *
+     * @return  ParameterList
+     */
+    public ParameterList getParameterList() {
+            return list;
+    }
+
+}
--- /dev/null	Tue Aug  4 10:19:01 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/DataSourceStreamingDataHandler.java	Tue Aug  4 10:19:01 2009
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.encoding;
+
+import com.sun.xml.internal.org.jvnet.mimepull.MIMEPart;
+
+import javax.activation.DataSource;
+import java.io.*;
+
+import com.sun.xml.internal.ws.developer.StreamingDataHandler;
+
+/**
+ * @author Jitendra Kotamraju
+ */
+public class DataSourceStreamingDataHandler extends StreamingDataHandler {
+
+    public DataSourceStreamingDataHandler(DataSource ds) {
+        super(ds);
+    }
+
+    public InputStream readOnce() throws IOException {
+        return getInputStream();
+    }
+
+    public void moveTo(File file) throws IOException {
+        InputStream in = getInputStream();
+        OutputStream os = new FileOutputStream(file);
+        byte[] temp = new byte[8192];
+        int len;
+        while((len=in.read(temp)) != -1) {
+            os.write(temp, 0, len);
+        }
+        in.close();
+        os.close();
+    }
+
+    public void close() throws IOException {
+        // nothing to do here
+    }
+
+}
--- /dev/null	Tue Aug  4 10:19:03 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/HeaderTokenizer.java	Tue Aug  4 10:19:03 2009
@@ -0,0 +1,382 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+/*
+ * @(#)HeaderTokenizer.java   1.9 02/03/27
+ */
+
+
+
+package com.sun.xml.internal.ws.encoding;
+
+import javax.xml.ws.WebServiceException;
+
+/**
+ * This class tokenizes RFC822 and MIME headers into the basic
+ * symbols specified by RFC822 and MIME. <p>
+ *
+ * This class handles folded headers (ie headers with embedded
+ * CRLF SPACE sequences). The folds are removed in the returned
+ * tokens.
+ *
+ * @version 1.9, 02/03/27
+ * @author  John Mani
+ */
+
+class HeaderTokenizer {
+
+    /**
+     * The Token class represents tokens returned by the
+     * HeaderTokenizer.
+     */
+    static class Token {
+
+        private int type;
+        private String value;
+
+        /**
+         * Token type indicating an ATOM.
+         */
+        public static final int ATOM            = -1;
+
+        /**
+         * Token type indicating a quoted string. The value
+         * field contains the string without the quotes.
+         */
+        public static final int QUOTEDSTRING    = -2;
+
+        /**
+         * Token type indicating a comment. The value field
+         * contains the comment string without the comment
+         * start and end symbols.
+         */
+        public static final int COMMENT         = -3;
+
+        /**
+         * Token type indicating end of input.
+         */
+        public static final int  EOF            = -4;
+
+        /**
+         * Constructor.
+         * @param       type    Token type
+         * @param       value   Token value
+         */
+        public Token(int type, String value) {
+             this.type = type;
+             this.value = value;
+        }
+
+        /**
+         * Return the type of the token. If the token represents a
+         * delimiter or a control character, the type is that character
+         * itself, converted to an integer. Otherwise, it's value is
+         * one of the following:
+         * <ul>
+         * <li><code>ATOM</code> A sequence of ASCII characters
+         *      delimited by either SPACE, CTL, "(", <"> or the
+         *      specified SPECIALS
+         * <li><code>QUOTEDSTRING</code> A sequence of ASCII characters
+         *      within quotes
+         * <li><code>COMMENT</code> A sequence of ASCII characters
+         *      within "(" and ")".
+         * <li><code>EOF</code> End of header
+         * </ul>
+         */
+        public int getType() {
+            return type;
+        }
+
+        /**
+         * Returns the value of the token just read. When the current
+         * token is a quoted string, this field contains the body of the
+         * string, without the quotes. When the current token is a comment,
+         * this field contains the body of the comment.
+         *
+         * @return      token value
+         */
+        public String getValue() {
+            return value;
+        }
+    }
+
+    private String string; // the string to be tokenized
+    private boolean skipComments; // should comments be skipped ?
+    private String delimiters; // delimiter string
+    private int currentPos; // current parse position
+    private int maxPos; // string length
+    private int nextPos; // track start of next Token for next()
+    private int peekPos; // track start of next Token for peek()
+
+    /**
+     * RFC822 specials
+     */
+    private final static String RFC822 = "()<>@,;:\\\"\t .[]";
+
+    /**
+     * MIME specials
+     */
+    final static String MIME = "()<>@,;:\\\"\t []/?=";
+
+    // The EOF Token
+    private final static Token EOFToken = new Token(Token.EOF, null);
+
+    /**
+     * Constructor that takes a rfc822 style header.
+     *
+     * @param   header  The rfc822 header to be tokenized
+     * @param   delimiters      Set of delimiter characters
+     *                          to be used to delimit ATOMS. These
+     *                          are usually <code>RFC822</code> or
+     *                          <code>MIME</code>
+     * @param   skipComments  If true, comments are skipped and
+     *                          not returned as tokens
+     */
+    HeaderTokenizer(String header, String delimiters,
+                           boolean skipComments) {
+        string = (header == null) ? "" : header; // paranoia ?!
+        this.skipComments = skipComments;
+        this.delimiters = delimiters;
+        currentPos = nextPos = peekPos = 0;
+        maxPos = string.length();
+    }
+
+    /**
+     * Constructor. Comments are ignored and not returned as tokens
+     *
+     * @param   header  The header that is tokenized
+     * @param   delimiters  The delimiters to be used
+     */
+    HeaderTokenizer(String header, String delimiters) {
+            this(header, delimiters, true);
+    }
+
+    /**
+     * Constructor. The RFC822 defined delimiters - RFC822 - are
+     * used to delimit ATOMS. Also comments are skipped and not
+     * returned as tokens
+     */
+    HeaderTokenizer(String header)  {
+            this(header, RFC822);
+    }
+
+    /**
+     * Parses the next token from this String. <p>
+     *
+     * Clients sit in a loop calling next() to parse successive
+     * tokens until an EOF Token is returned.
+     *
+     * @return          the next Token
+     * @exception WebServiceException if the parse fails
+     */
+    Token next() throws WebServiceException {
+        Token tk;
+
+        currentPos = nextPos; // setup currentPos
+        tk = getNext();
+        nextPos = peekPos = currentPos; // update currentPos and peekPos
+        return tk;
+    }
+
+    /**
+     * Peek at the next token, without actually removing the token
+     * from the parse stream. Invoking this method multiple times
+     * will return successive tokens, until <code>next()</code> is
+     * called. <p>
+     *
+     * @return          the next Token
+     * @exception       WebServiceException if the parse fails
+     */
+    Token peek() throws WebServiceException {
+        Token tk;
+
+        currentPos = peekPos; // setup currentPos
+        tk = getNext();
+        peekPos = currentPos; // update peekPos
+        return tk;
+    }
+
+    /**
+     * Return the rest of the Header.
+     *
+     * @return String   rest of header. null is returned if we are
+     *                  already at end of header
+     */
+    String getRemainder() {
+            return string.substring(nextPos);
+    }
+
+    /*
+     * Return the next token starting from 'currentPos'. After the
+     * parse, 'currentPos' is updated to point to the start of the
+     * next token.
+     */
+    private Token getNext() throws WebServiceException {
+        // If we're already at end of string, return EOF
+        if (currentPos >= maxPos)
+            return EOFToken;
+
+        // Skip white-space, position currentPos beyond the space
+        if (skipWhiteSpace() == Token.EOF)
+            return EOFToken;
+
+        char c;
+        int start;
+        boolean filter = false;
+
+        c = string.charAt(currentPos);
+
+        // Check or Skip comments and position currentPos
+        // beyond the comment
+        while (c == '(') {
+            // Parsing comment ..
+            int nesting;
+            for (start = ++currentPos, nesting = 1;
+             nesting > 0 && currentPos < maxPos;
+             currentPos++) {
+            c = string.charAt(currentPos);
+            if (c == '\\') {  // Escape sequence
+                currentPos++; // skip the escaped character
+                filter = true;
+            } else if (c == '\r')
+                filter = true;
+            else if (c == '(')
+                nesting++;
+            else if (c == ')')
+                nesting--;
+            }
+            if (nesting != 0)
+            throw new WebServiceException("Unbalanced comments");
+
+            if (!skipComments) {
+            // Return the comment, if we are asked to.
+            // Note that the comment start & end markers are ignored.
+            String s;
+            if (filter) // need to go thru the token again.
+                s = filterToken(string, start, currentPos-1);
+            else
+                s = string.substring(start,currentPos-1);
+
+            return new Token(Token.COMMENT, s);
+            }
+
+            // Skip any whitespace after the comment.
+            if (skipWhiteSpace() == Token.EOF)
+            return EOFToken;
+            c = string.charAt(currentPos);
+        }
+
+        // Check for quoted-string and position currentPos
+        //  beyond the terminating quote
+        if (c == '"') {
+            for (start = ++currentPos; currentPos < maxPos; currentPos++) {
+            c = string.charAt(currentPos);
+            if (c == '\\') { // Escape sequence
+                currentPos++;
+                filter = true;
+            } else if (c == '\r')
+                filter = true;
+            else if (c == '"') {
+                currentPos++;
+                String s;
+
+                if (filter)
+                s = filterToken(string, start, currentPos-1);
+                else
+                s = string.substring(start,currentPos-1);
+
+                return new Token(Token.QUOTEDSTRING, s);
+            }
+            }
+            throw new WebServiceException("Unbalanced quoted string");
+        }
+
+        // Check for SPECIAL or CTL
+        if (c < 040 || c >= 0177 || delimiters.indexOf(c) >= 0) {
+            currentPos++; // re-position currentPos
+            char ch[] = new char[1];
+            ch[0] = c;
+            return new Token((int)c, new String(ch));
+        }
+
+        // Check for ATOM
+        for (start = currentPos; currentPos < maxPos; currentPos++) {
+            c = string.charAt(currentPos);
+            // ATOM is delimited by either SPACE, CTL, "(", <">
+            // or the specified SPECIALS
+            if (c < 040 || c >= 0177 || c == '(' || c == ' ' ||
+            c == '"' || delimiters.indexOf(c) >= 0)
+            break;
+        }
+        return new Token(Token.ATOM, string.substring(start, currentPos));
+        }
+
+        // Skip SPACE, HT, CR and NL
+        private int skipWhiteSpace() {
+        char c;
+        for (; currentPos < maxPos; currentPos++)
+            if (((c = string.charAt(currentPos)) != ' ') &&
+            (c != '\t') && (c != '\r') && (c != '\n'))
+            return currentPos;
+        return Token.EOF;
+    }
+
+    /* Process escape sequences and embedded LWSPs from a comment or
+     * quoted string.
+     */
+    private static String filterToken(String s, int start, int end) {
+        StringBuffer sb = new StringBuffer();
+        char c;
+        boolean gotEscape = false;
+        boolean gotCR = false;
+
+        for (int i = start; i < end; i++) {
+            c = s.charAt(i);
+            if (c == '\n' && gotCR) {
+            // This LF is part of an unescaped
+            // CRLF sequence (i.e, LWSP). Skip it.
+            gotCR = false;
+            continue;
+            }
+
+            gotCR = false;
+            if (!gotEscape) {
+            // Previous character was NOT '\'
+            if (c == '\\') // skip this character
+                gotEscape = true;
+            else if (c == '\r') // skip this character
+                gotCR = true;
+            else // append this character
+                sb.append(c);
+            } else {
+            // Previous character was '\'. So no need to
+            // bother with any special processing, just
+            // append this character
+            sb.append(c);
+            gotEscape = false;
+            }
+        }
+        return sb.toString();
+    }
+}
--- /dev/null	Tue Aug  4 10:19:05 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/ImageDataContentHandler.java	Tue Aug  4 10:19:05 2009
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+
+package com.sun.xml.internal.ws.encoding;
+
+import javax.activation.DataContentHandler;
+import javax.activation.ActivationDataFlavor;
+import javax.activation.DataSource;
+import javax.imageio.ImageIO;
+import javax.imageio.ImageWriter;
+import javax.imageio.stream.ImageOutputStream;
+import java.awt.*;
+import java.awt.image.BufferedImage;
+import java.awt.datatransfer.DataFlavor;
+import java.util.logging.Logger;
+import java.util.Iterator;
+import java.io.IOException;
+import java.io.BufferedInputStream;
+import java.io.OutputStream;
+
+/**
+ * @author Jitendra Kotamraju
+ */
+
+public class ImageDataContentHandler extends Component
+    implements DataContentHandler {
+
+    private static final Logger log = Logger.getLogger(ImageDataContentHandler.class.getName());
+    private final DataFlavor[] flavor;
+
+    public ImageDataContentHandler() {
+        String[] mimeTypes = ImageIO.getReaderMIMETypes();
+        flavor = new DataFlavor[mimeTypes.length];
+        for(int i=0; i < mimeTypes.length; i++) {
+            flavor[i] = new ActivationDataFlavor(Image.class, mimeTypes[i], "Image");
+        }
+    }
+
+    /**
+     * Returns an array of DataFlavor objects indicating the flavors the
+     * data can be provided in. The array should be ordered according to
+     * preference for providing the data (from most richly descriptive to
+     * least descriptive).
+     *
+     * @return The DataFlavors.
+     */
+    public DataFlavor[] getTransferDataFlavors() {
+        return flavor;
+    }
+
+    /**
+     * Returns an object which represents the data to be transferred.
+     * The class of the object returned is defined by the representation class
+     * of the flavor.
+     *
+     * @param df The DataFlavor representing the requested type.
+     * @param ds The DataSource representing the data to be converted.
+     * @return The constructed Object.
+     */
+    public Object getTransferData(DataFlavor df, DataSource ds)
+        throws IOException {
+        for (DataFlavor aFlavor : flavor) {
+            if (aFlavor.equals(df)) {
+                return getContent(ds);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Return an object representing the data in its most preferred form.
+     * Generally this will be the form described by the first DataFlavor
+     * returned by the <code>getTransferDataFlavors</code> method.
+     *
+     * @param ds The DataSource representing the data to be converted.
+     * @return The constructed Object.
+     */
+    public Object getContent(DataSource ds) throws IOException {
+        return ImageIO.read(new BufferedInputStream(ds.getInputStream()));
+    }
+
+    /**
+     * Convert the object to a byte stream of the specified MIME type
+     * and write it to the output stream.
+     *
+     * @param obj   The object to be converted.
+     * @param type  The requested MIME type of the resulting byte stream.
+     * @param os    The output stream into which to write the converted
+     *          byte stream.
+     */
+
+    public void writeTo(Object obj, String type, OutputStream os)
+        throws IOException {
+
+        try {
+            BufferedImage bufImage;
+            if (obj instanceof BufferedImage) {
+                bufImage = (BufferedImage)obj;
+            } else if (obj instanceof Image) {
+                bufImage = render((Image)obj);
+            } else {
+                throw new IOException(
+                    "ImageDataContentHandler requires Image object, "
+                    + "was given object of type "
+                    + obj.getClass().toString());
+            }
+            ImageWriter writer = null;
+            Iterator<ImageWriter> i = ImageIO.getImageWritersByMIMEType(type);
+            if (i.hasNext()) {
+                writer = i.next();
+            }
+            if (writer != null) {
+                ImageOutputStream stream = ImageIO.createImageOutputStream(os);
+                writer.setOutput(stream);
+                writer.write(bufImage);
+                writer.dispose();
+                stream.close();
+            } else {
+                throw new IOException("Unsupported mime type:"+ type);
+            }
+        } catch (Exception e) {
+            throw new IOException("Unable to encode the image to a stream "
+                + e.getMessage());
+        }
+    }
+
+
+    private BufferedImage render(Image img) throws InterruptedException {
+
+        MediaTracker tracker = new MediaTracker(this);
+        tracker.addImage(img, 0);
+        tracker.waitForAll();
+        BufferedImage bufImage = new BufferedImage(img.getWidth(null),
+            img.getHeight(null), BufferedImage.TYPE_INT_RGB);
+        Graphics g = bufImage.createGraphics();
+        g.drawImage(img, 0, 0, null);
+        g.dispose();
+        return bufImage;
+    }
+
+}
--- /dev/null	Tue Aug  4 10:19:07 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/MIMEPartStreamingDataHandler.java	Tue Aug  4 10:19:07 2009
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.encoding;
+
+import com.sun.xml.internal.org.jvnet.mimepull.MIMEPart;
+
+import javax.activation.DataSource;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.File;
+
+import com.sun.xml.internal.ws.developer.StreamingDataHandler;
+
+/**
+ * Implementation of {@link StreamingDataHandler} to access MIME
+ * attachments efficiently. Applications can use the additional methods and decide
+ * on how to access the attachment data in JAX-WS applications.
+ *
+ * <p>
+ * for e.g.:
+ *
+ * DataHandler dh = proxy.getData();
+ * StreamingDataHandler sdh = (StreamingDataHandler)dh;
+ * // readOnce() doesn't store attachment on the disk in some cases
+ * // for e.g when only one huge attachment after soap envelope part in MIME message
+ * InputStream in = sdh.readOnce();
+ * ...
+ * in.close();
+ * sdh.close();
+ *
+ * @author Jitendra Kotamraju
+ */
+public class MIMEPartStreamingDataHandler extends StreamingDataHandler {
+    private final StreamingDataSource ds;
+
+    public MIMEPartStreamingDataHandler(MIMEPart part) {
+        super(new StreamingDataSource(part));
+        ds = (StreamingDataSource)getDataSource();
+    }
+
+    public InputStream readOnce() throws IOException {
+        return ds.readOnce();
+    }
+
+    public void moveTo(File file) throws IOException {
+        ds.moveTo(file);
+    }
+
+    public void close() throws IOException {
+        ds.close();
+    }
+
+    private static final class StreamingDataSource implements DataSource {
+        private final MIMEPart part;
+
+        StreamingDataSource(MIMEPart part) {
+            this.part = part;
+        }
+
+        public InputStream getInputStream() throws IOException {
+            return part.read();             //readOnce() ??
+        }
+
+        InputStream readOnce() throws IOException {
+            try {
+                return part.readOnce();
+            } catch(Exception e) {
+                throw new MyIOException(e);
+            }
+        }
+
+        void moveTo(File file) throws IOException {
+            part.moveTo(file);
+        }
+
+        public OutputStream getOutputStream() throws IOException {
+            return null;
+        }
+
+        public String getContentType() {
+            return part.getContentType();
+        }
+
+        public String getName() {
+            return "";
+        }
+
+        public void close() throws IOException {
+            part.close();
+        }
+    }
+
+    private static final class MyIOException extends IOException {
+        private final Exception linkedException;
+
+        MyIOException(Exception linkedException) {
+            this.linkedException = linkedException;
+        }
+
+        @Override
+        public Throwable getCause() {
+            return linkedException;
+        }
+    }
+
+}
--- /dev/null	Tue Aug  4 10:19:09 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/ParameterList.java	Tue Aug  4 10:19:09 2009
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.encoding;
+
+
+
+
+/*
+ * @(#)ParameterList.java     1.10 03/02/12
+ */
+
+
+import javax.xml.ws.WebServiceException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+/**
+ * This class holds MIME parameters (attribute-value pairs).
+ *
+ * @version 1.10, 03/02/12
+ * @author  John Mani
+ */
+
+final class ParameterList {
+
+    private final Map<String, String> list;
+
+    /**
+     * Constructor that takes a parameter-list string. The String
+     * is parsed and the parameters are collected and stored internally.
+     * A ParseException is thrown if the parse fails.
+     * Note that an empty parameter-list string is valid and will be
+     * parsed into an empty ParameterList.
+     *
+     * @param   s       the parameter-list string.
+     * @exception WebServiceException if the parse fails.
+     */
+    ParameterList(String s) {
+        HeaderTokenizer h = new HeaderTokenizer(s, HeaderTokenizer.MIME);
+        HeaderTokenizer.Token tk;
+        int type;
+        String name;
+
+        list = new HashMap<String, String>();
+        while (true) {
+            tk = h.next();
+            type = tk.getType();
+
+            if (type == HeaderTokenizer.Token.EOF) // done
+            return;
+
+            if ((char)type == ';') {
+                // expect parameter name
+                tk = h.next();
+                // tolerate trailing semicolon, even though it violates the spec
+                if (tk.getType() == HeaderTokenizer.Token.EOF)
+                    return;
+                // parameter name must be a MIME Atom
+                if (tk.getType() != HeaderTokenizer.Token.ATOM)
+                    throw new WebServiceException();
+                name = tk.getValue().toLowerCase();
+
+                // expect '='
+                tk = h.next();
+                if ((char)tk.getType() != '=')
+                    throw new WebServiceException();
+
+                // expect parameter value
+                tk = h.next();
+                type = tk.getType();
+                // parameter value must be a MIME Atom or Quoted String
+                if (type != HeaderTokenizer.Token.ATOM &&
+                    type != HeaderTokenizer.Token.QUOTEDSTRING)
+                    throw new WebServiceException();
+
+                list.put(name, tk.getValue());
+            } else
+                throw new WebServiceException();
+        }
+    }
+
+    /**
+     * Return the number of parameters in this list.
+     *
+     * @return  number of parameters.
+     */
+    int size() {
+            return list.size();
+    }
+
+    /**
+     * Returns the value of the specified parameter. Note that
+     * parameter names are case-insensitive.
+     *
+     * @param name      parameter name.
+     * @return          Value of the parameter. Returns
+     *                  <code>null</code> if the parameter is not
+     *                  present.
+     */
+    String get(String name) {
+            return list.get(name.trim().toLowerCase());
+    }
+
+
+    /**
+     * Return an enumeration of the names of all parameters in this
+     * list.
+     *
+     * @return Enumeration of all parameter names in this list.
+     */
+    Iterator<String> getNames() {
+            return list.keySet().iterator();
+    }
+
+}
--- /dev/null	Tue Aug  4 10:19:11 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/RootOnlyCodec.java	Tue Aug  4 10:19:11 2009
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.encoding;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.xml.internal.ws.api.message.AttachmentSet;
+import com.sun.xml.internal.ws.api.message.Message;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.pipe.Codec;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.channels.ReadableByteChannel;
+
+/**
+ * {@link Codec} that works only on the root part of the MIME/multipart.
+ * It doesn't work on the attachment parts, so it takes {@link AttachmentSet}
+ * as an argument and creates a corresponding {@link Message}. This enables
+ * attachments to be parsed lazily by wrapping the mimepull parser into an
+ * {@link AttachmentSet}
+ *
+ * @author Jitendra Kotamraju
+ */
+public interface RootOnlyCodec extends Codec {
+
+    /**
+     * Reads root part bytes from {@link InputStream} and constructs a {@link Message}
+     * along with the given attachments.
+     *
+     * @param in root part's data
+     *
+     * @param contentType root part's MIME content type (like "application/xml")
+     *
+     * @param packet the new created {@link Message} is set in this packet
+     *
+     * @param att attachments
+     *
+     * @throws IOException
+     *      if {@link InputStream} throws an exception.
+     */
+    void decode(@NotNull InputStream in, @NotNull String contentType, @NotNull Packet packet, @NotNull AttachmentSet att)
+            throws IOException;
+
+    /**
+     *
+     * @see #decode(InputStream, String, Packet, AttachmentSet)
+     */
+    void decode(@NotNull ReadableByteChannel in, @NotNull String contentType, @NotNull Packet packet, @NotNull AttachmentSet att);
+}
--- /dev/null	Tue Aug  4 10:19:13 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/StringDataContentHandler.java	Tue Aug  4 10:19:13 2009
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.encoding;
+
+import javax.activation.ActivationDataFlavor;
+import javax.activation.DataSource;
+import javax.activation.DataContentHandler;
+import java.awt.datatransfer.DataFlavor;
+import java.io.*;
+
+/**
+ * JAF data content handler for text/plain --> String
+ *
+ * @author Anil Vijendran
+ */
+public class StringDataContentHandler implements DataContentHandler {
+
+    /**
+     * return the DataFlavors for this <code>DataContentHandler</code>
+     * @return The DataFlavors.
+     */
+    public DataFlavor[] getTransferDataFlavors() { // throws Exception;
+        DataFlavor flavors[] = new DataFlavor[2];
+        flavors[0] =  new ActivationDataFlavor(String.class, "text/plain", "text string");
+        flavors[1] = new DataFlavor("text/plain", "Plain Text");
+        return flavors;
+    }
+
+    /**
+     * return the Transfer Data of type DataFlavor from InputStream
+     * @param df The DataFlavor.
+     * @param ds The InputStream corresponding to the data.
+     * @return The constructed Object.
+     */
+    public Object getTransferData(DataFlavor df, DataSource ds) {
+
+        // this is sort of hacky, but will work for the
+        // sake of testing...
+        if (df.getMimeType().startsWith("text/plain")) {
+            if (df
+                .getRepresentationClass()
+                .getName()
+                .equals("java.lang.String")) {
+                // spit out String
+                StringBuffer buf = new StringBuffer();
+                char data[] = new char[1024];
+                // InputStream is = null;
+                InputStreamReader isr = null;
+                int bytes_read = 0;
+                int total_bytes = 0;
+
+                try {
+                    isr = new InputStreamReader(ds.getInputStream());
+
+                    while (true) {
+                        bytes_read = isr.read(data);
+                        if (bytes_read > 0)
+                            buf.append(data, 0, bytes_read);
+                        else
+                            break;
+                        total_bytes += bytes_read;
+                    }
+                } catch (Exception e) {
+                }
+
+                return buf.toString();
+
+            } else if (
+                df.getRepresentationClass().getName().equals(
+                    "java.io.InputStream")) {
+                // spit out InputStream
+                try {
+                    return ds.getInputStream();
+                } catch (Exception e) {
+                }
+            }
+
+        }
+        return null;
+    }
+
+    /**
+     *
+     */
+    public Object getContent(DataSource ds) { // throws Exception;
+        StringBuffer buf = new StringBuffer();
+        char data[] = new char[1024];
+        // InputStream is = null;
+        InputStreamReader isr = null;
+        int bytes_read = 0;
+        int total_bytes = 0;
+
+        try {
+            isr = new InputStreamReader(ds.getInputStream());
+
+            while (true) {
+                bytes_read = isr.read(data);
+                if (bytes_read > 0)
+                    buf.append(data, 0, bytes_read);
+                else
+                    break;
+                total_bytes += bytes_read;
+            }
+        } catch (Exception e) {
+        }
+
+        return buf.toString();
+    }
+    /**
+     * construct an object from a byte stream
+     * (similar semantically to previous method, we are deciding
+     *  which one to support)
+     */
+    public void writeTo(Object obj, String mimeType, OutputStream os)
+        throws IOException {
+        if (!mimeType.startsWith("text/plain"))
+            throw new IOException(
+                "Invalid type \"" + mimeType + "\" on StringDCH");
+
+        Writer out = new OutputStreamWriter(os);
+        out.write((String) obj);
+        out.flush();
+    }
+
+}
--- /dev/null	Tue Aug  4 10:19:15 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/encoding/XmlDataContentHandler.java	Tue Aug  4 10:19:15 2009
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.encoding;
+
+import com.sun.xml.internal.ws.util.xml.XmlUtil;
+
+import javax.activation.ActivationDataFlavor;
+import javax.activation.DataContentHandler;
+import javax.activation.DataSource;
+import javax.xml.transform.Source;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.stream.StreamResult;
+import javax.xml.transform.stream.StreamSource;
+import java.awt.datatransfer.DataFlavor;
+import java.io.IOException;
+import java.io.OutputStream;
+
+
+/**
+ * JAF data handler for XML content
+ *
+ * @author Anil Vijendran
+ */
+public class XmlDataContentHandler implements DataContentHandler {
+
+    private final DataFlavor[] flavors;
+
+    public XmlDataContentHandler() throws ClassNotFoundException {
+        flavors = new DataFlavor[2];
+        flavors[0] = new ActivationDataFlavor(StreamSource.class, "text/xml", "XML");
+        flavors[1] = new ActivationDataFlavor(StreamSource.class, "application/xml", "XML");
+    }
+
+    /**
+     * return the DataFlavors for this <code>DataContentHandler</code>
+     * @return The DataFlavors.
+     */
+    public DataFlavor[] getTransferDataFlavors() { // throws Exception;
+        return flavors;
+    }
+
+    /**
+     * return the Transfer Data of type DataFlavor from InputStream
+     * @param df The DataFlavor.
+     * @param ds The InputStream corresponding to the data.
+     * @return The constructed Object.
+     */
+    public Object getTransferData(DataFlavor df, DataSource ds)
+        throws IOException {
+
+        for (DataFlavor aFlavor : flavors) {
+            if (aFlavor.equals(df)) {
+                return getContent(ds);
+            }
+        }
+        return null;
+    }
+
+    /**
+     *
+     */
+    public Object getContent(DataSource dataSource) throws IOException {
+        return new StreamSource(dataSource.getInputStream());
+    }
+
+    /**
+     * construct an object from a byte stream
+     * (similar semantically to previous method, we are deciding
+     *  which one to support)
+     */
+    public void writeTo(Object obj, String mimeType, OutputStream os)
+        throws IOException {
+        if (!mimeType.equals("text/xml") && !mimeType.equals("application/xml"))
+            throw new IOException(
+                "Invalid content type \"" + mimeType + "\" for XmlDCH");
+
+        try {
+            Transformer transformer = XmlUtil.newTransformer();
+            StreamResult result = new StreamResult(os);
+            if (obj instanceof DataSource) {
+                // Streaming transform applies only to javax.xml.transform.StreamSource
+                transformer.transform((Source) getContent((DataSource)obj), result);
+            } else {
+                transformer.transform((Source) obj, result);
+            }
+        } catch (Exception ex) {
+            throw new IOException(
+                "Unable to run the JAXP transformer on a stream "
+                    + ex.getMessage());
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:19:17 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/handler/ClientMessageHandlerTube.java	Tue Aug  4 10:19:17 2009
@@ -0,0 +1,150 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.handler;
+
+import com.sun.istack.internal.Nullable;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.handler.MessageHandler;
+import com.sun.xml.internal.ws.api.message.Attachment;
+import com.sun.xml.internal.ws.api.message.AttachmentSet;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.model.SEIModel;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
+import com.sun.xml.internal.ws.api.pipe.Tube;
+import com.sun.xml.internal.ws.api.pipe.TubeCloner;
+import com.sun.xml.internal.ws.api.pipe.helper.AbstractFilterTubeImpl;
+import com.sun.xml.internal.ws.binding.BindingImpl;
+import com.sun.xml.internal.ws.client.HandlerConfiguration;
+import com.sun.xml.internal.ws.message.DataHandlerAttachment;
+
+import javax.activation.DataHandler;
+import javax.xml.ws.WebServiceException;
+import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.Handler;
+import java.util.*;
+
+/**
+ * @author Rama Pulavarthi
+ */
+public class ClientMessageHandlerTube extends HandlerTube {
+    private SEIModel seiModel;
+    private WSBinding binding;
+    private Set<String> roles;
+
+    /**
+     * Creates a new instance of MessageHandlerTube
+     */
+    public ClientMessageHandlerTube(@Nullable SEIModel seiModel, WSBinding binding, WSDLPort port, Tube next) {
+        super(next, port);
+        this.seiModel = seiModel;
+        this.binding = binding;
+    }
+
+    /**
+     * Copy constructor for {@link com.sun.xml.internal.ws.api.pipe.Tube#copy(com.sun.xml.internal.ws.api.pipe.TubeCloner)}.
+     */
+    private ClientMessageHandlerTube(ClientMessageHandlerTube that, TubeCloner cloner) {
+        super(that, cloner);
+        this.seiModel = that.seiModel;
+        this.binding = that.binding;
+    }
+
+    public AbstractFilterTubeImpl copy(TubeCloner cloner) {
+        return new ClientMessageHandlerTube(this, cloner);
+    }
+
+    void callHandlersOnResponse(MessageUpdatableContext context, boolean handleFault) {
+        try {
+            //CLIENT-SIDE
+            processor.callHandlersResponse(HandlerProcessor.Direction.INBOUND, context, handleFault);
+
+        } catch (WebServiceException wse) {
+            //no rewrapping
+            throw wse;
+        } catch (RuntimeException re) {
+            throw new WebServiceException(re);
+        }
+    }
+
+    boolean callHandlersOnRequest(MessageUpdatableContext context, boolean isOneWay) {
+        boolean handlerResult;
+
+        //Lets copy all the MessageContext.OUTBOUND_ATTACHMENT_PROPERTY to the message
+        Map<String, DataHandler> atts = (Map<String, DataHandler>) context.get(MessageContext.OUTBOUND_MESSAGE_ATTACHMENTS);
+        AttachmentSet attSet = packet.getMessage().getAttachments();
+        for(String cid : atts.keySet()){
+            if (attSet.get(cid) == null) {  // Otherwise we would be adding attachments twice
+                Attachment att = new DataHandlerAttachment(cid, atts.get(cid));
+                attSet.add(att);
+            }
+        }
+
+        try {
+            //CLIENT-SIDE
+            handlerResult = processor.callHandlersRequest(HandlerProcessor.Direction.OUTBOUND, context, !isOneWay);
+        } catch (WebServiceException wse) {
+            remedyActionTaken = true;
+            //no rewrapping
+            throw wse;
+        } catch (RuntimeException re) {
+            remedyActionTaken = true;
+
+            throw new WebServiceException(re);
+
+        }
+        if (!handlerResult) {
+            remedyActionTaken = true;
+        }
+        return handlerResult;
+    }
+
+    void closeHandlers(MessageContext mc) {
+        closeClientsideHandlers(mc);
+
+    }
+
+    void setUpProcessor() {
+       // Take a snapshot, User may change chain after invocation, Same chain
+        // should be used for the entire MEP
+        handlers = new ArrayList<Handler>();
+        HandlerConfiguration handlerConfig = ((BindingImpl) binding).getHandlerConfig();
+        List<MessageHandler> msgHandlersSnapShot= handlerConfig.getMessageHandlers();
+        if (!msgHandlersSnapShot.isEmpty()) {
+            handlers.addAll(msgHandlersSnapShot);
+            roles = new HashSet<String>();
+            roles.addAll(handlerConfig.getRoles());
+            processor = new SOAPHandlerProcessor(true, this, binding, handlers);
+        }
+    }
+
+
+
+    MessageUpdatableContext getContext(Packet p) {
+        MessageHandlerContextImpl context = new MessageHandlerContextImpl(seiModel, binding, port, packet,roles);
+        return context;
+    }
+
+
+}
--- /dev/null	Tue Aug  4 10:19:19 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/handler/MessageHandlerContextImpl.java	Tue Aug  4 10:19:19 2009
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.handler;
+
+import com.sun.istack.internal.Nullable;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.handler.MessageHandlerContext;
+import com.sun.xml.internal.ws.api.message.Message;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.model.SEIModel;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLPort;
+
+import java.util.Set;
+
+/**
+ * @author Rama Pulavarthi
+ */
+public class MessageHandlerContextImpl extends MessageUpdatableContext implements MessageHandlerContext {
+    private @Nullable SEIModel seiModel;
+    private Set<String> roles;
+    private WSBinding binding;
+    private @Nullable WSDLPort wsdlModel;
+
+    public MessageHandlerContextImpl(@Nullable SEIModel seiModel, WSBinding binding, @Nullable WSDLPort wsdlModel, Packet packet, Set<String> roles) {
+        super(packet);
+        this.seiModel = seiModel;
+        this.binding = binding;
+        this.wsdlModel = wsdlModel;
+        this.roles = roles;
+    }
+    public Message getMessage() {
+        return packet.getMessage();
+    }
+
+    public void setMessage(Message message) {
+        packet.setMessage(message);
+    }
+
+    public Set<String> getRoles() {
+        return roles;
+    }
+
+    public WSBinding getWSBinding() {
+        return binding;
+    }
+
+    public @Nullable SEIModel getSEIModel() {
+        return seiModel;
+    }
+
+    public @Nullable WSDLPort getPort() {
+        return wsdlModel;
+    }
+
+    void updateMessage() {
+       // Do Nothing
+    }
+
+    void setPacketMessage(Message newMessage) {
+        setMessage(newMessage);
+    }
+}
--- /dev/null	Tue Aug  4 10:19:21 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/handler/ServerMessageHandlerTube.java	Tue Aug  4 10:19:21 2009
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.handler;
+
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.handler.MessageHandler;
+import com.sun.xml.internal.ws.api.message.Attachment;
+import com.sun.xml.internal.ws.api.message.AttachmentSet;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.model.SEIModel;
+import com.sun.xml.internal.ws.api.pipe.Tube;
+import com.sun.xml.internal.ws.api.pipe.TubeCloner;
+import com.sun.xml.internal.ws.api.pipe.helper.AbstractFilterTubeImpl;
+import com.sun.xml.internal.ws.binding.BindingImpl;
+import com.sun.xml.internal.ws.client.HandlerConfiguration;
+import com.sun.xml.internal.ws.message.DataHandlerAttachment;
+
+import javax.activation.DataHandler;
+import javax.xml.ws.WebServiceException;
+import javax.xml.ws.handler.MessageContext;
+import javax.xml.ws.handler.Handler;
+import java.util.*;
+
+/**
+ * @author Rama Pulavarthi
+ */
+public class ServerMessageHandlerTube extends HandlerTube{
+    private SEIModel seiModel;
+    private WSBinding binding;
+    private Set<String> roles;
+
+    public ServerMessageHandlerTube(SEIModel seiModel, WSBinding binding, Tube next, HandlerTube cousinTube) {
+        super(next, cousinTube);
+        this.seiModel = seiModel;
+        this.binding = binding;
+        setUpHandlersOnce();
+    }
+
+    /**
+     * Copy constructor for {@link com.sun.xml.internal.ws.api.pipe.Tube#copy(com.sun.xml.internal.ws.api.pipe.TubeCloner)}.
+     */
+    private ServerMessageHandlerTube(ServerMessageHandlerTube that, TubeCloner cloner) {
+        super(that, cloner);
+        this.seiModel = that.seiModel;
+        this.binding = that.binding;
+        this.handlers = that.handlers;
+        this.roles = that.roles;
+    }
+
+    private void setUpHandlersOnce() {
+        handlers = new ArrayList<Handler>();
+        HandlerConfiguration handlerConfig = ((BindingImpl) binding).getHandlerConfig();
+        List<MessageHandler> msgHandlersSnapShot= handlerConfig.getMessageHandlers();
+        if (!msgHandlersSnapShot.isEmpty()) {
+            handlers.addAll(msgHandlersSnapShot);
+            roles = new HashSet<String>();
+            roles.addAll(handlerConfig.getRoles());
+        }
+    }
+
+    void callHandlersOnResponse(MessageUpdatableContext context, boolean handleFault) {
+        //Lets copy all the MessageContext.OUTBOUND_ATTACHMENT_PROPERTY to the message
+        Map<String, DataHandler> atts = (Map<String, DataHandler>) context.get(MessageContext.OUTBOUND_MESSAGE_ATTACHMENTS);
+        AttachmentSet attSet = packet.getMessage().getAttachments();
+        for(String cid : atts.keySet()){
+            if (attSet.get(cid) == null) { // Otherwise we would be adding attachments twice
+                Attachment att = new DataHandlerAttachment(cid, atts.get(cid));
+                attSet.add(att);
+            }
+        }
+
+        try {
+            //SERVER-SIDE
+            processor.callHandlersResponse(HandlerProcessor.Direction.OUTBOUND, context, handleFault);
+
+        } catch (WebServiceException wse) {
+            //no rewrapping
+            throw wse;
+        } catch (RuntimeException re) {
+            throw re;
+
+        }
+    }
+
+    boolean callHandlersOnRequest(MessageUpdatableContext context, boolean isOneWay) {
+        boolean handlerResult;
+        try {
+            //SERVER-SIDE
+            handlerResult = processor.callHandlersRequest(HandlerProcessor.Direction.INBOUND, context, !isOneWay);
+
+        } catch (RuntimeException re) {
+            remedyActionTaken = true;
+            throw re;
+
+        }
+        if (!handlerResult) {
+            remedyActionTaken = true;
+        }
+        return handlerResult;
+    }
+
+    void setUpProcessor() {
+        if(!handlers.isEmpty()) {
+            processor = new SOAPHandlerProcessor(false, this, binding, handlers);
+        }
+    }
+
+    void closeHandlers(MessageContext mc) {
+        closeServersideHandlers(mc);
+
+    }
+    MessageUpdatableContext getContext(Packet packet) {
+       MessageHandlerContextImpl context = new MessageHandlerContextImpl(seiModel, binding, port, packet, roles);
+       return context;
+    }
+
+    //should be overridden by DriverHandlerTubes
+    @Override
+    protected void initiateClosing(MessageContext mc) {
+      close(mc);
+      super.initiateClosing(mc);
+    }
+
+   public AbstractFilterTubeImpl copy(TubeCloner cloner) {
+        return new ServerMessageHandlerTube(this, cloner);
+    }
+}
--- /dev/null	Tue Aug  4 10:19:23 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/message/FaultMessage.java	Tue Aug  4 10:19:23 2009
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.message;
+
+import com.sun.istack.internal.Nullable;
+import com.sun.xml.internal.ws.api.message.Message;
+import com.sun.xml.internal.ws.api.message.FilterMessageImpl;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLFault;
+
+import javax.xml.namespace.QName;
+
+/**
+ * SOAP Fault message. It has optimized implementation to get
+ * first detail entry's name. This is useful to identify the
+ * corresponding {@link WSDLFault}
+ *
+ * @author Jitendra Kotamraju
+ */
+public class FaultMessage extends FilterMessageImpl {
+
+    private final @Nullable QName detailEntryName;
+
+    public FaultMessage(Message delegate, @Nullable QName detailEntryName) {
+        super(delegate);
+        this.detailEntryName = detailEntryName;
+    }
+
+    @Override
+    public @Nullable QName getFirstDetailEntryName() {
+        return detailEntryName;
+    }
+
+}
--- /dev/null	Tue Aug  4 10:19:25 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/FieldSignature.java	Tue Aug  4 10:19:25 2009
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.model;
+
+import java.util.*;
+import java.util.logging.Logger;
+import java.lang.reflect.*;
+
+/**
+ * Creates vm signature string from Type
+ *
+ * TypeSignature: Z | C | B | S | I | F | J | D | FieldTypeSignature
+ * FieldTypeSignature: ClassTypeSignature | [ TypeSignature | TypeVar
+ * ClassTypeSignature: L Id ( / Id )* TypeArgs? ( . Id TypeArgs? )* ;
+ * TypeArgs: < TypeArg+ >
+ * TypeArg: * | ( + | - )? FieldTypeSignature
+ * TypeVar: T Id ;
+ *
+ * @author Jitendra Kotamraju
+ */
+public class FieldSignature {
+
+    static String vms(Type t) {
+        if (t instanceof Class || t instanceof ParameterizedType) {
+            return "L"+fqcn(t)+";";
+        } else if (t instanceof GenericArrayType) {
+            return "["+vms(((GenericArrayType)t).getGenericComponentType());
+        } else if (t instanceof TypeVariable) {
+            // While creating wrapper bean fields, it doesn't create with TypeVariables
+            // Otherwise, the type variable need to be declared in the wrapper bean class
+            // return "T"+((TypeVariable)t).getName()+";";
+            return "Ljava/lang/Object;";        // TODO bounds ??
+        } else if (t instanceof WildcardType) {
+            WildcardType w = (WildcardType)t;
+            if (w.getLowerBounds().length > 0) {
+                return "-"+vms(w.getLowerBounds()[0]);
+            } else if (w.getUpperBounds().length > 0) {
+                Type wt = w.getUpperBounds()[0];
+                if (wt.equals(Object.class)) {
+                    return "*";
+                } else {
+                    return "+"+vms(wt);
+                }
+            }
+        }
+        throw new IllegalArgumentException("Illegal vms arg " + t);
+    }
+
+    private static String fqcn(Type t) {
+        if (t instanceof Class) {
+            Class c = (Class)t;
+            if (c.getDeclaringClass() == null) {
+                return c.getName().replace('.', '/');
+            } else {
+                return fqcn(c.getDeclaringClass())+"."+c.getSimpleName();
+            }
+        } else if (t instanceof ParameterizedType) {
+            ParameterizedType p = (ParameterizedType)t;
+            if (p.getOwnerType() == null) {
+                return fqcn(p.getRawType())+args(p);
+            } else {
+                assert p.getRawType() instanceof Class;
+                return fqcn(p.getOwnerType())+"."+
+                        ((Class)p.getRawType()).getSimpleName()+args(p);
+            }
+        }
+        throw new IllegalArgumentException("Illegal fqcn arg = "+t);
+    }
+
+    private static String args(ParameterizedType p) {
+        String sig = "<";
+        for(Type t : p.getActualTypeArguments()) {
+            sig += vms(t);
+        }
+        return sig+">";
+    }
+
+}
--- /dev/null	Tue Aug  4 10:19:27 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/Injector.java	Tue Aug  4 10:19:27 2009
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.model;
+
+import com.sun.xml.internal.bind.Util;
+import com.sun.xml.internal.bind.v2.runtime.reflect.Accessor;
+
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Method;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Map;
+import java.util.Collections;
+import java.util.WeakHashMap;
+import java.util.HashMap;
+import java.util.logging.Logger;
+import java.util.logging.Level;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+
+/**
+ * A {@link ClassLoader} used to "inject" optimized accessor classes
+ * into the VM.
+ *
+ * <p>
+ * Its parent class loader needs to be set to the one that can see the user
+ * class.
+ *
+ * @author Kohsuke Kawaguchi
+ */
+final class Injector {
+
+    /**
+     * {@link Injector}s keyed by their parent {@link ClassLoader}.
+     *
+     * We only need one injector per one user class loader.
+     */
+    private static final Map<ClassLoader,WeakReference<Injector>> injectors =
+        Collections.synchronizedMap(new WeakHashMap<ClassLoader,WeakReference<Injector>>());
+
+    private static final Logger logger = Util.getClassLogger();
+
+    /**
+     * Injects a new class into the given class loader.
+     *
+     * @return null
+     *      if it fails to inject.
+     */
+    static Class inject( ClassLoader cl, String className, byte[] image ) {
+        Injector injector = get(cl);
+        if(injector!=null)
+            return injector.inject(className,image);
+        else
+            return null;
+    }
+
+    /**
+     * Returns the already injected class, or null.
+     */
+    static Class find( ClassLoader cl, String className ) {
+        Injector injector = get(cl);
+        if(injector!=null)
+            return injector.find(className);
+        else
+            return null;
+    }
+
+    /**
+     * Gets or creates an {@link Injector} for the given class loader.
+     *
+     * @return null
+     *      if it fails.
+     */
+    private static Injector get(ClassLoader cl) {
+        Injector injector = null;
+        WeakReference<Injector> wr = injectors.get(cl);
+        if(wr!=null)
+            injector = wr.get();
+        if(injector==null)
+            try {
+                injectors.put(cl,new WeakReference<Injector>(injector = new Injector(cl)));
+            } catch (SecurityException e) {
+                logger.log(Level.FINE,"Unable to set up a back-door for the injector",e);
+                return null;
+            }
+        return injector;
+    }
+
+    /**
+     * Injected classes keyed by their names.
+     */
+    private final Map<String,Class> classes = new HashMap<String,Class>();
+
+    private final ClassLoader parent;
+
+    /**
+     * True if this injector is capable of injecting accessors.
+     * False otherwise, which happens if this classloader can't see {@link com.sun.xml.internal.bind.v2.runtime.reflect.Accessor}.
+     */
+    private final boolean loadable;
+
+    private static final Method defineClass;
+    private static final Method resolveClass;
+
+    static {
+        try {
+            defineClass = ClassLoader.class.getDeclaredMethod("defineClass",String.class,byte[].class,Integer.TYPE,Integer.TYPE);
+            resolveClass = ClassLoader.class.getDeclaredMethod("resolveClass",Class.class);
+        } catch (NoSuchMethodException e) {
+            // impossible
+            throw new NoSuchMethodError(e.getMessage());
+        }
+        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+            public Void run() {
+                // TODO: check security implication
+                // do these setAccessible allow anyone to call these methods freely?s
+                defineClass.setAccessible(true);
+                resolveClass.setAccessible(true);
+                return null;
+            }
+        });
+    }
+
+    private Injector(ClassLoader parent) {
+        this.parent = parent;
+        assert parent!=null;
+
+        boolean loadable = false;
+
+        try {
+            loadable = parent.loadClass(Accessor.class.getName())==Accessor.class;
+        } catch (ClassNotFoundException e) {
+            ; // not loadable
+        }
+
+        this.loadable = loadable;
+    }
+
+
+    private synchronized Class inject(String className, byte[] image) {
+        if(!loadable)   // this injector cannot inject anything
+            return null;
+
+        Class c = classes.get(className);
+        if(c==null) {
+            // we need to inject a class into the
+            try {
+                c = (Class)defineClass.invoke(parent,className.replace('/','.'),image,0,image.length);
+                resolveClass.invoke(parent,c);
+            } catch (IllegalAccessException e) {
+                logger.log(Level.FINE,"Unable to inject "+className,e);
+                return null;
+            } catch (InvocationTargetException e) {
+                logger.log(Level.FINE,"Unable to inject "+className,e);
+                return null;
+            } catch (SecurityException e) {
+                logger.log(Level.FINE,"Unable to inject "+className,e);
+                return null;
+            } catch (LinkageError e) {
+                logger.log(Level.FINE,"Unable to inject "+className,e);
+                return null;
+            }
+            classes.put(className,c);
+        }
+        return c;
+    }
+
+    private synchronized Class find(String className) {
+        return classes.get(className);
+    }
+}
--- /dev/null	Tue Aug  4 10:19:29 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/WrapperBeanGenerator.java	Tue Aug  4 10:19:29 2009
@@ -0,0 +1,659 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.model;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.xml.internal.bind.api.JAXBRIContext;
+import com.sun.xml.internal.ws.util.StringUtils;
+import static com.sun.xml.internal.ws.org.objectweb.asm.Opcodes.*;
+import com.sun.xml.internal.ws.org.objectweb.asm.Type;
+import com.sun.xml.internal.ws.org.objectweb.asm.*;
+
+import javax.jws.WebParam;
+import javax.jws.WebResult;
+import javax.xml.bind.annotation.XmlAttachmentRef;
+import javax.xml.bind.annotation.XmlList;
+import javax.xml.bind.annotation.XmlMimeType;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+import javax.xml.ws.Holder;
+import javax.xml.ws.WebServiceException;
+import javax.xml.namespace.QName;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.*;
+import java.util.*;
+import java.util.logging.Logger;
+import java.util.logging.Level;
+
+/**
+ * Byte code generator for request,response wrapper and exception beans
+ *
+ * @author Jitendra Kotamraju
+ */
+public class WrapperBeanGenerator {
+
+    private static final Logger LOGGER = Logger.getLogger(WrapperBeanGenerator.class.getName());
+
+    public static final String PD                           = ".";
+    public static final String JAXWS                        = "jaxws";
+    public static final String JAXWS_PACKAGE_PD             = JAXWS+PD;
+    public static final String PD_JAXWS_PACKAGE_PD          = PD+JAXWS+PD;
+
+    // Creates class's bytes
+    private static byte[] createBeanImage(String className,
+                               String rootName, String rootNS,
+                               String typeName, String typeNS, String[] propOrder,
+                               List<Field> fields) throws Exception {
+
+        ClassWriter cw = new ClassWriter(0);
+        //org.objectweb.asm.util.TraceClassVisitor cw = new org.objectweb.asm.util.TraceClassVisitor(actual, new java.io.PrintWriter(System.out));
+
+        cw.visit(V1_5, ACC_PUBLIC + ACC_SUPER, replaceDotWithSlash(className), null, "java/lang/Object", null);
+
+        AnnotationVisitor root = cw.visitAnnotation("Ljavax/xml/bind/annotation/XmlRootElement;", true);
+        root.visit("name", rootName);
+        root.visit("namespace", rootNS);
+        root.visitEnd();
+
+        AnnotationVisitor type = cw.visitAnnotation("Ljavax/xml/bind/annotation/XmlType;", true);
+        type.visit("name", typeName);
+        type.visit("namespace", typeNS);
+        if (propOrder.length > 1) {
+            AnnotationVisitor propVisitor = type.visitArray("propOrder");
+            for(String prop : propOrder) {
+                propVisitor.visit("propOrder", prop);
+            }
+            propVisitor.visitEnd();
+        }
+        type.visitEnd();
+
+        for(Field field : fields) {
+            FieldVisitor fv = cw.visitField(ACC_PUBLIC, field.fieldName, field.asmType.getDescriptor(), field.getSignature(), null);
+
+            if (!field.noXmlElem) { // Exception fields do not have any @XmlElement
+                AnnotationVisitor elem = fv.visitAnnotation("Ljavax/xml/bind/annotation/XmlElement;", true);
+                elem.visit("name", field.elementName);
+                elem.visit("namespace", field.elementNS);
+                if (field.reflectType instanceof GenericArrayType) {
+                    elem.visit("nillable", true);
+                }
+                elem.visitEnd();
+            }
+
+            for(Annotation ann : field.jaxbAnnotations) {
+                if (ann instanceof XmlMimeType) {
+                    AnnotationVisitor mime = fv.visitAnnotation("Ljavax/xml/bind/annotation/XmlMimeType;", true);
+                    mime.visit("value", ((XmlMimeType)ann).value());
+                    mime.visitEnd();
+                } else if (ann instanceof XmlJavaTypeAdapter) {
+                    AnnotationVisitor ada = fv.visitAnnotation("Ljavax/xml/bind/annotation/XmlJavaTypeAdapter;", true);
+                    ada.visit("value", ((XmlJavaTypeAdapter)ann).value());
+                    ada.visit("type", ((XmlJavaTypeAdapter)ann).type());
+                    ada.visitEnd();
+                } else if (ann instanceof XmlAttachmentRef) {
+                    AnnotationVisitor att = fv.visitAnnotation("Ljavax/xml/bind/annotation/XmlAttachmentRef;", true);
+                    att.visitEnd();
+                } else if (ann instanceof XmlList) {
+                    AnnotationVisitor list = fv.visitAnnotation("Ljavax/xml/bind/annotation/XmlList;", true);
+                    list.visitEnd();
+                } else {
+                    throw new WebServiceException("Unknown JAXB annotation " + ann);
+                }
+            }
+
+            fv.visitEnd();
+        }
+
+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
+        mv.visitCode();
+        mv.visitVarInsn(ALOAD, 0);
+        mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V");
+        mv.visitInsn(RETURN);
+        mv.visitMaxs(1, 1);
+        mv.visitEnd();
+
+        cw.visitEnd();
+
+        if (LOGGER.isLoggable(Level.INFO)) {
+            // Class's @XmlRootElement
+            StringBuilder sb = new StringBuilder();
+            sb.append("\n");
+            sb.append("@XmlRootElement(name=");
+            sb.append(rootName);
+            sb.append(", namespace=");
+            sb.append(rootNS);
+            sb.append(")");
+
+            // Class's @XmlType
+            sb.append("\n");
+            sb.append("@XmlType(name=");
+            sb.append(typeName);
+            sb.append(", namespace=");
+            sb.append(typeNS);
+            if (propOrder.length > 1) {
+                sb.append(", propOrder={");
+                for(int i=0; i < propOrder.length; i++) {
+                    if (i != 0) {
+                        sb.append(", ");
+                    }
+                    sb.append(propOrder[i]);
+                }
+                sb.append("}");
+            }
+            sb.append(")");
+
+            // class declaration
+            sb.append("\n");
+            sb.append("public class ");
+            sb.append(className);
+            sb.append(" {");
+
+            // fields declaration
+            for(Field field : fields) {
+                sb.append("\n");
+
+                // Field's @XmlRootElement decl
+                if (!field.noXmlElem) {
+                    sb.append("\n    ");
+                    sb.append("@XmlRootElement(name=");
+                    sb.append(field.elementName);
+                    sb.append(", namespace=");
+                    sb.append(field.elementNS);
+                    if (field.reflectType instanceof GenericArrayType) {
+                        sb.append("nillable=true");
+                    }
+                    sb.append(")");
+                }
+
+                // Field's other JAXB annotations
+                for(Annotation ann : field.jaxbAnnotations) {
+                    sb.append("\n    ");
+
+                    if (ann instanceof XmlMimeType) {
+                        sb.append("@XmlMimeType(value=");
+                        sb.append(((XmlMimeType)ann).value());
+                        sb.append(")");
+                    } else if (ann instanceof XmlJavaTypeAdapter) {
+                        sb.append("@XmlJavaTypeAdapter(value=");
+                        sb.append(((XmlMimeType)ann).value());
+                        sb.append(", type=");
+                        sb.append(((XmlJavaTypeAdapter)ann).type());
+                        sb.append(")");
+                    } else if (ann instanceof XmlAttachmentRef) {
+                        sb.append("@XmlAttachmentRef");
+                    } else if (ann instanceof XmlList) {
+                        sb.append("@XmlList");
+                    } else {
+                        throw new WebServiceException("Unknown JAXB annotation " + ann);
+                    }
+                }
+
+                // Field declaration
+                sb.append("\n    ");
+                sb.append("public ");
+                if (field.getSignature() == null) {
+                    sb.append(field.asmType.getDescriptor());
+                } else {
+                    sb.append(field.getSignature());
+                }
+                sb.append(" ");
+                sb.append(field.fieldName);
+            }
+
+            sb.append("\n\n}");
+            LOGGER.fine(sb.toString());
+        }
+
+        return cw.toByteArray();
+    }
+
+    private static String replaceDotWithSlash(String name) {
+        return name.replace('.', '/');
+    }
+
+    static Class createRequestWrapperBean(String className, Method method, QName reqElemName, ClassLoader cl) {
+
+        LOGGER.fine("Request Wrapper Class : "+className);
+
+        List<Field> fields = collectRequestWrapperMembers(method);
+
+        String[] propOrder = getPropOrder(fields);
+
+        byte[] image;
+        try {
+            image = createBeanImage(className, reqElemName.getLocalPart(), reqElemName.getNamespaceURI(),
+                reqElemName.getLocalPart(), reqElemName.getNamespaceURI(), propOrder,
+                fields);
+        } catch(Exception e) {
+            throw new WebServiceException(e);
+        }
+
+        return Injector.inject(cl, className, image);
+    }
+
+    static Class createResponseWrapperBean(String className, Method method, QName resElemName, ClassLoader cl) {
+
+        LOGGER.fine("Response Wrapper Class : "+className);
+
+        List<Field> fields = collectResponseWrapperMembers(method);
+
+        String[] propOrder = getPropOrder(fields);
+
+        byte[] image;
+        try {
+            image = createBeanImage(className, resElemName.getLocalPart(), resElemName.getNamespaceURI(),
+                resElemName.getLocalPart(), resElemName.getNamespaceURI(), propOrder,
+                fields);
+        } catch(Exception e) {
+            throw new WebServiceException(e);
+        }
+
+        return Injector.inject(cl, className, image);
+    }
+
+    private static String[] getPropOrder(List<Field> fields) {
+        String[] propOrder = new String[fields.size()];
+        for(int i=0; i < fields.size(); i++) {
+            propOrder[i] = fields.get(i).fieldName;
+        }
+        return propOrder;
+    }
+
+    private static List<Field> collectRequestWrapperMembers(Method method) {
+
+        List<Field> fields = new ArrayList<Field>();
+        Annotation[][] paramAnns = method.getParameterAnnotations();
+        java.lang.reflect.Type[] paramTypes = method.getGenericParameterTypes();
+        Type[] asmTypes = Type.getArgumentTypes(method);
+        for(int i=0; i < paramTypes.length; i++) {
+            WebParam webParam = findAnnotation(paramAnns[i], WebParam.class);
+            if (webParam != null && webParam.header()) {
+                continue;
+            }
+            List<Annotation> jaxb = collectJAXBAnnotations(paramAnns[i]);
+
+            java.lang.reflect.Type paramType =  getHolderValueType(paramTypes[i]);
+            Type asmType = isHolder(paramTypes[i]) ? getASMType(paramType) : asmTypes[i];
+
+            String paramNamespace = "";
+            String paramName =  "arg"+i;
+            WebParam.Mode mode = WebParam.Mode.IN;
+            if (webParam != null) {
+                mode = webParam.mode();
+                if (webParam.name().length() > 0)
+                    paramName = webParam.name();
+                if (webParam.targetNamespace().length() > 0)
+                    paramNamespace = webParam.targetNamespace();
+            }
+
+            String fieldName = JAXBRIContext.mangleNameToVariableName(paramName);
+            //We wont have to do this if JAXBRIContext.mangleNameToVariableName() takes
+            //care of mangling java reserved keywords
+            fieldName = getJavaReservedVarialbeName(fieldName);
+
+            Field memInfo = new Field(fieldName, paramType, asmType, paramName, paramNamespace, jaxb);
+
+            if (mode.equals(WebParam.Mode.IN) || mode.equals(WebParam.Mode.INOUT)) {
+                fields.add(memInfo);
+            }
+
+        }
+        return fields;
+    }
+
+    private static List<Field> collectResponseWrapperMembers(Method method) {
+
+        List<Field> fields = new ArrayList<Field>();
+
+        // Collect all OUT, INOUT parameters as fields
+        Annotation[][] paramAnns = method.getParameterAnnotations();
+        java.lang.reflect.Type[] paramTypes = method.getGenericParameterTypes();
+        Type[] asmTypes = Type.getArgumentTypes(method);
+        for(int i=0; i < paramTypes.length; i++) {
+            WebParam webParam = findAnnotation(paramAnns[i], WebParam.class);
+            if (webParam != null) {
+                if (webParam.header() || webParam.mode() == WebParam.Mode.IN) {
+                    continue;
+                }
+            }
+            if (!isHolder(paramTypes[i])) {
+                continue;
+            }
+
+            List<Annotation> jaxb = collectJAXBAnnotations(paramAnns[i]);
+
+            java.lang.reflect.Type paramType = getHolderValueType(paramTypes[i]);
+            Type asmType = getASMType(paramType);
+
+            String paramNamespace = "";
+            String paramName =  "arg"+i;
+
+            if (webParam != null) {
+                if (webParam.name().length() > 0)
+                    paramName = webParam.name();
+                if (webParam.targetNamespace().length() > 0)
+                    paramNamespace = webParam.targetNamespace();
+            }
+
+            String fieldName = JAXBRIContext.mangleNameToVariableName(paramName);
+            //We wont have to do this if JAXBRIContext.mangleNameToVariableName() takes
+            //care of mangling java reserved keywords
+            fieldName = getJavaReservedVarialbeName(fieldName);
+
+            fields.add(new Field(fieldName, paramType, asmType, paramName, paramNamespace, jaxb));
+        }
+
+        WebResult webResult = method.getAnnotation(WebResult.class);
+        java.lang.reflect.Type returnType = method.getGenericReturnType();
+        Type asmType = Type.getReturnType(method);
+        if (!((webResult != null && webResult.header()) || returnType == Void.TYPE)) {
+            String fieldElementName = "return";
+            String fieldName = "_return";
+            String fieldNamespace = "";
+
+            if (webResult != null) {
+                if (webResult.name().length() > 0) {
+                    fieldElementName = webResult.name();
+                    fieldName = JAXBRIContext.mangleNameToVariableName(webResult.name());
+                    //We wont have to do this if JAXBRIContext.mangleNameToVariableName() takes
+                    //care of mangling java identifiers
+                    fieldName = getJavaReservedVarialbeName(fieldName);
+                }
+                if (webResult.targetNamespace().length() > 1) {
+                    fieldNamespace = webResult.targetNamespace();
+                }
+            }
+
+            List<Annotation> jaxb = collectJAXBAnnotations(method.getAnnotations());
+
+            fields.add(new Field(fieldName, returnType, asmType, fieldElementName, fieldNamespace, jaxb));
+        }
+        return fields;
+    }
+
+    private static boolean isHolder(java.lang.reflect.Type type) {
+        if (type instanceof ParameterizedType) {
+            ParameterizedType p = (ParameterizedType)type;
+            if (p.getRawType().equals(Holder.class)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static Type getASMType(java.lang.reflect.Type t) {
+        assert t!=null;
+
+        if (t instanceof Class) {
+            return Type.getType((Class)t);
+        }
+
+        if (t instanceof ParameterizedType) {
+            ParameterizedType pt = (ParameterizedType)t;
+            if (pt.getRawType() instanceof Class) {
+                return Type.getType((Class)pt.getRawType());
+            }
+        }
+        if (t instanceof GenericArrayType) {
+            // TODO
+        }
+
+        if (t instanceof WildcardType) {
+            // TODO
+        }
+        if (t instanceof TypeVariable) {
+            TypeVariable tv = (TypeVariable)t;
+            if (tv.getBounds()[0] instanceof Class) {
+                return Type.getType((Class)tv.getBounds()[0]);
+            }
+        }
+
+        // covered all the cases
+        assert false;
+        throw new IllegalArgumentException("Not creating ASM Type for type = "+t);
+    }
+
+    private static java.lang.reflect.Type getHolderValueType(java.lang.reflect.Type paramType) {
+        if (paramType instanceof ParameterizedType) {
+            ParameterizedType p = (ParameterizedType)paramType;
+            if (p.getRawType().equals(Holder.class)) {
+                return p.getActualTypeArguments()[0];
+            }
+        }
+        return paramType;
+    }
+
+    private static <T extends Annotation> T findAnnotation(Annotation[] anns, Class<T> annotationClass) {
+        for(Annotation a : anns) {
+            if (a.annotationType() == annotationClass) {
+                return (T)a;
+            }
+        }
+        return null;
+    }
+
+    static Class createExceptionBean(String className, Class exception, String typeNS, String elemName, String elemNS, ClassLoader cl) {
+
+        List<Field> fields = collectExceptionProperties(exception);
+        String[] propOrder = getPropOrder(fields);
+
+        byte[] image;
+        try {
+            image = createBeanImage(className, elemName, elemNS,
+                exception.getSimpleName(), typeNS, propOrder,
+                fields);
+        } catch(Exception e) {
+            throw new WebServiceException(e);
+        }
+
+        return Injector.inject(cl, className, image);
+    }
+
+    private static List<Field> collectExceptionProperties(Class exception) {
+        List<Field> fields = new ArrayList<Field>();
+
+        Method[] methods = exception.getMethods();
+        for (Method method : methods) {
+            int mod = method.getModifiers();
+            if (!Modifier.isPublic(mod)
+                || (Modifier.isFinal(mod) && Modifier.isStatic(mod))
+                || Modifier.isTransient(mod)) { // no final static, transient, non-public
+                continue;
+            }
+            String name = method.getName();
+            if (!(name.startsWith("get") || name.startsWith("is")) || skipProperties.contains(name) ||
+                name.equals("get") || name.equals("is")) {
+                // Don't bother with invalid propertyNames.
+                continue;
+            }
+
+            java.lang.reflect.Type[] paramTypes = method.getGenericParameterTypes();
+            java.lang.reflect.Type returnType = method.getGenericReturnType();
+            Type asmType = Type.getReturnType(method);
+            if (paramTypes.length == 0) {
+                if (name.startsWith("get")) {
+                    String fieldName = StringUtils.decapitalize(name.substring(3));
+                    Field field = new Field(fieldName, returnType, asmType, true, Collections.<Annotation>emptyList());
+                    fields.add(field);
+                } else {
+                    String fieldName = StringUtils.decapitalize(name.substring(2));
+                    Field field = new Field(fieldName, returnType, asmType, true, Collections.<Annotation>emptyList());
+                    fields.add(field);
+                }
+            }
+        }
+        Collections.sort(fields);
+        return fields;
+    }
+
+
+    private static List<Annotation> collectJAXBAnnotations(Annotation[] anns) {
+        Class[] known = { XmlAttachmentRef.class, XmlMimeType.class, XmlJavaTypeAdapter.class, XmlList.class };
+        List<Annotation> jaxbAnnotation = new ArrayList<Annotation>();
+        for(Class c : known) {
+            Annotation a = findAnnotation(anns, c);
+            if (a != null) {
+                jaxbAnnotation.add(a);
+            }
+        }
+        return jaxbAnnotation;
+    }
+
+
+    private List<Annotation> collectJAXBAnnotations(Method method) {
+        Class[] known = { XmlAttachmentRef.class, XmlMimeType.class, XmlJavaTypeAdapter.class, XmlList.class };
+        List<Annotation> jaxbAnnotation = new ArrayList<Annotation>();
+        for(Class c : known) {
+            Annotation ann = method.getAnnotation(c);
+            if(ann != null) {
+                jaxbAnnotation.add(ann);
+            }
+        }
+        return jaxbAnnotation;
+    }
+
+    private static class Field implements Comparable<Field> {
+        private final java.lang.reflect.Type reflectType;
+        private final Type asmType;
+        private final String fieldName;
+        private final String elementName;
+        private final String elementNS;
+        private final List<Annotation> jaxbAnnotations;
+        private final boolean noXmlElem;
+
+        Field(String paramName, java.lang.reflect.Type paramType, Type asmType, String elementName,
+              String elementNS, List<Annotation> jaxbAnnotations) {
+            this(paramName, paramType, asmType, false, elementName, elementNS, jaxbAnnotations);
+        }
+
+        Field(String paramName, java.lang.reflect.Type paramType, Type asmType, boolean noXmlElem,
+              List<Annotation> jaxbAnnotations) {
+            this(paramName, paramType, asmType, noXmlElem, null,null, jaxbAnnotations);
+        }
+
+        Field(String paramName, java.lang.reflect.Type paramType, Type asmType, boolean noXmlElem,
+              String elementName, String elementNS, List<Annotation> jaxbAnnotations) {
+            this.reflectType = paramType;
+            this.asmType = asmType;
+            this.fieldName = paramName;
+            this.noXmlElem = noXmlElem;
+            this.elementName = elementName;
+            this.elementNS = elementNS;
+            this.jaxbAnnotations = jaxbAnnotations;
+        }
+
+        String getSignature() {
+            if (reflectType instanceof Class) {
+                return null;
+            }
+            if (reflectType instanceof TypeVariable) {
+                return null;
+            }
+            return FieldSignature.vms(reflectType);
+        }
+
+        public int compareTo(Field o) {
+            return fieldName.compareTo(o.fieldName);
+        }
+
+    }
+
+    // TODO MOVE Names to runtime (instead of doing the following)
+
+    /**
+     * See if its a java keyword name, if so then mangle the name
+     */
+    private static @NotNull String getJavaReservedVarialbeName(@NotNull String name) {
+        String reservedName = reservedWords.get(name);
+        return reservedName == null ? name : reservedName;
+    }
+
+    private static final Map<String, String> reservedWords;
+
+    static {
+        reservedWords = new HashMap<String, String>();
+        reservedWords.put("abstract", "_abstract");
+        reservedWords.put("assert", "_assert");
+        reservedWords.put("boolean", "_boolean");
+        reservedWords.put("break", "_break");
+        reservedWords.put("byte", "_byte");
+        reservedWords.put("case", "_case");
+        reservedWords.put("catch", "_catch");
+        reservedWords.put("char", "_char");
+        reservedWords.put("class", "_class");
+        reservedWords.put("const", "_const");
+        reservedWords.put("continue", "_continue");
+        reservedWords.put("default", "_default");
+        reservedWords.put("do", "_do");
+        reservedWords.put("double", "_double");
+        reservedWords.put("else", "_else");
+        reservedWords.put("extends", "_extends");
+        reservedWords.put("false", "_false");
+        reservedWords.put("final", "_final");
+        reservedWords.put("finally", "_finally");
+        reservedWords.put("float", "_float");
+        reservedWords.put("for", "_for");
+        reservedWords.put("goto", "_goto");
+        reservedWords.put("if", "_if");
+        reservedWords.put("implements", "_implements");
+        reservedWords.put("import", "_import");
+        reservedWords.put("instanceof", "_instanceof");
+        reservedWords.put("int", "_int");
+        reservedWords.put("interface", "_interface");
+        reservedWords.put("long", "_long");
+        reservedWords.put("native", "_native");
+        reservedWords.put("new", "_new");
+        reservedWords.put("null", "_null");
+        reservedWords.put("package", "_package");
+        reservedWords.put("private", "_private");
+        reservedWords.put("protected", "_protected");
+        reservedWords.put("public", "_public");
+        reservedWords.put("return", "_return");
+        reservedWords.put("short", "_short");
+        reservedWords.put("static", "_static");
+        reservedWords.put("strictfp", "_strictfp");
+        reservedWords.put("super", "_super");
+        reservedWords.put("switch", "_switch");
+        reservedWords.put("synchronized", "_synchronized");
+        reservedWords.put("this", "_this");
+        reservedWords.put("throw", "_throw");
+        reservedWords.put("throws", "_throws");
+        reservedWords.put("transient", "_transient");
+        reservedWords.put("true", "_true");
+        reservedWords.put("try", "_try");
+        reservedWords.put("void", "_void");
+        reservedWords.put("volatile", "_volatile");
+        reservedWords.put("while", "_while");
+        reservedWords.put("enum", "_enum");
+    }
+
+    private static final Set<String> skipProperties = new HashSet<String>();
+    static{
+        skipProperties.add("getCause");
+        skipProperties.add("getLocalizedMessage");
+        skipProperties.add("getClass");
+        skipProperties.add("getStackTrace");
+    }
+
+}
--- /dev/null	Tue Aug  4 10:19:31 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/model/wsdl/WSDLBoundFaultImpl.java	Tue Aug  4 10:19:31 2009
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.model.wsdl;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundFault;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLFault;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLOperation;
+import com.sun.xml.internal.ws.api.model.wsdl.WSDLBoundOperation;
+
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.namespace.QName;
+
+/**
+ * @author Vivek Pandey
+ */
+public class WSDLBoundFaultImpl extends AbstractExtensibleImpl implements WSDLBoundFault {
+    private final String name;
+    private WSDLFault fault;
+    private WSDLBoundOperationImpl owner;
+
+    public WSDLBoundFaultImpl(XMLStreamReader xsr, String name, WSDLBoundOperationImpl owner) {
+        super(xsr);
+        this.name = name;
+        this.owner = owner;
+    }
+
+    public
+    @NotNull
+    String getName() {
+        return name;
+    }
+
+    public QName getQName() {
+        if(owner.getOperation() != null){
+            return new QName(owner.getOperation().getName().getNamespaceURI(), name);
+        }
+        return null;
+    }
+
+    public WSDLFault getFault() {
+        return fault;
+    }
+
+    @NotNull
+    public WSDLBoundOperation getBoundOperation() {
+        return owner;
+    }
+
+    void freeze(WSDLBoundOperationImpl root) {
+        assert root != null;
+        WSDLOperation op = root.getOperation();
+        if (op != null) {
+            for (WSDLFault f : op.getFaults()) {
+                if (f.getName().equals(name)) {
+                    this.fault = f;
+                    break;
+                }
+            }
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:19:33 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/AnnotationVisitor.java	Tue Aug  4 10:19:33 2009
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * A visitor to visit a Java annotation. The methods of this interface must be
+ * called in the following order: (<tt>visit<tt> | <tt>visitEnum<tt> |
+ * <tt>visitAnnotation<tt> | <tt>visitArray<tt>)* <tt>visitEnd<tt>.
+ *
+ * @author Eric Bruneton
+ * @author Eugene Kuleshov
+ */
+public interface AnnotationVisitor {
+
+    /**
+     * Visits a primitive value of the annotation.
+     *
+     * @param name the value name.
+     * @param value the actual value, whose type must be {@link Byte},
+     *        {@link Boolean}, {@link Character}, {@link Short},
+     *        {@link Integer}, {@link Long}, {@link Float}, {@link Double},
+     *        {@link String} or {@link Type}. This value can also be an array
+     *        of byte, boolean, short, char, int, long, float or double values
+     *        (this is equivalent to using {@link #visitArray visitArray} and
+     *        visiting each array element in turn, but is more convenient).
+     */
+    void visit(String name, Object value);
+
+    /**
+     * Visits an enumeration value of the annotation.
+     *
+     * @param name the value name.
+     * @param desc the class descriptor of the enumeration class.
+     * @param value the actual enumeration value.
+     */
+    void visitEnum(String name, String desc, String value);
+
+    /**
+     * Visits a nested annotation value of the annotation.
+     *
+     * @param name the value name.
+     * @param desc the class descriptor of the nested annotation class.
+     * @return a visitor to visit the actual nested annotation value, or
+     *         <tt>null</tt> if this visitor is not interested in visiting
+     *         this nested annotation. <i>The nested annotation value must be
+     *         fully visited before calling other methods on this annotation
+     *         visitor</i>.
+     */
+    AnnotationVisitor visitAnnotation(String name, String desc);
+
+    /**
+     * Visits an array value of the annotation. Note that arrays of primitive
+     * types (such as byte, boolean, short, char, int, long, float or double)
+     * can be passed as value to {@link #visit visit}. This is what
+     * {@link ClassReader} does.
+     *
+     * @param name the value name.
+     * @return a visitor to visit the actual array value elements, or
+     *         <tt>null</tt> if this visitor is not interested in visiting
+     *         these values. The 'name' parameters passed to the methods of this
+     *         visitor are ignored. <i>All the array values must be visited
+     *         before calling other methods on this annotation visitor</i>.
+     */
+    AnnotationVisitor visitArray(String name);
+
+    /**
+     * Visits the end of the annotation.
+     */
+    void visitEnd();
+}
--- /dev/null	Tue Aug  4 10:19:35 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/AnnotationWriter.java	Tue Aug  4 10:19:35 2009
@@ -0,0 +1,346 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * An {@link AnnotationVisitor} that generates annotations in bytecode form.
+ *
+ * @author Eric Bruneton
+ * @author Eugene Kuleshov
+ */
+final class AnnotationWriter implements AnnotationVisitor {
+
+    /**
+     * The class writer to which this annotation must be added.
+     */
+    private final ClassWriter cw;
+
+    /**
+     * The number of values in this annotation.
+     */
+    private int size;
+
+    /**
+     * <tt>true<tt> if values are named, <tt>false</tt> otherwise. Annotation
+     * writers used for annotation default and annotation arrays use unnamed
+     * values.
+     */
+    private final boolean named;
+
+    /**
+     * The annotation values in bytecode form. This byte vector only contains
+     * the values themselves, i.e. the number of values must be stored as a
+     * unsigned short just before these bytes.
+     */
+    private final ByteVector bv;
+
+    /**
+     * The byte vector to be used to store the number of values of this
+     * annotation. See {@link #bv}.
+     */
+    private final ByteVector parent;
+
+    /**
+     * Where the number of values of this annotation must be stored in
+     * {@link #parent}.
+     */
+    private final int offset;
+
+    /**
+     * Next annotation writer. This field is used to store annotation lists.
+     */
+    AnnotationWriter next;
+
+    /**
+     * Previous annotation writer. This field is used to store annotation lists.
+     */
+    AnnotationWriter prev;
+
+    // ------------------------------------------------------------------------
+    // Constructor
+    // ------------------------------------------------------------------------
+
+    /**
+     * Constructs a new {@link AnnotationWriter}.
+     *
+     * @param cw the class writer to which this annotation must be added.
+     * @param named <tt>true<tt> if values are named, <tt>false</tt> otherwise.
+     * @param bv where the annotation values must be stored.
+     * @param parent where the number of annotation values must be stored.
+     * @param offset where in <tt>parent</tt> the number of annotation values must
+     *      be stored.
+     */
+    AnnotationWriter(
+        final ClassWriter cw,
+        final boolean named,
+        final ByteVector bv,
+        final ByteVector parent,
+        final int offset)
+    {
+        this.cw = cw;
+        this.named = named;
+        this.bv = bv;
+        this.parent = parent;
+        this.offset = offset;
+    }
+
+    // ------------------------------------------------------------------------
+    // Implementation of the AnnotationVisitor interface
+    // ------------------------------------------------------------------------
+
+    public void visit(final String name, final Object value) {
+        ++size;
+        if (named) {
+            bv.putShort(cw.newUTF8(name));
+        }
+        if (value instanceof String) {
+            bv.put12('s', cw.newUTF8((String) value));
+        } else if (value instanceof Byte) {
+            bv.put12('B', cw.newInteger(((Byte) value).byteValue()).index);
+        } else if (value instanceof Boolean) {
+            int v = ((Boolean) value).booleanValue() ? 1 : 0;
+            bv.put12('Z', cw.newInteger(v).index);
+        } else if (value instanceof Character) {
+            bv.put12('C', cw.newInteger(((Character) value).charValue()).index);
+        } else if (value instanceof Short) {
+            bv.put12('S', cw.newInteger(((Short) value).shortValue()).index);
+        } else if (value instanceof Type) {
+            bv.put12('c', cw.newUTF8(((Type) value).getDescriptor()));
+        } else if (value instanceof byte[]) {
+            byte[] v = (byte[]) value;
+            bv.put12('[', v.length);
+            for (int i = 0; i < v.length; i++) {
+                bv.put12('B', cw.newInteger(v[i]).index);
+            }
+        } else if (value instanceof boolean[]) {
+            boolean[] v = (boolean[]) value;
+            bv.put12('[', v.length);
+            for (int i = 0; i < v.length; i++) {
+                bv.put12('Z', cw.newInteger(v[i] ? 1 : 0).index);
+            }
+        } else if (value instanceof short[]) {
+            short[] v = (short[]) value;
+            bv.put12('[', v.length);
+            for (int i = 0; i < v.length; i++) {
+                bv.put12('S', cw.newInteger(v[i]).index);
+            }
+        } else if (value instanceof char[]) {
+            char[] v = (char[]) value;
+            bv.put12('[', v.length);
+            for (int i = 0; i < v.length; i++) {
+                bv.put12('C', cw.newInteger(v[i]).index);
+            }
+        } else if (value instanceof int[]) {
+            int[] v = (int[]) value;
+            bv.put12('[', v.length);
+            for (int i = 0; i < v.length; i++) {
+                bv.put12('I', cw.newInteger(v[i]).index);
+            }
+        } else if (value instanceof long[]) {
+            long[] v = (long[]) value;
+            bv.put12('[', v.length);
+            for (int i = 0; i < v.length; i++) {
+                bv.put12('J', cw.newLong(v[i]).index);
+            }
+        } else if (value instanceof float[]) {
+            float[] v = (float[]) value;
+            bv.put12('[', v.length);
+            for (int i = 0; i < v.length; i++) {
+                bv.put12('F', cw.newFloat(v[i]).index);
+            }
+        } else if (value instanceof double[]) {
+            double[] v = (double[]) value;
+            bv.put12('[', v.length);
+            for (int i = 0; i < v.length; i++) {
+                bv.put12('D', cw.newDouble(v[i]).index);
+            }
+        } else {
+            Item i = cw.newConstItem(value);
+            bv.put12(".s.IFJDCS".charAt(i.type), i.index);
+        }
+    }
+
+    public void visitEnum(
+        final String name,
+        final String desc,
+        final String value)
+    {
+        ++size;
+        if (named) {
+            bv.putShort(cw.newUTF8(name));
+        }
+        bv.put12('e', cw.newUTF8(desc)).putShort(cw.newUTF8(value));
+    }
+
+    public AnnotationVisitor visitAnnotation(
+        final String name,
+        final String desc)
+    {
+        ++size;
+        if (named) {
+            bv.putShort(cw.newUTF8(name));
+        }
+        // write tag and type, and reserve space for values count
+        bv.put12('@', cw.newUTF8(desc)).putShort(0);
+        return new AnnotationWriter(cw, true, bv, bv, bv.length - 2);
+    }
+
+    public AnnotationVisitor visitArray(final String name) {
+        ++size;
+        if (named) {
+            bv.putShort(cw.newUTF8(name));
+        }
+        // write tag, and reserve space for array size
+        bv.put12('[', 0);
+        return new AnnotationWriter(cw, false, bv, bv, bv.length - 2);
+    }
+
+    public void visitEnd() {
+        if (parent != null) {
+            byte[] data = parent.data;
+            data[offset] = (byte) (size >>> 8);
+            data[offset + 1] = (byte) size;
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    // Utility methods
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns the size of this annotation writer list.
+     *
+     * @return the size of this annotation writer list.
+     */
+    int getSize() {
+        int size = 0;
+        AnnotationWriter aw = this;
+        while (aw != null) {
+            size += aw.bv.length;
+            aw = aw.next;
+        }
+        return size;
+    }
+
+    /**
+     * Puts the annotations of this annotation writer list into the given byte
+     * vector.
+     *
+     * @param out where the annotations must be put.
+     */
+    void put(final ByteVector out) {
+        int n = 0;
+        int size = 2;
+        AnnotationWriter aw = this;
+        AnnotationWriter last = null;
+        while (aw != null) {
+            ++n;
+            size += aw.bv.length;
+            aw.visitEnd(); // in case user forgot to call visitEnd
+            aw.prev = last;
+            last = aw;
+            aw = aw.next;
+        }
+        out.putInt(size);
+        out.putShort(n);
+        aw = last;
+        while (aw != null) {
+            out.putByteArray(aw.bv.data, 0, aw.bv.length);
+            aw = aw.prev;
+        }
+    }
+
+    /**
+     * Puts the given annotation lists into the given byte vector.
+     *
+     * @param panns an array of annotation writer lists.
+     * @param off index of the first annotation to be written.
+     * @param out where the annotations must be put.
+     */
+    static void put(
+        final AnnotationWriter[] panns,
+        final int off,
+        final ByteVector out)
+    {
+        int size = 1 + 2 * (panns.length - off);
+        for (int i = off; i < panns.length; ++i) {
+            size += panns[i] == null ? 0 : panns[i].getSize();
+        }
+        out.putInt(size).putByte(panns.length - off);
+        for (int i = off; i < panns.length; ++i) {
+            AnnotationWriter aw = panns[i];
+            AnnotationWriter last = null;
+            int n = 0;
+            while (aw != null) {
+                ++n;
+                aw.visitEnd(); // in case user forgot to call visitEnd
+                aw.prev = last;
+                last = aw;
+                aw = aw.next;
+            }
+            out.putShort(n);
+            aw = last;
+            while (aw != null) {
+                out.putByteArray(aw.bv.data, 0, aw.bv.length);
+                aw = aw.prev;
+            }
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:19:37 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/Attribute.java	Tue Aug  4 10:19:37 2009
@@ -0,0 +1,284 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * A non standard class, field, method or code attribute.
+ *
+ * @author Eric Bruneton
+ * @author Eugene Kuleshov
+ */
+public class Attribute {
+
+    /**
+     * The type of this attribute.
+     */
+    public final String type;
+
+    /**
+     * The raw value of this attribute, used only for unknown attributes.
+     */
+    byte[] value;
+
+    /**
+     * The next attribute in this attribute list. May be <tt>null</tt>.
+     */
+    Attribute next;
+
+    /**
+     * Constructs a new empty attribute.
+     *
+     * @param type the type of the attribute.
+     */
+    protected Attribute(final String type) {
+        this.type = type;
+    }
+
+    /**
+     * Returns <tt>true</tt> if this type of attribute is unknown. The default
+     * implementation of this method always returns <tt>true</tt>.
+     *
+     * @return <tt>true</tt> if this type of attribute is unknown.
+     */
+    public boolean isUnknown() {
+        return true;
+    }
+
+    /**
+     * Returns <tt>true</tt> if this type of attribute is a code attribute.
+     *
+     * @return <tt>true</tt> if this type of attribute is a code attribute.
+     */
+    public boolean isCodeAttribute() {
+        return false;
+    }
+
+    /**
+     * Returns the labels corresponding to this attribute.
+     *
+     * @return the labels corresponding to this attribute, or <tt>null</tt> if
+     *         this attribute is not a code attribute that contains labels.
+     */
+    protected Label[] getLabels() {
+        return null;
+    }
+
+    /**
+     * Reads a {@link #type type} attribute. This method must return a <i>new</i>
+     * {@link Attribute} object, of type {@link #type type}, corresponding to
+     * the <tt>len</tt> bytes starting at the given offset, in the given class
+     * reader.
+     *
+     * @param cr the class that contains the attribute to be read.
+     * @param off index of the first byte of the attribute's content in {@link
+     *        ClassReader#b cr.b}. The 6 attribute header bytes, containing the
+     *        type and the length of the attribute, are not taken into account
+     *        here.
+     * @param len the length of the attribute's content.
+     * @param buf buffer to be used to call
+     *        {@link ClassReader#readUTF8 readUTF8},
+     *        {@link ClassReader#readClass(int,char[]) readClass} or
+     *        {@link ClassReader#readConst readConst}.
+     * @param codeOff index of the first byte of code's attribute content in
+     *        {@link ClassReader#b cr.b}, or -1 if the attribute to be read is
+     *        not a code attribute. The 6 attribute header bytes, containing the
+     *        type and the length of the attribute, are not taken into account
+     *        here.
+     * @param labels the labels of the method's code, or <tt>null</tt> if the
+     *        attribute to be read is not a code attribute.
+     * @return a <i>new</i> {@link Attribute} object corresponding to the given
+     *         bytes.
+     */
+    protected Attribute read(
+        final ClassReader cr,
+        final int off,
+        final int len,
+        final char[] buf,
+        final int codeOff,
+        final Label[] labels)
+    {
+        Attribute attr = new Attribute(type);
+        attr.value = new byte[len];
+        System.arraycopy(cr.b, off, attr.value, 0, len);
+        return attr;
+    }
+
+    /**
+     * Returns the byte array form of this attribute.
+     *
+     * @param cw the class to which this attribute must be added. This parameter
+     *        can be used to add to the constant pool of this class the items
+     *        that corresponds to this attribute.
+     * @param code the bytecode of the method corresponding to this code
+     *        attribute, or <tt>null</tt> if this attribute is not a code
+     *        attributes.
+     * @param len the length of the bytecode of the method corresponding to this
+     *        code attribute, or <tt>null</tt> if this attribute is not a code
+     *        attribute.
+     * @param maxStack the maximum stack size of the method corresponding to
+     *        this code attribute, or -1 if this attribute is not a code
+     *        attribute.
+     * @param maxLocals the maximum number of local variables of the method
+     *        corresponding to this code attribute, or -1 if this attribute is
+     *        not a code attribute.
+     * @return the byte array form of this attribute.
+     */
+    protected ByteVector write(
+        final ClassWriter cw,
+        final byte[] code,
+        final int len,
+        final int maxStack,
+        final int maxLocals)
+    {
+        ByteVector v = new ByteVector();
+        v.data = value;
+        v.length = value.length;
+        return v;
+    }
+
+    /**
+     * Returns the length of the attribute list that begins with this attribute.
+     *
+     * @return the length of the attribute list that begins with this attribute.
+     */
+    final int getCount() {
+        int count = 0;
+        Attribute attr = this;
+        while (attr != null) {
+            count += 1;
+            attr = attr.next;
+        }
+        return count;
+    }
+
+    /**
+     * Returns the size of all the attributes in this attribute list.
+     *
+     * @param cw the class writer to be used to convert the attributes into byte
+     *        arrays, with the {@link #write write} method.
+     * @param code the bytecode of the method corresponding to these code
+     *        attributes, or <tt>null</tt> if these attributes are not code
+     *        attributes.
+     * @param len the length of the bytecode of the method corresponding to
+     *        these code attributes, or <tt>null</tt> if these attributes are
+     *        not code attributes.
+     * @param maxStack the maximum stack size of the method corresponding to
+     *        these code attributes, or -1 if these attributes are not code
+     *        attributes.
+     * @param maxLocals the maximum number of local variables of the method
+     *        corresponding to these code attributes, or -1 if these attributes
+     *        are not code attributes.
+     * @return the size of all the attributes in this attribute list. This size
+     *         includes the size of the attribute headers.
+     */
+    final int getSize(
+        final ClassWriter cw,
+        final byte[] code,
+        final int len,
+        final int maxStack,
+        final int maxLocals)
+    {
+        Attribute attr = this;
+        int size = 0;
+        while (attr != null) {
+            cw.newUTF8(attr.type);
+            size += attr.write(cw, code, len, maxStack, maxLocals).length + 6;
+            attr = attr.next;
+        }
+        return size;
+    }
+
+    /**
+     * Writes all the attributes of this attribute list in the given byte
+     * vector.
+     *
+     * @param cw the class writer to be used to convert the attributes into byte
+     *        arrays, with the {@link #write write} method.
+     * @param code the bytecode of the method corresponding to these code
+     *        attributes, or <tt>null</tt> if these attributes are not code
+     *        attributes.
+     * @param len the length of the bytecode of the method corresponding to
+     *        these code attributes, or <tt>null</tt> if these attributes are
+     *        not code attributes.
+     * @param maxStack the maximum stack size of the method corresponding to
+     *        these code attributes, or -1 if these attributes are not code
+     *        attributes.
+     * @param maxLocals the maximum number of local variables of the method
+     *        corresponding to these code attributes, or -1 if these attributes
+     *        are not code attributes.
+     * @param out where the attributes must be written.
+     */
+    final void put(
+        final ClassWriter cw,
+        final byte[] code,
+        final int len,
+        final int maxStack,
+        final int maxLocals,
+        final ByteVector out)
+    {
+        Attribute attr = this;
+        while (attr != null) {
+            ByteVector b = attr.write(cw, code, len, maxStack, maxLocals);
+            out.putShort(cw.newUTF8(attr.type)).putInt(b.length);
+            out.putByteArray(b.data, 0, b.length);
+            attr = attr.next;
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:19:39 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/ByteVector.java	Tue Aug  4 10:19:39 2009
@@ -0,0 +1,323 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * A dynamically extensible vector of bytes. This class is roughly equivalent to
+ * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.
+ *
+ * @author Eric Bruneton
+ */
+public class ByteVector {
+
+    /**
+     * The content of this vector.
+     */
+    byte[] data;
+
+    /**
+     * Actual number of bytes in this vector.
+     */
+    int length;
+
+    /**
+     * Constructs a new {@link ByteVector ByteVector} with a default initial
+     * size.
+     */
+    public ByteVector() {
+        data = new byte[64];
+    }
+
+    /**
+     * Constructs a new {@link ByteVector ByteVector} with the given initial
+     * size.
+     *
+     * @param initialSize the initial size of the byte vector to be constructed.
+     */
+    public ByteVector(final int initialSize) {
+        data = new byte[initialSize];
+    }
+
+    /**
+     * Puts a byte into this byte vector. The byte vector is automatically
+     * enlarged if necessary.
+     *
+     * @param b a byte.
+     * @return this byte vector.
+     */
+    public ByteVector putByte(final int b) {
+        int length = this.length;
+        if (length + 1 > data.length) {
+            enlarge(1);
+        }
+        data[length++] = (byte) b;
+        this.length = length;
+        return this;
+    }
+
+    /**
+     * Puts two bytes into this byte vector. The byte vector is automatically
+     * enlarged if necessary.
+     *
+     * @param b1 a byte.
+     * @param b2 another byte.
+     * @return this byte vector.
+     */
+    ByteVector put11(final int b1, final int b2) {
+        int length = this.length;
+        if (length + 2 > data.length) {
+            enlarge(2);
+        }
+        byte[] data = this.data;
+        data[length++] = (byte) b1;
+        data[length++] = (byte) b2;
+        this.length = length;
+        return this;
+    }
+
+    /**
+     * Puts a short into this byte vector. The byte vector is automatically
+     * enlarged if necessary.
+     *
+     * @param s a short.
+     * @return this byte vector.
+     */
+    public ByteVector putShort(final int s) {
+        int length = this.length;
+        if (length + 2 > data.length) {
+            enlarge(2);
+        }
+        byte[] data = this.data;
+        data[length++] = (byte) (s >>> 8);
+        data[length++] = (byte) s;
+        this.length = length;
+        return this;
+    }
+
+    /**
+     * Puts a byte and a short into this byte vector. The byte vector is
+     * automatically enlarged if necessary.
+     *
+     * @param b a byte.
+     * @param s a short.
+     * @return this byte vector.
+     */
+    ByteVector put12(final int b, final int s) {
+        int length = this.length;
+        if (length + 3 > data.length) {
+            enlarge(3);
+        }
+        byte[] data = this.data;
+        data[length++] = (byte) b;
+        data[length++] = (byte) (s >>> 8);
+        data[length++] = (byte) s;
+        this.length = length;
+        return this;
+    }
+
+    /**
+     * Puts an int into this byte vector. The byte vector is automatically
+     * enlarged if necessary.
+     *
+     * @param i an int.
+     * @return this byte vector.
+     */
+    public ByteVector putInt(final int i) {
+        int length = this.length;
+        if (length + 4 > data.length) {
+            enlarge(4);
+        }
+        byte[] data = this.data;
+        data[length++] = (byte) (i >>> 24);
+        data[length++] = (byte) (i >>> 16);
+        data[length++] = (byte) (i >>> 8);
+        data[length++] = (byte) i;
+        this.length = length;
+        return this;
+    }
+
+    /**
+     * Puts a long into this byte vector. The byte vector is automatically
+     * enlarged if necessary.
+     *
+     * @param l a long.
+     * @return this byte vector.
+     */
+    public ByteVector putLong(final long l) {
+        int length = this.length;
+        if (length + 8 > data.length) {
+            enlarge(8);
+        }
+        byte[] data = this.data;
+        int i = (int) (l >>> 32);
+        data[length++] = (byte) (i >>> 24);
+        data[length++] = (byte) (i >>> 16);
+        data[length++] = (byte) (i >>> 8);
+        data[length++] = (byte) i;
+        i = (int) l;
+        data[length++] = (byte) (i >>> 24);
+        data[length++] = (byte) (i >>> 16);
+        data[length++] = (byte) (i >>> 8);
+        data[length++] = (byte) i;
+        this.length = length;
+        return this;
+    }
+
+    /**
+     * Puts an UTF8 string into this byte vector. The byte vector is
+     * automatically enlarged if necessary.
+     *
+     * @param s a String.
+     * @return this byte vector.
+     */
+    public ByteVector putUTF8(final String s) {
+        int charLength = s.length();
+        if (length + 2 + charLength > data.length) {
+            enlarge(2 + charLength);
+        }
+        int len = length;
+        byte[] data = this.data;
+        // optimistic algorithm: instead of computing the byte length and then
+        // serializing the string (which requires two loops), we assume the byte
+        // length is equal to char length (which is the most frequent case), and
+        // we start serializing the string right away. During the serialization,
+        // if we find that this assumption is wrong, we continue with the
+        // general method.
+        data[len++] = (byte) (charLength >>> 8);
+        data[len++] = (byte) charLength;
+        for (int i = 0; i < charLength; ++i) {
+            char c = s.charAt(i);
+            if (c >= '\001' && c <= '\177') {
+                data[len++] = (byte) c;
+            } else {
+                int byteLength = i;
+                for (int j = i; j < charLength; ++j) {
+                    c = s.charAt(j);
+                    if (c >= '\001' && c <= '\177') {
+                        byteLength++;
+                    } else if (c > '\u07FF') {
+                        byteLength += 3;
+                    } else {
+                        byteLength += 2;
+                    }
+                }
+                data[length] = (byte) (byteLength >>> 8);
+                data[length + 1] = (byte) byteLength;
+                if (length + 2 + byteLength > data.length) {
+                    length = len;
+                    enlarge(2 + byteLength);
+                    data = this.data;
+                }
+                for (int j = i; j < charLength; ++j) {
+                    c = s.charAt(j);
+                    if (c >= '\001' && c <= '\177') {
+                        data[len++] = (byte) c;
+                    } else if (c > '\u07FF') {
+                        data[len++] = (byte) (0xE0 | c >> 12 & 0xF);
+                        data[len++] = (byte) (0x80 | c >> 6 & 0x3F);
+                        data[len++] = (byte) (0x80 | c & 0x3F);
+                    } else {
+                        data[len++] = (byte) (0xC0 | c >> 6 & 0x1F);
+                        data[len++] = (byte) (0x80 | c & 0x3F);
+                    }
+                }
+                break;
+            }
+        }
+        length = len;
+        return this;
+    }
+
+    /**
+     * Puts an array of bytes into this byte vector. The byte vector is
+     * automatically enlarged if necessary.
+     *
+     * @param b an array of bytes. May be <tt>null</tt> to put <tt>len</tt>
+     *        null bytes into this byte vector.
+     * @param off index of the fist byte of b that must be copied.
+     * @param len number of bytes of b that must be copied.
+     * @return this byte vector.
+     */
+    public ByteVector putByteArray(final byte[] b, final int off, final int len)
+    {
+        if (length + len > data.length) {
+            enlarge(len);
+        }
+        if (b != null) {
+            System.arraycopy(b, off, data, length, len);
+        }
+        length += len;
+        return this;
+    }
+
+    /**
+     * Enlarge this byte vector so that it can receive n more bytes.
+     *
+     * @param size number of additional bytes that this byte vector should be
+     *        able to receive.
+     */
+    private void enlarge(final int size) {
+        int length1 = 2 * data.length;
+        int length2 = length + size;
+        byte[] newData = new byte[length1 > length2 ? length1 : length2];
+        System.arraycopy(data, 0, newData, 0, length);
+        data = newData;
+    }
+}
--- /dev/null	Tue Aug  4 10:19:41 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/ClassReader.java	Tue Aug  4 10:19:41 2009
@@ -0,0 +1,2039 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+import java.io.InputStream;
+import java.io.IOException;
+
+/**
+ * A Java class parser to make a {@link ClassVisitor} visit an existing class.
+ * This class parses a byte array conforming to the Java class file format and
+ * calls the appropriate visit methods of a given class visitor for each field,
+ * method and bytecode instruction encountered.
+ *
+ * @author Eric Bruneton
+ * @author Eugene Kuleshov
+ */
+public class ClassReader {
+
+    /**
+     * True to enable signatures support.
+     */
+    static final boolean SIGNATURES = true;
+
+    /**
+     * True to enable annotations support.
+     */
+    static final boolean ANNOTATIONS = true;
+
+    /**
+     * True to enable stack map frames support.
+     */
+    static final boolean FRAMES = true;
+
+    /**
+     * True to enable bytecode writing support.
+     */
+    static final boolean WRITER = true;
+
+    /**
+     * True to enable JSR_W and GOTO_W support.
+     */
+    static final boolean RESIZE = true;
+
+    /**
+     * Flag to skip method code. If this class is set <code>CODE</code>
+     * attribute won't be visited. This can be used, for example, to retrieve
+     * annotations for methods and method parameters.
+     */
+    public static final int SKIP_CODE = 1;
+
+    /**
+     * Flag to skip the debug information in the class. If this flag is set the
+     * debug information of the class is not visited, i.e. the
+     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and
+     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be
+     * called.
+     */
+    public static final int SKIP_DEBUG = 2;
+
+    /**
+     * Flag to skip the stack map frames in the class. If this flag is set the
+     * stack map frames of the class is not visited, i.e. the
+     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.
+     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is
+     * used: it avoids visiting frames that will be ignored and recomputed from
+     * scratch in the class writer.
+     */
+    public static final int SKIP_FRAMES = 4;
+
+    /**
+     * Flag to expand the stack map frames. By default stack map frames are
+     * visited in their original format (i.e. "expanded" for classes whose
+     * version is less than V1_6, and "compressed" for the other classes). If
+     * this flag is set, stack map frames are always visited in expanded format
+     * (this option adds a decompression/recompression step in ClassReader and
+     * ClassWriter which degrades performances quite a lot).
+     */
+    public static final int EXPAND_FRAMES = 8;
+
+    /**
+     * The class to be parsed. <i>The content of this array must not be
+     * modified. This field is intended for {@link Attribute} sub classes, and
+     * is normally not needed by class generators or adapters.</i>
+     */
+    public final byte[] b;
+
+    /**
+     * The start index of each constant pool item in {@link #b b}, plus one.
+     * The one byte offset skips the constant pool item tag that indicates its
+     * type.
+     */
+    private final int[] items;
+
+    /**
+     * The String objects corresponding to the CONSTANT_Utf8 items. This cache
+     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,
+     * which GREATLY improves performances (by a factor 2 to 3). This caching
+     * strategy could be extended to all constant pool items, but its benefit
+     * would not be so great for these items (because they are much less
+     * expensive to parse than CONSTANT_Utf8 items).
+     */
+    private final String[] strings;
+
+    /**
+     * Maximum length of the strings contained in the constant pool of the
+     * class.
+     */
+    private final int maxStringLength;
+
+    /**
+     * Start index of the class header information (access, name...) in
+     * {@link #b b}.
+     */
+    public final int header;
+
+    // ------------------------------------------------------------------------
+    // Constructors
+    // ------------------------------------------------------------------------
+
+    /**
+     * Constructs a new {@link ClassReader} object.
+     *
+     * @param b the bytecode of the class to be read.
+     */
+    public ClassReader(final byte[] b) {
+        this(b, 0, b.length);
+    }
+
+    /**
+     * Constructs a new {@link ClassReader} object.
+     *
+     * @param b the bytecode of the class to be read.
+     * @param off the start offset of the class data.
+     * @param len the length of the class data.
+     */
+    public ClassReader(final byte[] b, final int off, final int len) {
+        this.b = b;
+        // parses the constant pool
+        items = new int[readUnsignedShort(off + 8)];
+        int n = items.length;
+        strings = new String[n];
+        int max = 0;
+        int index = off + 10;
+        for (int i = 1; i < n; ++i) {
+            items[i] = index + 1;
+            int size;
+            switch (b[index]) {
+                case ClassWriter.FIELD:
+                case ClassWriter.METH:
+                case ClassWriter.IMETH:
+                case ClassWriter.INT:
+                case ClassWriter.FLOAT:
+                case ClassWriter.NAME_TYPE:
+                    size = 5;
+                    break;
+                case ClassWriter.LONG:
+                case ClassWriter.DOUBLE:
+                    size = 9;
+                    ++i;
+                    break;
+                case ClassWriter.UTF8:
+                    size = 3 + readUnsignedShort(index + 1);
+                    if (size > max) {
+                        max = size;
+                    }
+                    break;
+                // case ClassWriter.CLASS:
+                // case ClassWriter.STR:
+                default:
+                    size = 3;
+                    break;
+            }
+            index += size;
+        }
+        maxStringLength = max;
+        // the class header information starts just after the constant pool
+        header = index;
+    }
+
+    /**
+     * Returns the class's access flags (see {@link Opcodes}). This value may
+     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5
+     * and those flags are represented by attributes.
+     *
+     * @return the class access flags
+     *
+     * @see ClassVisitor#visit(int, int, String, String, String, String[])
+     */
+    public int getAccess() {
+        return readUnsignedShort(header);
+    }
+
+    /**
+     * Returns the internal name of the class (see
+     * {@link Type#getInternalName() getInternalName}).
+     *
+     * @return the internal class name
+     *
+     * @see ClassVisitor#visit(int, int, String, String, String, String[])
+     */
+    public String getClassName() {
+        return readClass(header + 2, new char[maxStringLength]);
+    }
+
+    /**
+     * Returns the internal of name of the super class (see
+     * {@link Type#getInternalName() getInternalName}). For interfaces, the
+     * super class is {@link Object}.
+     *
+     * @return the internal name of super class, or <tt>null</tt> for
+     *         {@link Object} class.
+     *
+     * @see ClassVisitor#visit(int, int, String, String, String, String[])
+     */
+    public String getSuperName() {
+        int n = items[readUnsignedShort(header + 4)];
+        return n == 0 ? null : readUTF8(n, new char[maxStringLength]);
+    }
+
+    /**
+     * Returns the internal names of the class's interfaces (see
+     * {@link Type#getInternalName() getInternalName}).
+     *
+     * @return the array of internal names for all implemented interfaces or
+     *         <tt>null</tt>.
+     *
+     * @see ClassVisitor#visit(int, int, String, String, String, String[])
+     */
+    public String[] getInterfaces() {
+        int index = header + 6;
+        int n = readUnsignedShort(index);
+        String[] interfaces = new String[n];
+        if (n > 0) {
+            char[] buf = new char[maxStringLength];
+            for (int i = 0; i < n; ++i) {
+                index += 2;
+                interfaces[i] = readClass(index, buf);
+            }
+        }
+        return interfaces;
+    }
+
+    /**
+     * Copies the constant pool data into the given {@link ClassWriter}. Should
+     * be called before the {@link #accept(ClassVisitor,int)} method.
+     *
+     * @param classWriter the {@link ClassWriter} to copy constant pool into.
+     */
+    void copyPool(final ClassWriter classWriter) {
+        char[] buf = new char[maxStringLength];
+        int ll = items.length;
+        Item[] items2 = new Item[ll];
+        for (int i = 1; i < ll; i++) {
+            int index = items[i];
+            int tag = b[index - 1];
+            Item item = new Item(i);
+            int nameType;
+            switch (tag) {
+                case ClassWriter.FIELD:
+                case ClassWriter.METH:
+                case ClassWriter.IMETH:
+                    nameType = items[readUnsignedShort(index + 2)];
+                    item.set(tag,
+                            readClass(index, buf),
+                            readUTF8(nameType, buf),
+                            readUTF8(nameType + 2, buf));
+                    break;
+
+                case ClassWriter.INT:
+                    item.set(readInt(index));
+                    break;
+
+                case ClassWriter.FLOAT:
+                    item.set(Float.intBitsToFloat(readInt(index)));
+                    break;
+
+                case ClassWriter.NAME_TYPE:
+                    item.set(tag,
+                            readUTF8(index, buf),
+                            readUTF8(index + 2, buf),
+                            null);
+                    break;
+
+                case ClassWriter.LONG:
+                    item.set(readLong(index));
+                    ++i;
+                    break;
+
+                case ClassWriter.DOUBLE:
+                    item.set(Double.longBitsToDouble(readLong(index)));
+                    ++i;
+                    break;
+
+                case ClassWriter.UTF8: {
+                    String s = strings[i];
+                    if (s == null) {
+                        index = items[i];
+                        s = strings[i] = readUTF(index + 2,
+                                readUnsignedShort(index),
+                                buf);
+                    }
+                    item.set(tag, s, null, null);
+                }
+                    break;
+
+                // case ClassWriter.STR:
+                // case ClassWriter.CLASS:
+                default:
+                    item.set(tag, readUTF8(index, buf), null, null);
+                    break;
+            }
+
+            int index2 = item.hashCode % items2.length;
+            item.next = items2[index2];
+            items2[index2] = item;
+        }
+
+        int off = items[1] - 1;
+        classWriter.pool.putByteArray(b, off, header - off);
+        classWriter.items = items2;
+        classWriter.threshold = (int) (0.75d * ll);
+        classWriter.index = ll;
+    }
+
+    /**
+     * Constructs a new {@link ClassReader} object.
+     *
+     * @param is an input stream from which to read the class.
+     * @throws IOException if a problem occurs during reading.
+     */
+    public ClassReader(final InputStream is) throws IOException {
+        this(readClass(is));
+    }
+
+    /**
+     * Constructs a new {@link ClassReader} object.
+     *
+     * @param name the fully qualified name of the class to be read.
+     * @throws IOException if an exception occurs during reading.
+     */
+    public ClassReader(final String name) throws IOException {
+        this(ClassLoader.getSystemResourceAsStream(name.replace('.', '/')
+                + ".class"));
+    }
+
+    /**
+     * Reads the bytecode of a class.
+     *
+     * @param is an input stream from which to read the class.
+     * @return the bytecode read from the given input stream.
+     * @throws IOException if a problem occurs during reading.
+     */
+    private static byte[] readClass(final InputStream is) throws IOException {
+        if (is == null) {
+            throw new IOException("Class not found");
+        }
+        byte[] b = new byte[is.available()];
+        int len = 0;
+        while (true) {
+            int n = is.read(b, len, b.length - len);
+            if (n == -1) {
+                if (len < b.length) {
+                    byte[] c = new byte[len];
+                    System.arraycopy(b, 0, c, 0, len);
+                    b = c;
+                }
+                return b;
+            }
+            len += n;
+            if (len == b.length) {
+                byte[] c = new byte[b.length + 1000];
+                System.arraycopy(b, 0, c, 0, len);
+                b = c;
+            }
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    // Public methods
+    // ------------------------------------------------------------------------
+
+    /**
+     * Makes the given visitor visit the Java class of this {@link ClassReader}.
+     * This class is the one specified in the constructor (see
+     * {@link #ClassReader(byte[]) ClassReader}).
+     *
+     * @param classVisitor the visitor that must visit this class.
+     * @param flags option flags that can be used to modify the default behavior
+     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},
+     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.
+     */
+    public void accept(final ClassVisitor classVisitor, final int flags) {
+        accept(classVisitor, new Attribute[0], flags);
+    }
+
+    /**
+     * Makes the given visitor visit the Java class of this {@link ClassReader}.
+     * This class is the one specified in the constructor (see
+     * {@link #ClassReader(byte[]) ClassReader}).
+     *
+     * @param classVisitor the visitor that must visit this class.
+     * @param attrs prototypes of the attributes that must be parsed during the
+     *        visit of the class. Any attribute whose type is not equal to the
+     *        type of one the prototypes will not be parsed: its byte array
+     *        value will be passed unchanged to the ClassWriter. <i>This may
+     *        corrupt it if this value contains references to the constant pool,
+     *        or has syntactic or semantic links with a class element that has
+     *        been transformed by a class adapter between the reader and the
+     *        writer</i>.
+     * @param flags option flags that can be used to modify the default behavior
+     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},
+     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.
+     */
+    public void accept(
+        final ClassVisitor classVisitor,
+        final Attribute[] attrs,
+        final int flags)
+    {
+        byte[] b = this.b; // the bytecode array
+        char[] c = new char[maxStringLength]; // buffer used to read strings
+        int i, j, k; // loop variables
+        int u, v, w; // indexes in b
+        Attribute attr;
+
+        int access;
+        String name;
+        String desc;
+        String attrName;
+        String signature;
+        int anns = 0;
+        int ianns = 0;
+        Attribute cattrs = null;
+
+        // visits the header
+        u = header;
+        access = readUnsignedShort(u);
+        name = readClass(u + 2, c);
+        v = items[readUnsignedShort(u + 4)];
+        String superClassName = v == 0 ? null : readUTF8(v, c);
+        String[] implementedItfs = new String[readUnsignedShort(u + 6)];
+        w = 0;
+        u += 8;
+        for (i = 0; i < implementedItfs.length; ++i) {
+            implementedItfs[i] = readClass(u, c);
+            u += 2;
+        }
+
+        boolean skipCode = (flags & SKIP_CODE) != 0;
+        boolean skipDebug = (flags & SKIP_DEBUG) != 0;
+        boolean unzip = (flags & EXPAND_FRAMES) != 0;
+
+        // skips fields and methods
+        v = u;
+        i = readUnsignedShort(v);
+        v += 2;
+        for (; i > 0; --i) {
+            j = readUnsignedShort(v + 6);
+            v += 8;
+            for (; j > 0; --j) {
+                v += 6 + readInt(v + 2);
+            }
+        }
+        i = readUnsignedShort(v);
+        v += 2;
+        for (; i > 0; --i) {
+            j = readUnsignedShort(v + 6);
+            v += 8;
+            for (; j > 0; --j) {
+                v += 6 + readInt(v + 2);
+            }
+        }
+        // reads the class's attributes
+        signature = null;
+        String sourceFile = null;
+        String sourceDebug = null;
+        String enclosingOwner = null;
+        String enclosingName = null;
+        String enclosingDesc = null;
+
+        i = readUnsignedShort(v);
+        v += 2;
+        for (; i > 0; --i) {
+            attrName = readUTF8(v, c);
+            // tests are sorted in decreasing frequency order
+            // (based on frequencies observed on typical classes)
+            if ("SourceFile".equals(attrName)) {
+                sourceFile = readUTF8(v + 6, c);
+            } else if ("InnerClasses".equals(attrName)) {
+                w = v + 6;
+            } else if ("EnclosingMethod".equals(attrName)) {
+                enclosingOwner = readClass(v + 6, c);
+                int item = readUnsignedShort(v + 8);
+                if (item != 0) {
+                    enclosingName = readUTF8(items[item], c);
+                    enclosingDesc = readUTF8(items[item] + 2, c);
+                }
+            } else if (SIGNATURES && "Signature".equals(attrName)) {
+                signature = readUTF8(v + 6, c);
+            } else if (ANNOTATIONS && "RuntimeVisibleAnnotations".equals(attrName)) {
+                anns = v + 6;
+            } else if ("Deprecated".equals(attrName)) {
+                access |= Opcodes.ACC_DEPRECATED;
+            } else if ("Synthetic".equals(attrName)) {
+                access |= Opcodes.ACC_SYNTHETIC;
+            } else if ("SourceDebugExtension".equals(attrName)) {
+                int len = readInt(v + 2);
+                sourceDebug = readUTF(v + 6, len, new char[len]);
+            } else if (ANNOTATIONS && "RuntimeInvisibleAnnotations".equals(attrName)) {
+                ianns = v + 6;
+            } else {
+                attr = readAttribute(attrs,
+                        attrName,
+                        v + 6,
+                        readInt(v + 2),
+                        c,
+                        -1,
+                        null);
+                if (attr != null) {
+                    attr.next = cattrs;
+                    cattrs = attr;
+                }
+            }
+            v += 6 + readInt(v + 2);
+        }
+        // calls the visit method
+        classVisitor.visit(readInt(4),
+                access,
+                name,
+                signature,
+                superClassName,
+                implementedItfs);
+
+        // calls the visitSource method
+        if (!skipDebug && (sourceFile != null || sourceDebug != null)) {
+            classVisitor.visitSource(sourceFile, sourceDebug);
+        }
+
+        // calls the visitOuterClass method
+        if (enclosingOwner != null) {
+            classVisitor.visitOuterClass(enclosingOwner,
+                    enclosingName,
+                    enclosingDesc);
+        }
+
+        // visits the class annotations
+        if (ANNOTATIONS) {
+            for (i = 1; i >= 0; --i) {
+                v = i == 0 ? ianns : anns;
+                if (v != 0) {
+                    j = readUnsignedShort(v);
+                    v += 2;
+                    for (; j > 0; --j) {
+                        v = readAnnotationValues(v + 2,
+                                c,
+                                true,
+                                classVisitor.visitAnnotation(readUTF8(v, c), i != 0));
+                    }
+                }
+            }
+        }
+
+        // visits the class attributes
+        while (cattrs != null) {
+            attr = cattrs.next;
+            cattrs.next = null;
+            classVisitor.visitAttribute(cattrs);
+            cattrs = attr;
+        }
+
+        // calls the visitInnerClass method
+        if (w != 0) {
+            i = readUnsignedShort(w);
+            w += 2;
+            for (; i > 0; --i) {
+                classVisitor.visitInnerClass(readUnsignedShort(w) == 0
+                        ? null
+                        : readClass(w, c), readUnsignedShort(w + 2) == 0
+                        ? null
+                        : readClass(w + 2, c), readUnsignedShort(w + 4) == 0
+                        ? null
+                        : readUTF8(w + 4, c), readUnsignedShort(w + 6));
+                w += 8;
+            }
+        }
+
+        // visits the fields
+        i = readUnsignedShort(u);
+        u += 2;
+        for (; i > 0; --i) {
+            access = readUnsignedShort(u);
+            name = readUTF8(u + 2, c);
+            desc = readUTF8(u + 4, c);
+            // visits the field's attributes and looks for a ConstantValue
+            // attribute
+            int fieldValueItem = 0;
+            signature = null;
+            anns = 0;
+            ianns = 0;
+            cattrs = null;
+
+            j = readUnsignedShort(u + 6);
+            u += 8;
+            for (; j > 0; --j) {
+                attrName = readUTF8(u, c);
+                // tests are sorted in decreasing frequency order
+                // (based on frequencies observed on typical classes)
+                if ("ConstantValue".equals(attrName)) {
+                    fieldValueItem = readUnsignedShort(u + 6);
+                } else if (SIGNATURES && "Signature".equals(attrName)) {
+                    signature = readUTF8(u + 6, c);
+                } else if ("Deprecated".equals(attrName)) {
+                    access |= Opcodes.ACC_DEPRECATED;
+                } else if ("Synthetic".equals(attrName)) {
+                    access |= Opcodes.ACC_SYNTHETIC;
+                } else if (ANNOTATIONS && "RuntimeVisibleAnnotations".equals(attrName)) {
+                    anns = u + 6;
+                } else if (ANNOTATIONS && "RuntimeInvisibleAnnotations".equals(attrName)) {
+                    ianns = u + 6;
+                } else {
+                    attr = readAttribute(attrs,
+                            attrName,
+                            u + 6,
+                            readInt(u + 2),
+                            c,
+                            -1,
+                            null);
+                    if (attr != null) {
+                        attr.next = cattrs;
+                        cattrs = attr;
+                    }
+                }
+                u += 6 + readInt(u + 2);
+            }
+            // visits the field
+            FieldVisitor fv = classVisitor.visitField(access,
+                    name,
+                    desc,
+                    signature,
+                    fieldValueItem == 0 ? null : readConst(fieldValueItem, c));
+            // visits the field annotations and attributes
+            if (fv != null) {
+                if (ANNOTATIONS) {
+                    for (j = 1; j >= 0; --j) {
+                        v = j == 0 ? ianns : anns;
+                        if (v != 0) {
+                            k = readUnsignedShort(v);
+                            v += 2;
+                            for (; k > 0; --k) {
+                                v = readAnnotationValues(v + 2,
+                                        c,
+                                        true,
+                                        fv.visitAnnotation(readUTF8(v, c), j != 0));
+                            }
+                        }
+                    }
+                }
+                while (cattrs != null) {
+                    attr = cattrs.next;
+                    cattrs.next = null;
+                    fv.visitAttribute(cattrs);
+                    cattrs = attr;
+                }
+                fv.visitEnd();
+            }
+        }
+
+        // visits the methods
+        i = readUnsignedShort(u);
+        u += 2;
+        for (; i > 0; --i) {
+            int u0 = u + 6;
+            access = readUnsignedShort(u);
+            name = readUTF8(u + 2, c);
+            desc = readUTF8(u + 4, c);
+            signature = null;
+            anns = 0;
+            ianns = 0;
+            int dann = 0;
+            int mpanns = 0;
+            int impanns = 0;
+            cattrs = null;
+            v = 0;
+            w = 0;
+
+            // looks for Code and Exceptions attributes
+            j = readUnsignedShort(u + 6);
+            u += 8;
+            for (; j > 0; --j) {
+                attrName = readUTF8(u, c);
+                int attrSize = readInt(u + 2);
+                u += 6;
+                // tests are sorted in decreasing frequency order
+                // (based on frequencies observed on typical classes)
+                if ("Code".equals(attrName)) {
+                    if (!skipCode) {
+                        v = u;
+                    }
+                } else if ("Exceptions".equals(attrName)) {
+                    w = u;
+                } else if (SIGNATURES && "Signature".equals(attrName)) {
+                    signature = readUTF8(u, c);
+                } else if ("Deprecated".equals(attrName)) {
+                    access |= Opcodes.ACC_DEPRECATED;
+                } else if (ANNOTATIONS && "RuntimeVisibleAnnotations".equals(attrName)) {
+                    anns = u;
+                } else if (ANNOTATIONS && "AnnotationDefault".equals(attrName)) {
+                    dann = u;
+                } else if ("Synthetic".equals(attrName)) {
+                    access |= Opcodes.ACC_SYNTHETIC;
+                } else if (ANNOTATIONS && "RuntimeInvisibleAnnotations".equals(attrName)) {
+                    ianns = u;
+                } else if (ANNOTATIONS && "RuntimeVisibleParameterAnnotations".equals(attrName))
+                {
+                    mpanns = u;
+                } else if (ANNOTATIONS && "RuntimeInvisibleParameterAnnotations".equals(attrName))
+                {
+                    impanns = u;
+                } else {
+                    attr = readAttribute(attrs,
+                            attrName,
+                            u,
+                            attrSize,
+                            c,
+                            -1,
+                            null);
+                    if (attr != null) {
+                        attr.next = cattrs;
+                        cattrs = attr;
+                    }
+                }
+                u += attrSize;
+            }
+            // reads declared exceptions
+            String[] exceptions;
+            if (w == 0) {
+                exceptions = null;
+            } else {
+                exceptions = new String[readUnsignedShort(w)];
+                w += 2;
+                for (j = 0; j < exceptions.length; ++j) {
+                    exceptions[j] = readClass(w, c);
+                    w += 2;
+                }
+            }
+
+            // visits the method's code, if any
+            MethodVisitor mv = classVisitor.visitMethod(access,
+                    name,
+                    desc,
+                    signature,
+                    exceptions);
+
+            if (mv != null) {
+                /*
+                 * if the returned MethodVisitor is in fact a MethodWriter, it
+                 * means there is no method adapter between the reader and the
+                 * writer. If, in addition, the writer's constant pool was
+                 * copied from this reader (mw.cw.cr == this), and the signature
+                 * and exceptions of the method have not been changed, then it
+                 * is possible to skip all visit events and just copy the
+                 * original code of the method to the writer (the access, name
+                 * and descriptor can have been changed, this is not important
+                 * since they are not copied as is from the reader).
+                 */
+                if (WRITER && mv instanceof MethodWriter) {
+                    MethodWriter mw = (MethodWriter) mv;
+                    if (mw.cw.cr == this) {
+                        if (signature == mw.signature) {
+                            boolean sameExceptions = false;
+                            if (exceptions == null) {
+                                sameExceptions = mw.exceptionCount == 0;
+                            } else {
+                                if (exceptions.length == mw.exceptionCount) {
+                                    sameExceptions = true;
+                                    for (j = exceptions.length - 1; j >= 0; --j)
+                                    {
+                                        w -= 2;
+                                        if (mw.exceptions[j] != readUnsignedShort(w))
+                                        {
+                                            sameExceptions = false;
+                                            break;
+                                        }
+                                    }
+                                }
+                            }
+                            if (sameExceptions) {
+                                /*
+                                 * we do not copy directly the code into
+                                 * MethodWriter to save a byte array copy
+                                 * operation. The real copy will be done in
+                                 * ClassWriter.toByteArray().
+                                 */
+                                mw.classReaderOffset = u0;
+                                mw.classReaderLength = u - u0;
+                                continue;
+                            }
+                        }
+                    }
+                }
+
+                if (ANNOTATIONS && dann != 0) {
+                    AnnotationVisitor dv = mv.visitAnnotationDefault();
+                    readAnnotationValue(dann, c, null, dv);
+                    if (dv != null) {
+                        dv.visitEnd();
+                    }
+                }
+                if (ANNOTATIONS) {
+                    for (j = 1; j >= 0; --j) {
+                        w = j == 0 ? ianns : anns;
+                        if (w != 0) {
+                            k = readUnsignedShort(w);
+                            w += 2;
+                            for (; k > 0; --k) {
+                                w = readAnnotationValues(w + 2,
+                                        c,
+                                        true,
+                                        mv.visitAnnotation(readUTF8(w, c), j != 0));
+                            }
+                        }
+                    }
+                }
+                if (ANNOTATIONS && mpanns != 0) {
+                    readParameterAnnotations(mpanns, desc, c, true, mv);
+                }
+                if (ANNOTATIONS && impanns != 0) {
+                    readParameterAnnotations(impanns, desc, c, false, mv);
+                }
+                while (cattrs != null) {
+                    attr = cattrs.next;
+                    cattrs.next = null;
+                    mv.visitAttribute(cattrs);
+                    cattrs = attr;
+                }
+            }
+
+            if (mv != null && v != 0) {
+                int maxStack = readUnsignedShort(v);
+                int maxLocals = readUnsignedShort(v + 2);
+                int codeLength = readInt(v + 4);
+                v += 8;
+
+                int codeStart = v;
+                int codeEnd = v + codeLength;
+
+                mv.visitCode();
+
+                // 1st phase: finds the labels
+                int label;
+                Label[] labels = new Label[codeLength + 2];
+                readLabel(codeLength + 1, labels);
+                while (v < codeEnd) {
+                    w = v - codeStart;
+                    int opcode = b[v] & 0xFF;
+                    switch (ClassWriter.TYPE[opcode]) {
+                        case ClassWriter.NOARG_INSN:
+                        case ClassWriter.IMPLVAR_INSN:
+                            v += 1;
+                            break;
+                        case ClassWriter.LABEL_INSN:
+                            readLabel(w + readShort(v + 1), labels);
+                            v += 3;
+                            break;
+                        case ClassWriter.LABELW_INSN:
+                            readLabel(w + readInt(v + 1), labels);
+                            v += 5;
+                            break;
+                        case ClassWriter.WIDE_INSN:
+                            opcode = b[v + 1] & 0xFF;
+                            if (opcode == Opcodes.IINC) {
+                                v += 6;
+                            } else {
+                                v += 4;
+                            }
+                            break;
+                        case ClassWriter.TABL_INSN:
+                            // skips 0 to 3 padding bytes*
+                            v = v + 4 - (w & 3);
+                            // reads instruction
+                            readLabel(w + readInt(v), labels);
+                            j = readInt(v + 8) - readInt(v + 4) + 1;
+                            v += 12;
+                            for (; j > 0; --j) {
+                                readLabel(w + readInt(v), labels);
+                                v += 4;
+                            }
+                            break;
+                        case ClassWriter.LOOK_INSN:
+                            // skips 0 to 3 padding bytes*
+                            v = v + 4 - (w & 3);
+                            // reads instruction
+                            readLabel(w + readInt(v), labels);
+                            j = readInt(v + 4);
+                            v += 8;
+                            for (; j > 0; --j) {
+                                readLabel(w + readInt(v + 4), labels);
+                                v += 8;
+                            }
+                            break;
+                        case ClassWriter.VAR_INSN:
+                        case ClassWriter.SBYTE_INSN:
+                        case ClassWriter.LDC_INSN:
+                            v += 2;
+                            break;
+                        case ClassWriter.SHORT_INSN:
+                        case ClassWriter.LDCW_INSN:
+                        case ClassWriter.FIELDORMETH_INSN:
+                        case ClassWriter.TYPE_INSN:
+                        case ClassWriter.IINC_INSN:
+                            v += 3;
+                            break;
+                        case ClassWriter.ITFMETH_INSN:
+                            v += 5;
+                            break;
+                        // case MANA_INSN:
+                        default:
+                            v += 4;
+                            break;
+                    }
+                }
+                // parses the try catch entries
+                j = readUnsignedShort(v);
+                v += 2;
+                for (; j > 0; --j) {
+                    Label start = readLabel(readUnsignedShort(v), labels);
+                    Label end = readLabel(readUnsignedShort(v + 2), labels);
+                    Label handler = readLabel(readUnsignedShort(v + 4), labels);
+                    int type = readUnsignedShort(v + 6);
+                    if (type == 0) {
+                        mv.visitTryCatchBlock(start, end, handler, null);
+                    } else {
+                        mv.visitTryCatchBlock(start,
+                                end,
+                                handler,
+                                readUTF8(items[type], c));
+                    }
+                    v += 8;
+                }
+                // parses the local variable, line number tables, and code
+                // attributes
+                int varTable = 0;
+                int varTypeTable = 0;
+                int stackMap = 0;
+                int frameCount = 0;
+                int frameMode = 0;
+                int frameOffset = 0;
+                int frameLocalCount = 0;
+                int frameLocalDiff = 0;
+                int frameStackCount = 0;
+                Object[] frameLocal = null;
+                Object[] frameStack = null;
+                boolean zip = true;
+                cattrs = null;
+                j = readUnsignedShort(v);
+                v += 2;
+                for (; j > 0; --j) {
+                    attrName = readUTF8(v, c);
+                    if ("LocalVariableTable".equals(attrName)) {
+                        if (!skipDebug) {
+                            varTable = v + 6;
+                            k = readUnsignedShort(v + 6);
+                            w = v + 8;
+                            for (; k > 0; --k) {
+                                label = readUnsignedShort(w);
+                                if (labels[label] == null) {
+                                    readLabel(label, labels).status |= Label.DEBUG;
+                                }
+                                label += readUnsignedShort(w + 2);
+                                if (labels[label] == null) {
+                                    readLabel(label, labels).status |= Label.DEBUG;
+                                }
+                                w += 10;
+                            }
+                        }
+                    } else if ("LocalVariableTypeTable".equals(attrName)) {
+                        varTypeTable = v + 6;
+                    } else if ("LineNumberTable".equals(attrName)) {
+                        if (!skipDebug) {
+                            k = readUnsignedShort(v + 6);
+                            w = v + 8;
+                            for (; k > 0; --k) {
+                                label = readUnsignedShort(w);
+                                if (labels[label] == null) {
+                                    readLabel(label, labels).status |= Label.DEBUG;
+                                }
+                                labels[label].line = readUnsignedShort(w + 2);
+                                w += 4;
+                            }
+                        }
+                    } else if (FRAMES && "StackMapTable".equals(attrName)) {
+                        if ((flags & SKIP_FRAMES) == 0) {
+                            stackMap = v + 8;
+                            frameCount = readUnsignedShort(v + 6);
+                        }
+                        /*
+                         * here we do not extract the labels corresponding to
+                         * the attribute content. This would require a full
+                         * parsing of the attribute, which would need to be
+                         * repeated in the second phase (see below). Instead the
+                         * content of the attribute is read one frame at a time
+                         * (i.e. after a frame has been visited, the next frame
+                         * is read), and the labels it contains are also
+                         * extracted one frame at a time. Thanks to the ordering
+                         * of frames, having only a "one frame lookahead" is not
+                         * a problem, i.e. it is not possible to see an offset
+                         * smaller than the offset of the current insn and for
+                         * which no Label exist.
+                         */
+                        // TODO true for frame offsets,
+                        // but for UNINITIALIZED type offsets?
+                    } else if (FRAMES && "StackMap".equals(attrName)) {
+                        if ((flags & SKIP_FRAMES) == 0) {
+                            stackMap = v + 8;
+                            frameCount = readUnsignedShort(v + 6);
+                            zip = false;
+                        }
+                        /*
+                         * IMPORTANT! here we assume that the frames are
+                         * ordered, as in the StackMapTable attribute, although
+                         * this is not guaranteed by the attribute format.
+                         */
+                    } else {
+                        for (k = 0; k < attrs.length; ++k) {
+                            if (attrs[k].type.equals(attrName)) {
+                                attr = attrs[k].read(this,
+                                        v + 6,
+                                        readInt(v + 2),
+                                        c,
+                                        codeStart - 8,
+                                        labels);
+                                if (attr != null) {
+                                    attr.next = cattrs;
+                                    cattrs = attr;
+                                }
+                            }
+                        }
+                    }
+                    v += 6 + readInt(v + 2);
+                }
+
+                // 2nd phase: visits each instruction
+                if (FRAMES && stackMap != 0) {
+                    // creates the very first (implicit) frame from the method
+                    // descriptor
+                    frameLocal = new Object[maxLocals];
+                    frameStack = new Object[maxStack];
+                    if (unzip) {
+                        int local = 0;
+                        if ((access & Opcodes.ACC_STATIC) == 0) {
+                            if ("<init>".equals(name)) {
+                                frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;
+                            } else {
+                                frameLocal[local++] = readClass(header + 2, c);
+                            }
+                        }
+                        j = 1;
+                        loop: while (true) {
+                            k = j;
+                            switch (desc.charAt(j++)) {
+                                case 'Z':
+                                case 'C':
+                                case 'B':
+                                case 'S':
+                                case 'I':
+                                    frameLocal[local++] = Opcodes.INTEGER;
+                                    break;
+                                case 'F':
+                                    frameLocal[local++] = Opcodes.FLOAT;
+                                    break;
+                                case 'J':
+                                    frameLocal[local++] = Opcodes.LONG;
+                                    break;
+                                case 'D':
+                                    frameLocal[local++] = Opcodes.DOUBLE;
+                                    break;
+                                case '[':
+                                    while (desc.charAt(j) == '[') {
+                                        ++j;
+                                    }
+                                    if (desc.charAt(j) == 'L') {
+                                        ++j;
+                                        while (desc.charAt(j) != ';') {
+                                            ++j;
+                                        }
+                                    }
+                                    frameLocal[local++] = desc.substring(k, ++j);
+                                    break;
+                                case 'L':
+                                    while (desc.charAt(j) != ';') {
+                                        ++j;
+                                    }
+                                    frameLocal[local++] = desc.substring(k + 1,
+                                            j++);
+                                    break;
+                                default:
+                                    break loop;
+                            }
+                        }
+                        frameLocalCount = local;
+                    }
+                    /*
+                     * for the first explicit frame the offset is not
+                     * offset_delta + 1 but only offset_delta; setting the
+                     * implicit frame offset to -1 allow the use of the
+                     * "offset_delta + 1" rule in all cases
+                     */
+                    frameOffset = -1;
+                }
+                v = codeStart;
+                Label l;
+                while (v < codeEnd) {
+                    w = v - codeStart;
+
+                    l = labels[w];
+                    if (l != null) {
+                        mv.visitLabel(l);
+                        if (!skipDebug && l.line > 0) {
+                            mv.visitLineNumber(l.line, l);
+                        }
+                    }
+
+                    while (FRAMES && frameLocal != null
+                            && (frameOffset == w || frameOffset == -1))
+                    {
+                        // if there is a frame for this offset,
+                        // makes the visitor visit it,
+                        // and reads the next frame if there is one.
+                        if (!zip || unzip) {
+                            mv.visitFrame(Opcodes.F_NEW,
+                                    frameLocalCount,
+                                    frameLocal,
+                                    frameStackCount,
+                                    frameStack);
+                        } else if (frameOffset != -1) {
+                            mv.visitFrame(frameMode,
+                                    frameLocalDiff,
+                                    frameLocal,
+                                    frameStackCount,
+                                    frameStack);
+                        }
+
+                        if (frameCount > 0) {
+                            int tag, delta, n;
+                            if (zip) {
+                                tag = b[stackMap++] & 0xFF;
+                            } else {
+                                tag = MethodWriter.FULL_FRAME;
+                                frameOffset = -1;
+                            }
+                            frameLocalDiff = 0;
+                            if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME)
+                            {
+                                delta = tag;
+                                frameMode = Opcodes.F_SAME;
+                                frameStackCount = 0;
+                            } else if (tag < MethodWriter.RESERVED) {
+                                delta = tag
+                                        - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;
+                                stackMap = readFrameType(frameStack,
+                                        0,
+                                        stackMap,
+                                        c,
+                                        labels);
+                                frameMode = Opcodes.F_SAME1;
+                                frameStackCount = 1;
+                            } else {
+                                delta = readUnsignedShort(stackMap);
+                                stackMap += 2;
+                                if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)
+                                {
+                                    stackMap = readFrameType(frameStack,
+                                            0,
+                                            stackMap,
+                                            c,
+                                            labels);
+                                    frameMode = Opcodes.F_SAME1;
+                                    frameStackCount = 1;
+                                } else if (tag >= MethodWriter.CHOP_FRAME
+                                        && tag < MethodWriter.SAME_FRAME_EXTENDED)
+                                {
+                                    frameMode = Opcodes.F_CHOP;
+                                    frameLocalDiff = MethodWriter.SAME_FRAME_EXTENDED
+                                            - tag;
+                                    frameLocalCount -= frameLocalDiff;
+                                    frameStackCount = 0;
+                                } else if (tag == MethodWriter.SAME_FRAME_EXTENDED)
+                                {
+                                    frameMode = Opcodes.F_SAME;
+                                    frameStackCount = 0;
+                                } else if (tag < MethodWriter.FULL_FRAME) {
+                                    j = unzip ? frameLocalCount : 0;
+                                    for (k = tag
+                                            - MethodWriter.SAME_FRAME_EXTENDED; k > 0; k--)
+                                    {
+                                        stackMap = readFrameType(frameLocal,
+                                                j++,
+                                                stackMap,
+                                                c,
+                                                labels);
+                                    }
+                                    frameMode = Opcodes.F_APPEND;
+                                    frameLocalDiff = tag
+                                            - MethodWriter.SAME_FRAME_EXTENDED;
+                                    frameLocalCount += frameLocalDiff;
+                                    frameStackCount = 0;
+                                } else { // if (tag == FULL_FRAME) {
+                                    frameMode = Opcodes.F_FULL;
+                                    n = frameLocalDiff = frameLocalCount = readUnsignedShort(stackMap);
+                                    stackMap += 2;
+                                    for (j = 0; n > 0; n--) {
+                                        stackMap = readFrameType(frameLocal,
+                                                j++,
+                                                stackMap,
+                                                c,
+                                                labels);
+                                    }
+                                    n = frameStackCount = readUnsignedShort(stackMap);
+                                    stackMap += 2;
+                                    for (j = 0; n > 0; n--) {
+                                        stackMap = readFrameType(frameStack,
+                                                j++,
+                                                stackMap,
+                                                c,
+                                                labels);
+                                    }
+                                }
+                            }
+                            frameOffset += delta + 1;
+                            readLabel(frameOffset, labels);
+
+                            --frameCount;
+                        } else {
+                            frameLocal = null;
+                        }
+                    }
+
+                    int opcode = b[v] & 0xFF;
+                    switch (ClassWriter.TYPE[opcode]) {
+                        case ClassWriter.NOARG_INSN:
+                            mv.visitInsn(opcode);
+                            v += 1;
+                            break;
+                        case ClassWriter.IMPLVAR_INSN:
+                            if (opcode > Opcodes.ISTORE) {
+                                opcode -= 59; // ISTORE_0
+                                mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2),
+                                        opcode & 0x3);
+                            } else {
+                                opcode -= 26; // ILOAD_0
+                                mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2),
+                                        opcode & 0x3);
+                            }
+                            v += 1;
+                            break;
+                        case ClassWriter.LABEL_INSN:
+                            mv.visitJumpInsn(opcode, labels[w
+                                    + readShort(v + 1)]);
+                            v += 3;
+                            break;
+                        case ClassWriter.LABELW_INSN:
+                            mv.visitJumpInsn(opcode - 33, labels[w
+                                    + readInt(v + 1)]);
+                            v += 5;
+                            break;
+                        case ClassWriter.WIDE_INSN:
+                            opcode = b[v + 1] & 0xFF;
+                            if (opcode == Opcodes.IINC) {
+                                mv.visitIincInsn(readUnsignedShort(v + 2),
+                                        readShort(v + 4));
+                                v += 6;
+                            } else {
+                                mv.visitVarInsn(opcode,
+                                        readUnsignedShort(v + 2));
+                                v += 4;
+                            }
+                            break;
+                        case ClassWriter.TABL_INSN:
+                            // skips 0 to 3 padding bytes
+                            v = v + 4 - (w & 3);
+                            // reads instruction
+                            label = w + readInt(v);
+                            int min = readInt(v + 4);
+                            int max = readInt(v + 8);
+                            v += 12;
+                            Label[] table = new Label[max - min + 1];
+                            for (j = 0; j < table.length; ++j) {
+                                table[j] = labels[w + readInt(v)];
+                                v += 4;
+                            }
+                            mv.visitTableSwitchInsn(min,
+                                    max,
+                                    labels[label],
+                                    table);
+                            break;
+                        case ClassWriter.LOOK_INSN:
+                            // skips 0 to 3 padding bytes
+                            v = v + 4 - (w & 3);
+                            // reads instruction
+                            label = w + readInt(v);
+                            j = readInt(v + 4);
+                            v += 8;
+                            int[] keys = new int[j];
+                            Label[] values = new Label[j];
+                            for (j = 0; j < keys.length; ++j) {
+                                keys[j] = readInt(v);
+                                values[j] = labels[w + readInt(v + 4)];
+                                v += 8;
+                            }
+                            mv.visitLookupSwitchInsn(labels[label],
+                                    keys,
+                                    values);
+                            break;
+                        case ClassWriter.VAR_INSN:
+                            mv.visitVarInsn(opcode, b[v + 1] & 0xFF);
+                            v += 2;
+                            break;
+                        case ClassWriter.SBYTE_INSN:
+                            mv.visitIntInsn(opcode, b[v + 1]);
+                            v += 2;
+                            break;
+                        case ClassWriter.SHORT_INSN:
+                            mv.visitIntInsn(opcode, readShort(v + 1));
+                            v += 3;
+                            break;
+                        case ClassWriter.LDC_INSN:
+                            mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));
+                            v += 2;
+                            break;
+                        case ClassWriter.LDCW_INSN:
+                            mv.visitLdcInsn(readConst(readUnsignedShort(v + 1),
+                                    c));
+                            v += 3;
+                            break;
+                        case ClassWriter.FIELDORMETH_INSN:
+                        case ClassWriter.ITFMETH_INSN:
+                            int cpIndex = items[readUnsignedShort(v + 1)];
+                            String iowner = readClass(cpIndex, c);
+                            cpIndex = items[readUnsignedShort(cpIndex + 2)];
+                            String iname = readUTF8(cpIndex, c);
+                            String idesc = readUTF8(cpIndex + 2, c);
+                            if (opcode < Opcodes.INVOKEVIRTUAL) {
+                                mv.visitFieldInsn(opcode, iowner, iname, idesc);
+                            } else {
+                                mv.visitMethodInsn(opcode, iowner, iname, idesc);
+                            }
+                            if (opcode == Opcodes.INVOKEINTERFACE) {
+                                v += 5;
+                            } else {
+                                v += 3;
+                            }
+                            break;
+                        case ClassWriter.TYPE_INSN:
+                            mv.visitTypeInsn(opcode, readClass(v + 1, c));
+                            v += 3;
+                            break;
+                        case ClassWriter.IINC_INSN:
+                            mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);
+                            v += 3;
+                            break;
+                        // case MANA_INSN:
+                        default:
+                            mv.visitMultiANewArrayInsn(readClass(v + 1, c),
+                                    b[v + 3] & 0xFF);
+                            v += 4;
+                            break;
+                    }
+                }
+                l = labels[codeEnd - codeStart];
+                if (l != null) {
+                    mv.visitLabel(l);
+                }
+                // visits the local variable tables
+                if (!skipDebug && varTable != 0) {
+                    int[] typeTable = null;
+                    if (varTypeTable != 0) {
+                        k = readUnsignedShort(varTypeTable) * 3;
+                        w = varTypeTable + 2;
+                        typeTable = new int[k];
+                        while (k > 0) {
+                            typeTable[--k] = w + 6; // signature
+                            typeTable[--k] = readUnsignedShort(w + 8); // index
+                            typeTable[--k] = readUnsignedShort(w); // start
+                            w += 10;
+                        }
+                    }
+                    k = readUnsignedShort(varTable);
+                    w = varTable + 2;
+                    for (; k > 0; --k) {
+                        int start = readUnsignedShort(w);
+                        int length = readUnsignedShort(w + 2);
+                        int index = readUnsignedShort(w + 8);
+                        String vsignature = null;
+                        if (typeTable != null) {
+                            for (int a = 0; a < typeTable.length; a += 3) {
+                                if (typeTable[a] == start
+                                        && typeTable[a + 1] == index)
+                                {
+                                    vsignature = readUTF8(typeTable[a + 2], c);
+                                    break;
+                                }
+                            }
+                        }
+                        mv.visitLocalVariable(readUTF8(w + 4, c),
+                                readUTF8(w + 6, c),
+                                vsignature,
+                                labels[start],
+                                labels[start + length],
+                                index);
+                        w += 10;
+                    }
+                }
+                // visits the other attributes
+                while (cattrs != null) {
+                    attr = cattrs.next;
+                    cattrs.next = null;
+                    mv.visitAttribute(cattrs);
+                    cattrs = attr;
+                }
+                // visits the max stack and max locals values
+                mv.visitMaxs(maxStack, maxLocals);
+            }
+
+            if (mv != null) {
+                mv.visitEnd();
+            }
+        }
+
+        // visits the end of the class
+        classVisitor.visitEnd();
+    }
+
+    /**
+     * Reads parameter annotations and makes the given visitor visit them.
+     *
+     * @param v start offset in {@link #b b} of the annotations to be read.
+     * @param desc the method descriptor.
+     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},
+     *        {@link #readClass(int,char[]) readClass} or
+     *        {@link #readConst readConst}.
+     * @param visible <tt>true</tt> if the annotations to be read are visible
+     *        at runtime.
+     * @param mv the visitor that must visit the annotations.
+     */
+    private void readParameterAnnotations(
+        int v,
+        final String desc,
+        final char[] buf,
+        final boolean visible,
+        final MethodVisitor mv)
+    {
+        int i;
+        int n = b[v++] & 0xFF;
+        // workaround for a bug in javac (javac compiler generates a parameter
+        // annotation array whose size is equal to the number of parameters in
+        // the Java source file, while it should generate an array whose size is
+        // equal to the number of parameters in the method descriptor - which
+        // includes the synthetic parameters added by the compiler). This work-
+        // around supposes that the synthetic parameters are the first ones.
+        int synthetics = Type.getArgumentTypes(desc).length - n;
+        AnnotationVisitor av;
+        for (i = 0; i < synthetics; ++i) {
+            // virtual annotation to detect synthetic parameters in MethodWriter
+            av = mv.visitParameterAnnotation(i, "Ljava/lang/Synthetic;", false);
+            if (av != null) {
+                av.visitEnd();
+            }
+        }
+        for (; i < n + synthetics; ++i) {
+            int j = readUnsignedShort(v);
+            v += 2;
+            for (; j > 0; --j) {
+                av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);
+                v = readAnnotationValues(v + 2, buf, true, av);
+            }
+        }
+    }
+
+    /**
+     * Reads the values of an annotation and makes the given visitor visit them.
+     *
+     * @param v the start offset in {@link #b b} of the values to be read
+     *        (including the unsigned short that gives the number of values).
+     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},
+     *        {@link #readClass(int,char[]) readClass} or
+     *        {@link #readConst readConst}.
+     * @param named if the annotation values are named or not.
+     * @param av the visitor that must visit the values.
+     * @return the end offset of the annotation values.
+     */
+    private int readAnnotationValues(
+        int v,
+        final char[] buf,
+        final boolean named,
+        final AnnotationVisitor av)
+    {
+        int i = readUnsignedShort(v);
+        v += 2;
+        if (named) {
+            for (; i > 0; --i) {
+                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);
+            }
+        } else {
+            for (; i > 0; --i) {
+                v = readAnnotationValue(v, buf, null, av);
+            }
+        }
+        if (av != null) {
+            av.visitEnd();
+        }
+        return v;
+    }
+
+    /**
+     * Reads a value of an annotation and makes the given visitor visit it.
+     *
+     * @param v the start offset in {@link #b b} of the value to be read (<i>not
+     *        including the value name constant pool index</i>).
+     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},
+     *        {@link #readClass(int,char[]) readClass} or
+     *        {@link #readConst readConst}.
+     * @param name the name of the value to be read.
+     * @param av the visitor that must visit the value.
+     * @return the end offset of the annotation value.
+     */
+    private int readAnnotationValue(
+        int v,
+        final char[] buf,
+        final String name,
+        final AnnotationVisitor av)
+    {
+        int i;
+        if (av == null) {
+            switch (b[v] & 0xFF) {
+                case 'e': // enum_const_value
+                    return v + 5;
+                case '@': // annotation_value
+                    return readAnnotationValues(v + 3, buf, true, null);
+                case '[': // array_value
+                    return readAnnotationValues(v + 1, buf, false, null);
+                default:
+                    return v + 3;
+            }
+        }
+        switch (b[v++] & 0xFF) {
+            case 'I': // pointer to CONSTANT_Integer
+            case 'J': // pointer to CONSTANT_Long
+            case 'F': // pointer to CONSTANT_Float
+            case 'D': // pointer to CONSTANT_Double
+                av.visit(name, readConst(readUnsignedShort(v), buf));
+                v += 2;
+                break;
+            case 'B': // pointer to CONSTANT_Byte
+                av.visit(name,
+                        new Byte((byte) readInt(items[readUnsignedShort(v)])));
+                v += 2;
+                break;
+            case 'Z': // pointer to CONSTANT_Boolean
+                av.visit(name, readInt(items[readUnsignedShort(v)]) == 0
+                        ? Boolean.FALSE
+                        : Boolean.TRUE);
+                v += 2;
+                break;
+            case 'S': // pointer to CONSTANT_Short
+                av.visit(name,
+                        new Short((short) readInt(items[readUnsignedShort(v)])));
+                v += 2;
+                break;
+            case 'C': // pointer to CONSTANT_Char
+                av.visit(name,
+                        new Character((char) readInt(items[readUnsignedShort(v)])));
+                v += 2;
+                break;
+            case 's': // pointer to CONSTANT_Utf8
+                av.visit(name, readUTF8(v, buf));
+                v += 2;
+                break;
+            case 'e': // enum_const_value
+                av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));
+                v += 4;
+                break;
+            case 'c': // class_info
+                av.visit(name, Type.getType(readUTF8(v, buf)));
+                v += 2;
+                break;
+            case '@': // annotation_value
+                v = readAnnotationValues(v + 2,
+                        buf,
+                        true,
+                        av.visitAnnotation(name, readUTF8(v, buf)));
+                break;
+            case '[': // array_value
+                int size = readUnsignedShort(v);
+                v += 2;
+                if (size == 0) {
+                    return readAnnotationValues(v - 2,
+                            buf,
+                            false,
+                            av.visitArray(name));
+                }
+                switch (this.b[v++] & 0xFF) {
+                    case 'B':
+                        byte[] bv = new byte[size];
+                        for (i = 0; i < size; i++) {
+                            bv[i] = (byte) readInt(items[readUnsignedShort(v)]);
+                            v += 3;
+                        }
+                        av.visit(name, bv);
+                        --v;
+                        break;
+                    case 'Z':
+                        boolean[] zv = new boolean[size];
+                        for (i = 0; i < size; i++) {
+                            zv[i] = readInt(items[readUnsignedShort(v)]) != 0;
+                            v += 3;
+                        }
+                        av.visit(name, zv);
+                        --v;
+                        break;
+                    case 'S':
+                        short[] sv = new short[size];
+                        for (i = 0; i < size; i++) {
+                            sv[i] = (short) readInt(items[readUnsignedShort(v)]);
+                            v += 3;
+                        }
+                        av.visit(name, sv);
+                        --v;
+                        break;
+                    case 'C':
+                        char[] cv = new char[size];
+                        for (i = 0; i < size; i++) {
+                            cv[i] = (char) readInt(items[readUnsignedShort(v)]);
+                            v += 3;
+                        }
+                        av.visit(name, cv);
+                        --v;
+                        break;
+                    case 'I':
+                        int[] iv = new int[size];
+                        for (i = 0; i < size; i++) {
+                            iv[i] = readInt(items[readUnsignedShort(v)]);
+                            v += 3;
+                        }
+                        av.visit(name, iv);
+                        --v;
+                        break;
+                    case 'J':
+                        long[] lv = new long[size];
+                        for (i = 0; i < size; i++) {
+                            lv[i] = readLong(items[readUnsignedShort(v)]);
+                            v += 3;
+                        }
+                        av.visit(name, lv);
+                        --v;
+                        break;
+                    case 'F':
+                        float[] fv = new float[size];
+                        for (i = 0; i < size; i++) {
+                            fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));
+                            v += 3;
+                        }
+                        av.visit(name, fv);
+                        --v;
+                        break;
+                    case 'D':
+                        double[] dv = new double[size];
+                        for (i = 0; i < size; i++) {
+                            dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));
+                            v += 3;
+                        }
+                        av.visit(name, dv);
+                        --v;
+                        break;
+                    default:
+                        v = readAnnotationValues(v - 3,
+                                buf,
+                                false,
+                                av.visitArray(name));
+                }
+        }
+        return v;
+    }
+
+    private int readFrameType(
+        final Object[] frame,
+        final int index,
+        int v,
+        final char[] buf,
+        final Label[] labels)
+    {
+        int type = b[v++] & 0xFF;
+        switch (type) {
+            case 0:
+                frame[index] = Opcodes.TOP;
+                break;
+            case 1:
+                frame[index] = Opcodes.INTEGER;
+                break;
+            case 2:
+                frame[index] = Opcodes.FLOAT;
+                break;
+            case 3:
+                frame[index] = Opcodes.DOUBLE;
+                break;
+            case 4:
+                frame[index] = Opcodes.LONG;
+                break;
+            case 5:
+                frame[index] = Opcodes.NULL;
+                break;
+            case 6:
+                frame[index] = Opcodes.UNINITIALIZED_THIS;
+                break;
+            case 7: // Object
+                frame[index] = readClass(v, buf);
+                v += 2;
+                break;
+            default: // Uninitialized
+                frame[index] = readLabel(readUnsignedShort(v), labels);
+                v += 2;
+        }
+        return v;
+    }
+
+    /**
+     * Returns the label corresponding to the given offset. The default
+     * implementation of this method creates a label for the given offset if it
+     * has not been already created.
+     *
+     * @param offset a bytecode offset in a method.
+     * @param labels the already created labels, indexed by their offset. If a
+     *        label already exists for offset this method must not create a new
+     *        one. Otherwise it must store the new label in this array.
+     * @return a non null Label, which must be equal to labels[offset].
+     */
+    protected Label readLabel(int offset, Label[] labels) {
+        if (labels[offset] == null) {
+            labels[offset] = new Label();
+        }
+        return labels[offset];
+    }
+
+    /**
+     * Reads an attribute in {@link #b b}.
+     *
+     * @param attrs prototypes of the attributes that must be parsed during the
+     *        visit of the class. Any attribute whose type is not equal to the
+     *        type of one the prototypes is ignored (i.e. an empty
+     *        {@link Attribute} instance is returned).
+     * @param type the type of the attribute.
+     * @param off index of the first byte of the attribute's content in
+     *        {@link #b b}. The 6 attribute header bytes, containing the type
+     *        and the length of the attribute, are not taken into account here
+     *        (they have already been read).
+     * @param len the length of the attribute's content.
+     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},
+     *        {@link #readClass(int,char[]) readClass} or
+     *        {@link #readConst readConst}.
+     * @param codeOff index of the first byte of code's attribute content in
+     *        {@link #b b}, or -1 if the attribute to be read is not a code
+     *        attribute. The 6 attribute header bytes, containing the type and
+     *        the length of the attribute, are not taken into account here.
+     * @param labels the labels of the method's code, or <tt>null</tt> if the
+     *        attribute to be read is not a code attribute.
+     * @return the attribute that has been read, or <tt>null</tt> to skip this
+     *         attribute.
+     */
+    private Attribute readAttribute(
+        final Attribute[] attrs,
+        final String type,
+        final int off,
+        final int len,
+        final char[] buf,
+        final int codeOff,
+        final Label[] labels)
+    {
+        for (int i = 0; i < attrs.length; ++i) {
+            if (attrs[i].type.equals(type)) {
+                return attrs[i].read(this, off, len, buf, codeOff, labels);
+            }
+        }
+        return new Attribute(type).read(this, off, len, null, -1, null);
+    }
+
+    // ------------------------------------------------------------------------
+    // Utility methods: low level parsing
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns the start index of the constant pool item in {@link #b b}, plus
+     * one. <i>This method is intended for {@link Attribute} sub classes, and is
+     * normally not needed by class generators or adapters.</i>
+     *
+     * @param item the index a constant pool item.
+     * @return the start index of the constant pool item in {@link #b b}, plus
+     *         one.
+     */
+    public int getItem(final int item) {
+        return items[item];
+    }
+
+    /**
+     * Reads a byte value in {@link #b b}. <i>This method is intended for
+     * {@link Attribute} sub classes, and is normally not needed by class
+     * generators or adapters.</i>
+     *
+     * @param index the start index of the value to be read in {@link #b b}.
+     * @return the read value.
+     */
+    public int readByte(final int index) {
+        return b[index] & 0xFF;
+    }
+
+    /**
+     * Reads an unsigned short value in {@link #b b}. <i>This method is
+     * intended for {@link Attribute} sub classes, and is normally not needed by
+     * class generators or adapters.</i>
+     *
+     * @param index the start index of the value to be read in {@link #b b}.
+     * @return the read value.
+     */
+    public int readUnsignedShort(final int index) {
+        byte[] b = this.b;
+        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);
+    }
+
+    /**
+     * Reads a signed short value in {@link #b b}. <i>This method is intended
+     * for {@link Attribute} sub classes, and is normally not needed by class
+     * generators or adapters.</i>
+     *
+     * @param index the start index of the value to be read in {@link #b b}.
+     * @return the read value.
+     */
+    public short readShort(final int index) {
+        byte[] b = this.b;
+        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));
+    }
+
+    /**
+     * Reads a signed int value in {@link #b b}. <i>This method is intended for
+     * {@link Attribute} sub classes, and is normally not needed by class
+     * generators or adapters.</i>
+     *
+     * @param index the start index of the value to be read in {@link #b b}.
+     * @return the read value.
+     */
+    public int readInt(final int index) {
+        byte[] b = this.b;
+        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16)
+                | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);
+    }
+
+    /**
+     * Reads a signed long value in {@link #b b}. <i>This method is intended
+     * for {@link Attribute} sub classes, and is normally not needed by class
+     * generators or adapters.</i>
+     *
+     * @param index the start index of the value to be read in {@link #b b}.
+     * @return the read value.
+     */
+    public long readLong(final int index) {
+        long l1 = readInt(index);
+        long l0 = readInt(index + 4) & 0xFFFFFFFFL;
+        return (l1 << 32) | l0;
+    }
+
+    /**
+     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method
+     * is intended for {@link Attribute} sub classes, and is normally not needed
+     * by class generators or adapters.</i>
+     *
+     * @param index the start index of an unsigned short value in {@link #b b},
+     *        whose value is the index of an UTF8 constant pool item.
+     * @param buf buffer to be used to read the item. This buffer must be
+     *        sufficiently large. It is not automatically resized.
+     * @return the String corresponding to the specified UTF8 item.
+     */
+    public String readUTF8(int index, final char[] buf) {
+        int item = readUnsignedShort(index);
+        String s = strings[item];
+        if (s != null) {
+            return s;
+        }
+        index = items[item];
+        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);
+    }
+
+    /**
+     * Reads UTF8 string in {@link #b b}.
+     *
+     * @param index start offset of the UTF8 string to be read.
+     * @param utfLen length of the UTF8 string to be read.
+     * @param buf buffer to be used to read the string. This buffer must be
+     *        sufficiently large. It is not automatically resized.
+     * @return the String corresponding to the specified UTF8 string.
+     */
+    private String readUTF(int index, final int utfLen, final char[] buf) {
+        int endIndex = index + utfLen;
+        byte[] b = this.b;
+        int strLen = 0;
+        int c, d, e;
+        while (index < endIndex) {
+            c = b[index++] & 0xFF;
+            switch (c >> 4) {
+                case 0:
+                case 1:
+                case 2:
+                case 3:
+                case 4:
+                case 5:
+                case 6:
+                case 7:
+                    // 0xxxxxxx
+                    buf[strLen++] = (char) c;
+                    break;
+                case 12:
+                case 13:
+                    // 110x xxxx 10xx xxxx
+                    d = b[index++];
+                    buf[strLen++] = (char) (((c & 0x1F) << 6) | (d & 0x3F));
+                    break;
+                default:
+                    // 1110 xxxx 10xx xxxx 10xx xxxx
+                    d = b[index++];
+                    e = b[index++];
+                    buf[strLen++] = (char) (((c & 0x0F) << 12)
+                            | ((d & 0x3F) << 6) | (e & 0x3F));
+                    break;
+            }
+        }
+        return new String(buf, 0, strLen);
+    }
+
+    /**
+     * Reads a class constant pool item in {@link #b b}. <i>This method is
+     * intended for {@link Attribute} sub classes, and is normally not needed by
+     * class generators or adapters.</i>
+     *
+     * @param index the start index of an unsigned short value in {@link #b b},
+     *        whose value is the index of a class constant pool item.
+     * @param buf buffer to be used to read the item. This buffer must be
+     *        sufficiently large. It is not automatically resized.
+     * @return the String corresponding to the specified class item.
+     */
+    public String readClass(final int index, final char[] buf) {
+        // computes the start index of the CONSTANT_Class item in b
+        // and reads the CONSTANT_Utf8 item designated by
+        // the first two bytes of this CONSTANT_Class item
+        return readUTF8(items[readUnsignedShort(index)], buf);
+    }
+
+    /**
+     * Reads a numeric or string constant pool item in {@link #b b}. <i>This
+     * method is intended for {@link Attribute} sub classes, and is normally not
+     * needed by class generators or adapters.</i>
+     *
+     * @param item the index of a constant pool item.
+     * @param buf buffer to be used to read the item. This buffer must be
+     *        sufficiently large. It is not automatically resized.
+     * @return the {@link Integer}, {@link Float}, {@link Long},
+     *         {@link Double}, {@link String} or {@link Type} corresponding to
+     *         the given constant pool item.
+     */
+    public Object readConst(final int item, final char[] buf) {
+        int index = items[item];
+        switch (b[index - 1]) {
+            case ClassWriter.INT:
+                return new Integer(readInt(index));
+            case ClassWriter.FLOAT:
+                return new Float(Float.intBitsToFloat(readInt(index)));
+            case ClassWriter.LONG:
+                return new Long(readLong(index));
+            case ClassWriter.DOUBLE:
+                return new Double(Double.longBitsToDouble(readLong(index)));
+            case ClassWriter.CLASS:
+                return Type.getObjectType(readUTF8(index, buf));
+                // case ClassWriter.STR:
+            default:
+                return readUTF8(index, buf);
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:19:44 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/ClassVisitor.java	Tue Aug  4 10:19:43 2009
@@ -0,0 +1,226 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * A visitor to visit a Java class. The methods of this interface must be called
+ * in the following order: <tt>visit</tt> [ <tt>visitSource</tt> ] [
+ * <tt>visitOuterClass</tt> ] ( <tt>visitAnnotation</tt> |
+ * <tt>visitAttribute</tt> )* (<tt>visitInnerClass</tt> |
+ * <tt>visitField</tt> | <tt>visitMethod</tt> )* <tt>visitEnd</tt>.
+ *
+ * @author Eric Bruneton
+ */
+public interface ClassVisitor {
+
+    /**
+     * Visits the header of the class.
+     *
+     * @param version the class version.
+     * @param access the class's access flags (see {@link Opcodes}). This
+     *        parameter also indicates if the class is deprecated.
+     * @param name the internal name of the class (see
+     *        {@link Type#getInternalName() getInternalName}).
+     * @param signature the signature of this class. May be <tt>null</tt> if
+     *        the class is not a generic one, and does not extend or implement
+     *        generic classes or interfaces.
+     * @param superName the internal of name of the super class (see
+     *        {@link Type#getInternalName() getInternalName}). For interfaces,
+     *        the super class is {@link Object}. May be <tt>null</tt>, but
+     *        only for the {@link Object} class.
+     * @param interfaces the internal names of the class's interfaces (see
+     *        {@link Type#getInternalName() getInternalName}). May be
+     *        <tt>null</tt>.
+     */
+    void visit(
+        int version,
+        int access,
+        String name,
+        String signature,
+        String superName,
+        String[] interfaces);
+
+    /**
+     * Visits the source of the class.
+     *
+     * @param source the name of the source file from which the class was
+     *        compiled. May be <tt>null</tt>.
+     * @param debug additional debug information to compute the correspondance
+     *        between source and compiled elements of the class. May be
+     *        <tt>null</tt>.
+     */
+    void visitSource(String source, String debug);
+
+    /**
+     * Visits the enclosing class of the class. This method must be called only
+     * if the class has an enclosing class.
+     *
+     * @param owner internal name of the enclosing class of the class.
+     * @param name the name of the method that contains the class, or
+     *        <tt>null</tt> if the class is not enclosed in a method of its
+     *        enclosing class.
+     * @param desc the descriptor of the method that contains the class, or
+     *        <tt>null</tt> if the class is not enclosed in a method of its
+     *        enclosing class.
+     */
+    void visitOuterClass(String owner, String name, String desc);
+
+    /**
+     * Visits an annotation of the class.
+     *
+     * @param desc the class descriptor of the annotation class.
+     * @param visible <tt>true</tt> if the annotation is visible at runtime.
+     * @return a visitor to visit the annotation values, or <tt>null</tt> if
+     *         this visitor is not interested in visiting this annotation.
+     */
+    AnnotationVisitor visitAnnotation(String desc, boolean visible);
+
+    /**
+     * Visits a non standard attribute of the class.
+     *
+     * @param attr an attribute.
+     */
+    void visitAttribute(Attribute attr);
+
+    /**
+     * Visits information about an inner class. This inner class is not
+     * necessarily a member of the class being visited.
+     *
+     * @param name the internal name of an inner class (see
+     *        {@link Type#getInternalName() getInternalName}).
+     * @param outerName the internal name of the class to which the inner class
+     *        belongs (see {@link Type#getInternalName() getInternalName}). May
+     *        be <tt>null</tt> for not member classes.
+     * @param innerName the (simple) name of the inner class inside its
+     *        enclosing class. May be <tt>null</tt> for anonymous inner
+     *        classes.
+     * @param access the access flags of the inner class as originally declared
+     *        in the enclosing class.
+     */
+    void visitInnerClass(
+        String name,
+        String outerName,
+        String innerName,
+        int access);
+
+    /**
+     * Visits a field of the class.
+     *
+     * @param access the field's access flags (see {@link Opcodes}). This
+     *        parameter also indicates if the field is synthetic and/or
+     *        deprecated.
+     * @param name the field's name.
+     * @param desc the field's descriptor (see {@link Type Type}).
+     * @param signature the field's signature. May be <tt>null</tt> if the
+     *        field's type does not use generic types.
+     * @param value the field's initial value. This parameter, which may be
+     *        <tt>null</tt> if the field does not have an initial value, must
+     *        be an {@link Integer}, a {@link Float}, a {@link Long}, a
+     *        {@link Double} or a {@link String} (for <tt>int</tt>,
+     *        <tt>float</tt>, <tt>long</tt> or <tt>String</tt> fields
+     *        respectively). <i>This parameter is only used for static fields</i>.
+     *        Its value is ignored for non static fields, which must be
+     *        initialized through bytecode instructions in constructors or
+     *        methods.
+     * @return a visitor to visit field annotations and attributes, or
+     *         <tt>null</tt> if this class visitor is not interested in
+     *         visiting these annotations and attributes.
+     */
+    FieldVisitor visitField(
+        int access,
+        String name,
+        String desc,
+        String signature,
+        Object value);
+
+    /**
+     * Visits a method of the class. This method <i>must</i> return a new
+     * {@link MethodVisitor} instance (or <tt>null</tt>) each time it is
+     * called, i.e., it should not return a previously returned visitor.
+     *
+     * @param access the method's access flags (see {@link Opcodes}). This
+     *        parameter also indicates if the method is synthetic and/or
+     *        deprecated.
+     * @param name the method's name.
+     * @param desc the method's descriptor (see {@link Type Type}).
+     * @param signature the method's signature. May be <tt>null</tt> if the
+     *        method parameters, return type and exceptions do not use generic
+     *        types.
+     * @param exceptions the internal names of the method's exception classes
+     *        (see {@link Type#getInternalName() getInternalName}). May be
+     *        <tt>null</tt>.
+     * @return an object to visit the byte code of the method, or <tt>null</tt>
+     *         if this class visitor is not interested in visiting the code of
+     *         this method.
+     */
+    MethodVisitor visitMethod(
+        int access,
+        String name,
+        String desc,
+        String signature,
+        String[] exceptions);
+
+    /**
+     * Visits the end of the class. This method, which is the last one to be
+     * called, is used to inform the visitor that all the fields and methods of
+     * the class have been visited.
+     */
+    void visitEnd();
+}
--- /dev/null	Tue Aug  4 10:19:46 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/ClassWriter.java	Tue Aug  4 10:19:45 2009
@@ -0,0 +1,1374 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * A {@link ClassVisitor} that generates classes in bytecode form. More
+ * precisely this visitor generates a byte array conforming to the Java class
+ * file format. It can be used alone, to generate a Java class "from scratch",
+ * or with one or more {@link ClassReader ClassReader} and adapter class visitor
+ * to generate a modified class from one or more existing Java classes.
+ *
+ * @author Eric Bruneton
+ */
+public class ClassWriter implements ClassVisitor {
+
+    /**
+     * Flag to automatically compute the maximum stack size and the maximum
+     * number of local variables of methods. If this flag is set, then the
+     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the
+     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}
+     * method will be ignored, and computed automatically from the signature and
+     * the bytecode of each method.
+     *
+     * @see #ClassWriter(int)
+     */
+    public static final int COMPUTE_MAXS = 1;
+
+    /**
+     * Flag to automatically compute the stack map frames of methods from
+     * scratch. If this flag is set, then the calls to the
+     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map
+     * frames are recomputed from the methods bytecode. The arguments of the
+     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and
+     * recomputed from the bytecode. In other words, computeFrames implies
+     * computeMaxs.
+     *
+     * @see #ClassWriter(int)
+     */
+    public static final int COMPUTE_FRAMES = 2;
+
+    /**
+     * The type of instructions without any argument.
+     */
+    static final int NOARG_INSN = 0;
+
+    /**
+     * The type of instructions with an signed byte argument.
+     */
+    static final int SBYTE_INSN = 1;
+
+    /**
+     * The type of instructions with an signed short argument.
+     */
+    static final int SHORT_INSN = 2;
+
+    /**
+     * The type of instructions with a local variable index argument.
+     */
+    static final int VAR_INSN = 3;
+
+    /**
+     * The type of instructions with an implicit local variable index argument.
+     */
+    static final int IMPLVAR_INSN = 4;
+
+    /**
+     * The type of instructions with a type descriptor argument.
+     */
+    static final int TYPE_INSN = 5;
+
+    /**
+     * The type of field and method invocations instructions.
+     */
+    static final int FIELDORMETH_INSN = 6;
+
+    /**
+     * The type of the INVOKEINTERFACE instruction.
+     */
+    static final int ITFMETH_INSN = 7;
+
+    /**
+     * The type of instructions with a 2 bytes bytecode offset label.
+     */
+    static final int LABEL_INSN = 8;
+
+    /**
+     * The type of instructions with a 4 bytes bytecode offset label.
+     */
+    static final int LABELW_INSN = 9;
+
+    /**
+     * The type of the LDC instruction.
+     */
+    static final int LDC_INSN = 10;
+
+    /**
+     * The type of the LDC_W and LDC2_W instructions.
+     */
+    static final int LDCW_INSN = 11;
+
+    /**
+     * The type of the IINC instruction.
+     */
+    static final int IINC_INSN = 12;
+
+    /**
+     * The type of the TABLESWITCH instruction.
+     */
+    static final int TABL_INSN = 13;
+
+    /**
+     * The type of the LOOKUPSWITCH instruction.
+     */
+    static final int LOOK_INSN = 14;
+
+    /**
+     * The type of the MULTIANEWARRAY instruction.
+     */
+    static final int MANA_INSN = 15;
+
+    /**
+     * The type of the WIDE instruction.
+     */
+    static final int WIDE_INSN = 16;
+
+    /**
+     * The instruction types of all JVM opcodes.
+     */
+    static final byte[] TYPE;
+
+    /**
+     * The type of CONSTANT_Class constant pool items.
+     */
+    static final int CLASS = 7;
+
+    /**
+     * The type of CONSTANT_Fieldref constant pool items.
+     */
+    static final int FIELD = 9;
+
+    /**
+     * The type of CONSTANT_Methodref constant pool items.
+     */
+    static final int METH = 10;
+
+    /**
+     * The type of CONSTANT_InterfaceMethodref constant pool items.
+     */
+    static final int IMETH = 11;
+
+    /**
+     * The type of CONSTANT_String constant pool items.
+     */
+    static final int STR = 8;
+
+    /**
+     * The type of CONSTANT_Integer constant pool items.
+     */
+    static final int INT = 3;
+
+    /**
+     * The type of CONSTANT_Float constant pool items.
+     */
+    static final int FLOAT = 4;
+
+    /**
+     * The type of CONSTANT_Long constant pool items.
+     */
+    static final int LONG = 5;
+
+    /**
+     * The type of CONSTANT_Double constant pool items.
+     */
+    static final int DOUBLE = 6;
+
+    /**
+     * The type of CONSTANT_NameAndType constant pool items.
+     */
+    static final int NAME_TYPE = 12;
+
+    /**
+     * The type of CONSTANT_Utf8 constant pool items.
+     */
+    static final int UTF8 = 1;
+
+    /**
+     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},
+     * instead of the constant pool, in order to avoid clashes with normal
+     * constant pool items in the ClassWriter constant pool's hash table.
+     */
+    static final int TYPE_NORMAL = 13;
+
+    /**
+     * Uninitialized type Item stored in the ClassWriter
+     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to
+     * avoid clashes with normal constant pool items in the ClassWriter constant
+     * pool's hash table.
+     */
+    static final int TYPE_UNINIT = 14;
+
+    /**
+     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},
+     * instead of the constant pool, in order to avoid clashes with normal
+     * constant pool items in the ClassWriter constant pool's hash table.
+     */
+    static final int TYPE_MERGED = 15;
+
+    /**
+     * The class reader from which this class writer was constructed, if any.
+     */
+    ClassReader cr;
+
+    /**
+     * Minor and major version numbers of the class to be generated.
+     */
+    int version;
+
+    /**
+     * Index of the next item to be added in the constant pool.
+     */
+    int index;
+
+    /**
+     * The constant pool of this class.
+     */
+    final ByteVector pool;
+
+    /**
+     * The constant pool's hash table data.
+     */
+    Item[] items;
+
+    /**
+     * The threshold of the constant pool's hash table.
+     */
+    int threshold;
+
+    /**
+     * A reusable key used to look for items in the {@link #items} hash table.
+     */
+    final Item key;
+
+    /**
+     * A reusable key used to look for items in the {@link #items} hash table.
+     */
+    final Item key2;
+
+    /**
+     * A reusable key used to look for items in the {@link #items} hash table.
+     */
+    final Item key3;
+
+    /**
+     * A type table used to temporarily store internal names that will not
+     * necessarily be stored in the constant pool. This type table is used by
+     * the control flow and data flow analysis algorithm used to compute stack
+     * map frames from scratch. This array associates to each index <tt>i</tt>
+     * the Item whose index is <tt>i</tt>. All Item objects stored in this
+     * array are also stored in the {@link #items} hash table. These two arrays
+     * allow to retrieve an Item from its index or, conversely, to get the index
+     * of an Item from its value. Each Item stores an internal name in its
+     * {@link Item#strVal1} field.
+     */
+    Item[] typeTable;
+
+    /**
+     * Number of elements in the {@link #typeTable} array.
+     */
+    private short typeCount;
+
+    /**
+     * The access flags of this class.
+     */
+    private int access;
+
+    /**
+     * The constant pool item that contains the internal name of this class.
+     */
+    private int name;
+
+    /**
+     * The internal name of this class.
+     */
+    String thisName;
+
+    /**
+     * The constant pool item that contains the signature of this class.
+     */
+    private int signature;
+
+    /**
+     * The constant pool item that contains the internal name of the super class
+     * of this class.
+     */
+    private int superName;
+
+    /**
+     * Number of interfaces implemented or extended by this class or interface.
+     */
+    private int interfaceCount;
+
+    /**
+     * The interfaces implemented or extended by this class or interface. More
+     * precisely, this array contains the indexes of the constant pool items
+     * that contain the internal names of these interfaces.
+     */
+    private int[] interfaces;
+
+    /**
+     * The index of the constant pool item that contains the name of the source
+     * file from which this class was compiled.
+     */
+    private int sourceFile;
+
+    /**
+     * The SourceDebug attribute of this class.
+     */
+    private ByteVector sourceDebug;
+
+    /**
+     * The constant pool item that contains the name of the enclosing class of
+     * this class.
+     */
+    private int enclosingMethodOwner;
+
+    /**
+     * The constant pool item that contains the name and descriptor of the
+     * enclosing method of this class.
+     */
+    private int enclosingMethod;
+
+    /**
+     * The runtime visible annotations of this class.
+     */
+    private AnnotationWriter anns;
+
+    /**
+     * The runtime invisible annotations of this class.
+     */
+    private AnnotationWriter ianns;
+
+    /**
+     * The non standard attributes of this class.
+     */
+    private Attribute attrs;
+
+    /**
+     * The number of entries in the InnerClasses attribute.
+     */
+    private int innerClassesCount;
+
+    /**
+     * The InnerClasses attribute.
+     */
+    private ByteVector innerClasses;
+
+    /**
+     * The fields of this class. These fields are stored in a linked list of
+     * {@link FieldWriter} objects, linked to each other by their
+     * {@link FieldWriter#next} field. This field stores the first element of
+     * this list.
+     */
+    FieldWriter firstField;
+
+    /**
+     * The fields of this class. These fields are stored in a linked list of
+     * {@link FieldWriter} objects, linked to each other by their
+     * {@link FieldWriter#next} field. This field stores the last element of
+     * this list.
+     */
+    FieldWriter lastField;
+
+    /**
+     * The methods of this class. These methods are stored in a linked list of
+     * {@link MethodWriter} objects, linked to each other by their
+     * {@link MethodWriter#next} field. This field stores the first element of
+     * this list.
+     */
+    MethodWriter firstMethod;
+
+    /**
+     * The methods of this class. These methods are stored in a linked list of
+     * {@link MethodWriter} objects, linked to each other by their
+     * {@link MethodWriter#next} field. This field stores the last element of
+     * this list.
+     */
+    MethodWriter lastMethod;
+
+    /**
+     * <tt>true</tt> if the maximum stack size and number of local variables
+     * must be automatically computed.
+     */
+    private final boolean computeMaxs;
+
+    /**
+     * <tt>true</tt> if the stack map frames must be recomputed from scratch.
+     */
+    private final boolean computeFrames;
+
+    /**
+     * <tt>true</tt> if the stack map tables of this class are invalid. The
+     * {@link MethodWriter#resizeInstructions} method cannot transform existing
+     * stack map tables, and so produces potentially invalid classes when it is
+     * executed. In this case the class is reread and rewritten with the
+     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize
+     * stack map tables when this option is used).
+     */
+    boolean invalidFrames;
+
+    // ------------------------------------------------------------------------
+    // Static initializer
+    // ------------------------------------------------------------------------
+
+    /**
+     * Computes the instruction types of JVM opcodes.
+     */
+    static {
+        int i;
+        byte[] b = new byte[220];
+        String s = "AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD"
+                + "DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+                + "AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA"
+                + "AAAAGGGGGGGHAFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII";
+        for (i = 0; i < b.length; ++i) {
+            b[i] = (byte) (s.charAt(i) - 'A');
+        }
+        TYPE = b;
+
+        // code to generate the above string
+        //
+        // // SBYTE_INSN instructions
+        // b[Constants.NEWARRAY] = SBYTE_INSN;
+        // b[Constants.BIPUSH] = SBYTE_INSN;
+        //
+        // // SHORT_INSN instructions
+        // b[Constants.SIPUSH] = SHORT_INSN;
+        //
+        // // (IMPL)VAR_INSN instructions
+        // b[Constants.RET] = VAR_INSN;
+        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {
+        // b[i] = VAR_INSN;
+        // }
+        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {
+        // b[i] = VAR_INSN;
+        // }
+        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3
+        // b[i] = IMPLVAR_INSN;
+        // }
+        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3
+        // b[i] = IMPLVAR_INSN;
+        // }
+        //
+        // // TYPE_INSN instructions
+        // b[Constants.NEW] = TYPE_INSN;
+        // b[Constants.ANEWARRAY] = TYPE_INSN;
+        // b[Constants.CHECKCAST] = TYPE_INSN;
+        // b[Constants.INSTANCEOF] = TYPE_INSN;
+        //
+        // // (Set)FIELDORMETH_INSN instructions
+        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {
+        // b[i] = FIELDORMETH_INSN;
+        // }
+        // b[Constants.INVOKEINTERFACE] = ITFMETH_INSN;
+        //
+        // // LABEL(W)_INSN instructions
+        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {
+        // b[i] = LABEL_INSN;
+        // }
+        // b[Constants.IFNULL] = LABEL_INSN;
+        // b[Constants.IFNONNULL] = LABEL_INSN;
+        // b[200] = LABELW_INSN; // GOTO_W
+        // b[201] = LABELW_INSN; // JSR_W
+        // // temporary opcodes used internally by ASM - see Label and
+        // MethodWriter
+        // for (i = 202; i < 220; ++i) {
+        // b[i] = LABEL_INSN;
+        // }
+        //
+        // // LDC(_W) instructions
+        // b[Constants.LDC] = LDC_INSN;
+        // b[19] = LDCW_INSN; // LDC_W
+        // b[20] = LDCW_INSN; // LDC2_W
+        //
+        // // special instructions
+        // b[Constants.IINC] = IINC_INSN;
+        // b[Constants.TABLESWITCH] = TABL_INSN;
+        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;
+        // b[Constants.MULTIANEWARRAY] = MANA_INSN;
+        // b[196] = WIDE_INSN; // WIDE
+        //
+        // for (i = 0; i < b.length; ++i) {
+        // System.err.print((char)('A' + b[i]));
+        // }
+        // System.err.println();
+    }
+
+    // ------------------------------------------------------------------------
+    // Constructor
+    // ------------------------------------------------------------------------
+
+    /**
+     * Constructs a new {@link ClassWriter} object.
+     *
+     * @param flags option flags that can be used to modify the default behavior
+     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.
+     */
+    public ClassWriter(final int flags) {
+        index = 1;
+        pool = new ByteVector();
+        items = new Item[256];
+        threshold = (int) (0.75d * items.length);
+        key = new Item();
+        key2 = new Item();
+        key3 = new Item();
+        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;
+        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;
+    }
+
+    /**
+     * Constructs a new {@link ClassWriter} object and enables optimizations for
+     * "mostly add" bytecode transformations. These optimizations are the
+     * following:
+     *
+     * <ul> <li>The constant pool from the original class is copied as is in
+     * the new class, which saves time. New constant pool entries will be added
+     * at the end if necessary, but unused constant pool entries <i>won't be
+     * removed</i>.</li> <li>Methods that are not transformed are copied as
+     * is in the new class, directly from the original class bytecode (i.e.
+     * without emitting visit events for all the method instructions), which
+     * saves a <i>lot</i> of time. Untransformed methods are detected by the
+     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects
+     * that come from a {@link ClassWriter} (and not from a custom
+     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>
+     * </ul>
+     *
+     * @param classReader the {@link ClassReader} used to read the original
+     *        class. It will be used to copy the entire constant pool from the
+     *        original class and also to copy other fragments of original
+     *        bytecode where applicable.
+     * @param flags option flags that can be used to modify the default behavior
+     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.
+     */
+    public ClassWriter(final ClassReader classReader, final int flags) {
+        this(flags);
+        classReader.copyPool(this);
+        this.cr = classReader;
+    }
+
+    // ------------------------------------------------------------------------
+    // Implementation of the ClassVisitor interface
+    // ------------------------------------------------------------------------
+
+    public void visit(
+        final int version,
+        final int access,
+        final String name,
+        final String signature,
+        final String superName,
+        final String[] interfaces)
+    {
+        this.version = version;
+        this.access = access;
+        this.name = newClass(name);
+        thisName = name;
+        if (ClassReader.SIGNATURES && signature != null) {
+            this.signature = newUTF8(signature);
+        }
+        this.superName = superName == null ? 0 : newClass(superName);
+        if (interfaces != null && interfaces.length > 0) {
+            interfaceCount = interfaces.length;
+            this.interfaces = new int[interfaceCount];
+            for (int i = 0; i < interfaceCount; ++i) {
+                this.interfaces[i] = newClass(interfaces[i]);
+            }
+        }
+    }
+
+    public void visitSource(final String file, final String debug) {
+        if (file != null) {
+            sourceFile = newUTF8(file);
+        }
+        if (debug != null) {
+            sourceDebug = new ByteVector().putUTF8(debug);
+        }
+    }
+
+    public void visitOuterClass(
+        final String owner,
+        final String name,
+        final String desc)
+    {
+        enclosingMethodOwner = newClass(owner);
+        if (name != null && desc != null) {
+            enclosingMethod = newNameType(name, desc);
+        }
+    }
+
+    public AnnotationVisitor visitAnnotation(
+        final String desc,
+        final boolean visible)
+    {
+        if (!ClassReader.ANNOTATIONS) {
+            return null;
+        }
+        ByteVector bv = new ByteVector();
+        // write type, and reserve space for values count
+        bv.putShort(newUTF8(desc)).putShort(0);
+        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);
+        if (visible) {
+            aw.next = anns;
+            anns = aw;
+        } else {
+            aw.next = ianns;
+            ianns = aw;
+        }
+        return aw;
+    }
+
+    public void visitAttribute(final Attribute attr) {
+        attr.next = attrs;
+        attrs = attr;
+    }
+
+    public void visitInnerClass(
+        final String name,
+        final String outerName,
+        final String innerName,
+        final int access)
+    {
+        if (innerClasses == null) {
+            innerClasses = new ByteVector();
+        }
+        ++innerClassesCount;
+        innerClasses.putShort(name == null ? 0 : newClass(name));
+        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));
+        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));
+        innerClasses.putShort(access);
+    }
+
+    public FieldVisitor visitField(
+        final int access,
+        final String name,
+        final String desc,
+        final String signature,
+        final Object value)
+    {
+        return new FieldWriter(this, access, name, desc, signature, value);
+    }
+
+    public MethodVisitor visitMethod(
+        final int access,
+        final String name,
+        final String desc,
+        final String signature,
+        final String[] exceptions)
+    {
+        return new MethodWriter(this,
+                access,
+                name,
+                desc,
+                signature,
+                exceptions,
+                computeMaxs,
+                computeFrames);
+    }
+
+    public void visitEnd() {
+    }
+
+    // ------------------------------------------------------------------------
+    // Other public methods
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns the bytecode of the class that was build with this class writer.
+     *
+     * @return the bytecode of the class that was build with this class writer.
+     */
+    public byte[] toByteArray() {
+        // computes the real size of the bytecode of this class
+        int size = 24 + 2 * interfaceCount;
+        int nbFields = 0;
+        FieldWriter fb = firstField;
+        while (fb != null) {
+            ++nbFields;
+            size += fb.getSize();
+            fb = fb.next;
+        }
+        int nbMethods = 0;
+        MethodWriter mb = firstMethod;
+        while (mb != null) {
+            ++nbMethods;
+            size += mb.getSize();
+            mb = mb.next;
+        }
+        int attributeCount = 0;
+        if (ClassReader.SIGNATURES && signature != 0) {
+            ++attributeCount;
+            size += 8;
+            newUTF8("Signature");
+        }
+        if (sourceFile != 0) {
+            ++attributeCount;
+            size += 8;
+            newUTF8("SourceFile");
+        }
+        if (sourceDebug != null) {
+            ++attributeCount;
+            size += sourceDebug.length + 4;
+            newUTF8("SourceDebugExtension");
+        }
+        if (enclosingMethodOwner != 0) {
+            ++attributeCount;
+            size += 10;
+            newUTF8("EnclosingMethod");
+        }
+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
+            ++attributeCount;
+            size += 6;
+            newUTF8("Deprecated");
+        }
+        if ((access & Opcodes.ACC_SYNTHETIC) != 0
+                && (version & 0xffff) < Opcodes.V1_5)
+        {
+            ++attributeCount;
+            size += 6;
+            newUTF8("Synthetic");
+        }
+        if (innerClasses != null) {
+            ++attributeCount;
+            size += 8 + innerClasses.length;
+            newUTF8("InnerClasses");
+        }
+        if (ClassReader.ANNOTATIONS && anns != null) {
+            ++attributeCount;
+            size += 8 + anns.getSize();
+            newUTF8("RuntimeVisibleAnnotations");
+        }
+        if (ClassReader.ANNOTATIONS && ianns != null) {
+            ++attributeCount;
+            size += 8 + ianns.getSize();
+            newUTF8("RuntimeInvisibleAnnotations");
+        }
+        if (attrs != null) {
+            attributeCount += attrs.getCount();
+            size += attrs.getSize(this, null, 0, -1, -1);
+        }
+        size += pool.length;
+        // allocates a byte vector of this size, in order to avoid unnecessary
+        // arraycopy operations in the ByteVector.enlarge() method
+        ByteVector out = new ByteVector(size);
+        out.putInt(0xCAFEBABE).putInt(version);
+        out.putShort(index).putByteArray(pool.data, 0, pool.length);
+        out.putShort(access).putShort(name).putShort(superName);
+        out.putShort(interfaceCount);
+        for (int i = 0; i < interfaceCount; ++i) {
+            out.putShort(interfaces[i]);
+        }
+        out.putShort(nbFields);
+        fb = firstField;
+        while (fb != null) {
+            fb.put(out);
+            fb = fb.next;
+        }
+        out.putShort(nbMethods);
+        mb = firstMethod;
+        while (mb != null) {
+            mb.put(out);
+            mb = mb.next;
+        }
+        out.putShort(attributeCount);
+        if (ClassReader.SIGNATURES && signature != 0) {
+            out.putShort(newUTF8("Signature")).putInt(2).putShort(signature);
+        }
+        if (sourceFile != 0) {
+            out.putShort(newUTF8("SourceFile")).putInt(2).putShort(sourceFile);
+        }
+        if (sourceDebug != null) {
+            int len = sourceDebug.length - 2;
+            out.putShort(newUTF8("SourceDebugExtension")).putInt(len);
+            out.putByteArray(sourceDebug.data, 2, len);
+        }
+        if (enclosingMethodOwner != 0) {
+            out.putShort(newUTF8("EnclosingMethod")).putInt(4);
+            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);
+        }
+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
+            out.putShort(newUTF8("Deprecated")).putInt(0);
+        }
+        if ((access & Opcodes.ACC_SYNTHETIC) != 0
+                && (version & 0xffff) < Opcodes.V1_5)
+        {
+            out.putShort(newUTF8("Synthetic")).putInt(0);
+        }
+        if (innerClasses != null) {
+            out.putShort(newUTF8("InnerClasses"));
+            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);
+            out.putByteArray(innerClasses.data, 0, innerClasses.length);
+        }
+        if (ClassReader.ANNOTATIONS && anns != null) {
+            out.putShort(newUTF8("RuntimeVisibleAnnotations"));
+            anns.put(out);
+        }
+        if (ClassReader.ANNOTATIONS && ianns != null) {
+            out.putShort(newUTF8("RuntimeInvisibleAnnotations"));
+            ianns.put(out);
+        }
+        if (attrs != null) {
+            attrs.put(this, null, 0, -1, -1, out);
+        }
+        if (invalidFrames) {
+            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);
+            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);
+            return cw.toByteArray();
+        }
+        return out.data;
+    }
+
+    // ------------------------------------------------------------------------
+    // Utility methods: constant pool management
+    // ------------------------------------------------------------------------
+
+    /**
+     * Adds a number or string constant to the constant pool of the class being
+     * build. Does nothing if the constant pool already contains a similar item.
+     *
+     * @param cst the value of the constant to be added to the constant pool.
+     *        This parameter must be an {@link Integer}, a {@link Float}, a
+     *        {@link Long}, a {@link Double}, a {@link String} or a
+     *        {@link Type}.
+     * @return a new or already existing constant item with the given value.
+     */
+    Item newConstItem(final Object cst) {
+        if (cst instanceof Integer) {
+            int val = ((Integer) cst).intValue();
+            return newInteger(val);
+        } else if (cst instanceof Byte) {
+            int val = ((Byte) cst).intValue();
+            return newInteger(val);
+        } else if (cst instanceof Character) {
+            int val = ((Character) cst).charValue();
+            return newInteger(val);
+        } else if (cst instanceof Short) {
+            int val = ((Short) cst).intValue();
+            return newInteger(val);
+        } else if (cst instanceof Boolean) {
+            int val = ((Boolean) cst).booleanValue() ? 1 : 0;
+            return newInteger(val);
+        } else if (cst instanceof Float) {
+            float val = ((Float) cst).floatValue();
+            return newFloat(val);
+        } else if (cst instanceof Long) {
+            long val = ((Long) cst).longValue();
+            return newLong(val);
+        } else if (cst instanceof Double) {
+            double val = ((Double) cst).doubleValue();
+            return newDouble(val);
+        } else if (cst instanceof String) {
+            return newString((String) cst);
+        } else if (cst instanceof Type) {
+            Type t = (Type) cst;
+            return newClassItem(t.getSort() == Type.OBJECT
+                    ? t.getInternalName()
+                    : t.getDescriptor());
+        } else {
+            throw new IllegalArgumentException("value " + cst);
+        }
+    }
+
+    /**
+     * Adds a number or string constant to the constant pool of the class being
+     * build. Does nothing if the constant pool already contains a similar item.
+     * <i>This method is intended for {@link Attribute} sub classes, and is
+     * normally not needed by class generators or adapters.</i>
+     *
+     * @param cst the value of the constant to be added to the constant pool.
+     *        This parameter must be an {@link Integer}, a {@link Float}, a
+     *        {@link Long}, a {@link Double} or a {@link String}.
+     * @return the index of a new or already existing constant item with the
+     *         given value.
+     */
+    public int newConst(final Object cst) {
+        return newConstItem(cst).index;
+    }
+
+    /**
+     * Adds an UTF8 string to the constant pool of the class being build. Does
+     * nothing if the constant pool already contains a similar item. <i>This
+     * method is intended for {@link Attribute} sub classes, and is normally not
+     * needed by class generators or adapters.</i>
+     *
+     * @param value the String value.
+     * @return the index of a new or already existing UTF8 item.
+     */
+    public int newUTF8(final String value) {
+        key.set(UTF8, value, null, null);
+        Item result = get(key);
+        if (result == null) {
+            pool.putByte(UTF8).putUTF8(value);
+            result = new Item(index++, key);
+            put(result);
+        }
+        return result.index;
+    }
+
+    /**
+     * Adds a class reference to the constant pool of the class being build.
+     * Does nothing if the constant pool already contains a similar item.
+     * <i>This method is intended for {@link Attribute} sub classes, and is
+     * normally not needed by class generators or adapters.</i>
+     *
+     * @param value the internal name of the class.
+     * @return a new or already existing class reference item.
+     */
+    Item newClassItem(final String value) {
+        key2.set(CLASS, value, null, null);
+        Item result = get(key2);
+        if (result == null) {
+            pool.put12(CLASS, newUTF8(value));
+            result = new Item(index++, key2);
+            put(result);
+        }
+        return result;
+    }
+
+    /**
+     * Adds a class reference to the constant pool of the class being build.
+     * Does nothing if the constant pool already contains a similar item.
+     * <i>This method is intended for {@link Attribute} sub classes, and is
+     * normally not needed by class generators or adapters.</i>
+     *
+     * @param value the internal name of the class.
+     * @return the index of a new or already existing class reference item.
+     */
+    public int newClass(final String value) {
+        return newClassItem(value).index;
+    }
+
+    /**
+     * Adds a field reference to the constant pool of the class being build.
+     * Does nothing if the constant pool already contains a similar item.
+     *
+     * @param owner the internal name of the field's owner class.
+     * @param name the field's name.
+     * @param desc the field's descriptor.
+     * @return a new or already existing field reference item.
+     */
+    Item newFieldItem(final String owner, final String name, final String desc)
+    {
+        key3.set(FIELD, owner, name, desc);
+        Item result = get(key3);
+        if (result == null) {
+            put122(FIELD, newClass(owner), newNameType(name, desc));
+            result = new Item(index++, key3);
+            put(result);
+        }
+        return result;
+    }
+
+    /**
+     * Adds a field reference to the constant pool of the class being build.
+     * Does nothing if the constant pool already contains a similar item.
+     * <i>This method is intended for {@link Attribute} sub classes, and is
+     * normally not needed by class generators or adapters.</i>
+     *
+     * @param owner the internal name of the field's owner class.
+     * @param name the field's name.
+     * @param desc the field's descriptor.
+     * @return the index of a new or already existing field reference item.
+     */
+    public int newField(final String owner, final String name, final String desc)
+    {
+        return newFieldItem(owner, name, desc).index;
+    }
+
+    /**
+     * Adds a method reference to the constant pool of the class being build.
+     * Does nothing if the constant pool already contains a similar item.
+     *
+     * @param owner the internal name of the method's owner class.
+     * @param name the method's name.
+     * @param desc the method's descriptor.
+     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.
+     * @return a new or already existing method reference item.
+     */
+    Item newMethodItem(
+        final String owner,
+        final String name,
+        final String desc,
+        final boolean itf)
+    {
+        int type = itf ? IMETH : METH;
+        key3.set(type, owner, name, desc);
+        Item result = get(key3);
+        if (result == null) {
+            put122(type, newClass(owner), newNameType(name, desc));
+            result = new Item(index++, key3);
+            put(result);
+        }
+        return result;
+    }
+
+    /**
+     * Adds a method reference to the constant pool of the class being build.
+     * Does nothing if the constant pool already contains a similar item.
+     * <i>This method is intended for {@link Attribute} sub classes, and is
+     * normally not needed by class generators or adapters.</i>
+     *
+     * @param owner the internal name of the method's owner class.
+     * @param name the method's name.
+     * @param desc the method's descriptor.
+     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.
+     * @return the index of a new or already existing method reference item.
+     */
+    public int newMethod(
+        final String owner,
+        final String name,
+        final String desc,
+        final boolean itf)
+    {
+        return newMethodItem(owner, name, desc, itf).index;
+    }
+
+    /**
+     * Adds an integer to the constant pool of the class being build. Does
+     * nothing if the constant pool already contains a similar item.
+     *
+     * @param value the int value.
+     * @return a new or already existing int item.
+     */
+    Item newInteger(final int value) {
+        key.set(value);
+        Item result = get(key);
+        if (result == null) {
+            pool.putByte(INT).putInt(value);
+            result = new Item(index++, key);
+            put(result);
+        }
+        return result;
+    }
+
+    /**
+     * Adds a float to the constant pool of the class being build. Does nothing
+     * if the constant pool already contains a similar item.
+     *
+     * @param value the float value.
+     * @return a new or already existing float item.
+     */
+    Item newFloat(final float value) {
+        key.set(value);
+        Item result = get(key);
+        if (result == null) {
+            pool.putByte(FLOAT).putInt(key.intVal);
+            result = new Item(index++, key);
+            put(result);
+        }
+        return result;
+    }
+
+    /**
+     * Adds a long to the constant pool of the class being build. Does nothing
+     * if the constant pool already contains a similar item.
+     *
+     * @param value the long value.
+     * @return a new or already existing long item.
+     */
+    Item newLong(final long value) {
+        key.set(value);
+        Item result = get(key);
+        if (result == null) {
+            pool.putByte(LONG).putLong(value);
+            result = new Item(index, key);
+            put(result);
+            index += 2;
+        }
+        return result;
+    }
+
+    /**
+     * Adds a double to the constant pool of the class being build. Does nothing
+     * if the constant pool already contains a similar item.
+     *
+     * @param value the double value.
+     * @return a new or already existing double item.
+     */
+    Item newDouble(final double value) {
+        key.set(value);
+        Item result = get(key);
+        if (result == null) {
+            pool.putByte(DOUBLE).putLong(key.longVal);
+            result = new Item(index, key);
+            put(result);
+            index += 2;
+        }
+        return result;
+    }
+
+    /**
+     * Adds a string to the constant pool of the class being build. Does nothing
+     * if the constant pool already contains a similar item.
+     *
+     * @param value the String value.
+     * @return a new or already existing string item.
+     */
+    private Item newString(final String value) {
+        key2.set(STR, value, null, null);
+        Item result = get(key2);
+        if (result == null) {
+            pool.put12(STR, newUTF8(value));
+            result = new Item(index++, key2);
+            put(result);
+        }
+        return result;
+    }
+
+    /**
+     * Adds a name and type to the constant pool of the class being build. Does
+     * nothing if the constant pool already contains a similar item. <i>This
+     * method is intended for {@link Attribute} sub classes, and is normally not
+     * needed by class generators or adapters.</i>
+     *
+     * @param name a name.
+     * @param desc a type descriptor.
+     * @return the index of a new or already existing name and type item.
+     */
+    public int newNameType(final String name, final String desc) {
+        key2.set(NAME_TYPE, name, desc, null);
+        Item result = get(key2);
+        if (result == null) {
+            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));
+            result = new Item(index++, key2);
+            put(result);
+        }
+        return result.index;
+    }
+
+    /**
+     * Adds the given internal name to {@link #typeTable} and returns its index.
+     * Does nothing if the type table already contains this internal name.
+     *
+     * @param type the internal name to be added to the type table.
+     * @return the index of this internal name in the type table.
+     */
+    int addType(final String type) {
+        key.set(TYPE_NORMAL, type, null, null);
+        Item result = get(key);
+        if (result == null) {
+            result = addType(key);
+        }
+        return result.index;
+    }
+
+    /**
+     * Adds the given "uninitialized" type to {@link #typeTable} and returns its
+     * index. This method is used for UNINITIALIZED types, made of an internal
+     * name and a bytecode offset.
+     *
+     * @param type the internal name to be added to the type table.
+     * @param offset the bytecode offset of the NEW instruction that created
+     *        this UNINITIALIZED type value.
+     * @return the index of this internal name in the type table.
+     */
+    int addUninitializedType(final String type, final int offset) {
+        key.type = TYPE_UNINIT;
+        key.intVal = offset;
+        key.strVal1 = type;
+        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);
+        Item result = get(key);
+        if (result == null) {
+            result = addType(key);
+        }
+        return result.index;
+    }
+
+    /**
+     * Adds the given Item to {@link #typeTable}.
+     *
+     * @param item the value to be added to the type table.
+     * @return the added Item, which a new Item instance with the same value as
+     *         the given Item.
+     */
+    private Item addType(final Item item) {
+        ++typeCount;
+        Item result = new Item(typeCount, key);
+        put(result);
+        if (typeTable == null) {
+            typeTable = new Item[16];
+        }
+        if (typeCount == typeTable.length) {
+            Item[] newTable = new Item[2 * typeTable.length];
+            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);
+            typeTable = newTable;
+        }
+        typeTable[typeCount] = result;
+        return result;
+    }
+
+    /**
+     * Returns the index of the common super type of the two given types. This
+     * method calls {@link #getCommonSuperClass} and caches the result in the
+     * {@link #items} hash table to speedup future calls with the same
+     * parameters.
+     *
+     * @param type1 index of an internal name in {@link #typeTable}.
+     * @param type2 index of an internal name in {@link #typeTable}.
+     * @return the index of the common super type of the two given types.
+     */
+    int getMergedType(final int type1, final int type2) {
+        key2.type = TYPE_MERGED;
+        key2.longVal = type1 | (((long) type2) << 32);
+        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);
+        Item result = get(key2);
+        if (result == null) {
+            String t = typeTable[type1].strVal1;
+            String u = typeTable[type2].strVal1;
+            key2.intVal = addType(getCommonSuperClass(t, u));
+            result = new Item((short) 0, key2);
+            put(result);
+        }
+        return result.intVal;
+    }
+
+    /**
+     * Returns the common super type of the two given types. The default
+     * implementation of this method <i>loads<i> the two given classes and uses
+     * the java.lang.Class methods to find the common super class. It can be
+     * overridden to compute this common super type in other ways, in particular
+     * without actually loading any class, or to take into account the class
+     * that is currently being generated by this ClassWriter, which can of
+     * course not be loaded since it is under construction.
+     *
+     * @param type1 the internal name of a class.
+     * @param type2 the internal name of another class.
+     * @return the internal name of the common super class of the two given
+     *         classes.
+     */
+    protected String getCommonSuperClass(final String type1, final String type2)
+    {
+        Class c, d;
+        try {
+            c = Class.forName(type1.replace('/', '.'));
+            d = Class.forName(type2.replace('/', '.'));
+        } catch (Exception e) {
+            throw new RuntimeException(e.toString());
+        }
+        if (c.isAssignableFrom(d)) {
+            return type1;
+        }
+        if (d.isAssignableFrom(c)) {
+            return type2;
+        }
+        if (c.isInterface() || d.isInterface()) {
+            return "java/lang/Object";
+        } else {
+            do {
+                c = c.getSuperclass();
+            } while (!c.isAssignableFrom(d));
+            return c.getName().replace('.', '/');
+        }
+    }
+
+    /**
+     * Returns the constant pool's hash table item which is equal to the given
+     * item.
+     *
+     * @param key a constant pool item.
+     * @return the constant pool's hash table item which is equal to the given
+     *         item, or <tt>null</tt> if there is no such item.
+     */
+    private Item get(final Item key) {
+        Item i = items[key.hashCode % items.length];
+        while (i != null && !key.isEqualTo(i)) {
+            i = i.next;
+        }
+        return i;
+    }
+
+    /**
+     * Puts the given item in the constant pool's hash table. The hash table
+     * <i>must</i> not already contains this item.
+     *
+     * @param i the item to be added to the constant pool's hash table.
+     */
+    private void put(final Item i) {
+        if (index > threshold) {
+            int ll = items.length;
+            int nl = ll * 2 + 1;
+            Item[] newItems = new Item[nl];
+            for (int l = ll - 1; l >= 0; --l) {
+                Item j = items[l];
+                while (j != null) {
+                    int index = j.hashCode % newItems.length;
+                    Item k = j.next;
+                    j.next = newItems[index];
+                    newItems[index] = j;
+                    j = k;
+                }
+            }
+            items = newItems;
+            threshold = (int) (nl * 0.75);
+        }
+        int index = i.hashCode % items.length;
+        i.next = items[index];
+        items[index] = i;
+    }
+
+    /**
+     * Puts one byte and two shorts into the constant pool.
+     *
+     * @param b a byte.
+     * @param s1 a short.
+     * @param s2 another short.
+     */
+    private void put122(final int b, final int s1, final int s2) {
+        pool.put12(b, s1).putShort(s2);
+    }
+}
--- /dev/null	Tue Aug  4 10:19:48 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/Edge.java	Tue Aug  4 10:19:47 2009
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * An edge in the control flow graph of a method body. See {@link Label Label}.
+ *
+ * @author Eric Bruneton
+ */
+class Edge {
+
+    /**
+     * Denotes a normal control flow graph edge.
+     */
+    static final int NORMAL = 0;
+
+    /**
+     * Denotes a control flow graph edge corresponding to an exception handler.
+     * More precisely any {@link Edge} whose {@link #info} is strictly positive
+     * corresponds to an exception handler. The actual value of {@link #info} is
+     * the index, in the {@link ClassWriter} type table, of the exception that
+     * is catched.
+     */
+    static final int EXCEPTION = 0x7FFFFFFF;
+
+    /**
+     * Information about this control flow graph edge. If
+     * {@link ClassWriter#COMPUTE_MAXS} is used this field is the (relative)
+     * stack size in the basic block from which this edge originates. This size
+     * is equal to the stack size at the "jump" instruction to which this edge
+     * corresponds, relatively to the stack size at the beginning of the
+     * originating basic block. If {@link ClassWriter#COMPUTE_FRAMES} is used,
+     * this field is the kind of this control flow graph edge (i.e. NORMAL or
+     * EXCEPTION).
+     */
+    int info;
+
+    /**
+     * The successor block of the basic block from which this edge originates.
+     */
+    Label successor;
+
+    /**
+     * The next edge in the list of successors of the originating basic block.
+     * See {@link Label#successors successors}.
+     */
+    Edge next;
+}
--- /dev/null	Tue Aug  4 10:19:50 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/FieldVisitor.java	Tue Aug  4 10:19:49 2009
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * A visitor to visit a Java field. The methods of this interface must be called
+ * in the following order: ( <tt>visitAnnotation</tt> |
+ * <tt>visitAttribute</tt> )* <tt>visitEnd</tt>.
+ *
+ * @author Eric Bruneton
+ */
+public interface FieldVisitor {
+
+    /**
+     * Visits an annotation of the field.
+     *
+     * @param desc the class descriptor of the annotation class.
+     * @param visible <tt>true</tt> if the annotation is visible at runtime.
+     * @return a visitor to visit the annotation values, or <tt>null</tt> if
+     *         this visitor is not interested in visiting this annotation.
+     */
+    AnnotationVisitor visitAnnotation(String desc, boolean visible);
+
+    /**
+     * Visits a non standard attribute of the field.
+     *
+     * @param attr an attribute.
+     */
+    void visitAttribute(Attribute attr);
+
+    /**
+     * Visits the end of the field. This method, which is the last one to be
+     * called, is used to inform the visitor that all the annotations and
+     * attributes of the field have been visited.
+     */
+    void visitEnd();
+}
--- /dev/null	Tue Aug  4 10:19:52 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/FieldWriter.java	Tue Aug  4 10:19:51 2009
@@ -0,0 +1,299 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * An {@link FieldVisitor} that generates Java fields in bytecode form.
+ *
+ * @author Eric Bruneton
+ */
+final class FieldWriter implements FieldVisitor {
+
+    /**
+     * Next field writer (see {@link ClassWriter#firstField firstField}).
+     */
+    FieldWriter next;
+
+    /**
+     * The class writer to which this field must be added.
+     */
+    private final ClassWriter cw;
+
+    /**
+     * Access flags of this field.
+     */
+    private final int access;
+
+    /**
+     * The index of the constant pool item that contains the name of this
+     * method.
+     */
+    private final int name;
+
+    /**
+     * The index of the constant pool item that contains the descriptor of this
+     * field.
+     */
+    private final int desc;
+
+    /**
+     * The index of the constant pool item that contains the signature of this
+     * field.
+     */
+    private int signature;
+
+    /**
+     * The index of the constant pool item that contains the constant value of
+     * this field.
+     */
+    private int value;
+
+    /**
+     * The runtime visible annotations of this field. May be <tt>null</tt>.
+     */
+    private AnnotationWriter anns;
+
+    /**
+     * The runtime invisible annotations of this field. May be <tt>null</tt>.
+     */
+    private AnnotationWriter ianns;
+
+    /**
+     * The non standard attributes of this field. May be <tt>null</tt>.
+     */
+    private Attribute attrs;
+
+    // ------------------------------------------------------------------------
+    // Constructor
+    // ------------------------------------------------------------------------
+
+    /**
+     * Constructs a new {@link FieldWriter}.
+     *
+     * @param cw the class writer to which this field must be added.
+     * @param access the field's access flags (see {@link Opcodes}).
+     * @param name the field's name.
+     * @param desc the field's descriptor (see {@link Type}).
+     * @param signature the field's signature. May be <tt>null</tt>.
+     * @param value the field's constant value. May be <tt>null</tt>.
+     */
+    FieldWriter(
+        final ClassWriter cw,
+        final int access,
+        final String name,
+        final String desc,
+        final String signature,
+        final Object value)
+    {
+        if (cw.firstField == null) {
+            cw.firstField = this;
+        } else {
+            cw.lastField.next = this;
+        }
+        cw.lastField = this;
+        this.cw = cw;
+        this.access = access;
+        this.name = cw.newUTF8(name);
+        this.desc = cw.newUTF8(desc);
+        if (ClassReader.SIGNATURES && signature != null) {
+            this.signature = cw.newUTF8(signature);
+        }
+        if (value != null) {
+            this.value = cw.newConstItem(value).index;
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    // Implementation of the FieldVisitor interface
+    // ------------------------------------------------------------------------
+
+    public AnnotationVisitor visitAnnotation(
+        final String desc,
+        final boolean visible)
+    {
+        if (!ClassReader.ANNOTATIONS) {
+            return null;
+        }
+        ByteVector bv = new ByteVector();
+        // write type, and reserve space for values count
+        bv.putShort(cw.newUTF8(desc)).putShort(0);
+        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);
+        if (visible) {
+            aw.next = anns;
+            anns = aw;
+        } else {
+            aw.next = ianns;
+            ianns = aw;
+        }
+        return aw;
+    }
+
+    public void visitAttribute(final Attribute attr) {
+        attr.next = attrs;
+        attrs = attr;
+    }
+
+    public void visitEnd() {
+    }
+
+    // ------------------------------------------------------------------------
+    // Utility methods
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns the size of this field.
+     *
+     * @return the size of this field.
+     */
+    int getSize() {
+        int size = 8;
+        if (value != 0) {
+            cw.newUTF8("ConstantValue");
+            size += 8;
+        }
+        if ((access & Opcodes.ACC_SYNTHETIC) != 0
+                && (cw.version & 0xffff) < Opcodes.V1_5)
+        {
+            cw.newUTF8("Synthetic");
+            size += 6;
+        }
+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
+            cw.newUTF8("Deprecated");
+            size += 6;
+        }
+        if (ClassReader.SIGNATURES && signature != 0) {
+            cw.newUTF8("Signature");
+            size += 8;
+        }
+        if (ClassReader.ANNOTATIONS && anns != null) {
+            cw.newUTF8("RuntimeVisibleAnnotations");
+            size += 8 + anns.getSize();
+        }
+        if (ClassReader.ANNOTATIONS && ianns != null) {
+            cw.newUTF8("RuntimeInvisibleAnnotations");
+            size += 8 + ianns.getSize();
+        }
+        if (attrs != null) {
+            size += attrs.getSize(cw, null, 0, -1, -1);
+        }
+        return size;
+    }
+
+    /**
+     * Puts the content of this field into the given byte vector.
+     *
+     * @param out where the content of this field must be put.
+     */
+    void put(final ByteVector out) {
+        out.putShort(access).putShort(name).putShort(desc);
+        int attributeCount = 0;
+        if (value != 0) {
+            ++attributeCount;
+        }
+        if ((access & Opcodes.ACC_SYNTHETIC) != 0
+                && (cw.version & 0xffff) < Opcodes.V1_5)
+        {
+            ++attributeCount;
+        }
+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
+            ++attributeCount;
+        }
+        if (ClassReader.SIGNATURES && signature != 0) {
+            ++attributeCount;
+        }
+        if (ClassReader.ANNOTATIONS && anns != null) {
+            ++attributeCount;
+        }
+        if (ClassReader.ANNOTATIONS && ianns != null) {
+            ++attributeCount;
+        }
+        if (attrs != null) {
+            attributeCount += attrs.getCount();
+        }
+        out.putShort(attributeCount);
+        if (value != 0) {
+            out.putShort(cw.newUTF8("ConstantValue"));
+            out.putInt(2).putShort(value);
+        }
+        if ((access & Opcodes.ACC_SYNTHETIC) != 0
+                && (cw.version & 0xffff) < Opcodes.V1_5)
+        {
+            out.putShort(cw.newUTF8("Synthetic")).putInt(0);
+        }
+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
+            out.putShort(cw.newUTF8("Deprecated")).putInt(0);
+        }
+        if (ClassReader.SIGNATURES && signature != 0) {
+            out.putShort(cw.newUTF8("Signature"));
+            out.putInt(2).putShort(signature);
+        }
+        if (ClassReader.ANNOTATIONS && anns != null) {
+            out.putShort(cw.newUTF8("RuntimeVisibleAnnotations"));
+            anns.put(out);
+        }
+        if (ClassReader.ANNOTATIONS && ianns != null) {
+            out.putShort(cw.newUTF8("RuntimeInvisibleAnnotations"));
+            ianns.put(out);
+        }
+        if (attrs != null) {
+            attrs.put(cw, null, 0, -1, -1, out);
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:19:54 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/Frame.java	Tue Aug  4 10:19:53 2009
@@ -0,0 +1,1432 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * Information about the input and output stack map frames of a basic block.
+ *
+ * @author Eric Bruneton
+ */
+final class Frame {
+
+    /*
+     * Frames are computed in a two steps process: during the visit of each
+     * instruction, the state of the frame at the end of current basic block is
+     * updated by simulating the action of the instruction on the previous state
+     * of this so called "output frame". In visitMaxs, a fix point algorithm is
+     * used to compute the "input frame" of each basic block, i.e. the stack map
+     * frame at the begining of the basic block, starting from the input frame
+     * of the first basic block (which is computed from the method descriptor),
+     * and by using the previously computed output frames to compute the input
+     * state of the other blocks.
+     *
+     * All output and input frames are stored as arrays of integers. Reference
+     * and array types are represented by an index into a type table (which is
+     * not the same as the constant pool of the class, in order to avoid adding
+     * unnecessary constants in the pool - not all computed frames will end up
+     * being stored in the stack map table). This allows very fast type
+     * comparisons.
+     *
+     * Output stack map frames are computed relatively to the input frame of the
+     * basic block, which is not yet known when output frames are computed. It
+     * is therefore necessary to be able to represent abstract types such as
+     * "the type at position x in the input frame locals" or "the type at
+     * position x from the top of the input frame stack" or even "the type at
+     * position x in the input frame, with y more (or less) array dimensions".
+     * This explains the rather complicated type format used in output frames.
+     *
+     * This format is the following: DIM KIND VALUE (4, 4 and 24 bits). DIM is a
+     * signed number of array dimensions (from -8 to 7). KIND is either BASE,
+     * LOCAL or STACK. BASE is used for types that are not relative to the input
+     * frame. LOCAL is used for types that are relative to the input local
+     * variable types. STACK is used for types that are relative to the input
+     * stack types. VALUE depends on KIND. For LOCAL types, it is an index in
+     * the input local variable types. For STACK types, it is a position
+     * relatively to the top of input frame stack. For BASE types, it is either
+     * one of the constants defined in FrameVisitor, or for OBJECT and
+     * UNINITIALIZED types, a tag and an index in the type table.
+     *
+     * Output frames can contain types of any kind and with a positive or
+     * negative dimension (and even unassigned types, represented by 0 - which
+     * does not correspond to any valid type value). Input frames can only
+     * contain BASE types of positive or null dimension. In all cases the type
+     * table contains only internal type names (array type descriptors are
+     * forbidden - dimensions must be represented through the DIM field).
+     *
+     * The LONG and DOUBLE types are always represented by using two slots (LONG +
+     * TOP or DOUBLE + TOP), for local variable types as well as in the operand
+     * stack. This is necessary to be able to simulate DUPx_y instructions,
+     * whose effect would be dependent on the actual type values if types were
+     * always represented by a single slot in the stack (and this is not
+     * possible, since actual type values are not always known - cf LOCAL and
+     * STACK type kinds).
+     */
+
+    /**
+     * Mask to get the dimension of a frame type. This dimension is a signed
+     * integer between -8 and 7.
+     */
+    static final int DIM = 0xF0000000;
+
+    /**
+     * Constant to be added to a type to get a type with one more dimension.
+     */
+    static final int ARRAY_OF = 0x10000000;
+
+    /**
+     * Constant to be added to a type to get a type with one less dimension.
+     */
+    static final int ELEMENT_OF = 0xF0000000;
+
+    /**
+     * Mask to get the kind of a frame type.
+     *
+     * @see #BASE
+     * @see #LOCAL
+     * @see #STACK
+     */
+    static final int KIND = 0xF000000;
+
+    /**
+     * Mask to get the value of a frame type.
+     */
+    static final int VALUE = 0xFFFFFF;
+
+    /**
+     * Mask to get the kind of base types.
+     */
+    static final int BASE_KIND = 0xFF00000;
+
+    /**
+     * Mask to get the value of base types.
+     */
+    static final int BASE_VALUE = 0xFFFFF;
+
+    /**
+     * Kind of the types that are not relative to an input stack map frame.
+     */
+    static final int BASE = 0x1000000;
+
+    /**
+     * Base kind of the base reference types. The BASE_VALUE of such types is an
+     * index into the type table.
+     */
+    static final int OBJECT = BASE | 0x700000;
+
+    /**
+     * Base kind of the uninitialized base types. The BASE_VALUE of such types
+     * in an index into the type table (the Item at that index contains both an
+     * instruction offset and an internal class name).
+     */
+    static final int UNINITIALIZED = BASE | 0x800000;
+
+    /**
+     * Kind of the types that are relative to the local variable types of an
+     * input stack map frame. The value of such types is a local variable index.
+     */
+    private static final int LOCAL = 0x2000000;
+
+    /**
+     * Kind of the the types that are relative to the stack of an input stack
+     * map frame. The value of such types is a position relatively to the top of
+     * this stack.
+     */
+    private static final int STACK = 0x3000000;
+
+    /**
+     * The TOP type. This is a BASE type.
+     */
+    static final int TOP = BASE | 0;
+
+    /**
+     * The BOOLEAN type. This is a BASE type mainly used for array types.
+     */
+    static final int BOOLEAN = BASE | 9;
+
+    /**
+     * The BYTE type. This is a BASE type mainly used for array types.
+     */
+    static final int BYTE = BASE | 10;
+
+    /**
+     * The CHAR type. This is a BASE type mainly used for array types.
+     */
+    static final int CHAR = BASE | 11;
+
+    /**
+     * The SHORT type. This is a BASE type mainly used for array types.
+     */
+    static final int SHORT = BASE | 12;
+
+    /**
+     * The INTEGER type. This is a BASE type.
+     */
+    static final int INTEGER = BASE | 1;
+
+    /**
+     * The FLOAT type. This is a BASE type.
+     */
+    static final int FLOAT = BASE | 2;
+
+    /**
+     * The DOUBLE type. This is a BASE type.
+     */
+    static final int DOUBLE = BASE | 3;
+
+    /**
+     * The LONG type. This is a BASE type.
+     */
+    static final int LONG = BASE | 4;
+
+    /**
+     * The NULL type. This is a BASE type.
+     */
+    static final int NULL = BASE | 5;
+
+    /**
+     * The UNINITIALIZED_THIS type. This is a BASE type.
+     */
+    static final int UNINITIALIZED_THIS = BASE | 6;
+
+    /**
+     * The stack size variation corresponding to each JVM instruction. This
+     * stack variation is equal to the size of the values produced by an
+     * instruction, minus the size of the values consumed by this instruction.
+     */
+    static final int[] SIZE;
+
+    /**
+     * Computes the stack size variation corresponding to each JVM instruction.
+     */
+    static {
+        int i;
+        int[] b = new int[202];
+        String s = "EFFFFFFFFGGFFFGGFFFEEFGFGFEEEEEEEEEEEEEEEEEEEEDEDEDDDDD"
+                + "CDCDEEEEEEEEEEEEEEEEEEEEBABABBBBDCFFFGGGEDCDCDCDCDCDCDCDCD"
+                + "CDCEEEEDDDDDDDCDCDCEFEFDDEEFFDEDEEEBDDBBDDDDDDCCCCCCCCEFED"
+                + "DDCDCDEEEEEEEEEEFEEEEEEDDEEDDEE";
+        for (i = 0; i < b.length; ++i) {
+            b[i] = s.charAt(i) - 'E';
+        }
+        SIZE = b;
+
+        // code to generate the above string
+        //
+        // int NA = 0; // not applicable (unused opcode or variable size opcode)
+        //
+        // b = new int[] {
+        // 0, //NOP, // visitInsn
+        // 1, //ACONST_NULL, // -
+        // 1, //ICONST_M1, // -
+        // 1, //ICONST_0, // -
+        // 1, //ICONST_1, // -
+        // 1, //ICONST_2, // -
+        // 1, //ICONST_3, // -
+        // 1, //ICONST_4, // -
+        // 1, //ICONST_5, // -
+        // 2, //LCONST_0, // -
+        // 2, //LCONST_1, // -
+        // 1, //FCONST_0, // -
+        // 1, //FCONST_1, // -
+        // 1, //FCONST_2, // -
+        // 2, //DCONST_0, // -
+        // 2, //DCONST_1, // -
+        // 1, //BIPUSH, // visitIntInsn
+        // 1, //SIPUSH, // -
+        // 1, //LDC, // visitLdcInsn
+        // NA, //LDC_W, // -
+        // NA, //LDC2_W, // -
+        // 1, //ILOAD, // visitVarInsn
+        // 2, //LLOAD, // -
+        // 1, //FLOAD, // -
+        // 2, //DLOAD, // -
+        // 1, //ALOAD, // -
+        // NA, //ILOAD_0, // -
+        // NA, //ILOAD_1, // -
+        // NA, //ILOAD_2, // -
+        // NA, //ILOAD_3, // -
+        // NA, //LLOAD_0, // -
+        // NA, //LLOAD_1, // -
+        // NA, //LLOAD_2, // -
+        // NA, //LLOAD_3, // -
+        // NA, //FLOAD_0, // -
+        // NA, //FLOAD_1, // -
+        // NA, //FLOAD_2, // -
+        // NA, //FLOAD_3, // -
+        // NA, //DLOAD_0, // -
+        // NA, //DLOAD_1, // -
+        // NA, //DLOAD_2, // -
+        // NA, //DLOAD_3, // -
+        // NA, //ALOAD_0, // -
+        // NA, //ALOAD_1, // -
+        // NA, //ALOAD_2, // -
+        // NA, //ALOAD_3, // -
+        // -1, //IALOAD, // visitInsn
+        // 0, //LALOAD, // -
+        // -1, //FALOAD, // -
+        // 0, //DALOAD, // -
+        // -1, //AALOAD, // -
+        // -1, //BALOAD, // -
+        // -1, //CALOAD, // -
+        // -1, //SALOAD, // -
+        // -1, //ISTORE, // visitVarInsn
+        // -2, //LSTORE, // -
+        // -1, //FSTORE, // -
+        // -2, //DSTORE, // -
+        // -1, //ASTORE, // -
+        // NA, //ISTORE_0, // -
+        // NA, //ISTORE_1, // -
+        // NA, //ISTORE_2, // -
+        // NA, //ISTORE_3, // -
+        // NA, //LSTORE_0, // -
+        // NA, //LSTORE_1, // -
+        // NA, //LSTORE_2, // -
+        // NA, //LSTORE_3, // -
+        // NA, //FSTORE_0, // -
+        // NA, //FSTORE_1, // -
+        // NA, //FSTORE_2, // -
+        // NA, //FSTORE_3, // -
+        // NA, //DSTORE_0, // -
+        // NA, //DSTORE_1, // -
+        // NA, //DSTORE_2, // -
+        // NA, //DSTORE_3, // -
+        // NA, //ASTORE_0, // -
+        // NA, //ASTORE_1, // -
+        // NA, //ASTORE_2, // -
+        // NA, //ASTORE_3, // -
+        // -3, //IASTORE, // visitInsn
+        // -4, //LASTORE, // -
+        // -3, //FASTORE, // -
+        // -4, //DASTORE, // -
+        // -3, //AASTORE, // -
+        // -3, //BASTORE, // -
+        // -3, //CASTORE, // -
+        // -3, //SASTORE, // -
+        // -1, //POP, // -
+        // -2, //POP2, // -
+        // 1, //DUP, // -
+        // 1, //DUP_X1, // -
+        // 1, //DUP_X2, // -
+        // 2, //DUP2, // -
+        // 2, //DUP2_X1, // -
+        // 2, //DUP2_X2, // -
+        // 0, //SWAP, // -
+        // -1, //IADD, // -
+        // -2, //LADD, // -
+        // -1, //FADD, // -
+        // -2, //DADD, // -
+        // -1, //ISUB, // -
+        // -2, //LSUB, // -
+        // -1, //FSUB, // -
+        // -2, //DSUB, // -
+        // -1, //IMUL, // -
+        // -2, //LMUL, // -
+        // -1, //FMUL, // -
+        // -2, //DMUL, // -
+        // -1, //IDIV, // -
+        // -2, //LDIV, // -
+        // -1, //FDIV, // -
+        // -2, //DDIV, // -
+        // -1, //IREM, // -
+        // -2, //LREM, // -
+        // -1, //FREM, // -
+        // -2, //DREM, // -
+        // 0, //INEG, // -
+        // 0, //LNEG, // -
+        // 0, //FNEG, // -
+        // 0, //DNEG, // -
+        // -1, //ISHL, // -
+        // -1, //LSHL, // -
+        // -1, //ISHR, // -
+        // -1, //LSHR, // -
+        // -1, //IUSHR, // -
+        // -1, //LUSHR, // -
+        // -1, //IAND, // -
+        // -2, //LAND, // -
+        // -1, //IOR, // -
+        // -2, //LOR, // -
+        // -1, //IXOR, // -
+        // -2, //LXOR, // -
+        // 0, //IINC, // visitIincInsn
+        // 1, //I2L, // visitInsn
+        // 0, //I2F, // -
+        // 1, //I2D, // -
+        // -1, //L2I, // -
+        // -1, //L2F, // -
+        // 0, //L2D, // -
+        // 0, //F2I, // -
+        // 1, //F2L, // -
+        // 1, //F2D, // -
+        // -1, //D2I, // -
+        // 0, //D2L, // -
+        // -1, //D2F, // -
+        // 0, //I2B, // -
+        // 0, //I2C, // -
+        // 0, //I2S, // -
+        // -3, //LCMP, // -
+        // -1, //FCMPL, // -
+        // -1, //FCMPG, // -
+        // -3, //DCMPL, // -
+        // -3, //DCMPG, // -
+        // -1, //IFEQ, // visitJumpInsn
+        // -1, //IFNE, // -
+        // -1, //IFLT, // -
+        // -1, //IFGE, // -
+        // -1, //IFGT, // -
+        // -1, //IFLE, // -
+        // -2, //IF_ICMPEQ, // -
+        // -2, //IF_ICMPNE, // -
+        // -2, //IF_ICMPLT, // -
+        // -2, //IF_ICMPGE, // -
+        // -2, //IF_ICMPGT, // -
+        // -2, //IF_ICMPLE, // -
+        // -2, //IF_ACMPEQ, // -
+        // -2, //IF_ACMPNE, // -
+        // 0, //GOTO, // -
+        // 1, //JSR, // -
+        // 0, //RET, // visitVarInsn
+        // -1, //TABLESWITCH, // visiTableSwitchInsn
+        // -1, //LOOKUPSWITCH, // visitLookupSwitch
+        // -1, //IRETURN, // visitInsn
+        // -2, //LRETURN, // -
+        // -1, //FRETURN, // -
+        // -2, //DRETURN, // -
+        // -1, //ARETURN, // -
+        // 0, //RETURN, // -
+        // NA, //GETSTATIC, // visitFieldInsn
+        // NA, //PUTSTATIC, // -
+        // NA, //GETFIELD, // -
+        // NA, //PUTFIELD, // -
+        // NA, //INVOKEVIRTUAL, // visitMethodInsn
+        // NA, //INVOKESPECIAL, // -
+        // NA, //INVOKESTATIC, // -
+        // NA, //INVOKEINTERFACE, // -
+        // NA, //UNUSED, // NOT VISITED
+        // 1, //NEW, // visitTypeInsn
+        // 0, //NEWARRAY, // visitIntInsn
+        // 0, //ANEWARRAY, // visitTypeInsn
+        // 0, //ARRAYLENGTH, // visitInsn
+        // NA, //ATHROW, // -
+        // 0, //CHECKCAST, // visitTypeInsn
+        // 0, //INSTANCEOF, // -
+        // -1, //MONITORENTER, // visitInsn
+        // -1, //MONITOREXIT, // -
+        // NA, //WIDE, // NOT VISITED
+        // NA, //MULTIANEWARRAY, // visitMultiANewArrayInsn
+        // -1, //IFNULL, // visitJumpInsn
+        // -1, //IFNONNULL, // -
+        // NA, //GOTO_W, // -
+        // NA, //JSR_W, // -
+        // };
+        // for (i = 0; i < b.length; ++i) {
+        // System.err.print((char)('E' + b[i]));
+        // }
+        // System.err.println();
+    }
+
+    /**
+     * The label (i.e. basic block) to which these input and output stack map
+     * frames correspond.
+     */
+    Label owner;
+
+    /**
+     * The input stack map frame locals.
+     */
+    int[] inputLocals;
+
+    /**
+     * The input stack map frame stack.
+     */
+    int[] inputStack;
+
+    /**
+     * The output stack map frame locals.
+     */
+    private int[] outputLocals;
+
+    /**
+     * The output stack map frame stack.
+     */
+    private int[] outputStack;
+
+    /**
+     * Relative size of the output stack. The exact semantics of this field
+     * depends on the algorithm that is used.
+     *
+     * When only the maximum stack size is computed, this field is the size of
+     * the output stack relatively to the top of the input stack.
+     *
+     * When the stack map frames are completely computed, this field is the
+     * actual number of types in {@link #outputStack}.
+     */
+    private int outputStackTop;
+
+    /**
+     * Number of types that are initialized in the basic block.
+     *
+     * @see #initializations
+     */
+    private int initializationCount;
+
+    /**
+     * The types that are initialized in the basic block. A constructor
+     * invocation on an UNINITIALIZED or UNINITIALIZED_THIS type must replace
+     * <i>every occurence</i> of this type in the local variables and in the
+     * operand stack. This cannot be done during the first phase of the
+     * algorithm since, during this phase, the local variables and the operand
+     * stack are not completely computed. It is therefore necessary to store the
+     * types on which constructors are invoked in the basic block, in order to
+     * do this replacement during the second phase of the algorithm, where the
+     * frames are fully computed. Note that this array can contain types that
+     * are relative to input locals or to the input stack (see below for the
+     * description of the algorithm).
+     */
+    private int[] initializations;
+
+    /**
+     * Returns the output frame local variable type at the given index.
+     *
+     * @param local the index of the local that must be returned.
+     * @return the output frame local variable type at the given index.
+     */
+    private int get(final int local) {
+        if (outputLocals == null || local >= outputLocals.length) {
+            // this local has never been assigned in this basic block,
+            // so it is still equal to its value in the input frame
+            return LOCAL | local;
+        } else {
+            int type = outputLocals[local];
+            if (type == 0) {
+                // this local has never been assigned in this basic block,
+                // so it is still equal to its value in the input frame
+                type = outputLocals[local] = LOCAL | local;
+            }
+            return type;
+        }
+    }
+
+    /**
+     * Sets the output frame local variable type at the given index.
+     *
+     * @param local the index of the local that must be set.
+     * @param type the value of the local that must be set.
+     */
+    private void set(final int local, final int type) {
+        // creates and/or resizes the output local variables array if necessary
+        if (outputLocals == null) {
+            outputLocals = new int[10];
+        }
+        int n = outputLocals.length;
+        if (local >= n) {
+            int[] t = new int[Math.max(local + 1, 2 * n)];
+            System.arraycopy(outputLocals, 0, t, 0, n);
+            outputLocals = t;
+        }
+        // sets the local variable
+        outputLocals[local] = type;
+    }
+
+    /**
+     * Pushes a new type onto the output frame stack.
+     *
+     * @param type the type that must be pushed.
+     */
+    private void push(final int type) {
+        // creates and/or resizes the output stack array if necessary
+        if (outputStack == null) {
+            outputStack = new int[10];
+        }
+        int n = outputStack.length;
+        if (outputStackTop >= n) {
+            int[] t = new int[Math.max(outputStackTop + 1, 2 * n)];
+            System.arraycopy(outputStack, 0, t, 0, n);
+            outputStack = t;
+        }
+        // pushes the type on the output stack
+        outputStack[outputStackTop++] = type;
+        // updates the maximun height reached by the output stack, if needed
+        int top = owner.inputStackTop + outputStackTop;
+        if (top > owner.outputStackMax) {
+            owner.outputStackMax = top;
+        }
+    }
+
+    /**
+     * Pushes a new type onto the output frame stack.
+     *
+     * @param cw the ClassWriter to which this label belongs.
+     * @param desc the descriptor of the type to be pushed. Can also be a method
+     *        descriptor (in this case this method pushes its return type onto
+     *        the output frame stack).
+     */
+    private void push(final ClassWriter cw, final String desc) {
+        int type = type(cw, desc);
+        if (type != 0) {
+            push(type);
+            if (type == LONG || type == DOUBLE) {
+                push(TOP);
+            }
+        }
+    }
+
+    /**
+     * Returns the int encoding of the given type.
+     *
+     * @param cw the ClassWriter to which this label belongs.
+     * @param desc a type descriptor.
+     * @return the int encoding of the given type.
+     */
+    private static int type(final ClassWriter cw, final String desc) {
+        String t;
+        int index = desc.charAt(0) == '(' ? desc.indexOf(')') + 1 : 0;
+        switch (desc.charAt(index)) {
+            case 'V':
+                return 0;
+            case 'Z':
+            case 'C':
+            case 'B':
+            case 'S':
+            case 'I':
+                return INTEGER;
+            case 'F':
+                return FLOAT;
+            case 'J':
+                return LONG;
+            case 'D':
+                return DOUBLE;
+            case 'L':
+                // stores the internal name, not the descriptor!
+                t = desc.substring(index + 1, desc.length() - 1);
+                return OBJECT | cw.addType(t);
+                // case '[':
+            default:
+                // extracts the dimensions and the element type
+                int data;
+                int dims = index + 1;
+                while (desc.charAt(dims) == '[') {
+                    ++dims;
+                }
+                switch (desc.charAt(dims)) {
+                    case 'Z':
+                        data = BOOLEAN;
+                        break;
+                    case 'C':
+                        data = CHAR;
+                        break;
+                    case 'B':
+                        data = BYTE;
+                        break;
+                    case 'S':
+                        data = SHORT;
+                        break;
+                    case 'I':
+                        data = INTEGER;
+                        break;
+                    case 'F':
+                        data = FLOAT;
+                        break;
+                    case 'J':
+                        data = LONG;
+                        break;
+                    case 'D':
+                        data = DOUBLE;
+                        break;
+                    // case 'L':
+                    default:
+                        // stores the internal name, not the descriptor
+                        t = desc.substring(dims + 1, desc.length() - 1);
+                        data = OBJECT | cw.addType(t);
+                }
+                return (dims - index) << 28 | data;
+        }
+    }
+
+    /**
+     * Pops a type from the output frame stack and returns its value.
+     *
+     * @return the type that has been popped from the output frame stack.
+     */
+    private int pop() {
+        if (outputStackTop > 0) {
+            return outputStack[--outputStackTop];
+        } else {
+            // if the output frame stack is empty, pops from the input stack
+            return STACK | -(--owner.inputStackTop);
+        }
+    }
+
+    /**
+     * Pops the given number of types from the output frame stack.
+     *
+     * @param elements the number of types that must be popped.
+     */
+    private void pop(final int elements) {
+        if (outputStackTop >= elements) {
+            outputStackTop -= elements;
+        } else {
+            // if the number of elements to be popped is greater than the number
+            // of elements in the output stack, clear it, and pops the remaining
+            // elements from the input stack.
+            owner.inputStackTop -= elements - outputStackTop;
+            outputStackTop = 0;
+        }
+    }
+
+    /**
+     * Pops a type from the output frame stack.
+     *
+     * @param desc the descriptor of the type to be popped. Can also be a method
+     *        descriptor (in this case this method pops the types corresponding
+     *        to the method arguments).
+     */
+    private void pop(final String desc) {
+        char c = desc.charAt(0);
+        if (c == '(') {
+            pop((MethodWriter.getArgumentsAndReturnSizes(desc) >> 2) - 1);
+        } else if (c == 'J' || c == 'D') {
+            pop(2);
+        } else {
+            pop(1);
+        }
+    }
+
+    /**
+     * Adds a new type to the list of types on which a constructor is invoked in
+     * the basic block.
+     *
+     * @param var a type on a which a constructor is invoked.
+     */
+    private void init(final int var) {
+        // creates and/or resizes the initializations array if necessary
+        if (initializations == null) {
+            initializations = new int[2];
+        }
+        int n = initializations.length;
+        if (initializationCount >= n) {
+            int[] t = new int[Math.max(initializationCount + 1, 2 * n)];
+            System.arraycopy(initializations, 0, t, 0, n);
+            initializations = t;
+        }
+        // stores the type to be initialized
+        initializations[initializationCount++] = var;
+    }
+
+    /**
+     * Replaces the given type with the appropriate type if it is one of the
+     * types on which a constructor is invoked in the basic block.
+     *
+     * @param cw the ClassWriter to which this label belongs.
+     * @param t a type
+     * @return t or, if t is one of the types on which a constructor is invoked
+     *         in the basic block, the type corresponding to this constructor.
+     */
+    private int init(final ClassWriter cw, final int t) {
+        int s;
+        if (t == UNINITIALIZED_THIS) {
+            s = OBJECT | cw.addType(cw.thisName);
+        } else if ((t & (DIM | BASE_KIND)) == UNINITIALIZED) {
+            String type = cw.typeTable[t & BASE_VALUE].strVal1;
+            s = OBJECT | cw.addType(type);
+        } else {
+            return t;
+        }
+        for (int j = 0; j < initializationCount; ++j) {
+            int u = initializations[j];
+            int dim = u & DIM;
+            int kind = u & KIND;
+            if (kind == LOCAL) {
+                u = dim + inputLocals[u & VALUE];
+            } else if (kind == STACK) {
+                u = dim + inputStack[inputStack.length - (u & VALUE)];
+            }
+            if (t == u) {
+                return s;
+            }
+        }
+        return t;
+    }
+
+    /**
+     * Initializes the input frame of the first basic block from the method
+     * descriptor.
+     *
+     * @param cw the ClassWriter to which this label belongs.
+     * @param access the access flags of the method to which this label belongs.
+     * @param args the formal parameter types of this method.
+     * @param maxLocals the maximum number of local variables of this method.
+     */
+    void initInputFrame(
+        final ClassWriter cw,
+        final int access,
+        final Type[] args,
+        final int maxLocals)
+    {
+        inputLocals = new int[maxLocals];
+        inputStack = new int[0];
+        int i = 0;
+        if ((access & Opcodes.ACC_STATIC) == 0) {
+            if ((access & MethodWriter.ACC_CONSTRUCTOR) == 0) {
+                inputLocals[i++] = OBJECT | cw.addType(cw.thisName);
+            } else {
+                inputLocals[i++] = UNINITIALIZED_THIS;
+            }
+        }
+        for (int j = 0; j < args.length; ++j) {
+            int t = type(cw, args[j].getDescriptor());
+            inputLocals[i++] = t;
+            if (t == LONG || t == DOUBLE) {
+                inputLocals[i++] = TOP;
+            }
+        }
+        while (i < maxLocals) {
+            inputLocals[i++] = TOP;
+        }
+    }
+
+    /**
+     * Simulates the action of the given instruction on the output stack frame.
+     *
+     * @param opcode the opcode of the instruction.
+     * @param arg the operand of the instruction, if any.
+     * @param cw the class writer to which this label belongs.
+     * @param item the operand of the instructions, if any.
+     */
+    void execute(
+        final int opcode,
+        final int arg,
+        final ClassWriter cw,
+        final Item item)
+    {
+        int t1, t2, t3, t4;
+        switch (opcode) {
+            case Opcodes.NOP:
+            case Opcodes.INEG:
+            case Opcodes.LNEG:
+            case Opcodes.FNEG:
+            case Opcodes.DNEG:
+            case Opcodes.I2B:
+            case Opcodes.I2C:
+            case Opcodes.I2S:
+            case Opcodes.GOTO:
+            case Opcodes.RETURN:
+                break;
+            case Opcodes.ACONST_NULL:
+                push(NULL);
+                break;
+            case Opcodes.ICONST_M1:
+            case Opcodes.ICONST_0:
+            case Opcodes.ICONST_1:
+            case Opcodes.ICONST_2:
+            case Opcodes.ICONST_3:
+            case Opcodes.ICONST_4:
+            case Opcodes.ICONST_5:
+            case Opcodes.BIPUSH:
+            case Opcodes.SIPUSH:
+            case Opcodes.ILOAD:
+                push(INTEGER);
+                break;
+            case Opcodes.LCONST_0:
+            case Opcodes.LCONST_1:
+            case Opcodes.LLOAD:
+                push(LONG);
+                push(TOP);
+                break;
+            case Opcodes.FCONST_0:
+            case Opcodes.FCONST_1:
+            case Opcodes.FCONST_2:
+            case Opcodes.FLOAD:
+                push(FLOAT);
+                break;
+            case Opcodes.DCONST_0:
+            case Opcodes.DCONST_1:
+            case Opcodes.DLOAD:
+                push(DOUBLE);
+                push(TOP);
+                break;
+            case Opcodes.LDC:
+                switch (item.type) {
+                    case ClassWriter.INT:
+                        push(INTEGER);
+                        break;
+                    case ClassWriter.LONG:
+                        push(LONG);
+                        push(TOP);
+                        break;
+                    case ClassWriter.FLOAT:
+                        push(FLOAT);
+                        break;
+                    case ClassWriter.DOUBLE:
+                        push(DOUBLE);
+                        push(TOP);
+                        break;
+                    case ClassWriter.CLASS:
+                        push(OBJECT | cw.addType("java/lang/Class"));
+                        break;
+                    // case ClassWriter.STR:
+                    default:
+                        push(OBJECT | cw.addType("java/lang/String"));
+                }
+                break;
+            case Opcodes.ALOAD:
+                push(get(arg));
+                break;
+            case Opcodes.IALOAD:
+            case Opcodes.BALOAD:
+            case Opcodes.CALOAD:
+            case Opcodes.SALOAD:
+                pop(2);
+                push(INTEGER);
+                break;
+            case Opcodes.LALOAD:
+            case Opcodes.D2L:
+                pop(2);
+                push(LONG);
+                push(TOP);
+                break;
+            case Opcodes.FALOAD:
+                pop(2);
+                push(FLOAT);
+                break;
+            case Opcodes.DALOAD:
+            case Opcodes.L2D:
+                pop(2);
+                push(DOUBLE);
+                push(TOP);
+                break;
+            case Opcodes.AALOAD:
+                pop(1);
+                t1 = pop();
+                push(ELEMENT_OF + t1);
+                break;
+            case Opcodes.ISTORE:
+            case Opcodes.FSTORE:
+            case Opcodes.ASTORE:
+                t1 = pop();
+                set(arg, t1);
+                if (arg > 0) {
+                    t2 = get(arg - 1);
+                    // if t2 is of kind STACK or LOCAL we cannot know its size!
+                    if (t2 == LONG || t2 == DOUBLE) {
+                        set(arg - 1, TOP);
+                    }
+                }
+                break;
+            case Opcodes.LSTORE:
+            case Opcodes.DSTORE:
+                pop(1);
+                t1 = pop();
+                set(arg, t1);
+                set(arg + 1, TOP);
+                if (arg > 0) {
+                    t2 = get(arg - 1);
+                    // if t2 is of kind STACK or LOCAL we cannot know its size!
+                    if (t2 == LONG || t2 == DOUBLE) {
+                        set(arg - 1, TOP);
+                    }
+                }
+                break;
+            case Opcodes.IASTORE:
+            case Opcodes.BASTORE:
+            case Opcodes.CASTORE:
+            case Opcodes.SASTORE:
+            case Opcodes.FASTORE:
+            case Opcodes.AASTORE:
+                pop(3);
+                break;
+            case Opcodes.LASTORE:
+            case Opcodes.DASTORE:
+                pop(4);
+                break;
+            case Opcodes.POP:
+            case Opcodes.IFEQ:
+            case Opcodes.IFNE:
+            case Opcodes.IFLT:
+            case Opcodes.IFGE:
+            case Opcodes.IFGT:
+            case Opcodes.IFLE:
+            case Opcodes.IRETURN:
+            case Opcodes.FRETURN:
+            case Opcodes.ARETURN:
+            case Opcodes.TABLESWITCH:
+            case Opcodes.LOOKUPSWITCH:
+            case Opcodes.ATHROW:
+            case Opcodes.MONITORENTER:
+            case Opcodes.MONITOREXIT:
+            case Opcodes.IFNULL:
+            case Opcodes.IFNONNULL:
+                pop(1);
+                break;
+            case Opcodes.POP2:
+            case Opcodes.IF_ICMPEQ:
+            case Opcodes.IF_ICMPNE:
+            case Opcodes.IF_ICMPLT:
+            case Opcodes.IF_ICMPGE:
+            case Opcodes.IF_ICMPGT:
+            case Opcodes.IF_ICMPLE:
+            case Opcodes.IF_ACMPEQ:
+            case Opcodes.IF_ACMPNE:
+            case Opcodes.LRETURN:
+            case Opcodes.DRETURN:
+                pop(2);
+                break;
+            case Opcodes.DUP:
+                t1 = pop();
+                push(t1);
+                push(t1);
+                break;
+            case Opcodes.DUP_X1:
+                t1 = pop();
+                t2 = pop();
+                push(t1);
+                push(t2);
+                push(t1);
+                break;
+            case Opcodes.DUP_X2:
+                t1 = pop();
+                t2 = pop();
+                t3 = pop();
+                push(t1);
+                push(t3);
+                push(t2);
+                push(t1);
+                break;
+            case Opcodes.DUP2:
+                t1 = pop();
+                t2 = pop();
+                push(t2);
+                push(t1);
+                push(t2);
+                push(t1);
+                break;
+            case Opcodes.DUP2_X1:
+                t1 = pop();
+                t2 = pop();
+                t3 = pop();
+                push(t2);
+                push(t1);
+                push(t3);
+                push(t2);
+                push(t1);
+                break;
+            case Opcodes.DUP2_X2:
+                t1 = pop();
+                t2 = pop();
+                t3 = pop();
+                t4 = pop();
+                push(t2);
+                push(t1);
+                push(t4);
+                push(t3);
+                push(t2);
+                push(t1);
+                break;
+            case Opcodes.SWAP:
+                t1 = pop();
+                t2 = pop();
+                push(t1);
+                push(t2);
+                break;
+            case Opcodes.IADD:
+            case Opcodes.ISUB:
+            case Opcodes.IMUL:
+            case Opcodes.IDIV:
+            case Opcodes.IREM:
+            case Opcodes.IAND:
+            case Opcodes.IOR:
+            case Opcodes.IXOR:
+            case Opcodes.ISHL:
+            case Opcodes.ISHR:
+            case Opcodes.IUSHR:
+            case Opcodes.L2I:
+            case Opcodes.D2I:
+            case Opcodes.FCMPL:
+            case Opcodes.FCMPG:
+                pop(2);
+                push(INTEGER);
+                break;
+            case Opcodes.LADD:
+            case Opcodes.LSUB:
+            case Opcodes.LMUL:
+            case Opcodes.LDIV:
+            case Opcodes.LREM:
+            case Opcodes.LAND:
+            case Opcodes.LOR:
+            case Opcodes.LXOR:
+                pop(4);
+                push(LONG);
+                push(TOP);
+                break;
+            case Opcodes.FADD:
+            case Opcodes.FSUB:
+            case Opcodes.FMUL:
+            case Opcodes.FDIV:
+            case Opcodes.FREM:
+            case Opcodes.L2F:
+            case Opcodes.D2F:
+                pop(2);
+                push(FLOAT);
+                break;
+            case Opcodes.DADD:
+            case Opcodes.DSUB:
+            case Opcodes.DMUL:
+            case Opcodes.DDIV:
+            case Opcodes.DREM:
+                pop(4);
+                push(DOUBLE);
+                push(TOP);
+                break;
+            case Opcodes.LSHL:
+            case Opcodes.LSHR:
+            case Opcodes.LUSHR:
+                pop(3);
+                push(LONG);
+                push(TOP);
+                break;
+            case Opcodes.IINC:
+                set(arg, INTEGER);
+                break;
+            case Opcodes.I2L:
+            case Opcodes.F2L:
+                pop(1);
+                push(LONG);
+                push(TOP);
+                break;
+            case Opcodes.I2F:
+                pop(1);
+                push(FLOAT);
+                break;
+            case Opcodes.I2D:
+            case Opcodes.F2D:
+                pop(1);
+                push(DOUBLE);
+                push(TOP);
+                break;
+            case Opcodes.F2I:
+            case Opcodes.ARRAYLENGTH:
+            case Opcodes.INSTANCEOF:
+                pop(1);
+                push(INTEGER);
+                break;
+            case Opcodes.LCMP:
+            case Opcodes.DCMPL:
+            case Opcodes.DCMPG:
+                pop(4);
+                push(INTEGER);
+                break;
+            case Opcodes.JSR:
+            case Opcodes.RET:
+                throw new RuntimeException("JSR/RET are not supported with computeFrames option");
+            case Opcodes.GETSTATIC:
+                push(cw, item.strVal3);
+                break;
+            case Opcodes.PUTSTATIC:
+                pop(item.strVal3);
+                break;
+            case Opcodes.GETFIELD:
+                pop(1);
+                push(cw, item.strVal3);
+                break;
+            case Opcodes.PUTFIELD:
+                pop(item.strVal3);
+                pop();
+                break;
+            case Opcodes.INVOKEVIRTUAL:
+            case Opcodes.INVOKESPECIAL:
+            case Opcodes.INVOKESTATIC:
+            case Opcodes.INVOKEINTERFACE:
+                pop(item.strVal3);
+                if (opcode != Opcodes.INVOKESTATIC) {
+                    t1 = pop();
+                    if (opcode == Opcodes.INVOKESPECIAL
+                            && item.strVal2.charAt(0) == '<')
+                    {
+                        init(t1);
+                    }
+                }
+                push(cw, item.strVal3);
+                break;
+            case Opcodes.NEW:
+                push(UNINITIALIZED | cw.addUninitializedType(item.strVal1, arg));
+                break;
+            case Opcodes.NEWARRAY:
+                pop();
+                switch (arg) {
+                    case Opcodes.T_BOOLEAN:
+                        push(ARRAY_OF | BOOLEAN);
+                        break;
+                    case Opcodes.T_CHAR:
+                        push(ARRAY_OF | CHAR);
+                        break;
+                    case Opcodes.T_BYTE:
+                        push(ARRAY_OF | BYTE);
+                        break;
+                    case Opcodes.T_SHORT:
+                        push(ARRAY_OF | SHORT);
+                        break;
+                    case Opcodes.T_INT:
+                        push(ARRAY_OF | INTEGER);
+                        break;
+                    case Opcodes.T_FLOAT:
+                        push(ARRAY_OF | FLOAT);
+                        break;
+                    case Opcodes.T_DOUBLE:
+                        push(ARRAY_OF | DOUBLE);
+                        break;
+                    // case Opcodes.T_LONG:
+                    default:
+                        push(ARRAY_OF | LONG);
+                        break;
+                }
+                break;
+            case Opcodes.ANEWARRAY:
+                String s = item.strVal1;
+                pop();
+                if (s.charAt(0) == '[') {
+                    push(cw, '[' + s);
+                } else {
+                    push(ARRAY_OF | OBJECT | cw.addType(s));
+                }
+                break;
+            case Opcodes.CHECKCAST:
+                s = item.strVal1;
+                pop();
+                if (s.charAt(0) == '[') {
+                    push(cw, s);
+                } else {
+                    push(OBJECT | cw.addType(s));
+                }
+                break;
+            // case Opcodes.MULTIANEWARRAY:
+            default:
+                pop(arg);
+                push(cw, item.strVal1);
+                break;
+        }
+    }
+
+    /**
+     * Merges the input frame of the given basic block with the input and output
+     * frames of this basic block. Returns <tt>true</tt> if the input frame of
+     * the given label has been changed by this operation.
+     *
+     * @param cw the ClassWriter to which this label belongs.
+     * @param frame the basic block whose input frame must be updated.
+     * @param edge the kind of the {@link Edge} between this label and 'label'.
+     *        See {@link Edge#info}.
+     * @return <tt>true</tt> if the input frame of the given label has been
+     *         changed by this operation.
+     */
+    boolean merge(final ClassWriter cw, final Frame frame, final int edge) {
+        boolean changed = false;
+        int i, s, dim, kind, t;
+
+        int nLocal = inputLocals.length;
+        int nStack = inputStack.length;
+        if (frame.inputLocals == null) {
+            frame.inputLocals = new int[nLocal];
+            changed = true;
+        }
+
+        for (i = 0; i < nLocal; ++i) {
+            if (outputLocals != null && i < outputLocals.length) {
+                s = outputLocals[i];
+                if (s == 0) {
+                    t = inputLocals[i];
+                } else {
+                    dim = s & DIM;
+                    kind = s & KIND;
+                    if (kind == LOCAL) {
+                        t = dim + inputLocals[s & VALUE];
+                    } else if (kind == STACK) {
+                        t = dim + inputStack[nStack - (s & VALUE)];
+                    } else {
+                        t = s;
+                    }
+                }
+            } else {
+                t = inputLocals[i];
+            }
+            if (initializations != null) {
+                t = init(cw, t);
+            }
+            changed |= merge(cw, t, frame.inputLocals, i);
+        }
+
+        if (edge > 0) {
+            for (i = 0; i < nLocal; ++i) {
+                t = inputLocals[i];
+                changed |= merge(cw, t, frame.inputLocals, i);
+            }
+            if (frame.inputStack == null) {
+                frame.inputStack = new int[1];
+                changed = true;
+            }
+            changed |= merge(cw, edge, frame.inputStack, 0);
+            return changed;
+        }
+
+        int nInputStack = inputStack.length + owner.inputStackTop;
+        if (frame.inputStack == null) {
+            frame.inputStack = new int[nInputStack + outputStackTop];
+            changed = true;
+        }
+
+        for (i = 0; i < nInputStack; ++i) {
+            t = inputStack[i];
+            if (initializations != null) {
+                t = init(cw, t);
+            }
+            changed |= merge(cw, t, frame.inputStack, i);
+        }
+        for (i = 0; i < outputStackTop; ++i) {
+            s = outputStack[i];
+            dim = s & DIM;
+            kind = s & KIND;
+            if (kind == LOCAL) {
+                t = dim + inputLocals[s & VALUE];
+            } else if (kind == STACK) {
+                t = dim + inputStack[nStack - (s & VALUE)];
+            } else {
+                t = s;
+            }
+            if (initializations != null) {
+                t = init(cw, t);
+            }
+            changed |= merge(cw, t, frame.inputStack, nInputStack + i);
+        }
+        return changed;
+    }
+
+    /**
+     * Merges the type at the given index in the given type array with the given
+     * type. Returns <tt>true</tt> if the type array has been modified by this
+     * operation.
+     *
+     * @param cw the ClassWriter to which this label belongs.
+     * @param t the type with which the type array element must be merged.
+     * @param types an array of types.
+     * @param index the index of the type that must be merged in 'types'.
+     * @return <tt>true</tt> if the type array has been modified by this
+     *         operation.
+     */
+    private static boolean merge(
+        final ClassWriter cw,
+        int t,
+        final int[] types,
+        final int index)
+    {
+        int u = types[index];
+        if (u == t) {
+            // if the types are equal, merge(u,t)=u, so there is no change
+            return false;
+        }
+        if ((t & ~DIM) == NULL) {
+            if (u == NULL) {
+                return false;
+            }
+            t = NULL;
+        }
+        if (u == 0) {
+            // if types[index] has never been assigned, merge(u,t)=t
+            types[index] = t;
+            return true;
+        }
+        int v;
+        if ((u & BASE_KIND) == OBJECT || (u & DIM) != 0) {
+            // if u is a reference type of any dimension
+            if (t == NULL) {
+                // if t is the NULL type, merge(u,t)=u, so there is no change
+                return false;
+            } else if ((t & (DIM | BASE_KIND)) == (u & (DIM | BASE_KIND))) {
+                if ((u & BASE_KIND) == OBJECT) {
+                    // if t is also a reference type, and if u and t have the
+                    // same dimension merge(u,t) = dim(t) | common parent of the
+                    // element types of u and t
+                    v = (t & DIM) | OBJECT
+                            | cw.getMergedType(t & BASE_VALUE, u & BASE_VALUE);
+                } else {
+                    // if u and t are array types, but not with the same element
+                    // type, merge(u,t)=java/lang/Object
+                    v = OBJECT | cw.addType("java/lang/Object");
+                }
+            } else if ((t & BASE_KIND) == OBJECT || (t & DIM) != 0) {
+                // if t is any other reference or array type,
+                // merge(u,t)=java/lang/Object
+                v = OBJECT | cw.addType("java/lang/Object");
+            } else {
+                // if t is any other type, merge(u,t)=TOP
+                v = TOP;
+            }
+        } else if (u == NULL) {
+            // if u is the NULL type, merge(u,t)=t,
+            // or TOP if t is not a reference type
+            v = (t & BASE_KIND) == OBJECT || (t & DIM) != 0 ? t : TOP;
+        } else {
+            // if u is any other type, merge(u,t)=TOP whatever t
+            v = TOP;
+        }
+        if (u != v) {
+            types[index] = v;
+            return true;
+        }
+        return false;
+    }
+}
--- /dev/null	Tue Aug  4 10:19:56 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/Handler.java	Tue Aug  4 10:19:55 2009
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * Information about an exception handler block.
+ *
+ * @author Eric Bruneton
+ */
+class Handler {
+
+    /**
+     * Beginning of the exception handler's scope (inclusive).
+     */
+    Label start;
+
+    /**
+     * End of the exception handler's scope (exclusive).
+     */
+    Label end;
+
+    /**
+     * Beginning of the exception handler's code.
+     */
+    Label handler;
+
+    /**
+     * Internal name of the type of exceptions handled by this handler, or
+     * <tt>null</tt> to catch any exceptions.
+     */
+    String desc;
+
+    /**
+     * Constant pool index of the internal name of the type of exceptions
+     * handled by this handler, or 0 to catch any exceptions.
+     */
+    int type;
+
+    /**
+     * Next exception handler block info.
+     */
+    Handler next;
+}
--- /dev/null	Tue Aug  4 10:19:58 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/Item.java	Tue Aug  4 10:19:57 2009
@@ -0,0 +1,286 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * A constant pool item. Constant pool items can be created with the 'newXXX'
+ * methods in the {@link ClassWriter} class.
+ *
+ * @author Eric Bruneton
+ */
+final class Item {
+
+    /**
+     * Index of this item in the constant pool.
+     */
+    int index;
+
+    /**
+     * Type of this constant pool item. A single class is used to represent all
+     * constant pool item types, in order to minimize the bytecode size of this
+     * package. The value of this field is one of {@link ClassWriter#INT},
+     * {@link ClassWriter#LONG}, {@link ClassWriter#FLOAT},
+     * {@link ClassWriter#DOUBLE}, {@link ClassWriter#UTF8},
+     * {@link ClassWriter#STR}, {@link ClassWriter#CLASS},
+     * {@link ClassWriter#NAME_TYPE}, {@link ClassWriter#FIELD},
+     * {@link ClassWriter#METH}, {@link ClassWriter#IMETH}.
+     *
+     * Special Item types are used for Items that are stored in the ClassWriter
+     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to
+     * avoid clashes with normal constant pool items in the ClassWriter constant
+     * pool's hash table. These special item types are
+     * {@link ClassWriter#TYPE_NORMAL}, {@link ClassWriter#TYPE_UNINIT} and
+     * {@link ClassWriter#TYPE_MERGED}.
+     */
+    int type;
+
+    /**
+     * Value of this item, for an integer item.
+     */
+    int intVal;
+
+    /**
+     * Value of this item, for a long item.
+     */
+    long longVal;
+
+    /**
+     * First part of the value of this item, for items that do not hold a
+     * primitive value.
+     */
+    String strVal1;
+
+    /**
+     * Second part of the value of this item, for items that do not hold a
+     * primitive value.
+     */
+    String strVal2;
+
+    /**
+     * Third part of the value of this item, for items that do not hold a
+     * primitive value.
+     */
+    String strVal3;
+
+    /**
+     * The hash code value of this constant pool item.
+     */
+    int hashCode;
+
+    /**
+     * Link to another constant pool item, used for collision lists in the
+     * constant pool's hash table.
+     */
+    Item next;
+
+    /**
+     * Constructs an uninitialized {@link Item}.
+     */
+    Item() {
+    }
+
+    /**
+     * Constructs an uninitialized {@link Item} for constant pool element at
+     * given position.
+     *
+     * @param index index of the item to be constructed.
+     */
+    Item(final int index) {
+        this.index = index;
+    }
+
+    /**
+     * Constructs a copy of the given item.
+     *
+     * @param index index of the item to be constructed.
+     * @param i the item that must be copied into the item to be constructed.
+     */
+    Item(final int index, final Item i) {
+        this.index = index;
+        type = i.type;
+        intVal = i.intVal;
+        longVal = i.longVal;
+        strVal1 = i.strVal1;
+        strVal2 = i.strVal2;
+        strVal3 = i.strVal3;
+        hashCode = i.hashCode;
+    }
+
+    /**
+     * Sets this item to an integer item.
+     *
+     * @param intVal the value of this item.
+     */
+    void set(final int intVal) {
+        this.type = ClassWriter.INT;
+        this.intVal = intVal;
+        this.hashCode = 0x7FFFFFFF & (type + intVal);
+    }
+
+    /**
+     * Sets this item to a long item.
+     *
+     * @param longVal the value of this item.
+     */
+    void set(final long longVal) {
+        this.type = ClassWriter.LONG;
+        this.longVal = longVal;
+        this.hashCode = 0x7FFFFFFF & (type + (int) longVal);
+    }
+
+    /**
+     * Sets this item to a float item.
+     *
+     * @param floatVal the value of this item.
+     */
+    void set(final float floatVal) {
+        this.type = ClassWriter.FLOAT;
+        this.intVal = Float.floatToRawIntBits(floatVal);
+        this.hashCode = 0x7FFFFFFF & (type + (int) floatVal);
+    }
+
+    /**
+     * Sets this item to a double item.
+     *
+     * @param doubleVal the value of this item.
+     */
+    void set(final double doubleVal) {
+        this.type = ClassWriter.DOUBLE;
+        this.longVal = Double.doubleToRawLongBits(doubleVal);
+        this.hashCode = 0x7FFFFFFF & (type + (int) doubleVal);
+    }
+
+    /**
+     * Sets this item to an item that do not hold a primitive value.
+     *
+     * @param type the type of this item.
+     * @param strVal1 first part of the value of this item.
+     * @param strVal2 second part of the value of this item.
+     * @param strVal3 third part of the value of this item.
+     */
+    void set(
+        final int type,
+        final String strVal1,
+        final String strVal2,
+        final String strVal3)
+    {
+        this.type = type;
+        this.strVal1 = strVal1;
+        this.strVal2 = strVal2;
+        this.strVal3 = strVal3;
+        switch (type) {
+            case ClassWriter.UTF8:
+            case ClassWriter.STR:
+            case ClassWriter.CLASS:
+            case ClassWriter.TYPE_NORMAL:
+                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode());
+                return;
+            case ClassWriter.NAME_TYPE:
+                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode()
+                        * strVal2.hashCode());
+                return;
+                // ClassWriter.FIELD:
+                // ClassWriter.METH:
+                // ClassWriter.IMETH:
+            default:
+                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode()
+                        * strVal2.hashCode() * strVal3.hashCode());
+        }
+    }
+
+    /**
+     * Indicates if the given item is equal to this one.
+     *
+     * @param i the item to be compared to this one.
+     * @return <tt>true</tt> if the given item if equal to this one,
+     *         <tt>false</tt> otherwise.
+     */
+    boolean isEqualTo(final Item i) {
+        if (i.type == type) {
+            switch (type) {
+                case ClassWriter.INT:
+                case ClassWriter.FLOAT:
+                    return i.intVal == intVal;
+                case ClassWriter.TYPE_MERGED:
+                case ClassWriter.LONG:
+                case ClassWriter.DOUBLE:
+                    return i.longVal == longVal;
+                case ClassWriter.UTF8:
+                case ClassWriter.STR:
+                case ClassWriter.CLASS:
+                case ClassWriter.TYPE_NORMAL:
+                    return i.strVal1.equals(strVal1);
+                case ClassWriter.TYPE_UNINIT:
+                    return i.intVal == intVal && i.strVal1.equals(strVal1);
+                case ClassWriter.NAME_TYPE:
+                    return i.strVal1.equals(strVal1)
+                            && i.strVal2.equals(strVal2);
+                    // ClassWriter.FIELD:
+                    // ClassWriter.METH:
+                    // ClassWriter.IMETH:
+                default:
+                    return i.strVal1.equals(strVal1)
+                            && i.strVal2.equals(strVal2)
+                            && i.strVal3.equals(strVal3);
+            }
+        }
+        return false;
+    }
+}
--- /dev/null	Tue Aug  4 10:20:00 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/Label.java	Tue Aug  4 10:20:00 2009
@@ -0,0 +1,556 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * A label represents a position in the bytecode of a method. Labels are used
+ * for jump, goto, and switch instructions, and for try catch blocks.
+ *
+ * @author Eric Bruneton
+ */
+public class Label {
+
+    /**
+     * Indicates if this label is only used for debug attributes. Such a label
+     * is not the start of a basic block, the target of a jump instruction, or
+     * an exception handler. It can be safely ignored in control flow graph
+     * analysis algorithms (for optimization purposes).
+     */
+    static final int DEBUG = 1;
+
+    /**
+     * Indicates if the position of this label is known.
+     */
+    static final int RESOLVED = 2;
+
+    /**
+     * Indicates if this label has been updated, after instruction resizing.
+     */
+    static final int RESIZED = 4;
+
+    /**
+     * Indicates if this basic block has been pushed in the basic block stack.
+     * See {@link MethodWriter#visitMaxs visitMaxs}.
+     */
+    static final int PUSHED = 8;
+
+    /**
+     * Indicates if this label is the target of a jump instruction, or the start
+     * of an exception handler.
+     */
+    static final int TARGET = 16;
+
+    /**
+     * Indicates if a stack map frame must be stored for this label.
+     */
+    static final int STORE = 32;
+
+    /**
+     * Indicates if this label corresponds to a reachable basic block.
+     */
+    static final int REACHABLE = 64;
+
+    /**
+     * Indicates if this basic block ends with a JSR instruction.
+     */
+    static final int JSR = 128;
+
+    /**
+     * Indicates if this basic block ends with a RET instruction.
+     */
+    static final int RET = 256;
+
+    /**
+     * Indicates if this basic block is the start of a subroutine.
+     */
+    static final int SUBROUTINE = 512;
+
+    /**
+     * Indicates if this subroutine basic block has been visited.
+     */
+    static final int VISITED = 1024;
+
+    /**
+     * Field used to associate user information to a label. Warning: this field
+     * is used by the ASM tree package. In order to use it with the ASM tree
+     * package you must override the {@link
+     * com.sun.xml.internal.ws.org.objectweb.asm.tree.MethodNode#getLabelNode} method.
+     */
+    public Object info;
+
+    /**
+     * Flags that indicate the status of this label.
+     *
+     * @see #DEBUG
+     * @see #RESOLVED
+     * @see #RESIZED
+     * @see #PUSHED
+     * @see #TARGET
+     * @see #STORE
+     * @see #REACHABLE
+     * @see #JSR
+     * @see #RET
+     */
+    int status;
+
+    /**
+     * The line number corresponding to this label, if known.
+     */
+    int line;
+
+    /**
+     * The position of this label in the code, if known.
+     */
+    int position;
+
+    /**
+     * Number of forward references to this label, times two.
+     */
+    private int referenceCount;
+
+    /**
+     * Informations about forward references. Each forward reference is
+     * described by two consecutive integers in this array: the first one is the
+     * position of the first byte of the bytecode instruction that contains the
+     * forward reference, while the second is the position of the first byte of
+     * the forward reference itself. In fact the sign of the first integer
+     * indicates if this reference uses 2 or 4 bytes, and its absolute value
+     * gives the position of the bytecode instruction. This array is also used
+     * as a bitset to store the subroutines to which a basic block belongs. This
+     * information is needed in {@linked  MethodWriter#visitMaxs}, after all
+     * forward references have been resolved. Hence the same array can be used
+     * for both purposes without problems.
+     */
+    private int[] srcAndRefPositions;
+
+    // ------------------------------------------------------------------------
+
+    /*
+     * Fields for the control flow and data flow graph analysis algorithms (used
+     * to compute the maximum stack size or the stack map frames). A control
+     * flow graph contains one node per "basic block", and one edge per "jump"
+     * from one basic block to another. Each node (i.e., each basic block) is
+     * represented by the Label object that corresponds to the first instruction
+     * of this basic block. Each node also stores the list of its successors in
+     * the graph, as a linked list of Edge objects.
+     *
+     * The control flow analysis algorithms used to compute the maximum stack
+     * size or the stack map frames are similar and use two steps. The first
+     * step, during the visit of each instruction, builds information about the
+     * state of the local variables and the operand stack at the end of each
+     * basic block, called the "output frame", <i>relatively</i> to the frame
+     * state at the beginning of the basic block, which is called the "input
+     * frame", and which is <i>unknown</i> during this step. The second step,
+     * in {@link MethodWriter#visitMaxs}, is a fix point algorithm that
+     * computes information about the input frame of each basic block, from the
+     * input state of the first basic block (known from the method signature),
+     * and by the using the previously computed relative output frames.
+     *
+     * The algorithm used to compute the maximum stack size only computes the
+     * relative output and absolute input stack heights, while the algorithm
+     * used to compute stack map frames computes relative output frames and
+     * absolute input frames.
+     */
+
+    /**
+     * Start of the output stack relatively to the input stack. The exact
+     * semantics of this field depends on the algorithm that is used.
+     *
+     * When only the maximum stack size is computed, this field is the number of
+     * elements in the input stack.
+     *
+     * When the stack map frames are completely computed, this field is the
+     * offset of the first output stack element relatively to the top of the
+     * input stack. This offset is always negative or null. A null offset means
+     * that the output stack must be appended to the input stack. A -n offset
+     * means that the first n output stack elements must replace the top n input
+     * stack elements, and that the other elements must be appended to the input
+     * stack.
+     */
+    int inputStackTop;
+
+    /**
+     * Maximum height reached by the output stack, relatively to the top of the
+     * input stack. This maximum is always positive or null.
+     */
+    int outputStackMax;
+
+    /**
+     * Information about the input and output stack map frames of this basic
+     * block. This field is only used when {@link ClassWriter#COMPUTE_FRAMES}
+     * option is used.
+     */
+    Frame frame;
+
+    /**
+     * The successor of this label, in the order they are visited. This linked
+     * list does not include labels used for debug info only. If
+     * {@link ClassWriter#COMPUTE_FRAMES} option is used then, in addition, it
+     * does not contain successive labels that denote the same bytecode position
+     * (in this case only the first label appears in this list).
+     */
+    Label successor;
+
+    /**
+     * The successors of this node in the control flow graph. These successors
+     * are stored in a linked list of {@link Edge Edge} objects, linked to each
+     * other by their {@link Edge#next} field.
+     */
+    Edge successors;
+
+    /**
+     * The next basic block in the basic block stack. This stack is used in the
+     * main loop of the fix point algorithm used in the second step of the
+     * control flow analysis algorithms.
+     *
+     * @see MethodWriter#visitMaxs
+     */
+    Label next;
+
+    // ------------------------------------------------------------------------
+    // Constructor
+    // ------------------------------------------------------------------------
+
+    /**
+     * Constructs a new label.
+     */
+    public Label() {
+    }
+
+    // ------------------------------------------------------------------------
+    // Methods to compute offsets and to manage forward references
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns the offset corresponding to this label. This offset is computed
+     * from the start of the method's bytecode. <i>This method is intended for
+     * {@link Attribute} sub classes, and is normally not needed by class
+     * generators or adapters.</i>
+     *
+     * @return the offset corresponding to this label.
+     * @throws IllegalStateException if this label is not resolved yet.
+     */
+    public int getOffset() {
+        if ((status & RESOLVED) == 0) {
+            throw new IllegalStateException("Label offset position has not been resolved yet");
+        }
+        return position;
+    }
+
+    /**
+     * Puts a reference to this label in the bytecode of a method. If the
+     * position of the label is known, the offset is computed and written
+     * directly. Otherwise, a null offset is written and a new forward reference
+     * is declared for this label.
+     *
+     * @param owner the code writer that calls this method.
+     * @param out the bytecode of the method.
+     * @param source the position of first byte of the bytecode instruction that
+     *        contains this label.
+     * @param wideOffset <tt>true</tt> if the reference must be stored in 4
+     *        bytes, or <tt>false</tt> if it must be stored with 2 bytes.
+     * @throws IllegalArgumentException if this label has not been created by
+     *         the given code writer.
+     */
+    void put(
+        final MethodWriter owner,
+        final ByteVector out,
+        final int source,
+        final boolean wideOffset)
+    {
+        if ((status & RESOLVED) == 0) {
+            if (wideOffset) {
+                addReference(-1 - source, out.length);
+                out.putInt(-1);
+            } else {
+                addReference(source, out.length);
+                out.putShort(-1);
+            }
+        } else {
+            if (wideOffset) {
+                out.putInt(position - source);
+            } else {
+                out.putShort(position - source);
+            }
+        }
+    }
+
+    /**
+     * Adds a forward reference to this label. This method must be called only
+     * for a true forward reference, i.e. only if this label is not resolved
+     * yet. For backward references, the offset of the reference can be, and
+     * must be, computed and stored directly.
+     *
+     * @param sourcePosition the position of the referencing instruction. This
+     *        position will be used to compute the offset of this forward
+     *        reference.
+     * @param referencePosition the position where the offset for this forward
+     *        reference must be stored.
+     */
+    private void addReference(
+        final int sourcePosition,
+        final int referencePosition)
+    {
+        if (srcAndRefPositions == null) {
+            srcAndRefPositions = new int[6];
+        }
+        if (referenceCount >= srcAndRefPositions.length) {
+            int[] a = new int[srcAndRefPositions.length + 6];
+            System.arraycopy(srcAndRefPositions,
+                    0,
+                    a,
+                    0,
+                    srcAndRefPositions.length);
+            srcAndRefPositions = a;
+        }
+        srcAndRefPositions[referenceCount++] = sourcePosition;
+        srcAndRefPositions[referenceCount++] = referencePosition;
+    }
+
+    /**
+     * Resolves all forward references to this label. This method must be called
+     * when this label is added to the bytecode of the method, i.e. when its
+     * position becomes known. This method fills in the blanks that where left
+     * in the bytecode by each forward reference previously added to this label.
+     *
+     * @param owner the code writer that calls this method.
+     * @param position the position of this label in the bytecode.
+     * @param data the bytecode of the method.
+     * @return <tt>true</tt> if a blank that was left for this label was to
+     *         small to store the offset. In such a case the corresponding jump
+     *         instruction is replaced with a pseudo instruction (using unused
+     *         opcodes) using an unsigned two bytes offset. These pseudo
+     *         instructions will need to be replaced with true instructions with
+     *         wider offsets (4 bytes instead of 2). This is done in
+     *         {@link MethodWriter#resizeInstructions}.
+     * @throws IllegalArgumentException if this label has already been resolved,
+     *         or if it has not been created by the given code writer.
+     */
+    boolean resolve(
+        final MethodWriter owner,
+        final int position,
+        final byte[] data)
+    {
+        boolean needUpdate = false;
+        this.status |= RESOLVED;
+        this.position = position;
+        int i = 0;
+        while (i < referenceCount) {
+            int source = srcAndRefPositions[i++];
+            int reference = srcAndRefPositions[i++];
+            int offset;
+            if (source >= 0) {
+                offset = position - source;
+                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
+                    /*
+                     * changes the opcode of the jump instruction, in order to
+                     * be able to find it later (see resizeInstructions in
+                     * MethodWriter). These temporary opcodes are similar to
+                     * jump instruction opcodes, except that the 2 bytes offset
+                     * is unsigned (and can therefore represent values from 0 to
+                     * 65535, which is sufficient since the size of a method is
+                     * limited to 65535 bytes).
+                     */
+                    int opcode = data[reference - 1] & 0xFF;
+                    if (opcode <= Opcodes.JSR) {
+                        // changes IFEQ ... JSR to opcodes 202 to 217
+                        data[reference - 1] = (byte) (opcode + 49);
+                    } else {
+                        // changes IFNULL and IFNONNULL to opcodes 218 and 219
+                        data[reference - 1] = (byte) (opcode + 20);
+                    }
+                    needUpdate = true;
+                }
+                data[reference++] = (byte) (offset >>> 8);
+                data[reference] = (byte) offset;
+            } else {
+                offset = position + source + 1;
+                data[reference++] = (byte) (offset >>> 24);
+                data[reference++] = (byte) (offset >>> 16);
+                data[reference++] = (byte) (offset >>> 8);
+                data[reference] = (byte) offset;
+            }
+        }
+        return needUpdate;
+    }
+
+    /**
+     * Returns the first label of the series to which this label belongs. For an
+     * isolated label or for the first label in a series of successive labels,
+     * this method returns the label itself. For other labels it returns the
+     * first label of the series.
+     *
+     * @return the first label of the series to which this label belongs.
+     */
+    Label getFirst() {
+        return !ClassReader.FRAMES || frame == null ? this : frame.owner;
+    }
+
+    // ------------------------------------------------------------------------
+    // Methods related to subroutines
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns true is this basic block belongs to the given subroutine.
+     *
+     * @param id a subroutine id.
+     * @return true is this basic block belongs to the given subroutine.
+     */
+    boolean inSubroutine(final long id) {
+        if ((status & Label.VISITED) != 0) {
+            return (srcAndRefPositions[(int) (id >>> 32)] & (int) id) != 0;
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if this basic block and the given one belong to a common
+     * subroutine.
+     *
+     * @param block another basic block.
+     * @return true if this basic block and the given one belong to a common
+     *         subroutine.
+     */
+    boolean inSameSubroutine(final Label block) {
+        for (int i = 0; i < srcAndRefPositions.length; ++i) {
+            if ((srcAndRefPositions[i] & block.srcAndRefPositions[i]) != 0) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Marks this basic block as belonging to the given subroutine.
+     *
+     * @param id a subroutine id.
+     * @param nbSubroutines the total number of subroutines in the method.
+     */
+    void addToSubroutine(final long id, final int nbSubroutines) {
+        if ((status & VISITED) == 0) {
+            status |= VISITED;
+            srcAndRefPositions = new int[(nbSubroutines - 1) / 32 + 1];
+        }
+        srcAndRefPositions[(int) (id >>> 32)] |= (int) id;
+    }
+
+    /**
+     * Finds the basic blocks that belong to a given subroutine, and marks these
+     * blocks as belonging to this subroutine. This recursive method follows the
+     * control flow graph to find all the blocks that are reachable from the
+     * current block WITHOUT following any JSR target.
+     *
+     * @param JSR a JSR block that jumps to this subroutine. If this JSR is not
+     *        null it is added to the successor of the RET blocks found in the
+     *        subroutine.
+     * @param id the id of this subroutine.
+     * @param nbSubroutines the total number of subroutines in the method.
+     */
+    void visitSubroutine(final Label JSR, final long id, final int nbSubroutines)
+    {
+        if (JSR != null) {
+            if ((status & VISITED) != 0) {
+                return;
+            }
+            status |= VISITED;
+            // adds JSR to the successors of this block, if it is a RET block
+            if ((status & RET) != 0) {
+                if (!inSameSubroutine(JSR)) {
+                    Edge e = new Edge();
+                    e.info = inputStackTop;
+                    e.successor = JSR.successors.successor;
+                    e.next = successors;
+                    successors = e;
+                }
+            }
+        } else {
+            // if this block already belongs to subroutine 'id', returns
+            if (inSubroutine(id)) {
+                return;
+            }
+            // marks this block as belonging to subroutine 'id'
+            addToSubroutine(id, nbSubroutines);
+        }
+        // calls this method recursively on each successor, except JSR targets
+        Edge e = successors;
+        while (e != null) {
+            // if this block is a JSR block, then 'successors.next' leads
+            // to the JSR target (see {@link #visitJumpInsn}) and must therefore
+            // not be followed
+            if ((status & Label.JSR) == 0 || e != successors.next) {
+                e.successor.visitSubroutine(JSR, id, nbSubroutines);
+            }
+            e = e.next;
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    // Overriden Object methods
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns a string representation of this label.
+     *
+     * @return a string representation of this label.
+     */
+    public String toString() {
+        return "L" + System.identityHashCode(this);
+    }
+}
--- /dev/null	Tue Aug  4 10:20:02 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/MethodVisitor.java	Tue Aug  4 10:20:02 2009
@@ -0,0 +1,425 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * A visitor to visit a Java method. The methods of this interface must be
+ * called in the following order: [ <tt>visitAnnotationDefault</tt> ] (
+ * <tt>visitAnnotation</tt> | <tt>visitParameterAnnotation</tt> |
+ * <tt>visitAttribute</tt> )* [ <tt>visitCode</tt> ( <tt>visitFrame</tt> |
+ * <tt>visit</tt><i>X</i>Insn</tt> | <tt>visitLabel</tt> | <tt>visitTryCatchBlock</tt> |
+ * <tt>visitLocalVariable</tt> | <tt>visitLineNumber</tt>)* <tt>visitMaxs</tt> ]
+ * <tt>visitEnd</tt>. In addition, the <tt>visit</tt><i>X</i>Insn</tt>
+ * and <tt>visitLabel</tt> methods must be called in the sequential order of
+ * the bytecode instructions of the visited code, <tt>visitTryCatchBlock</tt>
+ * must be called <i>before</i> the labels passed as arguments have been
+ * visited, and the <tt>visitLocalVariable</tt> and <tt>visitLineNumber</tt>
+ * methods must be called <i>after</i> the labels passed as arguments have been
+ * visited.
+ *
+ * @author Eric Bruneton
+ */
+public interface MethodVisitor {
+
+    // -------------------------------------------------------------------------
+    // Annotations and non standard attributes
+    // -------------------------------------------------------------------------
+
+    /**
+     * Visits the default value of this annotation interface method.
+     *
+     * @return a visitor to the visit the actual default value of this
+     *         annotation interface method, or <tt>null</tt> if this visitor
+     *         is not interested in visiting this default value. The 'name'
+     *         parameters passed to the methods of this annotation visitor are
+     *         ignored. Moreover, exacly one visit method must be called on this
+     *         annotation visitor, followed by visitEnd.
+     */
+    AnnotationVisitor visitAnnotationDefault();
+
+    /**
+     * Visits an annotation of this method.
+     *
+     * @param desc the class descriptor of the annotation class.
+     * @param visible <tt>true</tt> if the annotation is visible at runtime.
+     * @return a visitor to visit the annotation values, or <tt>null</tt> if
+     *         this visitor is not interested in visiting this annotation.
+     */
+    AnnotationVisitor visitAnnotation(String desc, boolean visible);
+
+    /**
+     * Visits an annotation of a parameter this method.
+     *
+     * @param parameter the parameter index.
+     * @param desc the class descriptor of the annotation class.
+     * @param visible <tt>true</tt> if the annotation is visible at runtime.
+     * @return a visitor to visit the annotation values, or <tt>null</tt> if
+     *         this visitor is not interested in visiting this annotation.
+     */
+    AnnotationVisitor visitParameterAnnotation(
+        int parameter,
+        String desc,
+        boolean visible);
+
+    /**
+     * Visits a non standard attribute of this method.
+     *
+     * @param attr an attribute.
+     */
+    void visitAttribute(Attribute attr);
+
+    /**
+     * Starts the visit of the method's code, if any (i.e. non abstract method).
+     */
+    void visitCode();
+
+    /**
+     * Visits the current state of the local variables and operand stack
+     * elements. This method must(*) be called <i>just before</i> any
+     * instruction <b>i</b> that follows an unconditionnal branch instruction
+     * such as GOTO or THROW, that is the target of a jump instruction, or that
+     * starts an exception handler block. The visited types must describe the
+     * values of the local variables and of the operand stack elements <i>just
+     * before</i> <b>i</b> is executed. <br> <br> (*) this is mandatory only
+     * for classes whose version is greater than or equal to
+     * {@link Opcodes#V1_6 V1_6}. <br> <br> Packed frames are basically
+     * "deltas" from the state of the previous frame (very first frame is
+     * implicitly defined by the method's parameters and access flags): <ul>
+     * <li>{@link Opcodes#F_SAME} representing frame with exactly the same
+     * locals as the previous frame and with the empty stack.</li> <li>{@link Opcodes#F_SAME1}
+     * representing frame with exactly the same locals as the previous frame and
+     * with single value on the stack (<code>nStack</code> is 1 and
+     * <code>stack[0]</code> contains value for the type of the stack item).</li>
+     * <li>{@link Opcodes#F_APPEND} representing frame with current locals are
+     * the same as the locals in the previous frame, except that additional
+     * locals are defined (<code>nLocal</code> is 1, 2 or 3 and
+     * <code>local</code> elements contains values representing added types).</li>
+     * <li>{@link Opcodes#F_CHOP} representing frame with current locals are
+     * the same as the locals in the previous frame, except that the last 1-3
+     * locals are absent and with the empty stack (<code>nLocals</code> is 1,
+     * 2 or 3). </li> <li>{@link Opcodes#F_FULL} representing complete frame
+     * data.</li> </li> </ul>
+     *
+     * @param type the type of this stack map frame. Must be
+     *        {@link Opcodes#F_NEW} for expanded frames, or
+     *        {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND},
+     *        {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or
+     *        {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed
+     *        frames.
+     * @param nLocal the number of local variables in the visited frame.
+     * @param local the local variable types in this frame. This array must not
+     *        be modified. Primitive types are represented by
+     *        {@link Opcodes#TOP}, {@link Opcodes#INTEGER},
+     *        {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
+     *        {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
+     *        {@link Opcodes#UNINITIALIZED_THIS} (long and double are
+     *        represented by a single element). Reference types are represented
+     *        by String objects (representing internal names), and uninitialized
+     *        types by Label objects (this label designates the NEW instruction
+     *        that created this uninitialized value).
+     * @param nStack the number of operand stack elements in the visited frame.
+     * @param stack the operand stack types in this frame. This array must not
+     *        be modified. Its content has the same format as the "local" array.
+     */
+    void visitFrame(
+        int type,
+        int nLocal,
+        Object[] local,
+        int nStack,
+        Object[] stack);
+
+    // -------------------------------------------------------------------------
+    // Normal instructions
+    // -------------------------------------------------------------------------
+
+    /**
+     * Visits a zero operand instruction.
+     *
+     * @param opcode the opcode of the instruction to be visited. This opcode is
+     *        either NOP, ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2,
+     *        ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1, FCONST_0,
+     *        FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD, FALOAD,
+     *        DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE,
+     *        DASTORE, AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP,
+     *        DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP, IADD, LADD, FADD,
+     *        DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,
+     *        FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL,
+     *        LSHL, ISHR, LSHR, IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR,
+     *        I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F, I2B,
+     *        I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN,
+     *        FRETURN, DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW,
+     *        MONITORENTER, or MONITOREXIT.
+     */
+    void visitInsn(int opcode);
+
+    /**
+     * Visits an instruction with a single int operand.
+     *
+     * @param opcode the opcode of the instruction to be visited. This opcode is
+     *        either BIPUSH, SIPUSH or NEWARRAY.
+     * @param operand the operand of the instruction to be visited.<br> When
+     *        opcode is BIPUSH, operand value should be between Byte.MIN_VALUE
+     *        and Byte.MAX_VALUE.<br> When opcode is SIPUSH, operand value
+     *        should be between Short.MIN_VALUE and Short.MAX_VALUE.<br> When
+     *        opcode is NEWARRAY, operand value should be one of
+     *        {@link Opcodes#T_BOOLEAN}, {@link Opcodes#T_CHAR},
+     *        {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE},
+     *        {@link Opcodes#T_BYTE}, {@link Opcodes#T_SHORT},
+     *        {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.
+     */
+    void visitIntInsn(int opcode, int operand);
+
+    /**
+     * Visits a local variable instruction. A local variable instruction is an
+     * instruction that loads or stores the value of a local variable.
+     *
+     * @param opcode the opcode of the local variable instruction to be visited.
+     *        This opcode is either ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE,
+     *        LSTORE, FSTORE, DSTORE, ASTORE or RET.
+     * @param var the operand of the instruction to be visited. This operand is
+     *        the index of a local variable.
+     */
+    void visitVarInsn(int opcode, int var);
+
+    /**
+     * Visits a type instruction. A type instruction is an instruction that
+     * takes the internal name of a class as parameter.
+     *
+     * @param opcode the opcode of the type instruction to be visited. This
+     *        opcode is either NEW, ANEWARRAY, CHECKCAST or INSTANCEOF.
+     * @param type the operand of the instruction to be visited. This operand
+     *        must be the internal name of an object or array class (see {@link
+     *        Type#getInternalName() getInternalName}).
+     */
+    void visitTypeInsn(int opcode, String type);
+
+    /**
+     * Visits a field instruction. A field instruction is an instruction that
+     * loads or stores the value of a field of an object.
+     *
+     * @param opcode the opcode of the type instruction to be visited. This
+     *        opcode is either GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
+     * @param owner the internal name of the field's owner class (see {@link
+     *        Type#getInternalName() getInternalName}).
+     * @param name the field's name.
+     * @param desc the field's descriptor (see {@link Type Type}).
+     */
+    void visitFieldInsn(int opcode, String owner, String name, String desc);
+
+    /**
+     * Visits a method instruction. A method instruction is an instruction that
+     * invokes a method.
+     *
+     * @param opcode the opcode of the type instruction to be visited. This
+     *        opcode is either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or
+     *        INVOKEINTERFACE.
+     * @param owner the internal name of the method's owner class (see {@link
+     *        Type#getInternalName() getInternalName}).
+     * @param name the method's name.
+     * @param desc the method's descriptor (see {@link Type Type}).
+     */
+    void visitMethodInsn(int opcode, String owner, String name, String desc);
+
+    /**
+     * Visits a jump instruction. A jump instruction is an instruction that may
+     * jump to another instruction.
+     *
+     * @param opcode the opcode of the type instruction to be visited. This
+     *        opcode is either IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ,
+     *        IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ,
+     *        IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
+     * @param label the operand of the instruction to be visited. This operand
+     *        is a label that designates the instruction to which the jump
+     *        instruction may jump.
+     */
+    void visitJumpInsn(int opcode, Label label);
+
+    /**
+     * Visits a label. A label designates the instruction that will be visited
+     * just after it.
+     *
+     * @param label a {@link Label Label} object.
+     */
+    void visitLabel(Label label);
+
+    // -------------------------------------------------------------------------
+    // Special instructions
+    // -------------------------------------------------------------------------
+
+    /**
+     * Visits a LDC instruction.
+     *
+     * @param cst the constant to be loaded on the stack. This parameter must be
+     *        a non null {@link Integer}, a {@link Float}, a {@link Long}, a
+     *        {@link Double} a {@link String} (or a {@link Type} for
+     *        <tt>.class</tt> constants, for classes whose version is 49.0 or
+     *        more).
+     */
+    void visitLdcInsn(Object cst);
+
+    /**
+     * Visits an IINC instruction.
+     *
+     * @param var index of the local variable to be incremented.
+     * @param increment amount to increment the local variable by.
+     */
+    void visitIincInsn(int var, int increment);
+
+    /**
+     * Visits a TABLESWITCH instruction.
+     *
+     * @param min the minimum key value.
+     * @param max the maximum key value.
+     * @param dflt beginning of the default handler block.
+     * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is
+     *        the beginning of the handler block for the <tt>min + i</tt> key.
+     */
+    void visitTableSwitchInsn(int min, int max, Label dflt, Label[] labels);
+
+    /**
+     * Visits a LOOKUPSWITCH instruction.
+     *
+     * @param dflt beginning of the default handler block.
+     * @param keys the values of the keys.
+     * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is
+     *        the beginning of the handler block for the <tt>keys[i]</tt> key.
+     */
+    void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels);
+
+    /**
+     * Visits a MULTIANEWARRAY instruction.
+     *
+     * @param desc an array type descriptor (see {@link Type Type}).
+     * @param dims number of dimensions of the array to allocate.
+     */
+    void visitMultiANewArrayInsn(String desc, int dims);
+
+    // -------------------------------------------------------------------------
+    // Exceptions table entries, debug information, max stack and max locals
+    // -------------------------------------------------------------------------
+
+    /**
+     * Visits a try catch block.
+     *
+     * @param start beginning of the exception handler's scope (inclusive).
+     * @param end end of the exception handler's scope (exclusive).
+     * @param handler beginning of the exception handler's code.
+     * @param type internal name of the type of exceptions handled by the
+     *        handler, or <tt>null</tt> to catch any exceptions (for "finally"
+     *        blocks).
+     * @throws IllegalArgumentException if one of the labels has already been
+     *         visited by this visitor (by the {@link #visitLabel visitLabel}
+     *         method).
+     */
+    void visitTryCatchBlock(Label start, Label end, Label handler, String type);
+
+    /**
+     * Visits a local variable declaration.
+     *
+     * @param name the name of a local variable.
+     * @param desc the type descriptor of this local variable.
+     * @param signature the type signature of this local variable. May be
+     *        <tt>null</tt> if the local variable type does not use generic
+     *        types.
+     * @param start the first instruction corresponding to the scope of this
+     *        local variable (inclusive).
+     * @param end the last instruction corresponding to the scope of this local
+     *        variable (exclusive).
+     * @param index the local variable's index.
+     * @throws IllegalArgumentException if one of the labels has not already
+     *         been visited by this visitor (by the
+     *         {@link #visitLabel visitLabel} method).
+     */
+    void visitLocalVariable(
+        String name,
+        String desc,
+        String signature,
+        Label start,
+        Label end,
+        int index);
+
+    /**
+     * Visits a line number declaration.
+     *
+     * @param line a line number. This number refers to the source file from
+     *        which the class was compiled.
+     * @param start the first instruction corresponding to this line number.
+     * @throws IllegalArgumentException if <tt>start</tt> has not already been
+     *         visited by this visitor (by the {@link #visitLabel visitLabel}
+     *         method).
+     */
+    void visitLineNumber(int line, Label start);
+
+    /**
+     * Visits the maximum stack size and the maximum number of local variables
+     * of the method.
+     *
+     * @param maxStack maximum stack size of the method.
+     * @param maxLocals maximum number of local variables for the method.
+     */
+    void visitMaxs(int maxStack, int maxLocals);
+
+    /**
+     * Visits the end of the method. This method, which is the last one to be
+     * called, is used to inform the visitor that all the annotations and
+     * attributes of the method have been visited.
+     */
+    void visitEnd();
+}
--- /dev/null	Tue Aug  4 10:20:04 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/MethodWriter.java	Tue Aug  4 10:20:04 2009
@@ -0,0 +1,2631 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * A {@link MethodVisitor} that generates methods in bytecode form. Each visit
+ * method of this class appends the bytecode corresponding to the visited
+ * instruction to a byte vector, in the order these methods are called.
+ *
+ * @author Eric Bruneton
+ * @author Eugene Kuleshov
+ */
+class MethodWriter implements MethodVisitor {
+
+    /**
+     * Pseudo access flag used to denote constructors.
+     */
+    static final int ACC_CONSTRUCTOR = 262144;
+
+    /**
+     * Frame has exactly the same locals as the previous stack map frame and
+     * number of stack items is zero.
+     */
+    static final int SAME_FRAME = 0; // to 63 (0-3f)
+
+    /**
+     * Frame has exactly the same locals as the previous stack map frame and
+     * number of stack items is 1
+     */
+    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64; // to 127 (40-7f)
+
+    /**
+     * Reserved for future use
+     */
+    static final int RESERVED = 128;
+
+    /**
+     * Frame has exactly the same locals as the previous stack map frame and
+     * number of stack items is 1. Offset is bigger then 63;
+     */
+    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247; // f7
+
+    /**
+     * Frame where current locals are the same as the locals in the previous
+     * frame, except that the k last locals are absent. The value of k is given
+     * by the formula 251-frame_type.
+     */
+    static final int CHOP_FRAME = 248; // to 250 (f8-fA)
+
+    /**
+     * Frame has exactly the same locals as the previous stack map frame and
+     * number of stack items is zero. Offset is bigger then 63;
+     */
+    static final int SAME_FRAME_EXTENDED = 251; // fb
+
+    /**
+     * Frame where current locals are the same as the locals in the previous
+     * frame, except that k additional locals are defined. The value of k is
+     * given by the formula frame_type-251.
+     */
+    static final int APPEND_FRAME = 252; // to 254 // fc-fe
+
+    /**
+     * Full frame
+     */
+    static final int FULL_FRAME = 255; // ff
+
+    /**
+     * Indicates that the stack map frames must be recomputed from scratch. In
+     * this case the maximum stack size and number of local variables is also
+     * recomputed from scratch.
+     *
+     * @see #compute
+     */
+    private static final int FRAMES = 0;
+
+    /**
+     * Indicates that the maximum stack size and number of local variables must
+     * be automatically computed.
+     *
+     * @see #compute
+     */
+    private static final int MAXS = 1;
+
+    /**
+     * Indicates that nothing must be automatically computed.
+     *
+     * @see #compute
+     */
+    private static final int NOTHING = 2;
+
+    /**
+     * Next method writer (see {@link ClassWriter#firstMethod firstMethod}).
+     */
+    MethodWriter next;
+
+    /**
+     * The class writer to which this method must be added.
+     */
+    final ClassWriter cw;
+
+    /**
+     * Access flags of this method.
+     */
+    private int access;
+
+    /**
+     * The index of the constant pool item that contains the name of this
+     * method.
+     */
+    private final int name;
+
+    /**
+     * The index of the constant pool item that contains the descriptor of this
+     * method.
+     */
+    private final int desc;
+
+    /**
+     * The descriptor of this method.
+     */
+    private final String descriptor;
+
+    /**
+     * The signature of this method.
+     */
+    String signature;
+
+    /**
+     * If not zero, indicates that the code of this method must be copied from
+     * the ClassReader associated to this writer in <code>cw.cr</code>. More
+     * precisely, this field gives the index of the first byte to copied from
+     * <code>cw.cr.b</code>.
+     */
+    int classReaderOffset;
+
+    /**
+     * If not zero, indicates that the code of this method must be copied from
+     * the ClassReader associated to this writer in <code>cw.cr</code>. More
+     * precisely, this field gives the number of bytes to copied from
+     * <code>cw.cr.b</code>.
+     */
+    int classReaderLength;
+
+    /**
+     * Number of exceptions that can be thrown by this method.
+     */
+    int exceptionCount;
+
+    /**
+     * The exceptions that can be thrown by this method. More precisely, this
+     * array contains the indexes of the constant pool items that contain the
+     * internal names of these exception classes.
+     */
+    int[] exceptions;
+
+    /**
+     * The annotation default attribute of this method. May be <tt>null</tt>.
+     */
+    private ByteVector annd;
+
+    /**
+     * The runtime visible annotations of this method. May be <tt>null</tt>.
+     */
+    private AnnotationWriter anns;
+
+    /**
+     * The runtime invisible annotations of this method. May be <tt>null</tt>.
+     */
+    private AnnotationWriter ianns;
+
+    /**
+     * The runtime visible parameter annotations of this method. May be
+     * <tt>null</tt>.
+     */
+    private AnnotationWriter[] panns;
+
+    /**
+     * The runtime invisible parameter annotations of this method. May be
+     * <tt>null</tt>.
+     */
+    private AnnotationWriter[] ipanns;
+
+    /**
+     * The number of synthetic parameters of this method.
+     */
+    private int synthetics;
+
+    /**
+     * The non standard attributes of the method.
+     */
+    private Attribute attrs;
+
+    /**
+     * The bytecode of this method.
+     */
+    private ByteVector code = new ByteVector();
+
+    /**
+     * Maximum stack size of this method.
+     */
+    private int maxStack;
+
+    /**
+     * Maximum number of local variables for this method.
+     */
+    private int maxLocals;
+
+    /**
+     * Number of stack map frames in the StackMapTable attribute.
+     */
+    private int frameCount;
+
+    /**
+     * The StackMapTable attribute.
+     */
+    private ByteVector stackMap;
+
+    /**
+     * The offset of the last frame that was written in the StackMapTable
+     * attribute.
+     */
+    private int previousFrameOffset;
+
+    /**
+     * The last frame that was written in the StackMapTable attribute.
+     *
+     * @see #frame
+     */
+    private int[] previousFrame;
+
+    /**
+     * Index of the next element to be added in {@link #frame}.
+     */
+    private int frameIndex;
+
+    /**
+     * The current stack map frame. The first element contains the offset of the
+     * instruction to which the frame corresponds, the second element is the
+     * number of locals and the third one is the number of stack elements. The
+     * local variables start at index 3 and are followed by the operand stack
+     * values. In summary frame[0] = offset, frame[1] = nLocal, frame[2] =
+     * nStack, frame[3] = nLocal. All types are encoded as integers, with the
+     * same format as the one used in {@link Label}, but limited to BASE types.
+     */
+    private int[] frame;
+
+    /**
+     * Number of elements in the exception handler list.
+     */
+    private int handlerCount;
+
+    /**
+     * The first element in the exception handler list.
+     */
+    private Handler firstHandler;
+
+    /**
+     * The last element in the exception handler list.
+     */
+    private Handler lastHandler;
+
+    /**
+     * Number of entries in the LocalVariableTable attribute.
+     */
+    private int localVarCount;
+
+    /**
+     * The LocalVariableTable attribute.
+     */
+    private ByteVector localVar;
+
+    /**
+     * Number of entries in the LocalVariableTypeTable attribute.
+     */
+    private int localVarTypeCount;
+
+    /**
+     * The LocalVariableTypeTable attribute.
+     */
+    private ByteVector localVarType;
+
+    /**
+     * Number of entries in the LineNumberTable attribute.
+     */
+    private int lineNumberCount;
+
+    /**
+     * The LineNumberTable attribute.
+     */
+    private ByteVector lineNumber;
+
+    /**
+     * The non standard attributes of the method's code.
+     */
+    private Attribute cattrs;
+
+    /**
+     * Indicates if some jump instructions are too small and need to be resized.
+     */
+    private boolean resize;
+
+    /**
+     * The number of subroutines in this method.
+     */
+    private int subroutines;
+
+    // ------------------------------------------------------------------------
+
+    /*
+     * Fields for the control flow graph analysis algorithm (used to compute the
+     * maximum stack size). A control flow graph contains one node per "basic
+     * block", and one edge per "jump" from one basic block to another. Each
+     * node (i.e., each basic block) is represented by the Label object that
+     * corresponds to the first instruction of this basic block. Each node also
+     * stores the list of its successors in the graph, as a linked list of Edge
+     * objects.
+     */
+
+    /**
+     * Indicates what must be automatically computed.
+     *
+     * @see #FRAMES
+     * @see #MAXS
+     * @see #NOTHING
+     */
+    private final int compute;
+
+    /**
+     * A list of labels. This list is the list of basic blocks in the method,
+     * i.e. a list of Label objects linked to each other by their
+     * {@link Label#successor} field, in the order they are visited by
+     * {@link MethodVisitor#visitLabel}, and starting with the first basic block.
+     */
+    private Label labels;
+
+    /**
+     * The previous basic block.
+     */
+    private Label previousBlock;
+
+    /**
+     * The current basic block.
+     */
+    private Label currentBlock;
+
+    /**
+     * The (relative) stack size after the last visited instruction. This size
+     * is relative to the beginning of the current basic block, i.e., the true
+     * stack size after the last visited instruction is equal to the
+     * {@link Label#inputStackTop beginStackSize} of the current basic block
+     * plus <tt>stackSize</tt>.
+     */
+    private int stackSize;
+
+    /**
+     * The (relative) maximum stack size after the last visited instruction.
+     * This size is relative to the beginning of the current basic block, i.e.,
+     * the true maximum stack size after the last visited instruction is equal
+     * to the {@link Label#inputStackTop beginStackSize} of the current basic
+     * block plus <tt>stackSize</tt>.
+     */
+    private int maxStackSize;
+
+    // ------------------------------------------------------------------------
+    // Constructor
+    // ------------------------------------------------------------------------
+
+    /**
+     * Constructs a new {@link MethodWriter}.
+     *
+     * @param cw the class writer in which the method must be added.
+     * @param access the method's access flags (see {@link Opcodes}).
+     * @param name the method's name.
+     * @param desc the method's descriptor (see {@link Type}).
+     * @param signature the method's signature. May be <tt>null</tt>.
+     * @param exceptions the internal names of the method's exceptions. May be
+     *        <tt>null</tt>.
+     * @param computeMaxs <tt>true</tt> if the maximum stack size and number
+     *        of local variables must be automatically computed.
+     * @param computeFrames <tt>true</tt> if the stack map tables must be
+     *        recomputed from scratch.
+     */
+    MethodWriter(
+        final ClassWriter cw,
+        final int access,
+        final String name,
+        final String desc,
+        final String signature,
+        final String[] exceptions,
+        final boolean computeMaxs,
+        final boolean computeFrames)
+    {
+        if (cw.firstMethod == null) {
+            cw.firstMethod = this;
+        } else {
+            cw.lastMethod.next = this;
+        }
+        cw.lastMethod = this;
+        this.cw = cw;
+        this.access = access;
+        this.name = cw.newUTF8(name);
+        this.desc = cw.newUTF8(desc);
+        this.descriptor = desc;
+        if (ClassReader.SIGNATURES) {
+            this.signature = signature;
+        }
+        if (exceptions != null && exceptions.length > 0) {
+            exceptionCount = exceptions.length;
+            this.exceptions = new int[exceptionCount];
+            for (int i = 0; i < exceptionCount; ++i) {
+                this.exceptions[i] = cw.newClass(exceptions[i]);
+            }
+        }
+        this.compute = computeFrames ? FRAMES : (computeMaxs ? MAXS : NOTHING);
+        if (computeMaxs || computeFrames) {
+            if (computeFrames && "<init>".equals(name)) {
+                this.access |= ACC_CONSTRUCTOR;
+            }
+            // updates maxLocals
+            int size = getArgumentsAndReturnSizes(descriptor) >> 2;
+            if ((access & Opcodes.ACC_STATIC) != 0) {
+                --size;
+            }
+            maxLocals = size;
+            // creates and visits the label for the first basic block
+            labels = new Label();
+            labels.status |= Label.PUSHED;
+            visitLabel(labels);
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    // Implementation of the MethodVisitor interface
+    // ------------------------------------------------------------------------
+
+    public AnnotationVisitor visitAnnotationDefault() {
+        if (!ClassReader.ANNOTATIONS) {
+            return null;
+        }
+        annd = new ByteVector();
+        return new AnnotationWriter(cw, false, annd, null, 0);
+    }
+
+    public AnnotationVisitor visitAnnotation(
+        final String desc,
+        final boolean visible)
+    {
+        if (!ClassReader.ANNOTATIONS) {
+            return null;
+        }
+        ByteVector bv = new ByteVector();
+        // write type, and reserve space for values count
+        bv.putShort(cw.newUTF8(desc)).putShort(0);
+        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);
+        if (visible) {
+            aw.next = anns;
+            anns = aw;
+        } else {
+            aw.next = ianns;
+            ianns = aw;
+        }
+        return aw;
+    }
+
+    public AnnotationVisitor visitParameterAnnotation(
+        final int parameter,
+        final String desc,
+        final boolean visible)
+    {
+        if (!ClassReader.ANNOTATIONS) {
+            return null;
+        }
+        ByteVector bv = new ByteVector();
+        if ("Ljava/lang/Synthetic;".equals(desc)) {
+            // workaround for a bug in javac with synthetic parameters
+            // see ClassReader.readParameterAnnotations
+            synthetics = Math.max(synthetics, parameter + 1);
+            return new AnnotationWriter(cw, false, bv, null, 0);
+        }
+        // write type, and reserve space for values count
+        bv.putShort(cw.newUTF8(desc)).putShort(0);
+        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);
+        if (visible) {
+            if (panns == null) {
+                panns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];
+            }
+            aw.next = panns[parameter];
+            panns[parameter] = aw;
+        } else {
+            if (ipanns == null) {
+                ipanns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];
+            }
+            aw.next = ipanns[parameter];
+            ipanns[parameter] = aw;
+        }
+        return aw;
+    }
+
+    public void visitAttribute(final Attribute attr) {
+        if (attr.isCodeAttribute()) {
+            attr.next = cattrs;
+            cattrs = attr;
+        } else {
+            attr.next = attrs;
+            attrs = attr;
+        }
+    }
+
+    public void visitCode() {
+    }
+
+    public void visitFrame(
+        final int type,
+        final int nLocal,
+        final Object[] local,
+        final int nStack,
+        final Object[] stack)
+    {
+        if (!ClassReader.FRAMES || compute == FRAMES) {
+            return;
+        }
+
+        if (type == Opcodes.F_NEW) {
+            startFrame(code.length, nLocal, nStack);
+            for (int i = 0; i < nLocal; ++i) {
+                if (local[i] instanceof String) {
+                    frame[frameIndex++] = Frame.OBJECT
+                            | cw.addType((String) local[i]);
+                } else if (local[i] instanceof Integer) {
+                    frame[frameIndex++] = ((Integer) local[i]).intValue();
+                } else {
+                    frame[frameIndex++] = Frame.UNINITIALIZED
+                            | cw.addUninitializedType("",
+                                    ((Label) local[i]).position);
+                }
+            }
+            for (int i = 0; i < nStack; ++i) {
+                if (stack[i] instanceof String) {
+                    frame[frameIndex++] = Frame.OBJECT
+                            | cw.addType((String) stack[i]);
+                } else if (stack[i] instanceof Integer) {
+                    frame[frameIndex++] = ((Integer) stack[i]).intValue();
+                } else {
+                    frame[frameIndex++] = Frame.UNINITIALIZED
+                            | cw.addUninitializedType("",
+                                    ((Label) stack[i]).position);
+                }
+            }
+            endFrame();
+        } else {
+            int delta;
+            if (stackMap == null) {
+                stackMap = new ByteVector();
+                delta = code.length;
+            } else {
+                delta = code.length - previousFrameOffset - 1;
+            }
+
+            switch (type) {
+                case Opcodes.F_FULL:
+                    stackMap.putByte(FULL_FRAME)
+                            .putShort(delta)
+                            .putShort(nLocal);
+                    for (int i = 0; i < nLocal; ++i) {
+                        writeFrameType(local[i]);
+                    }
+                    stackMap.putShort(nStack);
+                    for (int i = 0; i < nStack; ++i) {
+                        writeFrameType(stack[i]);
+                    }
+                    break;
+                case Opcodes.F_APPEND:
+                    stackMap.putByte(SAME_FRAME_EXTENDED + nLocal)
+                            .putShort(delta);
+                    for (int i = 0; i < nLocal; ++i) {
+                        writeFrameType(local[i]);
+                    }
+                    break;
+                case Opcodes.F_CHOP:
+                    stackMap.putByte(SAME_FRAME_EXTENDED - nLocal)
+                            .putShort(delta);
+                    break;
+                case Opcodes.F_SAME:
+                    if (delta < 64) {
+                        stackMap.putByte(delta);
+                    } else {
+                        stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);
+                    }
+                    break;
+                case Opcodes.F_SAME1:
+                    if (delta < 64) {
+                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);
+                    } else {
+                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)
+                                .putShort(delta);
+                    }
+                    writeFrameType(stack[0]);
+                    break;
+            }
+
+            previousFrameOffset = code.length;
+            ++frameCount;
+        }
+    }
+
+    public void visitInsn(final int opcode) {
+        // adds the instruction to the bytecode of the method
+        code.putByte(opcode);
+        // update currentBlock
+        // Label currentBlock = this.currentBlock;
+        if (currentBlock != null) {
+            if (compute == FRAMES) {
+                currentBlock.frame.execute(opcode, 0, null, null);
+            } else {
+                // updates current and max stack sizes
+                int size = stackSize + Frame.SIZE[opcode];
+                if (size > maxStackSize) {
+                    maxStackSize = size;
+                }
+                stackSize = size;
+            }
+            // if opcode == ATHROW or xRETURN, ends current block (no successor)
+            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN)
+                    || opcode == Opcodes.ATHROW)
+            {
+                noSuccessor();
+            }
+        }
+    }
+
+    public void visitIntInsn(final int opcode, final int operand) {
+        // Label currentBlock = this.currentBlock;
+        if (currentBlock != null) {
+            if (compute == FRAMES) {
+                currentBlock.frame.execute(opcode, operand, null, null);
+            } else if (opcode != Opcodes.NEWARRAY) {
+                // updates current and max stack sizes only for NEWARRAY
+                // (stack size variation = 0 for BIPUSH or SIPUSH)
+                int size = stackSize + 1;
+                if (size > maxStackSize) {
+                    maxStackSize = size;
+                }
+                stackSize = size;
+            }
+        }
+        // adds the instruction to the bytecode of the method
+        if (opcode == Opcodes.SIPUSH) {
+            code.put12(opcode, operand);
+        } else { // BIPUSH or NEWARRAY
+            code.put11(opcode, operand);
+        }
+    }
+
+    public void visitVarInsn(final int opcode, final int var) {
+        // Label currentBlock = this.currentBlock;
+        if (currentBlock != null) {
+            if (compute == FRAMES) {
+                currentBlock.frame.execute(opcode, var, null, null);
+            } else {
+                // updates current and max stack sizes
+                if (opcode == Opcodes.RET) {
+                    // no stack change, but end of current block (no successor)
+                    currentBlock.status |= Label.RET;
+                    // save 'stackSize' here for future use
+                    // (see {@link #findSubroutineSuccessors})
+                    currentBlock.inputStackTop = stackSize;
+                    noSuccessor();
+                } else { // xLOAD or xSTORE
+                    int size = stackSize + Frame.SIZE[opcode];
+                    if (size > maxStackSize) {
+                        maxStackSize = size;
+                    }
+                    stackSize = size;
+                }
+            }
+        }
+        if (compute != NOTHING) {
+            // updates max locals
+            int n;
+            if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD
+                    || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE)
+            {
+                n = var + 2;
+            } else {
+                n = var + 1;
+            }
+            if (n > maxLocals) {
+                maxLocals = n;
+            }
+        }
+        // adds the instruction to the bytecode of the method
+        if (var < 4 && opcode != Opcodes.RET) {
+            int opt;
+            if (opcode < Opcodes.ISTORE) {
+                /* ILOAD_0 */
+                opt = 26 + ((opcode - Opcodes.ILOAD) << 2) + var;
+            } else {
+                /* ISTORE_0 */
+                opt = 59 + ((opcode - Opcodes.ISTORE) << 2) + var;
+            }
+            code.putByte(opt);
+        } else if (var >= 256) {
+            code.putByte(196 /* WIDE */).put12(opcode, var);
+        } else {
+            code.put11(opcode, var);
+        }
+        if (opcode >= Opcodes.ISTORE && compute == FRAMES && handlerCount > 0) {
+            visitLabel(new Label());
+        }
+    }
+
+    public void visitTypeInsn(final int opcode, final String type) {
+        Item i = cw.newClassItem(type);
+        // Label currentBlock = this.currentBlock;
+        if (currentBlock != null) {
+            if (compute == FRAMES) {
+                currentBlock.frame.execute(opcode, code.length, cw, i);
+            } else if (opcode == Opcodes.NEW) {
+                // updates current and max stack sizes only if opcode == NEW
+                // (no stack change for ANEWARRAY, CHECKCAST, INSTANCEOF)
+                int size = stackSize + 1;
+                if (size > maxStackSize) {
+                    maxStackSize = size;
+                }
+                stackSize = size;
+            }
+        }
+        // adds the instruction to the bytecode of the method
+        code.put12(opcode, i.index);
+    }
+
+    public void visitFieldInsn(
+        final int opcode,
+        final String owner,
+        final String name,
+        final String desc)
+    {
+        Item i = cw.newFieldItem(owner, name, desc);
+        // Label currentBlock = this.currentBlock;
+        if (currentBlock != null) {
+            if (compute == FRAMES) {
+                currentBlock.frame.execute(opcode, 0, cw, i);
+            } else {
+                int size;
+                // computes the stack size variation
+                char c = desc.charAt(0);
+                switch (opcode) {
+                    case Opcodes.GETSTATIC:
+                        size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);
+                        break;
+                    case Opcodes.PUTSTATIC:
+                        size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);
+                        break;
+                    case Opcodes.GETFIELD:
+                        size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);
+                        break;
+                    // case Constants.PUTFIELD:
+                    default:
+                        size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);
+                        break;
+                }
+                // updates current and max stack sizes
+                if (size > maxStackSize) {
+                    maxStackSize = size;
+                }
+                stackSize = size;
+            }
+        }
+        // adds the instruction to the bytecode of the method
+        code.put12(opcode, i.index);
+    }
+
+    public void visitMethodInsn(
+        final int opcode,
+        final String owner,
+        final String name,
+        final String desc)
+    {
+        boolean itf = opcode == Opcodes.INVOKEINTERFACE;
+        Item i = cw.newMethodItem(owner, name, desc, itf);
+        int argSize = i.intVal;
+        // Label currentBlock = this.currentBlock;
+        if (currentBlock != null) {
+            if (compute == FRAMES) {
+                currentBlock.frame.execute(opcode, 0, cw, i);
+            } else {
+                /*
+                 * computes the stack size variation. In order not to recompute
+                 * several times this variation for the same Item, we use the
+                 * intVal field of this item to store this variation, once it
+                 * has been computed. More precisely this intVal field stores
+                 * the sizes of the arguments and of the return value
+                 * corresponding to desc.
+                 */
+                if (argSize == 0) {
+                    // the above sizes have not been computed yet,
+                    // so we compute them...
+                    argSize = getArgumentsAndReturnSizes(desc);
+                    // ... and we save them in order
+                    // not to recompute them in the future
+                    i.intVal = argSize;
+                }
+                int size;
+                if (opcode == Opcodes.INVOKESTATIC) {
+                    size = stackSize - (argSize >> 2) + (argSize & 0x03) + 1;
+                } else {
+                    size = stackSize - (argSize >> 2) + (argSize & 0x03);
+                }
+                // updates current and max stack sizes
+                if (size > maxStackSize) {
+                    maxStackSize = size;
+                }
+                stackSize = size;
+            }
+        }
+        // adds the instruction to the bytecode of the method
+        if (itf) {
+            if (argSize == 0) {
+                argSize = getArgumentsAndReturnSizes(desc);
+                i.intVal = argSize;
+            }
+            code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);
+        } else {
+            code.put12(opcode, i.index);
+        }
+    }
+
+    public void visitJumpInsn(final int opcode, final Label label) {
+        Label nextInsn = null;
+        // Label currentBlock = this.currentBlock;
+        if (currentBlock != null) {
+            if (compute == FRAMES) {
+                currentBlock.frame.execute(opcode, 0, null, null);
+                // 'label' is the target of a jump instruction
+                label.getFirst().status |= Label.TARGET;
+                // adds 'label' as a successor of this basic block
+                addSuccessor(Edge.NORMAL, label);
+                if (opcode != Opcodes.GOTO) {
+                    // creates a Label for the next basic block
+                    nextInsn = new Label();
+                }
+            } else {
+                if (opcode == Opcodes.JSR) {
+                    if ((label.status & Label.SUBROUTINE) == 0) {
+                        label.status |= Label.SUBROUTINE;
+                        ++subroutines;
+                    }
+                    currentBlock.status |= Label.JSR;
+                    addSuccessor(stackSize + 1, label);
+                    // creates a Label for the next basic block
+                    nextInsn = new Label();
+                    /*
+                     * note that, by construction in this method, a JSR block
+                     * has at least two successors in the control flow graph:
+                     * the first one leads the next instruction after the JSR,
+                     * while the second one leads to the JSR target.
+                     */
+                } else {
+                    // updates current stack size (max stack size unchanged
+                    // because stack size variation always negative in this
+                    // case)
+                    stackSize += Frame.SIZE[opcode];
+                    addSuccessor(stackSize, label);
+                }
+            }
+        }
+        // adds the instruction to the bytecode of the method
+        if ((label.status & Label.RESOLVED) != 0
+                && label.position - code.length < Short.MIN_VALUE)
+        {
+            /*
+             * case of a backward jump with an offset < -32768. In this case we
+             * automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx
+             * <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is the
+             * "opposite" opcode of IFxxx (i.e., IFNE for IFEQ) and where <l'>
+             * designates the instruction just after the GOTO_W.
+             */
+            if (opcode == Opcodes.GOTO) {
+                code.putByte(200); // GOTO_W
+            } else if (opcode == Opcodes.JSR) {
+                code.putByte(201); // JSR_W
+            } else {
+                // if the IF instruction is transformed into IFNOT GOTO_W the
+                // next instruction becomes the target of the IFNOT instruction
+                if (nextInsn != null) {
+                    nextInsn.status |= Label.TARGET;
+                }
+                code.putByte(opcode <= 166
+                        ? ((opcode + 1) ^ 1) - 1
+                        : opcode ^ 1);
+                code.putShort(8); // jump offset
+                code.putByte(200); // GOTO_W
+            }
+            label.put(this, code, code.length - 1, true);
+        } else {
+            /*
+             * case of a backward jump with an offset >= -32768, or of a forward
+             * jump with, of course, an unknown offset. In these cases we store
+             * the offset in 2 bytes (which will be increased in
+             * resizeInstructions, if needed).
+             */
+            code.putByte(opcode);
+            label.put(this, code, code.length - 1, false);
+        }
+        if (currentBlock != null) {
+            if (nextInsn != null) {
+                // if the jump instruction is not a GOTO, the next instruction
+                // is also a successor of this instruction. Calling visitLabel
+                // adds the label of this next instruction as a successor of the
+                // current block, and starts a new basic block
+                visitLabel(nextInsn);
+            }
+            if (opcode == Opcodes.GOTO) {
+                noSuccessor();
+            }
+        }
+    }
+
+    public void visitLabel(final Label label) {
+        // resolves previous forward references to label, if any
+        resize |= label.resolve(this, code.length, code.data);
+        // updates currentBlock
+        if ((label.status & Label.DEBUG) != 0) {
+            return;
+        }
+        if (compute == FRAMES) {
+            if (currentBlock != null) {
+                if (label.position == currentBlock.position) {
+                    // successive labels, do not start a new basic block
+                    currentBlock.status |= (label.status & Label.TARGET);
+                    label.frame = currentBlock.frame;
+                    return;
+                }
+                // ends current block (with one new successor)
+                addSuccessor(Edge.NORMAL, label);
+            }
+            // begins a new current block
+            currentBlock = label;
+            if (label.frame == null) {
+                label.frame = new Frame();
+                label.frame.owner = label;
+            }
+            // updates the basic block list
+            if (previousBlock != null) {
+                if (label.position == previousBlock.position) {
+                    previousBlock.status |= (label.status & Label.TARGET);
+                    label.frame = previousBlock.frame;
+                    currentBlock = previousBlock;
+                    return;
+                }
+                previousBlock.successor = label;
+            }
+            previousBlock = label;
+        } else if (compute == MAXS) {
+            if (currentBlock != null) {
+                // ends current block (with one new successor)
+                currentBlock.outputStackMax = maxStackSize;
+                addSuccessor(stackSize, label);
+            }
+            // begins a new current block
+            currentBlock = label;
+            // resets the relative current and max stack sizes
+            stackSize = 0;
+            maxStackSize = 0;
+            // updates the basic block list
+            if (previousBlock != null) {
+                previousBlock.successor = label;
+            }
+            previousBlock = label;
+        }
+    }
+
+    public void visitLdcInsn(final Object cst) {
+        Item i = cw.newConstItem(cst);
+        // Label currentBlock = this.currentBlock;
+        if (currentBlock != null) {
+            if (compute == FRAMES) {
+                currentBlock.frame.execute(Opcodes.LDC, 0, cw, i);
+            } else {
+                int size;
+                // computes the stack size variation
+                if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE)
+                {
+                    size = stackSize + 2;
+                } else {
+                    size = stackSize + 1;
+                }
+                // updates current and max stack sizes
+                if (size > maxStackSize) {
+                    maxStackSize = size;
+                }
+                stackSize = size;
+            }
+        }
+        // adds the instruction to the bytecode of the method
+        int index = i.index;
+        if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {
+            code.put12(20 /* LDC2_W */, index);
+        } else if (index >= 256) {
+            code.put12(19 /* LDC_W */, index);
+        } else {
+            code.put11(Opcodes.LDC, index);
+        }
+    }
+
+    public void visitIincInsn(final int var, final int increment) {
+        if (currentBlock != null) {
+            if (compute == FRAMES) {
+                currentBlock.frame.execute(Opcodes.IINC, var, null, null);
+            }
+        }
+        if (compute != NOTHING) {
+            // updates max locals
+            int n = var + 1;
+            if (n > maxLocals) {
+                maxLocals = n;
+            }
+        }
+        // adds the instruction to the bytecode of the method
+        if ((var > 255) || (increment > 127) || (increment < -128)) {
+            code.putByte(196 /* WIDE */)
+                    .put12(Opcodes.IINC, var)
+                    .putShort(increment);
+        } else {
+            code.putByte(Opcodes.IINC).put11(var, increment);
+        }
+    }
+
+    public void visitTableSwitchInsn(
+        final int min,
+        final int max,
+        final Label dflt,
+        final Label[] labels)
+    {
+        // adds the instruction to the bytecode of the method
+        int source = code.length;
+        code.putByte(Opcodes.TABLESWITCH);
+        code.length += (4 - code.length % 4) % 4;
+        dflt.put(this, code, source, true);
+        code.putInt(min).putInt(max);
+        for (int i = 0; i < labels.length; ++i) {
+            labels[i].put(this, code, source, true);
+        }
+        // updates currentBlock
+        visitSwitchInsn(dflt, labels);
+    }
+
+    public void visitLookupSwitchInsn(
+        final Label dflt,
+        final int[] keys,
+        final Label[] labels)
+    {
+        // adds the instruction to the bytecode of the method
+        int source = code.length;
+        code.putByte(Opcodes.LOOKUPSWITCH);
+        code.length += (4 - code.length % 4) % 4;
+        dflt.put(this, code, source, true);
+        code.putInt(labels.length);
+        for (int i = 0; i < labels.length; ++i) {
+            code.putInt(keys[i]);
+            labels[i].put(this, code, source, true);
+        }
+        // updates currentBlock
+        visitSwitchInsn(dflt, labels);
+    }
+
+    private void visitSwitchInsn(final Label dflt, final Label[] labels) {
+        // Label currentBlock = this.currentBlock;
+        if (currentBlock != null) {
+            if (compute == FRAMES) {
+                currentBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);
+                // adds current block successors
+                addSuccessor(Edge.NORMAL, dflt);
+                dflt.getFirst().status |= Label.TARGET;
+                for (int i = 0; i < labels.length; ++i) {
+                    addSuccessor(Edge.NORMAL, labels[i]);
+                    labels[i].getFirst().status |= Label.TARGET;
+                }
+            } else {
+                // updates current stack size (max stack size unchanged)
+                --stackSize;
+                // adds current block successors
+                addSuccessor(stackSize, dflt);
+                for (int i = 0; i < labels.length; ++i) {
+                    addSuccessor(stackSize, labels[i]);
+                }
+            }
+            // ends current block
+            noSuccessor();
+        }
+    }
+
+    public void visitMultiANewArrayInsn(final String desc, final int dims) {
+        Item i = cw.newClassItem(desc);
+        // Label currentBlock = this.currentBlock;
+        if (currentBlock != null) {
+            if (compute == FRAMES) {
+                currentBlock.frame.execute(Opcodes.MULTIANEWARRAY, dims, cw, i);
+            } else {
+                // updates current stack size (max stack size unchanged because
+                // stack size variation always negative or null)
+                stackSize += 1 - dims;
+            }
+        }
+        // adds the instruction to the bytecode of the method
+        code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte(dims);
+    }
+
+    public void visitTryCatchBlock(
+        final Label start,
+        final Label end,
+        final Label handler,
+        final String type)
+    {
+        ++handlerCount;
+        Handler h = new Handler();
+        h.start = start;
+        h.end = end;
+        h.handler = handler;
+        h.desc = type;
+        h.type = type != null ? cw.newClass(type) : 0;
+        if (lastHandler == null) {
+            firstHandler = h;
+        } else {
+            lastHandler.next = h;
+        }
+        lastHandler = h;
+    }
+
+    public void visitLocalVariable(
+        final String name,
+        final String desc,
+        final String signature,
+        final Label start,
+        final Label end,
+        final int index)
+    {
+        if (signature != null) {
+            if (localVarType == null) {
+                localVarType = new ByteVector();
+            }
+            ++localVarTypeCount;
+            localVarType.putShort(start.position)
+                    .putShort(end.position - start.position)
+                    .putShort(cw.newUTF8(name))
+                    .putShort(cw.newUTF8(signature))
+                    .putShort(index);
+        }
+        if (localVar == null) {
+            localVar = new ByteVector();
+        }
+        ++localVarCount;
+        localVar.putShort(start.position)
+                .putShort(end.position - start.position)
+                .putShort(cw.newUTF8(name))
+                .putShort(cw.newUTF8(desc))
+                .putShort(index);
+        if (compute != NOTHING) {
+            // updates max locals
+            char c = desc.charAt(0);
+            int n = index + (c == 'J' || c == 'D' ? 2 : 1);
+            if (n > maxLocals) {
+                maxLocals = n;
+            }
+        }
+    }
+
+    public void visitLineNumber(final int line, final Label start) {
+        if (lineNumber == null) {
+            lineNumber = new ByteVector();
+        }
+        ++lineNumberCount;
+        lineNumber.putShort(start.position);
+        lineNumber.putShort(line);
+    }
+
+    public void visitMaxs(final int maxStack, final int maxLocals) {
+        if (ClassReader.FRAMES && compute == FRAMES) {
+            // completes the control flow graph with exception handler blocks
+            Handler handler = firstHandler;
+            while (handler != null) {
+                Label l = handler.start.getFirst();
+                Label h = handler.handler.getFirst();
+                Label e = handler.end.getFirst();
+                // computes the kind of the edges to 'h'
+                String t = handler.desc == null
+                        ? "java/lang/Throwable"
+                        : handler.desc;
+                int kind = Frame.OBJECT | cw.addType(t);
+                // h is an exception handler
+                h.status |= Label.TARGET;
+                // adds 'h' as a successor of labels between 'start' and 'end'
+                while (l != e) {
+                    // creates an edge to 'h'
+                    Edge b = new Edge();
+                    b.info = kind;
+                    b.successor = h;
+                    // adds it to the successors of 'l'
+                    b.next = l.successors;
+                    l.successors = b;
+                    // goes to the next label
+                    l = l.successor;
+                }
+                handler = handler.next;
+            }
+
+            // creates and visits the first (implicit) frame
+            Frame f = labels.frame;
+            Type[] args = Type.getArgumentTypes(descriptor);
+            f.initInputFrame(cw, access, args, this.maxLocals);
+            visitFrame(f);
+
+            /*
+             * fix point algorithm: mark the first basic block as 'changed'
+             * (i.e. put it in the 'changed' list) and, while there are changed
+             * basic blocks, choose one, mark it as unchanged, and update its
+             * successors (which can be changed in the process).
+             */
+            int max = 0;
+            Label changed = labels;
+            while (changed != null) {
+                // removes a basic block from the list of changed basic blocks
+                Label l = changed;
+                changed = changed.next;
+                l.next = null;
+                f = l.frame;
+                // a reacheable jump target must be stored in the stack map
+                if ((l.status & Label.TARGET) != 0) {
+                    l.status |= Label.STORE;
+                }
+                // all visited labels are reacheable, by definition
+                l.status |= Label.REACHABLE;
+                // updates the (absolute) maximum stack size
+                int blockMax = f.inputStack.length + l.outputStackMax;
+                if (blockMax > max) {
+                    max = blockMax;
+                }
+                // updates the successors of the current basic block
+                Edge e = l.successors;
+                while (e != null) {
+                    Label n = e.successor.getFirst();
+                    boolean change = f.merge(cw, n.frame, e.info);
+                    if (change && n.next == null) {
+                        // if n has changed and is not already in the 'changed'
+                        // list, adds it to this list
+                        n.next = changed;
+                        changed = n;
+                    }
+                    e = e.next;
+                }
+            }
+            this.maxStack = max;
+
+            // visits all the frames that must be stored in the stack map
+            Label l = labels;
+            while (l != null) {
+                f = l.frame;
+                if ((l.status & Label.STORE) != 0) {
+                    visitFrame(f);
+                }
+                if ((l.status & Label.REACHABLE) == 0) {
+                    // finds start and end of dead basic block
+                    Label k = l.successor;
+                    int start = l.position;
+                    int end = (k == null ? code.length : k.position) - 1;
+                    // if non empty basic block
+                    if (end >= start) {
+                        // replaces instructions with NOP ... NOP ATHROW
+                        for (int i = start; i < end; ++i) {
+                            code.data[i] = Opcodes.NOP;
+                        }
+                        code.data[end] = (byte) Opcodes.ATHROW;
+                        // emits a frame for this unreachable block
+                        startFrame(start, 0, 1);
+                        frame[frameIndex++] = Frame.OBJECT
+                                | cw.addType("java/lang/Throwable");
+                        endFrame();
+                    }
+                }
+                l = l.successor;
+            }
+        } else if (compute == MAXS) {
+            // completes the control flow graph with exception handler blocks
+            Handler handler = firstHandler;
+            while (handler != null) {
+                Label l = handler.start;
+                Label h = handler.handler;
+                Label e = handler.end;
+                // adds 'h' as a successor of labels between 'start' and 'end'
+                while (l != e) {
+                    // creates an edge to 'h'
+                    Edge b = new Edge();
+                    b.info = Edge.EXCEPTION;
+                    b.successor = h;
+                    // adds it to the successors of 'l'
+                    if ((l.status & Label.JSR) == 0) {
+                        b.next = l.successors;
+                        l.successors = b;
+                    } else {
+                        // if l is a JSR block, adds b after the first two edges
+                        // to preserve the hypothesis about JSR block successors
+                        // order (see {@link #visitJumpInsn})
+                        b.next = l.successors.next.next;
+                        l.successors.next.next = b;
+                    }
+                    // goes to the next label
+                    l = l.successor;
+                }
+                handler = handler.next;
+            }
+
+            if (subroutines > 0) {
+                // completes the control flow graph with the RET successors
+                /*
+                 * first step: finds the subroutines. This step determines, for
+                 * each basic block, to which subroutine(s) it belongs.
+                 */
+                // finds the basic blocks that belong to the "main" subroutine
+                int id = 0;
+                labels.visitSubroutine(null, 1, subroutines);
+                // finds the basic blocks that belong to the real subroutines
+                Label l = labels;
+                while (l != null) {
+                    if ((l.status & Label.JSR) != 0) {
+                        // the subroutine is defined by l's TARGET, not by l
+                        Label subroutine = l.successors.next.successor;
+                        // if this subroutine has not been visited yet...
+                        if ((subroutine.status & Label.VISITED) == 0) {
+                            // ...assigns it a new id and finds its basic blocks
+                            id += 1;
+                            subroutine.visitSubroutine(null, (id / 32L) << 32
+                                    | (1L << (id % 32)), subroutines);
+                        }
+                    }
+                    l = l.successor;
+                }
+                // second step: finds the successors of RET blocks
+                l = labels;
+                while (l != null) {
+                    if ((l.status & Label.JSR) != 0) {
+                        Label L = labels;
+                        while (L != null) {
+                            L.status &= ~Label.VISITED;
+                            L = L.successor;
+                        }
+                        // the subroutine is defined by l's TARGET, not by l
+                        Label subroutine = l.successors.next.successor;
+                        subroutine.visitSubroutine(l, 0, subroutines);
+                    }
+                    l = l.successor;
+                }
+            }
+
+            /*
+             * control flow analysis algorithm: while the block stack is not
+             * empty, pop a block from this stack, update the max stack size,
+             * compute the true (non relative) begin stack size of the
+             * successors of this block, and push these successors onto the
+             * stack (unless they have already been pushed onto the stack).
+             * Note: by hypothesis, the {@link Label#inputStackTop} of the
+             * blocks in the block stack are the true (non relative) beginning
+             * stack sizes of these blocks.
+             */
+            int max = 0;
+            Label stack = labels;
+            while (stack != null) {
+                // pops a block from the stack
+                Label l = stack;
+                stack = stack.next;
+                // computes the true (non relative) max stack size of this block
+                int start = l.inputStackTop;
+                int blockMax = start + l.outputStackMax;
+                // updates the global max stack size
+                if (blockMax > max) {
+                    max = blockMax;
+                }
+                // analyzes the successors of the block
+                Edge b = l.successors;
+                if ((l.status & Label.JSR) != 0) {
+                    // ignores the first edge of JSR blocks (virtual successor)
+                    b = b.next;
+                }
+                while (b != null) {
+                    l = b.successor;
+                    // if this successor has not already been pushed...
+                    if ((l.status & Label.PUSHED) == 0) {
+                        // computes its true beginning stack size...
+                        l.inputStackTop = b.info == Edge.EXCEPTION ? 1 : start
+                                + b.info;
+                        // ...and pushes it onto the stack
+                        l.status |= Label.PUSHED;
+                        l.next = stack;
+                        stack = l;
+                    }
+                    b = b.next;
+                }
+            }
+            this.maxStack = max;
+        } else {
+            this.maxStack = maxStack;
+            this.maxLocals = maxLocals;
+        }
+    }
+
+    public void visitEnd() {
+    }
+
+    // ------------------------------------------------------------------------
+    // Utility methods: control flow analysis algorithm
+    // ------------------------------------------------------------------------
+
+    /**
+     * Computes the size of the arguments and of the return value of a method.
+     *
+     * @param desc the descriptor of a method.
+     * @return the size of the arguments of the method (plus one for the
+     *         implicit this argument), argSize, and the size of its return
+     *         value, retSize, packed into a single int i =
+     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal
+     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).
+     */
+    static int getArgumentsAndReturnSizes(final String desc) {
+        int n = 1;
+        int c = 1;
+        while (true) {
+            char car = desc.charAt(c++);
+            if (car == ')') {
+                car = desc.charAt(c);
+                return n << 2
+                        | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));
+            } else if (car == 'L') {
+                while (desc.charAt(c++) != ';') {
+                }
+                n += 1;
+            } else if (car == '[') {
+                while ((car = desc.charAt(c)) == '[') {
+                    ++c;
+                }
+                if (car == 'D' || car == 'J') {
+                    n -= 1;
+                }
+            } else if (car == 'D' || car == 'J') {
+                n += 2;
+            } else {
+                n += 1;
+            }
+        }
+    }
+
+    /**
+     * Adds a successor to the {@link #currentBlock currentBlock} block.
+     *
+     * @param info information about the control flow edge to be added.
+     * @param successor the successor block to be added to the current block.
+     */
+    private void addSuccessor(final int info, final Label successor) {
+        // creates and initializes an Edge object...
+        Edge b = new Edge();
+        b.info = info;
+        b.successor = successor;
+        // ...and adds it to the successor list of the currentBlock block
+        b.next = currentBlock.successors;
+        currentBlock.successors = b;
+    }
+
+    /**
+     * Ends the current basic block. This method must be used in the case where
+     * the current basic block does not have any successor.
+     */
+    private void noSuccessor() {
+        if (compute == FRAMES) {
+            Label l = new Label();
+            l.frame = new Frame();
+            l.frame.owner = l;
+            l.resolve(this, code.length, code.data);
+            previousBlock.successor = l;
+            previousBlock = l;
+        } else {
+            currentBlock.outputStackMax = maxStackSize;
+        }
+        currentBlock = null;
+    }
+
+    // ------------------------------------------------------------------------
+    // Utility methods: stack map frames
+    // ------------------------------------------------------------------------
+
+    /**
+     * Visits a frame that has been computed from scratch.
+     *
+     * @param f the frame that must be visited.
+     */
+    private void visitFrame(final Frame f) {
+        int i, t;
+        int nTop = 0;
+        int nLocal = 0;
+        int nStack = 0;
+        int[] locals = f.inputLocals;
+        int[] stacks = f.inputStack;
+        // computes the number of locals (ignores TOP types that are just after
+        // a LONG or a DOUBLE, and all trailing TOP types)
+        for (i = 0; i < locals.length; ++i) {
+            t = locals[i];
+            if (t == Frame.TOP) {
+                ++nTop;
+            } else {
+                nLocal += nTop + 1;
+                nTop = 0;
+            }
+            if (t == Frame.LONG || t == Frame.DOUBLE) {
+                ++i;
+            }
+        }
+        // computes the stack size (ignores TOP types that are just after
+        // a LONG or a DOUBLE)
+        for (i = 0; i < stacks.length; ++i) {
+            t = stacks[i];
+            ++nStack;
+            if (t == Frame.LONG || t == Frame.DOUBLE) {
+                ++i;
+            }
+        }
+        // visits the frame and its content
+        startFrame(f.owner.position, nLocal, nStack);
+        for (i = 0; nLocal > 0; ++i, --nLocal) {
+            t = locals[i];
+            frame[frameIndex++] = t;
+            if (t == Frame.LONG || t == Frame.DOUBLE) {
+                ++i;
+            }
+        }
+        for (i = 0; i < stacks.length; ++i) {
+            t = stacks[i];
+            frame[frameIndex++] = t;
+            if (t == Frame.LONG || t == Frame.DOUBLE) {
+                ++i;
+            }
+        }
+        endFrame();
+    }
+
+    /**
+     * Starts the visit of a stack map frame.
+     *
+     * @param offset the offset of the instruction to which the frame
+     *        corresponds.
+     * @param nLocal the number of local variables in the frame.
+     * @param nStack the number of stack elements in the frame.
+     */
+    private void startFrame(final int offset, final int nLocal, final int nStack)
+    {
+        int n = 3 + nLocal + nStack;
+        if (frame == null || frame.length < n) {
+            frame = new int[n];
+        }
+        frame[0] = offset;
+        frame[1] = nLocal;
+        frame[2] = nStack;
+        frameIndex = 3;
+    }
+
+    /**
+     * Checks if the visit of the current frame {@link #frame} is finished, and
+     * if yes, write it in the StackMapTable attribute.
+     */
+    private void endFrame() {
+        if (previousFrame != null) { // do not write the first frame
+            if (stackMap == null) {
+                stackMap = new ByteVector();
+            }
+            writeFrame();
+            ++frameCount;
+        }
+        previousFrame = frame;
+        frame = null;
+    }
+
+    /**
+     * Compress and writes the current frame {@link #frame} in the StackMapTable
+     * attribute.
+     */
+    private void writeFrame() {
+        int clocalsSize = frame[1];
+        int cstackSize = frame[2];
+        if ((cw.version & 0xFFFF) < Opcodes.V1_6) {
+            stackMap.putShort(frame[0]).putShort(clocalsSize);
+            writeFrameTypes(3, 3 + clocalsSize);
+            stackMap.putShort(cstackSize);
+            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);
+            return;
+        }
+        int localsSize = previousFrame[1];
+        int type = FULL_FRAME;
+        int k = 0;
+        int delta;
+        if (frameCount == 0) {
+            delta = frame[0];
+        } else {
+            delta = frame[0] - previousFrame[0] - 1;
+        }
+        if (cstackSize == 0) {
+            k = clocalsSize - localsSize;
+            switch (k) {
+                case -3:
+                case -2:
+                case -1:
+                    type = CHOP_FRAME;
+                    localsSize = clocalsSize;
+                    break;
+                case 0:
+                    type = delta < 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;
+                    break;
+                case 1:
+                case 2:
+                case 3:
+                    type = APPEND_FRAME;
+                    break;
+            }
+        } else if (clocalsSize == localsSize && cstackSize == 1) {
+            type = delta < 63
+                    ? SAME_LOCALS_1_STACK_ITEM_FRAME
+                    : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;
+        }
+        if (type != FULL_FRAME) {
+            // verify if locals are the same
+            int l = 3;
+            for (int j = 0; j < localsSize; j++) {
+                if (frame[l] != previousFrame[l]) {
+                    type = FULL_FRAME;
+                    break;
+                }
+                l++;
+            }
+        }
+        switch (type) {
+            case SAME_FRAME:
+                stackMap.putByte(delta);
+                break;
+            case SAME_LOCALS_1_STACK_ITEM_FRAME:
+                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);
+                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);
+                break;
+            case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:
+                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)
+                        .putShort(delta);
+                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);
+                break;
+            case SAME_FRAME_EXTENDED:
+                stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);
+                break;
+            case CHOP_FRAME:
+                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);
+                break;
+            case APPEND_FRAME:
+                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);
+                writeFrameTypes(3 + localsSize, 3 + clocalsSize);
+                break;
+            // case FULL_FRAME:
+            default:
+                stackMap.putByte(FULL_FRAME)
+                        .putShort(delta)
+                        .putShort(clocalsSize);
+                writeFrameTypes(3, 3 + clocalsSize);
+                stackMap.putShort(cstackSize);
+                writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);
+        }
+    }
+
+    /**
+     * Writes some types of the current frame {@link #frame} into the
+     * StackMapTableAttribute. This method converts types from the format used
+     * in {@link Label} to the format used in StackMapTable attributes. In
+     * particular, it converts type table indexes to constant pool indexes.
+     *
+     * @param start index of the first type in {@link #frame} to write.
+     * @param end index of last type in {@link #frame} to write (exclusive).
+     */
+    private void writeFrameTypes(final int start, final int end) {
+        for (int i = start; i < end; ++i) {
+            int t = frame[i];
+            int d = t & Frame.DIM;
+            if (d == 0) {
+                int v = t & Frame.BASE_VALUE;
+                switch (t & Frame.BASE_KIND) {
+                    case Frame.OBJECT:
+                        stackMap.putByte(7)
+                                .putShort(cw.newClass(cw.typeTable[v].strVal1));
+                        break;
+                    case Frame.UNINITIALIZED:
+                        stackMap.putByte(8).putShort(cw.typeTable[v].intVal);
+                        break;
+                    default:
+                        stackMap.putByte(v);
+                }
+            } else {
+                StringBuffer buf = new StringBuffer();
+                d >>= 28;
+                while (d-- > 0) {
+                    buf.append('[');
+                }
+                if ((t & Frame.BASE_KIND) == Frame.OBJECT) {
+                    buf.append('L');
+                    buf.append(cw.typeTable[t & Frame.BASE_VALUE].strVal1);
+                    buf.append(';');
+                } else {
+                    switch (t & 0xF) {
+                        case 1:
+                            buf.append('I');
+                            break;
+                        case 2:
+                            buf.append('F');
+                            break;
+                        case 3:
+                            buf.append('D');
+                            break;
+                        case 9:
+                            buf.append('Z');
+                            break;
+                        case 10:
+                            buf.append('B');
+                            break;
+                        case 11:
+                            buf.append('C');
+                            break;
+                        case 12:
+                            buf.append('S');
+                            break;
+                        default:
+                            buf.append('J');
+                    }
+                }
+                stackMap.putByte(7).putShort(cw.newClass(buf.toString()));
+            }
+        }
+    }
+
+    private void writeFrameType(final Object type) {
+        if (type instanceof String) {
+            stackMap.putByte(7).putShort(cw.newClass((String) type));
+        } else if (type instanceof Integer) {
+            stackMap.putByte(((Integer) type).intValue());
+        } else {
+            stackMap.putByte(8).putShort(((Label) type).position);
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    // Utility methods: dump bytecode array
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns the size of the bytecode of this method.
+     *
+     * @return the size of the bytecode of this method.
+     */
+    final int getSize() {
+        if (classReaderOffset != 0) {
+            return 6 + classReaderLength;
+        }
+        if (resize) {
+            // replaces the temporary jump opcodes introduced by Label.resolve.
+            if (ClassReader.RESIZE) {
+                resizeInstructions();
+            } else {
+                throw new RuntimeException("Method code too large!");
+            }
+        }
+        int size = 8;
+        if (code.length > 0) {
+            cw.newUTF8("Code");
+            size += 18 + code.length + 8 * handlerCount;
+            if (localVar != null) {
+                cw.newUTF8("LocalVariableTable");
+                size += 8 + localVar.length;
+            }
+            if (localVarType != null) {
+                cw.newUTF8("LocalVariableTypeTable");
+                size += 8 + localVarType.length;
+            }
+            if (lineNumber != null) {
+                cw.newUTF8("LineNumberTable");
+                size += 8 + lineNumber.length;
+            }
+            if (stackMap != null) {
+                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;
+                cw.newUTF8(zip ? "StackMapTable" : "StackMap");
+                size += 8 + stackMap.length;
+            }
+            if (cattrs != null) {
+                size += cattrs.getSize(cw,
+                        code.data,
+                        code.length,
+                        maxStack,
+                        maxLocals);
+            }
+        }
+        if (exceptionCount > 0) {
+            cw.newUTF8("Exceptions");
+            size += 8 + 2 * exceptionCount;
+        }
+        if ((access & Opcodes.ACC_SYNTHETIC) != 0
+                && (cw.version & 0xffff) < Opcodes.V1_5)
+        {
+            cw.newUTF8("Synthetic");
+            size += 6;
+        }
+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
+            cw.newUTF8("Deprecated");
+            size += 6;
+        }
+        if (ClassReader.SIGNATURES && signature != null) {
+            cw.newUTF8("Signature");
+            cw.newUTF8(signature);
+            size += 8;
+        }
+        if (ClassReader.ANNOTATIONS && annd != null) {
+            cw.newUTF8("AnnotationDefault");
+            size += 6 + annd.length;
+        }
+        if (ClassReader.ANNOTATIONS && anns != null) {
+            cw.newUTF8("RuntimeVisibleAnnotations");
+            size += 8 + anns.getSize();
+        }
+        if (ClassReader.ANNOTATIONS && ianns != null) {
+            cw.newUTF8("RuntimeInvisibleAnnotations");
+            size += 8 + ianns.getSize();
+        }
+        if (ClassReader.ANNOTATIONS && panns != null) {
+            cw.newUTF8("RuntimeVisibleParameterAnnotations");
+            size += 7 + 2 * (panns.length - synthetics);
+            for (int i = panns.length - 1; i >= synthetics; --i) {
+                size += panns[i] == null ? 0 : panns[i].getSize();
+            }
+        }
+        if (ClassReader.ANNOTATIONS && ipanns != null) {
+            cw.newUTF8("RuntimeInvisibleParameterAnnotations");
+            size += 7 + 2 * (ipanns.length - synthetics);
+            for (int i = ipanns.length - 1; i >= synthetics; --i) {
+                size += ipanns[i] == null ? 0 : ipanns[i].getSize();
+            }
+        }
+        if (attrs != null) {
+            size += attrs.getSize(cw, null, 0, -1, -1);
+        }
+        return size;
+    }
+
+    /**
+     * Puts the bytecode of this method in the given byte vector.
+     *
+     * @param out the byte vector into which the bytecode of this method must be
+     *        copied.
+     */
+    final void put(final ByteVector out) {
+        out.putShort(access).putShort(name).putShort(desc);
+        if (classReaderOffset != 0) {
+            out.putByteArray(cw.cr.b, classReaderOffset, classReaderLength);
+            return;
+        }
+        int attributeCount = 0;
+        if (code.length > 0) {
+            ++attributeCount;
+        }
+        if (exceptionCount > 0) {
+            ++attributeCount;
+        }
+        if ((access & Opcodes.ACC_SYNTHETIC) != 0
+                && (cw.version & 0xffff) < Opcodes.V1_5)
+        {
+            ++attributeCount;
+        }
+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
+            ++attributeCount;
+        }
+        if (ClassReader.SIGNATURES && signature != null) {
+            ++attributeCount;
+        }
+        if (ClassReader.ANNOTATIONS && annd != null) {
+            ++attributeCount;
+        }
+        if (ClassReader.ANNOTATIONS && anns != null) {
+            ++attributeCount;
+        }
+        if (ClassReader.ANNOTATIONS && ianns != null) {
+            ++attributeCount;
+        }
+        if (ClassReader.ANNOTATIONS && panns != null) {
+            ++attributeCount;
+        }
+        if (ClassReader.ANNOTATIONS && ipanns != null) {
+            ++attributeCount;
+        }
+        if (attrs != null) {
+            attributeCount += attrs.getCount();
+        }
+        out.putShort(attributeCount);
+        if (code.length > 0) {
+            int size = 12 + code.length + 8 * handlerCount;
+            if (localVar != null) {
+                size += 8 + localVar.length;
+            }
+            if (localVarType != null) {
+                size += 8 + localVarType.length;
+            }
+            if (lineNumber != null) {
+                size += 8 + lineNumber.length;
+            }
+            if (stackMap != null) {
+                size += 8 + stackMap.length;
+            }
+            if (cattrs != null) {
+                size += cattrs.getSize(cw,
+                        code.data,
+                        code.length,
+                        maxStack,
+                        maxLocals);
+            }
+            out.putShort(cw.newUTF8("Code")).putInt(size);
+            out.putShort(maxStack).putShort(maxLocals);
+            out.putInt(code.length).putByteArray(code.data, 0, code.length);
+            out.putShort(handlerCount);
+            if (handlerCount > 0) {
+                Handler h = firstHandler;
+                while (h != null) {
+                    out.putShort(h.start.position)
+                            .putShort(h.end.position)
+                            .putShort(h.handler.position)
+                            .putShort(h.type);
+                    h = h.next;
+                }
+            }
+            attributeCount = 0;
+            if (localVar != null) {
+                ++attributeCount;
+            }
+            if (localVarType != null) {
+                ++attributeCount;
+            }
+            if (lineNumber != null) {
+                ++attributeCount;
+            }
+            if (stackMap != null) {
+                ++attributeCount;
+            }
+            if (cattrs != null) {
+                attributeCount += cattrs.getCount();
+            }
+            out.putShort(attributeCount);
+            if (localVar != null) {
+                out.putShort(cw.newUTF8("LocalVariableTable"));
+                out.putInt(localVar.length + 2).putShort(localVarCount);
+                out.putByteArray(localVar.data, 0, localVar.length);
+            }
+            if (localVarType != null) {
+                out.putShort(cw.newUTF8("LocalVariableTypeTable"));
+                out.putInt(localVarType.length + 2).putShort(localVarTypeCount);
+                out.putByteArray(localVarType.data, 0, localVarType.length);
+            }
+            if (lineNumber != null) {
+                out.putShort(cw.newUTF8("LineNumberTable"));
+                out.putInt(lineNumber.length + 2).putShort(lineNumberCount);
+                out.putByteArray(lineNumber.data, 0, lineNumber.length);
+            }
+            if (stackMap != null) {
+                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;
+                out.putShort(cw.newUTF8(zip ? "StackMapTable" : "StackMap"));
+                out.putInt(stackMap.length + 2).putShort(frameCount);
+                out.putByteArray(stackMap.data, 0, stackMap.length);
+            }
+            if (cattrs != null) {
+                cattrs.put(cw, code.data, code.length, maxLocals, maxStack, out);
+            }
+        }
+        if (exceptionCount > 0) {
+            out.putShort(cw.newUTF8("Exceptions"))
+                    .putInt(2 * exceptionCount + 2);
+            out.putShort(exceptionCount);
+            for (int i = 0; i < exceptionCount; ++i) {
+                out.putShort(exceptions[i]);
+            }
+        }
+        if ((access & Opcodes.ACC_SYNTHETIC) != 0
+                && (cw.version & 0xffff) < Opcodes.V1_5)
+        {
+            out.putShort(cw.newUTF8("Synthetic")).putInt(0);
+        }
+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {
+            out.putShort(cw.newUTF8("Deprecated")).putInt(0);
+        }
+        if (ClassReader.SIGNATURES && signature != null) {
+            out.putShort(cw.newUTF8("Signature"))
+                    .putInt(2)
+                    .putShort(cw.newUTF8(signature));
+        }
+        if (ClassReader.ANNOTATIONS && annd != null) {
+            out.putShort(cw.newUTF8("AnnotationDefault"));
+            out.putInt(annd.length);
+            out.putByteArray(annd.data, 0, annd.length);
+        }
+        if (ClassReader.ANNOTATIONS && anns != null) {
+            out.putShort(cw.newUTF8("RuntimeVisibleAnnotations"));
+            anns.put(out);
+        }
+        if (ClassReader.ANNOTATIONS && ianns != null) {
+            out.putShort(cw.newUTF8("RuntimeInvisibleAnnotations"));
+            ianns.put(out);
+        }
+        if (ClassReader.ANNOTATIONS && panns != null) {
+            out.putShort(cw.newUTF8("RuntimeVisibleParameterAnnotations"));
+            AnnotationWriter.put(panns, synthetics, out);
+        }
+        if (ClassReader.ANNOTATIONS && ipanns != null) {
+            out.putShort(cw.newUTF8("RuntimeInvisibleParameterAnnotations"));
+            AnnotationWriter.put(ipanns, synthetics, out);
+        }
+        if (attrs != null) {
+            attrs.put(cw, null, 0, -1, -1, out);
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    // Utility methods: instruction resizing (used to handle GOTO_W and JSR_W)
+    // ------------------------------------------------------------------------
+
+    /**
+     * Resizes and replaces the temporary instructions inserted by
+     * {@link Label#resolve} for wide forward jumps, while keeping jump offsets
+     * and instruction addresses consistent. This may require to resize other
+     * existing instructions, or even to introduce new instructions: for
+     * example, increasing the size of an instruction by 2 at the middle of a
+     * method can increases the offset of an IFEQ instruction from 32766 to
+     * 32768, in which case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W
+     * 32765. This, in turn, may require to increase the size of another jump
+     * instruction, and so on... All these operations are handled automatically
+     * by this method. <p> <i>This method must be called after all the method
+     * that is being built has been visited</i>. In particular, the
+     * {@link Label Label} objects used to construct the method are no longer
+     * valid after this method has been called.
+     */
+    private void resizeInstructions() {
+        byte[] b = code.data; // bytecode of the method
+        int u, v, label; // indexes in b
+        int i, j; // loop indexes
+        /*
+         * 1st step: As explained above, resizing an instruction may require to
+         * resize another one, which may require to resize yet another one, and
+         * so on. The first step of the algorithm consists in finding all the
+         * instructions that need to be resized, without modifying the code.
+         * This is done by the following "fix point" algorithm:
+         *
+         * Parse the code to find the jump instructions whose offset will need
+         * more than 2 bytes to be stored (the future offset is computed from
+         * the current offset and from the number of bytes that will be inserted
+         * or removed between the source and target instructions). For each such
+         * instruction, adds an entry in (a copy of) the indexes and sizes
+         * arrays (if this has not already been done in a previous iteration!).
+         *
+         * If at least one entry has been added during the previous step, go
+         * back to the beginning, otherwise stop.
+         *
+         * In fact the real algorithm is complicated by the fact that the size
+         * of TABLESWITCH and LOOKUPSWITCH instructions depends on their
+         * position in the bytecode (because of padding). In order to ensure the
+         * convergence of the algorithm, the number of bytes to be added or
+         * removed from these instructions is over estimated during the previous
+         * loop, and computed exactly only after the loop is finished (this
+         * requires another pass to parse the bytecode of the method).
+         */
+        int[] allIndexes = new int[0]; // copy of indexes
+        int[] allSizes = new int[0]; // copy of sizes
+        boolean[] resize; // instructions to be resized
+        int newOffset; // future offset of a jump instruction
+
+        resize = new boolean[code.length];
+
+        // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done
+        int state = 3;
+        do {
+            if (state == 3) {
+                state = 2;
+            }
+            u = 0;
+            while (u < b.length) {
+                int opcode = b[u] & 0xFF; // opcode of current instruction
+                int insert = 0; // bytes to be added after this instruction
+
+                switch (ClassWriter.TYPE[opcode]) {
+                    case ClassWriter.NOARG_INSN:
+                    case ClassWriter.IMPLVAR_INSN:
+                        u += 1;
+                        break;
+                    case ClassWriter.LABEL_INSN:
+                        if (opcode > 201) {
+                            // converts temporary opcodes 202 to 217, 218 and
+                            // 219 to IFEQ ... JSR (inclusive), IFNULL and
+                            // IFNONNULL
+                            opcode = opcode < 218 ? opcode - 49 : opcode - 20;
+                            label = u + readUnsignedShort(b, u + 1);
+                        } else {
+                            label = u + readShort(b, u + 1);
+                        }
+                        newOffset = getNewOffset(allIndexes, allSizes, u, label);
+                        if (newOffset < Short.MIN_VALUE
+                                || newOffset > Short.MAX_VALUE)
+                        {
+                            if (!resize[u]) {
+                                if (opcode == Opcodes.GOTO
+                                        || opcode == Opcodes.JSR)
+                                {
+                                    // two additional bytes will be required to
+                                    // replace this GOTO or JSR instruction with
+                                    // a GOTO_W or a JSR_W
+                                    insert = 2;
+                                } else {
+                                    // five additional bytes will be required to
+                                    // replace this IFxxx <l> instruction with
+                                    // IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx
+                                    // is the "opposite" opcode of IFxxx (i.e.,
+                                    // IFNE for IFEQ) and where <l'> designates
+                                    // the instruction just after the GOTO_W.
+                                    insert = 5;
+                                }
+                                resize[u] = true;
+                            }
+                        }
+                        u += 3;
+                        break;
+                    case ClassWriter.LABELW_INSN:
+                        u += 5;
+                        break;
+                    case ClassWriter.TABL_INSN:
+                        if (state == 1) {
+                            // true number of bytes to be added (or removed)
+                            // from this instruction = (future number of padding
+                            // bytes - current number of padding byte) -
+                            // previously over estimated variation =
+                            // = ((3 - newOffset%4) - (3 - u%4)) - u%4
+                            // = (-newOffset%4 + u%4) - u%4
+                            // = -(newOffset & 3)
+                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);
+                            insert = -(newOffset & 3);
+                        } else if (!resize[u]) {
+                            // over estimation of the number of bytes to be
+                            // added to this instruction = 3 - current number
+                            // of padding bytes = 3 - (3 - u%4) = u%4 = u & 3
+                            insert = u & 3;
+                            resize[u] = true;
+                        }
+                        // skips instruction
+                        u = u + 4 - (u & 3);
+                        u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;
+                        break;
+                    case ClassWriter.LOOK_INSN:
+                        if (state == 1) {
+                            // like TABL_INSN
+                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);
+                            insert = -(newOffset & 3);
+                        } else if (!resize[u]) {
+                            // like TABL_INSN
+                            insert = u & 3;
+                            resize[u] = true;
+                        }
+                        // skips instruction
+                        u = u + 4 - (u & 3);
+                        u += 8 * readInt(b, u + 4) + 8;
+                        break;
+                    case ClassWriter.WIDE_INSN:
+                        opcode = b[u + 1] & 0xFF;
+                        if (opcode == Opcodes.IINC) {
+                            u += 6;
+                        } else {
+                            u += 4;
+                        }
+                        break;
+                    case ClassWriter.VAR_INSN:
+                    case ClassWriter.SBYTE_INSN:
+                    case ClassWriter.LDC_INSN:
+                        u += 2;
+                        break;
+                    case ClassWriter.SHORT_INSN:
+                    case ClassWriter.LDCW_INSN:
+                    case ClassWriter.FIELDORMETH_INSN:
+                    case ClassWriter.TYPE_INSN:
+                    case ClassWriter.IINC_INSN:
+                        u += 3;
+                        break;
+                    case ClassWriter.ITFMETH_INSN:
+                        u += 5;
+                        break;
+                    // case ClassWriter.MANA_INSN:
+                    default:
+                        u += 4;
+                        break;
+                }
+                if (insert != 0) {
+                    // adds a new (u, insert) entry in the allIndexes and
+                    // allSizes arrays
+                    int[] newIndexes = new int[allIndexes.length + 1];
+                    int[] newSizes = new int[allSizes.length + 1];
+                    System.arraycopy(allIndexes,
+                            0,
+                            newIndexes,
+                            0,
+                            allIndexes.length);
+                    System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);
+                    newIndexes[allIndexes.length] = u;
+                    newSizes[allSizes.length] = insert;
+                    allIndexes = newIndexes;
+                    allSizes = newSizes;
+                    if (insert > 0) {
+                        state = 3;
+                    }
+                }
+            }
+            if (state < 3) {
+                --state;
+            }
+        } while (state != 0);
+
+        // 2nd step:
+        // copies the bytecode of the method into a new bytevector, updates the
+        // offsets, and inserts (or removes) bytes as requested.
+
+        ByteVector newCode = new ByteVector(code.length);
+
+        u = 0;
+        while (u < code.length) {
+            int opcode = b[u] & 0xFF;
+            switch (ClassWriter.TYPE[opcode]) {
+                case ClassWriter.NOARG_INSN:
+                case ClassWriter.IMPLVAR_INSN:
+                    newCode.putByte(opcode);
+                    u += 1;
+                    break;
+                case ClassWriter.LABEL_INSN:
+                    if (opcode > 201) {
+                        // changes temporary opcodes 202 to 217 (inclusive), 218
+                        // and 219 to IFEQ ... JSR (inclusive), IFNULL and
+                        // IFNONNULL
+                        opcode = opcode < 218 ? opcode - 49 : opcode - 20;
+                        label = u + readUnsignedShort(b, u + 1);
+                    } else {
+                        label = u + readShort(b, u + 1);
+                    }
+                    newOffset = getNewOffset(allIndexes, allSizes, u, label);
+                    if (resize[u]) {
+                        // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx
+                        // <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is
+                        // the "opposite" opcode of IFxxx (i.e., IFNE for IFEQ)
+                        // and where <l'> designates the instruction just after
+                        // the GOTO_W.
+                        if (opcode == Opcodes.GOTO) {
+                            newCode.putByte(200); // GOTO_W
+                        } else if (opcode == Opcodes.JSR) {
+                            newCode.putByte(201); // JSR_W
+                        } else {
+                            newCode.putByte(opcode <= 166
+                                    ? ((opcode + 1) ^ 1) - 1
+                                    : opcode ^ 1);
+                            newCode.putShort(8); // jump offset
+                            newCode.putByte(200); // GOTO_W
+                            // newOffset now computed from start of GOTO_W
+                            newOffset -= 3;
+                        }
+                        newCode.putInt(newOffset);
+                    } else {
+                        newCode.putByte(opcode);
+                        newCode.putShort(newOffset);
+                    }
+                    u += 3;
+                    break;
+                case ClassWriter.LABELW_INSN:
+                    label = u + readInt(b, u + 1);
+                    newOffset = getNewOffset(allIndexes, allSizes, u, label);
+                    newCode.putByte(opcode);
+                    newCode.putInt(newOffset);
+                    u += 5;
+                    break;
+                case ClassWriter.TABL_INSN:
+                    // skips 0 to 3 padding bytes
+                    v = u;
+                    u = u + 4 - (v & 3);
+                    // reads and copies instruction
+                    newCode.putByte(Opcodes.TABLESWITCH);
+                    newCode.length += (4 - newCode.length % 4) % 4;
+                    label = v + readInt(b, u);
+                    u += 4;
+                    newOffset = getNewOffset(allIndexes, allSizes, v, label);
+                    newCode.putInt(newOffset);
+                    j = readInt(b, u);
+                    u += 4;
+                    newCode.putInt(j);
+                    j = readInt(b, u) - j + 1;
+                    u += 4;
+                    newCode.putInt(readInt(b, u - 4));
+                    for (; j > 0; --j) {
+                        label = v + readInt(b, u);
+                        u += 4;
+                        newOffset = getNewOffset(allIndexes, allSizes, v, label);
+                        newCode.putInt(newOffset);
+                    }
+                    break;
+                case ClassWriter.LOOK_INSN:
+                    // skips 0 to 3 padding bytes
+                    v = u;
+                    u = u + 4 - (v & 3);
+                    // reads and copies instruction
+                    newCode.putByte(Opcodes.LOOKUPSWITCH);
+                    newCode.length += (4 - newCode.length % 4) % 4;
+                    label = v + readInt(b, u);
+                    u += 4;
+                    newOffset = getNewOffset(allIndexes, allSizes, v, label);
+                    newCode.putInt(newOffset);
+                    j = readInt(b, u);
+                    u += 4;
+                    newCode.putInt(j);
+                    for (; j > 0; --j) {
+                        newCode.putInt(readInt(b, u));
+                        u += 4;
+                        label = v + readInt(b, u);
+                        u += 4;
+                        newOffset = getNewOffset(allIndexes, allSizes, v, label);
+                        newCode.putInt(newOffset);
+                    }
+                    break;
+                case ClassWriter.WIDE_INSN:
+                    opcode = b[u + 1] & 0xFF;
+                    if (opcode == Opcodes.IINC) {
+                        newCode.putByteArray(b, u, 6);
+                        u += 6;
+                    } else {
+                        newCode.putByteArray(b, u, 4);
+                        u += 4;
+                    }
+                    break;
+                case ClassWriter.VAR_INSN:
+                case ClassWriter.SBYTE_INSN:
+                case ClassWriter.LDC_INSN:
+                    newCode.putByteArray(b, u, 2);
+                    u += 2;
+                    break;
+                case ClassWriter.SHORT_INSN:
+                case ClassWriter.LDCW_INSN:
+                case ClassWriter.FIELDORMETH_INSN:
+                case ClassWriter.TYPE_INSN:
+                case ClassWriter.IINC_INSN:
+                    newCode.putByteArray(b, u, 3);
+                    u += 3;
+                    break;
+                case ClassWriter.ITFMETH_INSN:
+                    newCode.putByteArray(b, u, 5);
+                    u += 5;
+                    break;
+                // case MANA_INSN:
+                default:
+                    newCode.putByteArray(b, u, 4);
+                    u += 4;
+                    break;
+            }
+        }
+
+        // recomputes the stack map frames
+        if (frameCount > 0) {
+            if (compute == FRAMES) {
+                frameCount = 0;
+                stackMap = null;
+                previousFrame = null;
+                frame = null;
+                Frame f = new Frame();
+                f.owner = labels;
+                Type[] args = Type.getArgumentTypes(descriptor);
+                f.initInputFrame(cw, access, args, maxLocals);
+                visitFrame(f);
+                Label l = labels;
+                while (l != null) {
+                    /*
+                     * here we need the original label position. getNewOffset
+                     * must therefore never have been called for this label.
+                     */
+                    u = l.position - 3;
+                    if ((l.status & Label.STORE) != 0 || (u >= 0 && resize[u]))
+                    {
+                        getNewOffset(allIndexes, allSizes, l);
+                        // TODO update offsets in UNINITIALIZED values
+                        visitFrame(l.frame);
+                    }
+                    l = l.successor;
+                }
+            } else {
+                /*
+                 * Resizing an existing stack map frame table is really hard.
+                 * Not only the table must be parsed to update the offets, but
+                 * new frames may be needed for jump instructions that were
+                 * inserted by this method. And updating the offsets or
+                 * inserting frames can change the format of the following
+                 * frames, in case of packed frames. In practice the whole table
+                 * must be recomputed. For this the frames are marked as
+                 * potentially invalid. This will cause the whole class to be
+                 * reread and rewritten with the COMPUTE_FRAMES option (see the
+                 * ClassWriter.toByteArray method). This is not very efficient
+                 * but is much easier and requires much less code than any other
+                 * method I can think of.
+                 */
+                cw.invalidFrames = true;
+            }
+        }
+        // updates the exception handler block labels
+        Handler h = firstHandler;
+        while (h != null) {
+            getNewOffset(allIndexes, allSizes, h.start);
+            getNewOffset(allIndexes, allSizes, h.end);
+            getNewOffset(allIndexes, allSizes, h.handler);
+            h = h.next;
+        }
+        // updates the instructions addresses in the
+        // local var and line number tables
+        for (i = 0; i < 2; ++i) {
+            ByteVector bv = i == 0 ? localVar : localVarType;
+            if (bv != null) {
+                b = bv.data;
+                u = 0;
+                while (u < bv.length) {
+                    label = readUnsignedShort(b, u);
+                    newOffset = getNewOffset(allIndexes, allSizes, 0, label);
+                    writeShort(b, u, newOffset);
+                    label += readUnsignedShort(b, u + 2);
+                    newOffset = getNewOffset(allIndexes, allSizes, 0, label)
+                            - newOffset;
+                    writeShort(b, u + 2, newOffset);
+                    u += 10;
+                }
+            }
+        }
+        if (lineNumber != null) {
+            b = lineNumber.data;
+            u = 0;
+            while (u < lineNumber.length) {
+                writeShort(b, u, getNewOffset(allIndexes,
+                        allSizes,
+                        0,
+                        readUnsignedShort(b, u)));
+                u += 4;
+            }
+        }
+        // updates the labels of the other attributes
+        Attribute attr = cattrs;
+        while (attr != null) {
+            Label[] labels = attr.getLabels();
+            if (labels != null) {
+                for (i = labels.length - 1; i >= 0; --i) {
+                    getNewOffset(allIndexes, allSizes, labels[i]);
+                }
+            }
+            attr = attr.next;
+        }
+
+        // replaces old bytecodes with new ones
+        code = newCode;
+    }
+
+    /**
+     * Reads an unsigned short value in the given byte array.
+     *
+     * @param b a byte array.
+     * @param index the start index of the value to be read.
+     * @return the read value.
+     */
+    static int readUnsignedShort(final byte[] b, final int index) {
+        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);
+    }
+
+    /**
+     * Reads a signed short value in the given byte array.
+     *
+     * @param b a byte array.
+     * @param index the start index of the value to be read.
+     * @return the read value.
+     */
+    static short readShort(final byte[] b, final int index) {
+        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));
+    }
+
+    /**
+     * Reads a signed int value in the given byte array.
+     *
+     * @param b a byte array.
+     * @param index the start index of the value to be read.
+     * @return the read value.
+     */
+    static int readInt(final byte[] b, final int index) {
+        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16)
+                | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);
+    }
+
+    /**
+     * Writes a short value in the given byte array.
+     *
+     * @param b a byte array.
+     * @param index where the first byte of the short value must be written.
+     * @param s the value to be written in the given byte array.
+     */
+    static void writeShort(final byte[] b, final int index, final int s) {
+        b[index] = (byte) (s >>> 8);
+        b[index + 1] = (byte) s;
+    }
+
+    /**
+     * Computes the future value of a bytecode offset. <p> Note: it is possible
+     * to have several entries for the same instruction in the <tt>indexes</tt>
+     * and <tt>sizes</tt>: two entries (index=a,size=b) and (index=a,size=b')
+     * are equivalent to a single entry (index=a,size=b+b').
+     *
+     * @param indexes current positions of the instructions to be resized. Each
+     *        instruction must be designated by the index of its <i>last</i>
+     *        byte, plus one (or, in other words, by the index of the <i>first</i>
+     *        byte of the <i>next</i> instruction).
+     * @param sizes the number of bytes to be <i>added</i> to the above
+     *        instructions. More precisely, for each i < <tt>len</tt>,
+     *        <tt>sizes</tt>[i] bytes will be added at the end of the
+     *        instruction designated by <tt>indexes</tt>[i] or, if
+     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|
+     *        bytes of the instruction will be removed (the instruction size
+     *        <i>must not</i> become negative or null).
+     * @param begin index of the first byte of the source instruction.
+     * @param end index of the first byte of the target instruction.
+     * @return the future value of the given bytecode offset.
+     */
+    static int getNewOffset(
+        final int[] indexes,
+        final int[] sizes,
+        final int begin,
+        final int end)
+    {
+        int offset = end - begin;
+        for (int i = 0; i < indexes.length; ++i) {
+            if (begin < indexes[i] && indexes[i] <= end) {
+                // forward jump
+                offset += sizes[i];
+            } else if (end < indexes[i] && indexes[i] <= begin) {
+                // backward jump
+                offset -= sizes[i];
+            }
+        }
+        return offset;
+    }
+
+    /**
+     * Updates the offset of the given label.
+     *
+     * @param indexes current positions of the instructions to be resized. Each
+     *        instruction must be designated by the index of its <i>last</i>
+     *        byte, plus one (or, in other words, by the index of the <i>first</i>
+     *        byte of the <i>next</i> instruction).
+     * @param sizes the number of bytes to be <i>added</i> to the above
+     *        instructions. More precisely, for each i < <tt>len</tt>,
+     *        <tt>sizes</tt>[i] bytes will be added at the end of the
+     *        instruction designated by <tt>indexes</tt>[i] or, if
+     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|
+     *        bytes of the instruction will be removed (the instruction size
+     *        <i>must not</i> become negative or null).
+     * @param label the label whose offset must be updated.
+     */
+    static void getNewOffset(
+        final int[] indexes,
+        final int[] sizes,
+        final Label label)
+    {
+        if ((label.status & Label.RESIZED) == 0) {
+            label.position = getNewOffset(indexes, sizes, 0, label.position);
+            label.status |= Label.RESIZED;
+        }
+    }
+}
--- /dev/null	Tue Aug  4 10:20:06 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/Opcodes.java	Tue Aug  4 10:20:06 2009
@@ -0,0 +1,371 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+/**
+ * Defines the JVM opcodes, access flags and array type codes. This interface
+ * does not define all the JVM opcodes because some opcodes are automatically
+ * handled. For example, the xLOAD and xSTORE opcodes are automatically replaced
+ * by xLOAD_n and xSTORE_n opcodes when possible. The xLOAD_n and xSTORE_n
+ * opcodes are therefore not defined in this interface. Likewise for LDC,
+ * automatically replaced by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and
+ * JSR_W.
+ *
+ * @author Eric Bruneton
+ * @author Eugene Kuleshov
+ */
+public interface Opcodes {
+
+    // versions
+
+    int V1_1 = 3 << 16 | 45;
+    int V1_2 = 0 << 16 | 46;
+    int V1_3 = 0 << 16 | 47;
+    int V1_4 = 0 << 16 | 48;
+    int V1_5 = 0 << 16 | 49;
+    int V1_6 = 0 << 16 | 50;
+
+    // access flags
+
+    int ACC_PUBLIC = 0x0001; // class, field, method
+    int ACC_PRIVATE = 0x0002; // class, field, method
+    int ACC_PROTECTED = 0x0004; // class, field, method
+    int ACC_STATIC = 0x0008; // field, method
+    int ACC_FINAL = 0x0010; // class, field, method
+    int ACC_SUPER = 0x0020; // class
+    int ACC_SYNCHRONIZED = 0x0020; // method
+    int ACC_VOLATILE = 0x0040; // field
+    int ACC_BRIDGE = 0x0040; // method
+    int ACC_VARARGS = 0x0080; // method
+    int ACC_TRANSIENT = 0x0080; // field
+    int ACC_NATIVE = 0x0100; // method
+    int ACC_INTERFACE = 0x0200; // class
+    int ACC_ABSTRACT = 0x0400; // class, method
+    int ACC_STRICT = 0x0800; // method
+    int ACC_SYNTHETIC = 0x1000; // class, field, method
+    int ACC_ANNOTATION = 0x2000; // class
+    int ACC_ENUM = 0x4000; // class(?) field inner
+
+    // ASM specific pseudo access flags
+
+    int ACC_DEPRECATED = 131072; // class, field, method
+
+    // types for NEWARRAY
+
+    int T_BOOLEAN = 4;
+    int T_CHAR = 5;
+    int T_FLOAT = 6;
+    int T_DOUBLE = 7;
+    int T_BYTE = 8;
+    int T_SHORT = 9;
+    int T_INT = 10;
+    int T_LONG = 11;
+
+    // stack map frame types
+
+    /**
+     * Represents an expanded frame. See {@link ClassReader#EXPAND_FRAMES}.
+     */
+    int F_NEW = -1;
+
+    /**
+     * Represents a compressed frame with complete frame data.
+     */
+    int F_FULL = 0;
+
+    /**
+     * Represents a compressed frame where locals are the same as the locals in
+     * the previous frame, except that additional 1-3 locals are defined, and
+     * with an empty stack.
+     */
+    int F_APPEND = 1;
+
+    /**
+     * Represents a compressed frame where locals are the same as the locals in
+     * the previous frame, except that the last 1-3 locals are absent and with
+     * an empty stack.
+     */
+    int F_CHOP = 2;
+
+    /**
+     * Represents a compressed frame with exactly the same locals as the
+     * previous frame and with an empty stack.
+     */
+    int F_SAME = 3;
+
+    /**
+     * Represents a compressed frame with exactly the same locals as the
+     * previous frame and with a single value on the stack.
+     */
+    int F_SAME1 = 4;
+
+    Integer TOP = new Integer(0);
+    Integer INTEGER = new Integer(1);
+    Integer FLOAT = new Integer(2);
+    Integer DOUBLE = new Integer(3);
+    Integer LONG = new Integer(4);
+    Integer NULL = new Integer(5);
+    Integer UNINITIALIZED_THIS = new Integer(6);
+
+    // opcodes // visit method (- = idem)
+
+    int NOP = 0; // visitInsn
+    int ACONST_NULL = 1; // -
+    int ICONST_M1 = 2; // -
+    int ICONST_0 = 3; // -
+    int ICONST_1 = 4; // -
+    int ICONST_2 = 5; // -
+    int ICONST_3 = 6; // -
+    int ICONST_4 = 7; // -
+    int ICONST_5 = 8; // -
+    int LCONST_0 = 9; // -
+    int LCONST_1 = 10; // -
+    int FCONST_0 = 11; // -
+    int FCONST_1 = 12; // -
+    int FCONST_2 = 13; // -
+    int DCONST_0 = 14; // -
+    int DCONST_1 = 15; // -
+    int BIPUSH = 16; // visitIntInsn
+    int SIPUSH = 17; // -
+    int LDC = 18; // visitLdcInsn
+    // int LDC_W = 19; // -
+    // int LDC2_W = 20; // -
+    int ILOAD = 21; // visitVarInsn
+    int LLOAD = 22; // -
+    int FLOAD = 23; // -
+    int DLOAD = 24; // -
+    int ALOAD = 25; // -
+    // int ILOAD_0 = 26; // -
+    // int ILOAD_1 = 27; // -
+    // int ILOAD_2 = 28; // -
+    // int ILOAD_3 = 29; // -
+    // int LLOAD_0 = 30; // -
+    // int LLOAD_1 = 31; // -
+    // int LLOAD_2 = 32; // -
+    // int LLOAD_3 = 33; // -
+    // int FLOAD_0 = 34; // -
+    // int FLOAD_1 = 35; // -
+    // int FLOAD_2 = 36; // -
+    // int FLOAD_3 = 37; // -
+    // int DLOAD_0 = 38; // -
+    // int DLOAD_1 = 39; // -
+    // int DLOAD_2 = 40; // -
+    // int DLOAD_3 = 41; // -
+    // int ALOAD_0 = 42; // -
+    // int ALOAD_1 = 43; // -
+    // int ALOAD_2 = 44; // -
+    // int ALOAD_3 = 45; // -
+    int IALOAD = 46; // visitInsn
+    int LALOAD = 47; // -
+    int FALOAD = 48; // -
+    int DALOAD = 49; // -
+    int AALOAD = 50; // -
+    int BALOAD = 51; // -
+    int CALOAD = 52; // -
+    int SALOAD = 53; // -
+    int ISTORE = 54; // visitVarInsn
+    int LSTORE = 55; // -
+    int FSTORE = 56; // -
+    int DSTORE = 57; // -
+    int ASTORE = 58; // -
+    // int ISTORE_0 = 59; // -
+    // int ISTORE_1 = 60; // -
+    // int ISTORE_2 = 61; // -
+    // int ISTORE_3 = 62; // -
+    // int LSTORE_0 = 63; // -
+    // int LSTORE_1 = 64; // -
+    // int LSTORE_2 = 65; // -
+    // int LSTORE_3 = 66; // -
+    // int FSTORE_0 = 67; // -
+    // int FSTORE_1 = 68; // -
+    // int FSTORE_2 = 69; // -
+    // int FSTORE_3 = 70; // -
+    // int DSTORE_0 = 71; // -
+    // int DSTORE_1 = 72; // -
+    // int DSTORE_2 = 73; // -
+    // int DSTORE_3 = 74; // -
+    // int ASTORE_0 = 75; // -
+    // int ASTORE_1 = 76; // -
+    // int ASTORE_2 = 77; // -
+    // int ASTORE_3 = 78; // -
+    int IASTORE = 79; // visitInsn
+    int LASTORE = 80; // -
+    int FASTORE = 81; // -
+    int DASTORE = 82; // -
+    int AASTORE = 83; // -
+    int BASTORE = 84; // -
+    int CASTORE = 85; // -
+    int SASTORE = 86; // -
+    int POP = 87; // -
+    int POP2 = 88; // -
+    int DUP = 89; // -
+    int DUP_X1 = 90; // -
+    int DUP_X2 = 91; // -
+    int DUP2 = 92; // -
+    int DUP2_X1 = 93; // -
+    int DUP2_X2 = 94; // -
+    int SWAP = 95; // -
+    int IADD = 96; // -
+    int LADD = 97; // -
+    int FADD = 98; // -
+    int DADD = 99; // -
+    int ISUB = 100; // -
+    int LSUB = 101; // -
+    int FSUB = 102; // -
+    int DSUB = 103; // -
+    int IMUL = 104; // -
+    int LMUL = 105; // -
+    int FMUL = 106; // -
+    int DMUL = 107; // -
+    int IDIV = 108; // -
+    int LDIV = 109; // -
+    int FDIV = 110; // -
+    int DDIV = 111; // -
+    int IREM = 112; // -
+    int LREM = 113; // -
+    int FREM = 114; // -
+    int DREM = 115; // -
+    int INEG = 116; // -
+    int LNEG = 117; // -
+    int FNEG = 118; // -
+    int DNEG = 119; // -
+    int ISHL = 120; // -
+    int LSHL = 121; // -
+    int ISHR = 122; // -
+    int LSHR = 123; // -
+    int IUSHR = 124; // -
+    int LUSHR = 125; // -
+    int IAND = 126; // -
+    int LAND = 127; // -
+    int IOR = 128; // -
+    int LOR = 129; // -
+    int IXOR = 130; // -
+    int LXOR = 131; // -
+    int IINC = 132; // visitIincInsn
+    int I2L = 133; // visitInsn
+    int I2F = 134; // -
+    int I2D = 135; // -
+    int L2I = 136; // -
+    int L2F = 137; // -
+    int L2D = 138; // -
+    int F2I = 139; // -
+    int F2L = 140; // -
+    int F2D = 141; // -
+    int D2I = 142; // -
+    int D2L = 143; // -
+    int D2F = 144; // -
+    int I2B = 145; // -
+    int I2C = 146; // -
+    int I2S = 147; // -
+    int LCMP = 148; // -
+    int FCMPL = 149; // -
+    int FCMPG = 150; // -
+    int DCMPL = 151; // -
+    int DCMPG = 152; // -
+    int IFEQ = 153; // visitJumpInsn
+    int IFNE = 154; // -
+    int IFLT = 155; // -
+    int IFGE = 156; // -
+    int IFGT = 157; // -
+    int IFLE = 158; // -
+    int IF_ICMPEQ = 159; // -
+    int IF_ICMPNE = 160; // -
+    int IF_ICMPLT = 161; // -
+    int IF_ICMPGE = 162; // -
+    int IF_ICMPGT = 163; // -
+    int IF_ICMPLE = 164; // -
+    int IF_ACMPEQ = 165; // -
+    int IF_ACMPNE = 166; // -
+    int GOTO = 167; // -
+    int JSR = 168; // -
+    int RET = 169; // visitVarInsn
+    int TABLESWITCH = 170; // visiTableSwitchInsn
+    int LOOKUPSWITCH = 171; // visitLookupSwitch
+    int IRETURN = 172; // visitInsn
+    int LRETURN = 173; // -
+    int FRETURN = 174; // -
+    int DRETURN = 175; // -
+    int ARETURN = 176; // -
+    int RETURN = 177; // -
+    int GETSTATIC = 178; // visitFieldInsn
+    int PUTSTATIC = 179; // -
+    int GETFIELD = 180; // -
+    int PUTFIELD = 181; // -
+    int INVOKEVIRTUAL = 182; // visitMethodInsn
+    int INVOKESPECIAL = 183; // -
+    int INVOKESTATIC = 184; // -
+    int INVOKEINTERFACE = 185; // -
+    // int UNUSED = 186; // NOT VISITED
+    int NEW = 187; // visitTypeInsn
+    int NEWARRAY = 188; // visitIntInsn
+    int ANEWARRAY = 189; // visitTypeInsn
+    int ARRAYLENGTH = 190; // visitInsn
+    int ATHROW = 191; // -
+    int CHECKCAST = 192; // visitTypeInsn
+    int INSTANCEOF = 193; // -
+    int MONITORENTER = 194; // visitInsn
+    int MONITOREXIT = 195; // -
+    // int WIDE = 196; // NOT VISITED
+    int MULTIANEWARRAY = 197; // visitMultiANewArrayInsn
+    int IFNULL = 198; // visitJumpInsn
+    int IFNONNULL = 199; // -
+    // int GOTO_W = 200; // -
+    // int JSR_W = 201; // -
+}
--- /dev/null	Tue Aug  4 10:20:08 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/org/objectweb/asm/Type.java	Tue Aug  4 10:20:08 2009
@@ -0,0 +1,824 @@
+/*
+ * Copyright 2005-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * This file is available under and governed by the GNU General Public
+ * License version 2 only, as published by the Free Software Foundation.
+ * However, the following notice accompanied the original version of this
+ * file:
+ *
+ * ASM: a very small and fast Java bytecode manipulation framework
+ * Copyright (c) 2000-2007 INRIA, France Telecom
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.sun.xml.internal.ws.org.objectweb.asm;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+
+/**
+ * A Java type. This class can be used to make it easier to manipulate type and
+ * method descriptors.
+ *
+ * @author Eric Bruneton
+ * @author Chris Nokleberg
+ */
+public class Type {
+
+    /**
+     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.
+     */
+    public static final int VOID = 0;
+
+    /**
+     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.
+     */
+    public static final int BOOLEAN = 1;
+
+    /**
+     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.
+     */
+    public static final int CHAR = 2;
+
+    /**
+     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.
+     */
+    public static final int BYTE = 3;
+
+    /**
+     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.
+     */
+    public static final int SHORT = 4;
+
+    /**
+     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.
+     */
+    public static final int INT = 5;
+
+    /**
+     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.
+     */
+    public static final int FLOAT = 6;
+
+    /**
+     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.
+     */
+    public static final int LONG = 7;
+
+    /**
+     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.
+     */
+    public static final int DOUBLE = 8;
+
+    /**
+     * The sort of array reference types. See {@link #getSort getSort}.
+     */
+    public static final int ARRAY = 9;
+
+    /**
+     * The sort of object reference type. See {@link #getSort getSort}.
+     */
+    public static final int OBJECT = 10;
+
+    /**
+     * The <tt>void</tt> type.
+     */
+    public static final Type VOID_TYPE = new Type(VOID);
+
+    /**
+     * The <tt>boolean</tt> type.
+     */
+    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN);
+
+    /**
+     * The <tt>char</tt> type.
+     */
+    public static final Type CHAR_TYPE = new Type(CHAR);
+
+    /**
+     * The <tt>byte</tt> type.
+     */
+    public static final Type BYTE_TYPE = new Type(BYTE);
+
+    /**
+     * The <tt>short</tt> type.
+     */
+    public static final Type SHORT_TYPE = new Type(SHORT);
+
+    /**
+     * The <tt>int</tt> type.
+     */
+    public static final Type INT_TYPE = new Type(INT);
+
+    /**
+     * The <tt>float</tt> type.
+     */
+    public static final Type FLOAT_TYPE = new Type(FLOAT);
+
+    /**
+     * The <tt>long</tt> type.
+     */
+    public static final Type LONG_TYPE = new Type(LONG);
+
+    /**
+     * The <tt>double</tt> type.
+     */
+    public static final Type DOUBLE_TYPE = new Type(DOUBLE);
+
+    // ------------------------------------------------------------------------
+    // Fields
+    // ------------------------------------------------------------------------
+
+    /**
+     * The sort of this Java type.
+     */
+    private final int sort;
+
+    /**
+     * A buffer containing the internal name of this Java type. This field is
+     * only used for reference types.
+     */
+    private final char[] buf;
+
+    /**
+     * The offset of the internal name of this Java type in {@link #buf buf}.
+     * This field is only used for reference types.
+     */
+    private final int off;
+
+    /**
+     * The length of the internal name of this Java type. This field is only
+     * used for reference types.
+     */
+    private final int len;
+
+    // ------------------------------------------------------------------------
+    // Constructors
+    // ------------------------------------------------------------------------
+
+    /**
+     * Constructs a primitive type.
+     *
+     * @param sort the sort of the primitive type to be constructed.
+     */
+    private Type(final int sort) {
+        this(sort, null, 0, 1);
+    }
+
+    /**
+     * Constructs a reference type.
+     *
+     * @param sort the sort of the reference type to be constructed.
+     * @param buf a buffer containing the descriptor of the previous type.
+     * @param off the offset of this descriptor in the previous buffer.
+     * @param len the length of this descriptor.
+     */
+    private Type(final int sort, final char[] buf, final int off, final int len)
+    {
+        this.sort = sort;
+        this.buf = buf;
+        this.off = off;
+        this.len = len;
+    }
+
+    /**
+     * Returns the Java type corresponding to the given type descriptor.
+     *
+     * @param typeDescriptor a type descriptor.
+     * @return the Java type corresponding to the given type descriptor.
+     */
+    public static Type getType(final String typeDescriptor) {
+        return getType(typeDescriptor.toCharArray(), 0);
+    }
+
+    /**
+     * Returns the Java type corresponding to the given internal name.
+     *
+     * @param internalName an internal name.
+     * @return the Java type corresponding to the given internal name.
+     */
+    public static Type getObjectType(final String internalName) {
+        char[] buf = internalName.toCharArray();
+        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);
+    }
+
+    /**
+     * Returns the Java type corresponding to the given class.
+     *
+     * @param c a class.
+     * @return the Java type corresponding to the given class.
+     */
+    public static Type getType(final Class c) {
+        if (c.isPrimitive()) {
+            if (c == Integer.TYPE) {
+                return INT_TYPE;
+            } else if (c == Void.TYPE) {
+                return VOID_TYPE;
+            } else if (c == Boolean.TYPE) {
+                return BOOLEAN_TYPE;
+            } else if (c == Byte.TYPE) {
+                return BYTE_TYPE;
+            } else if (c == Character.TYPE) {
+                return CHAR_TYPE;
+            } else if (c == Short.TYPE) {
+                return SHORT_TYPE;
+            } else if (c == Double.TYPE) {
+                return DOUBLE_TYPE;
+            } else if (c == Float.TYPE) {
+                return FLOAT_TYPE;
+            } else /* if (c == Long.TYPE) */{
+                return LONG_TYPE;
+            }
+        } else {
+            return getType(getDescriptor(c));
+        }
+    }
+
+    /**
+     * Returns the Java types corresponding to the argument types of the given
+     * method descriptor.
+     *
+     * @param methodDescriptor a method descriptor.
+     * @return the Java types corresponding to the argument types of the given
+     *         method descriptor.
+     */
+    public static Type[] getArgumentTypes(final String methodDescriptor) {
+        char[] buf = methodDescriptor.toCharArray();
+        int off = 1;
+        int size = 0;
+        while (true) {
+            char car = buf[off++];
+            if (car == ')') {
+                break;
+            } else if (car == 'L') {
+                while (buf[off++] != ';') {
+                }
+                ++size;
+            } else if (car != '[') {
+                ++size;
+            }
+        }
+        Type[] args = new Type[size];
+        off = 1;
+        size = 0;
+        while (buf[off] != ')') {
+            args[size] = getType(buf, off);
+            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);
+            size += 1;
+        }
+        return args;
+    }
+
+    /**
+     * Returns the Java types corresponding to the argument types of the given
+     * method.
+     *
+     * @param method a method.
+     * @return the Java types corresponding to the argument types of the given
+     *         method.
+     */
+    public static Type[] getArgumentTypes(final Method method) {
+        Class[] classes = method.getParameterTypes();
+        Type[] types = new Type[classes.length];
+        for (int i = classes.length - 1; i >= 0; --i) {
+            types[i] = getType(classes[i]);
+        }
+        return types;
+    }
+
+    /**
+     * Returns the Java type corresponding to the return type of the given
+     * method descriptor.
+     *
+     * @param methodDescriptor a method descriptor.
+     * @return the Java type corresponding to the return type of the given
+     *         method descriptor.
+     */
+    public static Type getReturnType(final String methodDescriptor) {
+        char[] buf = methodDescriptor.toCharArray();
+        return getType(buf, methodDescriptor.indexOf(')') + 1);
+    }
+
+    /**
+     * Returns the Java type corresponding to the return type of the given
+     * method.
+     *
+     * @param method a method.
+     * @return the Java type corresponding to the return type of the given
+     *         method.
+     */
+    public static Type getReturnType(final Method method) {
+        return getType(method.getReturnType());
+    }
+
+    /**
+     * Returns the Java type corresponding to the given type descriptor.
+     *
+     * @param buf a buffer containing a type descriptor.
+     * @param off the offset of this descriptor in the previous buffer.
+     * @return the Java type corresponding to the given type descriptor.
+     */
+    private static Type getType(final char[] buf, final int off) {
+        int len;
+        switch (buf[off]) {
+            case 'V':
+                return VOID_TYPE;
+            case 'Z':
+                return BOOLEAN_TYPE;
+            case 'C':
+                return CHAR_TYPE;
+            case 'B':
+                return BYTE_TYPE;
+            case 'S':
+                return SHORT_TYPE;
+            case 'I':
+                return INT_TYPE;
+            case 'F':
+                return FLOAT_TYPE;
+            case 'J':
+                return LONG_TYPE;
+            case 'D':
+                return DOUBLE_TYPE;
+            case '[':
+                len = 1;
+                while (buf[off + len] == '[') {
+                    ++len;
+                }
+                if (buf[off + len] == 'L') {
+                    ++len;
+                    while (buf[off + len] != ';') {
+                        ++len;
+                    }
+                }
+                return new Type(ARRAY, buf, off, len + 1);
+                // case 'L':
+            default:
+                len = 1;
+                while (buf[off + len] != ';') {
+                    ++len;
+                }
+                return new Type(OBJECT, buf, off + 1, len - 1);
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    // Accessors
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns the sort of this Java type.
+     *
+     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},
+     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},
+     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},
+     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or
+     *         {@link #OBJECT OBJECT}.
+     */
+    public int getSort() {
+        return sort;
+    }
+
+    /**
+     * Returns the number of dimensions of this array type. This method should
+     * only be used for an array type.
+     *
+     * @return the number of dimensions of this array type.
+     */
+    public int getDimensions() {
+        int i = 1;
+        while (buf[off + i] == '[') {
+            ++i;
+        }
+        return i;
+    }
+
+    /**
+     * Returns the type of the elements of this array type. This method should
+     * only be used for an array type.
+     *
+     * @return Returns the type of the elements of this array type.
+     */
+    public Type getElementType() {
+        return getType(buf, off + getDimensions());
+    }
+
+    /**
+     * Returns the name of the class corresponding to this type.
+     *
+     * @return the fully qualified name of the class corresponding to this type.
+     */
+    public String getClassName() {
+        switch (sort) {
+            case VOID:
+                return "void";
+            case BOOLEAN:
+                return "boolean";
+            case CHAR:
+                return "char";
+            case BYTE:
+                return "byte";
+            case SHORT:
+                return "short";
+            case INT:
+                return "int";
+            case FLOAT:
+                return "float";
+            case LONG:
+                return "long";
+            case DOUBLE:
+                return "double";
+            case ARRAY:
+                StringBuffer b = new StringBuffer(getElementType().getClassName());
+                for (int i = getDimensions(); i > 0; --i) {
+                    b.append("[]");
+                }
+                return b.toString();
+                // case OBJECT:
+            default:
+                return new String(buf, off, len).replace('/', '.');
+        }
+    }
+
+    /**
+     * Returns the internal name of the class corresponding to this object or
+     * array type. The internal name of a class is its fully qualified name (as
+     * returned by Class.getName(), where '.' are replaced by '/'. This method
+     * should only be used for an object or array type.
+     *
+     * @return the internal name of the class corresponding to this object type.
+     */
+    public String getInternalName() {
+        return new String(buf, off, len);
+    }
+
+    // ------------------------------------------------------------------------
+    // Conversion to type descriptors
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns the descriptor corresponding to this Java type.
+     *
+     * @return the descriptor corresponding to this Java type.
+     */
+    public String getDescriptor() {
+        StringBuffer buf = new StringBuffer();
+        getDescriptor(buf);
+        return buf.toString();
+    }
+
+    /**
+     * Returns the descriptor corresponding to the given argument and return
+     * types.
+     *
+     * @param returnType the return type of the method.
+     * @param argumentTypes the argument types of the method.
+     * @return the descriptor corresponding to the given argument and return
+     *         types.
+     */
+    public static String getMethodDescriptor(
+        final Type returnType,
+        final Type[] argumentTypes)
+    {
+        StringBuffer buf = new StringBuffer();
+        buf.append('(');
+        for (int i = 0; i < argumentTypes.length; ++i) {
+            argumentTypes[i].getDescriptor(buf);
+        }
+        buf.append(')');
+        returnType.getDescriptor(buf);
+        return buf.toString();
+    }
+
+    /**
+     * Appends the descriptor corresponding to this Java type to the given
+     * string buffer.
+     *
+     * @param buf the string buffer to which the descriptor must be appended.
+     */
+    private void getDescriptor(final StringBuffer buf) {
+        switch (sort) {
+            case VOID:
+                buf.append('V');
+                return;
+            case BOOLEAN:
+                buf.append('Z');
+                return;
+            case CHAR:
+                buf.append('C');
+                return;
+            case BYTE:
+                buf.append('B');
+                return;
+            case SHORT:
+                buf.append('S');
+                return;
+            case INT:
+                buf.append('I');
+                return;
+            case FLOAT:
+                buf.append('F');
+                return;
+            case LONG:
+                buf.append('J');
+                return;
+            case DOUBLE:
+                buf.append('D');
+                return;
+            case ARRAY:
+                buf.append(this.buf, off, len);
+                return;
+                // case OBJECT:
+            default:
+                buf.append('L');
+                buf.append(this.buf, off, len);
+                buf.append(';');
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    // Direct conversion from classes to type descriptors,
+    // without intermediate Type objects
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns the internal name of the given class. The internal name of a
+     * class is its fully qualified name, as returned by Class.getName(), where
+     * '.' are replaced by '/'.
+     *
+     * @param c an object or array class.
+     * @return the internal name of the given class.
+     */
+    public static String getInternalName(final Class c) {
+        return c.getName().replace('.', '/');
+    }
+
+    /**
+     * Returns the descriptor corresponding to the given Java type.
+     *
+     * @param c an object class, a primitive class or an array class.
+     * @return the descriptor corresponding to the given class.
+     */
+    public static String getDescriptor(final Class c) {
+        StringBuffer buf = new StringBuffer();
+        getDescriptor(buf, c);
+        return buf.toString();
+    }
+
+    /**
+     * Returns the descriptor corresponding to the given constructor.
+     *
+     * @param c a {@link Constructor Constructor} object.
+     * @return the descriptor of the given constructor.
+     */
+    public static String getConstructorDescriptor(final Constructor c) {
+        Class[] parameters = c.getParameterTypes();
+        StringBuffer buf = new StringBuffer();
+        buf.append('(');
+        for (int i = 0; i < parameters.length; ++i) {
+            getDescriptor(buf, parameters[i]);
+        }
+        return buf.append(")V").toString();
+    }
+
+    /**
+     * Returns the descriptor corresponding to the given method.
+     *
+     * @param m a {@link Method Method} object.
+     * @return the descriptor of the given method.
+     */
+    public static String getMethodDescriptor(final Method m) {
+        Class[] parameters = m.getParameterTypes();
+        StringBuffer buf = new StringBuffer();
+        buf.append('(');
+        for (int i = 0; i < parameters.length; ++i) {
+            getDescriptor(buf, parameters[i]);
+        }
+        buf.append(')');
+        getDescriptor(buf, m.getReturnType());
+        return buf.toString();
+    }
+
+    /**
+     * Appends the descriptor of the given class to the given string buffer.
+     *
+     * @param buf the string buffer to which the descriptor must be appended.
+     * @param c the class whose descriptor must be computed.
+     */
+    private static void getDescriptor(final StringBuffer buf, final Class c) {
+        Class d = c;
+        while (true) {
+            if (d.isPrimitive()) {
+                char car;
+                if (d == Integer.TYPE) {
+                    car = 'I';
+                } else if (d == Void.TYPE) {
+                    car = 'V';
+                } else if (d == Boolean.TYPE) {
+                    car = 'Z';
+                } else if (d == Byte.TYPE) {
+                    car = 'B';
+                } else if (d == Character.TYPE) {
+                    car = 'C';
+                } else if (d == Short.TYPE) {
+                    car = 'S';
+                } else if (d == Double.TYPE) {
+                    car = 'D';
+                } else if (d == Float.TYPE) {
+                    car = 'F';
+                } else /* if (d == Long.TYPE) */{
+                    car = 'J';
+                }
+                buf.append(car);
+                return;
+            } else if (d.isArray()) {
+                buf.append('[');
+                d = d.getComponentType();
+            } else {
+                buf.append('L');
+                String name = d.getName();
+                int len = name.length();
+                for (int i = 0; i < len; ++i) {
+                    char car = name.charAt(i);
+                    buf.append(car == '.' ? '/' : car);
+                }
+                buf.append(';');
+                return;
+            }
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    // Corresponding size and opcodes
+    // ------------------------------------------------------------------------
+
+    /**
+     * Returns the size of values of this type.
+     *
+     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and
+     *         <tt>double</tt>, and 1 otherwise.
+     */
+    public int getSize() {
+        return sort == LONG || sort == DOUBLE ? 2 : 1;
+    }
+
+    /**
+     * Returns a JVM instruction opcode adapted to this Java type.
+     *
+     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,
+     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,
+     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.
+     * @return an opcode that is similar to the given opcode, but adapted to
+     *         this Java type. For example, if this type is <tt>float</tt> and
+     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.
+     */
+    public int getOpcode(final int opcode) {
+        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {
+            switch (sort) {
+                case BOOLEAN:
+                case BYTE:
+                    return opcode + 5;
+                case CHAR:
+                    return opcode + 6;
+                case SHORT:
+                    return opcode + 7;
+                case INT:
+                    return opcode;
+                case FLOAT:
+                    return opcode + 2;
+                case LONG:
+                    return opcode + 1;
+                case DOUBLE:
+                    return opcode + 3;
+                    // case ARRAY:
+                    // case OBJECT:
+                default:
+                    return opcode + 4;
+            }
+        } else {
+            switch (sort) {
+                case VOID:
+                    return opcode + 5;
+                case BOOLEAN:
+                case CHAR:
+                case BYTE:
+                case SHORT:
+                case INT:
+                    return opcode;
+                case FLOAT:
+                    return opcode + 2;
+                case LONG:
+                    return opcode + 1;
+                case DOUBLE:
+                    return opcode + 3;
+                    // case ARRAY:
+                    // case OBJECT:
+                default:
+                    return opcode + 4;
+            }
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    // Equals, hashCode and toString
+    // ------------------------------------------------------------------------
+
+    /**
+     * Tests if the given object is equal to this type.
+     *
+     * @param o the object to be compared to this type.
+     * @return <tt>true</tt> if the given object is equal to this type.
+     */
+    public boolean equals(final Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (!(o instanceof Type)) {
+            return false;
+        }
+        Type t = (Type) o;
+        if (sort != t.sort) {
+            return false;
+        }
+        if (sort == OBJECT || sort == ARRAY) {
+            if (len != t.len) {
+                return false;
+            }
+            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {
+                if (buf[i] != t.buf[j]) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Returns a hash code value for this type.
+     *
+     * @return a hash code value for this type.
+     */
+    public int hashCode() {
+        int hc = 13 * sort;
+        if (sort == OBJECT || sort == ARRAY) {
+            for (int i = off, end = i + len; i < end; i++) {
+                hc = 17 * (hc + buf[i]);
+            }
+        }
+        return hc;
+    }
+
+    /**
+     * Returns a string representation of this type.
+     *
+     * @return the descriptor of this type.
+     */
+    public String toString() {
+        return getDescriptor();
+    }
+}
--- /dev/null	Tue Aug  4 10:20:10 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/protocol/soap/MessageCreationException.java	Tue Aug  4 10:20:10 2009
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.protocol.soap;
+
+import com.sun.xml.internal.ws.api.SOAPVersion;
+import com.sun.xml.internal.ws.api.message.ExceptionHasMessage;
+import com.sun.xml.internal.ws.api.message.Message;
+import com.sun.xml.internal.ws.fault.SOAPFaultBuilder;
+
+import javax.xml.namespace.QName;
+
+/**
+ * This is used to represent Message creation exception when a {@link com.sun.xml.internal.ws.api.pipe.Codec}
+ * trying to create a {@link Message}.
+ *
+ * @author Jitendra Kotamraju
+ */
+public class MessageCreationException extends ExceptionHasMessage {
+
+    private final SOAPVersion soapVersion;
+
+    public MessageCreationException(SOAPVersion soapVersion, Object... args) {
+        super("soap.msg.create.err", args);
+        this.soapVersion = soapVersion;
+    }
+
+    public String getDefaultResourceBundleName() {
+        return "com.sun.xml.internal.ws.resources.soap";
+    }
+
+    public Message getFaultMessage() {
+        QName faultCode = soapVersion.faultCodeClient;
+        return SOAPFaultBuilder.createSOAPFaultMessage(
+                soapVersion, getLocalizedMessage(), faultCode);
+    }
+
+}
--- /dev/null	Tue Aug  4 10:20:12 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/DraconianValidationErrorHandler.java	Tue Aug  4 10:20:12 2009
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.server;
+
+import com.sun.xml.internal.ws.developer.ValidationErrorHandler;
+import org.xml.sax.SAXParseException;
+import org.xml.sax.SAXException;
+
+/**
+ * @author Jitendra Kotamraju
+ */
+public class DraconianValidationErrorHandler extends ValidationErrorHandler {
+    public void warning(SAXParseException e) throws SAXException {
+        throw e;
+    }
+
+    public void error(SAXParseException e) throws SAXException {
+        throw e;
+    }
+
+    public void fatalError(SAXParseException e) throws SAXException {
+        ; // noop
+    }
+
+}
--- /dev/null	Tue Aug  4 10:20:14 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/JMXAgent.java	Tue Aug  4 10:20:14 2009
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * JAXWSServerAgent.java
+ *
+ * Created on February 7, 2007, 6:37 PM
+ */
+
+package com.sun.xml.internal.ws.server;
+
+import com.sun.xml.internal.ws.util.RuntimeVersionMBean;
+import com.sun.xml.internal.ws.util.RuntimeVersion;
+import com.sun.xml.internal.ws.transport.http.HttpDump;
+
+import javax.management.ObjectName;
+import javax.management.MBeanServer;
+import java.lang.management.ManagementFactory;
+
+/**
+ *
+ * @author Jitendra Kotamraju
+ */
+public class JMXAgent {
+
+    // Platform MBeanServer used to register your MBeans
+    private final MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+
+    // Singleton instance
+    private static JMXAgent singleton;
+
+    /**
+     * Instantiate and register your MBeans.
+     */
+    public void init() throws Exception {
+
+        RuntimeVersionMBean mbean = new RuntimeVersion();
+        ObjectName mbeanName = new ObjectName("com.sun.xml.internal.ws.util:type=RuntimeVersion");
+        if (!getMBeanServer().isRegistered(mbeanName)) {
+            getMBeanServer().registerMBean(mbean, mbeanName);
+        }
+
+        HttpDump dump = new HttpDump();
+        ObjectName dumpName = new ObjectName("com.sun.xml.internal.ws.transport.http:type=HttpDump");
+        if (!getMBeanServer().isRegistered(dumpName)) {
+            getMBeanServer().registerMBean(dump, dumpName);
+        }
+    }
+
+    /**
+     * Returns an agent singleton.
+     */
+    public synchronized static JMXAgent getDefault() throws Exception {
+        if(singleton == null) {
+            singleton = new JMXAgent();
+            singleton.init();
+        }
+        return singleton;
+    }
+
+    private MBeanServer getMBeanServer() {
+        return mbs;
+    }
+
+}
--- /dev/null	Tue Aug  4 10:20:17 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/ServerSchemaValidationTube.java	Tue Aug  4 10:20:16 2009
@@ -0,0 +1,319 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.server;
+
+import com.sun.istack.internal.Nullable;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.pipe.Tube;
+import com.sun.xml.internal.ws.api.pipe.TubeCloner;
+import com.sun.xml.internal.ws.api.pipe.helper.AbstractTubeImpl;
+import com.sun.xml.internal.ws.api.server.SDDocument;
+import com.sun.xml.internal.ws.api.server.SDDocumentSource;
+import com.sun.xml.internal.ws.api.server.ServiceDefinition;
+import com.sun.xml.internal.ws.api.server.WSEndpoint;
+import com.sun.xml.internal.ws.util.ByteArrayBuffer;
+import com.sun.xml.internal.ws.util.MetadataUtil;
+import com.sun.xml.internal.ws.util.pipe.AbstractSchemaValidationTube;
+import com.sun.xml.internal.ws.util.xml.MetadataDocument;
+import org.w3c.dom.*;
+import org.w3c.dom.ls.LSInput;
+import org.w3c.dom.ls.LSResourceResolver;
+import org.xml.sax.SAXException;
+import org.xml.sax.helpers.NamespaceSupport;
+
+import javax.xml.XMLConstants;
+import javax.xml.namespace.QName;
+import javax.xml.transform.Source;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+import javax.xml.validation.Validator;
+import javax.xml.ws.WebServiceException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.*;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * {@link Tube} that does the schema validation on the server side.
+ *
+ * @author Jitendra Kotamraju
+ */
+public class ServerSchemaValidationTube extends AbstractSchemaValidationTube {
+
+    private static final Logger LOGGER = Logger.getLogger(ServerSchemaValidationTube.class.getName());
+
+    //private final ServiceDefinition docs;
+    private final Schema schema;
+    private final Validator validator;
+
+    private final boolean noValidation;
+
+    public ServerSchemaValidationTube(WSEndpoint endpoint, WSBinding binding, Tube next) {
+        super(binding, next);
+        //docs = endpoint.getServiceDefinition();
+        SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
+        Source[] sources = getSchemaSources(endpoint.getServiceDefinition());
+        for(Source source : sources) {
+            LOGGER.fine("Constructing validation Schema from = "+source.getSystemId());
+            //printDOM((DOMSource)source);
+        }
+        if (sources.length != 0) {
+            noValidation = false;
+            sf.setResourceResolver(new MetadataResolverImpl(endpoint.getServiceDefinition()));
+            try {
+                schema = sf.newSchema(sources);
+            } catch(SAXException e) {
+                throw new WebServiceException(e);
+            }
+            validator = schema.newValidator();
+        } else {
+            noValidation = true;
+            schema = null;
+            validator = null;
+        }
+    }
+
+    /**
+     * Constructs list of schema documents as follows:
+     *   - all <xsd:schema> fragements from all WSDL documents.
+     *   - all schema documents in the application(from WAR etc)
+     *
+     * @return list of root schema documents
+     */
+    private Source[] getSchemaSources(ServiceDefinition sd) {
+        String primary = sd.getPrimary().getURL().toExternalForm();
+        MetadataUtil.MetadataResolver mdresolver = new MetadataResolverImpl(sd);
+        Map<String, SDDocument> docs = MetadataUtil.getMetadataClosure(primary, mdresolver, true);
+
+        List<Source> list = new ArrayList<Source>();
+        for(Map.Entry<String, SDDocument> entry : docs.entrySet()) {
+            SDDocument doc = entry.getValue();
+            // Add all xsd:schema fragments from all WSDLs. That should form a closure of schemas.
+            if (doc.isWSDL()) {
+                Document dom = createDOM(doc);
+                // Get xsd:schema node from WSDL's DOM
+                addSchemaFragmentSource(dom, doc.getURL().toExternalForm(), list);
+            } else if (doc.isSchema()) {
+                // If there are multiple schemas with the same targetnamespace,
+                // JAXP works only with the first one. Above, all schema fragments may have the same targetnamespace,
+                // and that means it will not include all the schemas. Since we have a list of schemas, just add them.
+                Document dom = createDOM(doc);
+                list.add(new DOMSource(dom, doc.getURL().toExternalForm()));
+            }
+        }
+        //addSchemaSource(list);
+        return list.toArray(new Source[list.size()]) ;
+    }
+
+    private class MetadataResolverImpl implements MetadataUtil.MetadataResolver, LSResourceResolver {
+
+        Map<String, SDDocument> docs = new HashMap<String, SDDocument>();
+
+        MetadataResolverImpl(ServiceDefinition sd) {
+            for(SDDocument doc : sd) {
+                SDDocument sdi = doc;
+                docs.put(sdi.getURL().toExternalForm(), sdi);
+            }
+        }
+
+        public SDDocument resolveEntity(String systemId) {
+            SDDocument sdi = docs.get(systemId);
+            if (sdi == null) {
+                SDDocumentSource sds;
+                try {
+                    sds = SDDocumentSource.create(new URL(systemId));
+                } catch(MalformedURLException e) {
+                    throw new WebServiceException(e);
+                }
+                sdi = MetadataDocument.create(sds, new QName(""), new QName(""));
+                docs.put(systemId, sdi);
+            }
+            return sdi;
+        }
+
+        public LSInput resolveResource(String type, String namespaceURI, String publicId, final String systemId, final String baseURI) {
+            LOGGER.fine("type="+type+ " namespaceURI="+namespaceURI+" publicId="+publicId+" systemId="+systemId+" baseURI="+baseURI);
+            try {
+                URL base = baseURI == null ? null : new URL(baseURI);
+                final URL rel = new URL(base, systemId);
+                final SDDocument doc = docs.get(rel.toExternalForm());
+                if (doc != null) {
+                    return new LSInput() {
+
+                        public Reader getCharacterStream() {
+                            return null;
+                        }
+
+                        public void setCharacterStream(Reader characterStream) {
+                            throw new UnsupportedOperationException();
+                        }
+
+                        public InputStream getByteStream() {
+                            ByteArrayBuffer bab = new ByteArrayBuffer();
+                            try {
+                                doc.writeTo(null, resolver, bab);
+                            } catch (IOException ioe) {
+                                throw new WebServiceException(ioe);
+                            }
+                            return bab.newInputStream();
+                        }
+
+                        public void setByteStream(InputStream byteStream) {
+                            throw new UnsupportedOperationException();
+                        }
+
+                        public String getStringData() {
+                            return null;
+                        }
+
+                        public void setStringData(String stringData) {
+                            throw new UnsupportedOperationException();
+                        }
+
+                        public String getSystemId() {
+                            return rel.toExternalForm();
+                        }
+
+                        public void setSystemId(String systemId) {
+                            throw new UnsupportedOperationException();
+                        }
+
+                        public String getPublicId() {
+                            return null;
+                        }
+
+                        public void setPublicId(String publicId) {
+                            throw new UnsupportedOperationException();
+                        }
+
+                        public String getBaseURI() {
+                            return rel.toExternalForm();
+                        }
+
+                        public void setBaseURI(String baseURI) {
+                            throw new UnsupportedOperationException();
+                        }
+
+                        public String getEncoding() {
+                            return null;
+                        }
+
+                        public void setEncoding(String encoding) {
+                            throw new UnsupportedOperationException();
+                        }
+
+                        public boolean getCertifiedText() {
+                            return false;
+                        }
+
+                        public void setCertifiedText(boolean certifiedText) {
+                            throw new UnsupportedOperationException();
+                        }
+                    };
+                }
+            } catch(Exception e) {
+                LOGGER.log(Level.WARNING, "Exception in LSResourceResolver impl", e);
+            }
+            LOGGER.fine("Don't know about systemId="+systemId+" baseURI="+baseURI);
+            return null;
+        }
+
+    }
+
+
+    protected Validator getValidator() {
+        return validator;
+    }
+
+    protected boolean isNoValidation() {
+        return noValidation;
+    }
+
+    /**
+     * Recursively visit ancestors and build up {@link org.xml.sax.helpers.NamespaceSupport} oject.
+     */
+    private void buildNamespaceSupport(NamespaceSupport nss, Node node) {
+        if(node==null || node.getNodeType()!=Node.ELEMENT_NODE)
+            return;
+
+        buildNamespaceSupport( nss, node.getParentNode() );
+
+        nss.pushContext();
+        NamedNodeMap atts = node.getAttributes();
+        for( int i=0; i<atts.getLength(); i++ ) {
+            Attr a = (Attr)atts.item(i);
+            if( "xmlns".equals(a.getPrefix()) ) {
+                nss.declarePrefix( a.getLocalName(), a.getValue() );
+                continue;
+            }
+            if( "xmlns".equals(a.getName()) ) {
+                nss.declarePrefix( "", a.getValue() );
+                continue;
+            }
+        }
+    }
+
+    /**
+     * Adds inscope namespaces as attributes to  <xsd:schema> fragment nodes.
+     *
+     * @param nss namespace context info
+     * @param elem that is patched with inscope namespaces
+     */
+    private @Nullable void patchDOMFragment(NamespaceSupport nss, Element elem) {
+        NamedNodeMap atts = elem.getAttributes();
+        for( Enumeration en = nss.getPrefixes(); en.hasMoreElements(); ) {
+            String prefix = (String)en.nextElement();
+
+            for( int i=0; i<atts.getLength(); i++ ) {
+                Attr a = (Attr)atts.item(i);
+                if (!"xmlns".equals(a.getPrefix()) || !a.getLocalName().equals("prefix")) {
+                    LOGGER.fine("Patching with xmlns:"+prefix+"="+nss.getURI(prefix));
+                    elem.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, "xmlns:"+prefix, nss.getURI(prefix));
+                }
+            }
+        }
+    }
+
+
+
+
+    protected ServerSchemaValidationTube(ServerSchemaValidationTube that, TubeCloner cloner) {
+        super(that,cloner);
+        //this.docs = that.docs;
+        this.schema = that.schema;
+        this.validator = schema.newValidator();
+        this.noValidation = that.noValidation;
+    }
+
+    public AbstractTubeImpl copy(TubeCloner cloner) {
+        return new ServerSchemaValidationTube(this,cloner);
+    }
+
+}
--- /dev/null	Tue Aug  4 10:20:19 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/server/sei/SOAPActionBasedDispatcher.java	Tue Aug  4 10:20:18 2009
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.server.sei;
+
+import com.sun.istack.internal.Nullable;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.model.AbstractSEIModelImpl;
+import com.sun.xml.internal.ws.model.JavaMethodImpl;
+
+import javax.xml.namespace.QName;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * An {@link EndpointMethodDispatcher} that uses SOAPAction as the key for dispatching.
+ * <p/>
+ * A map of all SOAPAction on the port and the corresponding {@link EndpointMethodHandler}
+ * is initialized in the constructor. The SOAPAction from the
+ * request {@link Packet} is used as the key to return the correct handler.
+ *
+ * @author Jitendra Kotamraju
+ */
+final class SOAPActionBasedDispatcher implements EndpointMethodDispatcher {
+    private final Map<String, EndpointMethodHandler> methodHandlers;
+
+    public SOAPActionBasedDispatcher(AbstractSEIModelImpl model, WSBinding binding, SEIInvokerTube invokerTube) {
+        // Find if any SOAPAction repeat for operations
+        Map<String, Integer> unique = new HashMap<String, Integer>();
+        for(JavaMethodImpl m : model.getJavaMethods()) {
+            String soapAction = m.getOperation().getSOAPAction();
+            Integer count = unique.get(soapAction);
+            if (count == null) {
+                unique.put(soapAction, 1);
+            } else {
+                unique.put(soapAction, ++count);
+            }
+        }
+        methodHandlers = new HashMap<String, EndpointMethodHandler>();
+        for( JavaMethodImpl m : model.getJavaMethods() ) {
+            String soapAction = m.getOperation().getSOAPAction();
+            // Set up method handlers only for unique SOAPAction values so
+            // that dispatching happens consistently for a method
+            if (unique.get(soapAction) == 1) {
+                methodHandlers.put('"'+soapAction+'"', new EndpointMethodHandler(invokerTube,m,binding));
+            }
+        }
+    }
+
+    public @Nullable EndpointMethodHandler getEndpointMethodHandler(Packet request) {
+        return request.soapAction == null ? null : methodHandlers.get(request.soapAction);
+    }
+
+}
--- /dev/null	Tue Aug  4 10:20:21 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/streaming/MtomStreamWriter.java	Tue Aug  4 10:20:20 2009
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.streaming;
+
+import com.sun.xml.internal.ws.message.jaxb.JAXBMessage;
+import com.sun.xml.internal.ws.encoding.MtomCodec;
+
+import javax.xml.bind.attachment.AttachmentMarshaller;
+import javax.xml.stream.XMLStreamWriter;
+
+/**
+ * A {@link XMLStreamWriter} that used for MTOM encoding may provide its own
+ * {@link AttachmentMarshaller}. The marshaller could do processing based on
+ * MTOM threshold, and make decisions about inlining the attachment data or not.
+ *
+ * @author Jitendra Kotamraju
+ * @see JAXBMessage
+ * @see MtomCodec
+ */
+public interface MtomStreamWriter {
+    AttachmentMarshaller getAttachmentMarshaller();
+}
--- /dev/null	Tue Aug  4 10:20:23 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/HttpDump.java	Tue Aug  4 10:20:22 2009
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.transport.http;
+
+/**
+ * @author Jitendra Kotamraju
+ *
+ */
+public class HttpDump implements HttpDumpMBean {
+    public void setDump(boolean dump) {
+        HttpAdapter.dump = dump;
+    }
+
+    public boolean getDump() {
+        return HttpAdapter.dump;
+    }
+}
--- /dev/null	Tue Aug  4 10:20:25 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/HttpDumpMBean.java	Tue Aug  4 10:20:24 2009
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.transport.http;
+
+/**
+ * @author Jitendra Kotamraju
+ */
+public interface HttpDumpMBean {
+
+    public void setDump(boolean dump);
+
+    public boolean getDump();
+
+}
--- /dev/null	Tue Aug  4 10:20:27 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/transport/http/HttpMetadataPublisher.java	Tue Aug  4 10:20:26 2009
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.transport.http;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.xml.internal.ws.api.server.EndpointComponent;
+import com.sun.xml.internal.ws.api.server.WSEndpoint;
+
+import java.io.IOException;
+
+/**
+ * Intercepts GET HTTP requests to process the requests.
+ *
+ * <p>
+ * {@link HttpAdapter} looks for this SPI in {@link WSEndpoint#getComponentRegistry()}
+ * to allow components to expose additional information through HTTP.
+ *
+ * @author Kohsuke Kawaguchi
+ * @see EndpointComponent#getSPI(Class)
+ * @since 2.1.2
+ */
+public abstract class HttpMetadataPublisher {
+    /**
+     * When {@link HttpAdapter} receives a GET request with a query string
+     * (which is a convention for metadata requests, such as '?wsdl' or '?xsd=...'),
+     * then this method is invoked to allow components to intercept the request.
+     *
+     * @param adapter
+     *      Adapter that accepted the connection.
+     * @param connection
+     *      Represents the current connection.
+     * @return
+     *      true if the request is processed. If false is returned the default processing kicks in.
+     */
+    public abstract boolean handleMetadataRequest(@NotNull HttpAdapter adapter, @NotNull WSHTTPConnection connection) throws IOException;
+}
--- /dev/null	Tue Aug  4 10:20:29 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/MetadataUtil.java	Tue Aug  4 10:20:28 2009
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.util;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.xml.internal.ws.api.server.SDDocument;
+import com.sun.xml.internal.ws.server.SDDocumentImpl;
+import org.xml.sax.EntityResolver;
+
+import java.util.*;
+
+/**
+ * WSDL, schema document metadata utility class.
+ *
+ * @author Jitendra Kotamraju
+ */
+public class MetadataUtil {
+
+    /**
+     * Gets closure of all the referenced documents from the primary document(typically
+     * the service WSDL). It traverses the WSDL and schema imports and builds a closure
+     * set of documents.
+     *
+     * @param systemId primary wsdl or the any root document
+     * @param resolver used to get SDDocumentImpl for a document
+     * @param onlyTopLevelSchemas if true, the imported schemas from a schema would be ignored
+     * @return all the documents
+     */
+    public static Map<String, SDDocument> getMetadataClosure(@NotNull String systemId,
+            @NotNull MetadataResolver resolver, boolean onlyTopLevelSchemas) {
+        Map <String, SDDocument> closureDocs = new HashMap<String, SDDocument>();
+        Set<String> remaining = new HashSet<String>();
+        remaining.add(systemId);
+
+        while(!remaining.isEmpty()) {
+            Iterator<String> it = remaining.iterator();
+            String current = it.next();
+            remaining.remove(current);
+
+            SDDocument currentDoc = resolver.resolveEntity(current);
+            SDDocument old = closureDocs.put(currentDoc.getURL().toExternalForm(), currentDoc);
+            assert old == null;
+
+            Set<String> imports =  currentDoc.getImports();
+            if (!currentDoc.isSchema() || !onlyTopLevelSchemas) {
+                for(String importedDoc : imports) {
+                    if (closureDocs.get(importedDoc) == null) {
+                        remaining.add(importedDoc);
+                    }
+                }
+            }
+        }
+
+        return closureDocs;
+    }
+
+    public interface MetadataResolver {
+        /**
+         * returns {@link SDDocumentImpl} for the give systemId. It
+         * parses the document and categorises as WSDL, schema etc.
+         * The implementation could use a catlog resolver or an entity
+         * resolver {@link EntityResolver} before parsing.
+         *
+         * @param systemId document's systemId
+         * @return document for the systemId
+         */
+        @NotNull SDDocument resolveEntity(String systemId);
+    }
+
+}
--- /dev/null	Tue Aug  4 10:20:31 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/RuntimeVersionMBean.java	Tue Aug  4 10:20:30 2009
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+
+
+package com.sun.xml.internal.ws.util;
+
+import javax.management.*;
+import com.sun.xml.internal.ws.util.RuntimeVersion;
+
+/**
+ * @author Jitendra Kotamraju
+ */
+public interface RuntimeVersionMBean {
+
+    /**
+     * Get JAX-WS runtime version
+     */
+    public String getVersion();
+
+}
--- /dev/null	Tue Aug  4 10:20:33 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/pipe/AbstractSchemaValidationTube.java	Tue Aug  4 10:20:32 2009
@@ -0,0 +1,261 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.util.pipe;
+
+import com.sun.istack.internal.NotNull;
+import com.sun.istack.internal.Nullable;
+import com.sun.xml.internal.ws.api.WSBinding;
+import com.sun.xml.internal.ws.api.message.Message;
+import com.sun.xml.internal.ws.api.message.Packet;
+import com.sun.xml.internal.ws.api.pipe.NextAction;
+import com.sun.xml.internal.ws.api.pipe.Tube;
+import com.sun.xml.internal.ws.api.pipe.TubeCloner;
+import com.sun.xml.internal.ws.api.pipe.helper.AbstractFilterTubeImpl;
+import com.sun.xml.internal.ws.api.server.DocumentAddressResolver;
+import com.sun.xml.internal.ws.api.server.SDDocument;
+import com.sun.xml.internal.ws.developer.SchemaValidationFeature;
+import com.sun.xml.internal.ws.developer.ValidationErrorHandler;
+import com.sun.xml.internal.ws.util.ByteArrayBuffer;
+import com.sun.xml.internal.ws.util.xml.XmlUtil;
+import com.sun.xml.internal.ws.wsdl.parser.WSDLConstants;
+import org.w3c.dom.*;
+import org.xml.sax.helpers.NamespaceSupport;
+
+import javax.xml.XMLConstants;
+import javax.xml.transform.Source;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMResult;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.validation.Validator;
+import javax.xml.ws.WebServiceException;
+import java.io.IOException;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.logging.Logger;
+
+/**
+ * {@link Tube} that does the schema validation.
+ *
+ * @author Jitendra Kotamraju
+ */
+public abstract class AbstractSchemaValidationTube extends AbstractFilterTubeImpl {
+
+    private static final Logger LOGGER = Logger.getLogger(AbstractSchemaValidationTube.class.getName());
+
+    protected final WSBinding binding;
+    protected final SchemaValidationFeature feature;
+    protected final DocumentAddressResolver resolver = new ValidationDocumentAddressResolver();
+
+    public AbstractSchemaValidationTube(WSBinding binding, Tube next) {
+        super(next);
+        this.binding = binding;
+        feature = binding.getFeature(SchemaValidationFeature.class);
+    }
+
+    protected AbstractSchemaValidationTube(AbstractSchemaValidationTube that, TubeCloner cloner) {
+        super(that, cloner);
+        this.binding = that.binding;
+        this.feature = that.feature;
+    }
+
+    protected abstract Validator getValidator();
+
+    protected abstract boolean isNoValidation();
+
+    private static class ValidationDocumentAddressResolver implements DocumentAddressResolver {
+
+        @Nullable
+        public String getRelativeAddressFor(@NotNull SDDocument current, @NotNull SDDocument referenced) {
+            LOGGER.fine("Current = "+current.getURL()+" resolved relative="+referenced.getURL());
+            return referenced.getURL().toExternalForm();
+        }
+    }
+
+    protected Document createDOM(SDDocument doc) {
+        // Get infoset
+        ByteArrayBuffer bab = new ByteArrayBuffer();
+        try {
+            doc.writeTo(null, resolver, bab);
+        } catch (IOException ioe) {
+            throw new WebServiceException(ioe);
+        }
+
+        // Convert infoset to DOM
+        Transformer trans = XmlUtil.newTransformer();
+        Source source = new StreamSource(bab.newInputStream(), null); //doc.getURL().toExternalForm());
+        DOMResult result = new DOMResult();
+        try {
+            trans.transform(source, result);
+        } catch(TransformerException te) {
+            throw new WebServiceException(te);
+        }
+        return (Document)result.getNode();
+    }
+
+
+    /**
+     * Locates xsd:schema elements in the WSDL and creates DOMSource and adds them to the list
+     *
+     * @param doc WSDL document
+     * @param systemId systemId for WSDL document
+     * @param list xsd:schema DOMSource list
+     */
+    protected @Nullable void addSchemaFragmentSource(Document doc, String systemId, List<Source> list) {
+
+        Element e = doc.getDocumentElement();
+        assert e.getNamespaceURI().equals(WSDLConstants.NS_WSDL);
+        assert e.getLocalName().equals("definitions");
+
+        NodeList typesList = e.getElementsByTagNameNS(WSDLConstants.NS_WSDL, "types");
+        for(int i=0; i < typesList.getLength(); i++) {
+            NodeList schemaList = ((Element)typesList.item(i)).getElementsByTagNameNS(WSDLConstants.NS_XMLNS, "schema");
+            for(int j=0; j < schemaList.getLength(); j++) {
+                Element elem = (Element)schemaList.item(j);
+                NamespaceSupport nss = new NamespaceSupport();
+                buildNamespaceSupport(nss, elem);
+                patchDOMFragment(nss, elem);
+                list.add(new DOMSource(elem, systemId+"#schema"+j));
+            }
+        }
+    }
+
+
+    /**
+     * Recursively visit ancestors and build up {@link org.xml.sax.helpers.NamespaceSupport} oject.
+     */
+    private void buildNamespaceSupport(NamespaceSupport nss, Node node) {
+        if(node==null || node.getNodeType()!=Node.ELEMENT_NODE)
+            return;
+
+        buildNamespaceSupport( nss, node.getParentNode() );
+
+        nss.pushContext();
+        NamedNodeMap atts = node.getAttributes();
+        for( int i=0; i<atts.getLength(); i++ ) {
+            Attr a = (Attr)atts.item(i);
+            if( "xmlns".equals(a.getPrefix()) ) {
+                nss.declarePrefix( a.getLocalName(), a.getValue() );
+                continue;
+            }
+            if( "xmlns".equals(a.getName()) ) {
+                nss.declarePrefix( "", a.getValue() );
+                continue;
+            }
+        }
+    }
+
+    /**
+     * Adds inscope namespaces as attributes to  <xsd:schema> fragment nodes.
+     *
+     * @param nss namespace context info
+     * @param elem that is patched with inscope namespaces
+     */
+    private @Nullable void patchDOMFragment(NamespaceSupport nss, Element elem) {
+        NamedNodeMap atts = elem.getAttributes();
+        for( Enumeration en = nss.getPrefixes(); en.hasMoreElements(); ) {
+            String prefix = (String)en.nextElement();
+
+            for( int i=0; i<atts.getLength(); i++ ) {
+                Attr a = (Attr)atts.item(i);
+                if (!"xmlns".equals(a.getPrefix()) || !a.getLocalName().equals("prefix")) {
+                    LOGGER.fine("Patching with xmlns:"+prefix+"="+nss.getURI(prefix));
+                    elem.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, "xmlns:"+prefix, nss.getURI(prefix));
+                }
+            }
+        }
+    }
+
+    @Override
+    public NextAction processRequest(Packet request) {
+        if (isNoValidation() || !request.getMessage().hasPayload() || request.getMessage().isFault()) {
+            return super.processRequest(request);
+        }
+        doProcess(request);
+        return super.processRequest(request);
+    }
+
+    @Override
+    public NextAction processResponse(Packet response) {
+        if (isNoValidation() || response.getMessage() == null || !response.getMessage().hasPayload() || response.getMessage().isFault()) {
+            return super.processResponse(response);
+        }
+        doProcess(response);
+        return super.processResponse(response);
+    }
+
+    private void doProcess(Packet packet) {
+        getValidator().reset();
+        Class<? extends ValidationErrorHandler> handlerClass = feature.getErrorHandler();
+        ValidationErrorHandler handler;
+        try {
+            handler = handlerClass.newInstance();
+        } catch(Exception e) {
+            throw new WebServiceException(e);
+        }
+        handler.setPacket(packet);
+        getValidator().setErrorHandler(handler);
+        Message msg = packet.getMessage().copy();
+        Source source = msg.readPayloadAsSource();
+        try {
+            // Validator javadoc allows ONLY SAX, and DOM Sources
+            // But the impl seems to handle all kinds.
+            getValidator().validate(source);
+        } catch(Exception e) {
+            throw new WebServiceException(e);
+        }
+    }
+
+    protected DOMSource toDOMSource(Source source) {
+        if (source instanceof DOMSource) {
+            return (DOMSource)source;
+        }
+        Transformer trans = XmlUtil.newTransformer();
+        DOMResult result = new DOMResult();
+        try {
+            trans.transform(source, result);
+        } catch(TransformerException te) {
+            throw new WebServiceException(te);
+        }
+        return new DOMSource(result.getNode());
+    }
+
+    protected static void printDOM(DOMSource src) {
+        try {
+            ByteArrayBuffer bos = new ByteArrayBuffer();
+            StreamResult sr = new StreamResult(bos );
+            Transformer trans = TransformerFactory.newInstance().newTransformer();
+            trans.transform(src, sr);
+            LOGGER.info("**** src ******"+bos.toString());
+            bos.close();
+        } catch(Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+}
--- /dev/null	Tue Aug  4 10:20:35 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/util/xml/MetadataDocument.java	Tue Aug  4 10:20:34 2009
@@ -0,0 +1,317 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package com.sun.xml.internal.ws.util.xml;
+
+import com.sun.xml.internal.ws.api.server.*;
+import com.sun.xml.internal.ws.api.streaming.XMLStreamWriterFactory;
+import com.sun.xml.internal.ws.streaming.XMLStreamReaderUtil;
+import com.sun.xml.internal.ws.util.RuntimeVersion;
+import com.sun.xml.internal.ws.wsdl.parser.ParserUtil;
+import com.sun.xml.internal.ws.wsdl.parser.WSDLConstants;
+import com.sun.xml.internal.ws.server.ServerRtException;
+
+import javax.xml.namespace.QName;
+import javax.xml.stream.*;
+import javax.xml.ws.WebServiceException;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * {@link com.sun.xml.internal.ws.api.server.SDDocument} implmentation.
+ *
+ * <p>
+ * This extends from {@link com.sun.xml.internal.ws.api.server.SDDocumentSource} so that
+ * JAX-WS server runtime code can use {@link com.sun.xml.internal.ws.api.server.SDDocument}
+ * as {@link com.sun.xml.internal.ws.api.server.SDDocumentSource}.
+ *
+ * @author Kohsuke Kawaguchi
+ * @author Jitendra Kotamraju
+ */
+public class MetadataDocument extends SDDocumentSource implements SDDocument {
+
+    private static final String NS_XSD = "http://www.w3.org/2001/XMLSchema";
+    private static final QName SCHEMA_INCLUDE_QNAME = new QName(NS_XSD, "include");
+    private static final QName SCHEMA_IMPORT_QNAME = new QName(NS_XSD, "import");
+    private static final QName SCHEMA_REDEFINE_QNAME = new QName(NS_XSD, "redefine");
+    private static final String VERSION_COMMENT =
+        " Published by JAX-WS RI at http://jax-ws.dev.java.net. RI's version is "+RuntimeVersion.VERSION+". ";
+
+    /**
+     * Creates {@link com.sun.xml.internal.ws.api.server.SDDocument} from {@link com.sun.xml.internal.ws.api.server.SDDocumentSource}.
+     * @param src WSDL document infoset
+     * @param serviceName wsdl:service name
+     * @param portTypeName
+     *      The information about the port of {@link com.sun.xml.internal.ws.api.server.WSEndpoint} to which this document is built for.
+     *      These values are used to determine which document is the concrete and abstract WSDLs
+     *      for this endpoint.
+     *
+     * @return null
+     *      Always non-null.
+     */
+    public static SDDocument create(SDDocumentSource src, QName serviceName, QName portTypeName) {
+        URL systemId = src.getSystemId();
+
+        try {
+            // RuntimeWSDLParser parser = new RuntimeWSDLParser(null);
+            XMLStreamReader reader = src.read();
+            try {
+                XMLStreamReaderUtil.nextElementContent(reader);
+
+                QName rootName = reader.getName();
+                if(rootName.equals(WSDLConstants.QNAME_SCHEMA)) {
+                    String tns = ParserUtil.getMandatoryNonEmptyAttribute(reader, WSDLConstants.ATTR_TNS);
+                    Set<String> importedDocs = new HashSet<String>();
+                    while (XMLStreamReaderUtil.nextContent(reader) != XMLStreamConstants.END_DOCUMENT) {
+                         if (reader.getEventType() != XMLStreamConstants.START_ELEMENT)
+                            continue;
+                        QName name = reader.getName();
+                        if (SCHEMA_INCLUDE_QNAME.equals(name) || SCHEMA_IMPORT_QNAME.equals(name) ||
+                                SCHEMA_REDEFINE_QNAME.equals(name)) {
+                            String importedDoc = reader.getAttributeValue(null, "schemaLocation");
+                            if (importedDoc != null) {
+                                importedDocs.add(new URL(src.getSystemId(), importedDoc).toString());
+                            }
+                        }
+                    }
+                    return new SchemaImpl(rootName,systemId,src,tns,importedDocs);
+                } else if (rootName.equals(WSDLConstants.QNAME_DEFINITIONS)) {
+                    String tns = ParserUtil.getMandatoryNonEmptyAttribute(reader, WSDLConstants.ATTR_TNS);
+
+                    boolean hasPortType = false;
+                    boolean hasService = false;
+                    Set<String> importedDocs = new HashSet<String>();
+                    Set<QName> allServices = new HashSet<QName>();
+
+                    // if WSDL, parse more
+                    while (XMLStreamReaderUtil.nextContent(reader) != XMLStreamConstants.END_DOCUMENT) {
+                         if(reader.getEventType() != XMLStreamConstants.START_ELEMENT)
+                            continue;
+
+                        QName name = reader.getName();
+                        if (WSDLConstants.QNAME_PORT_TYPE.equals(name)) {
+                            String pn = ParserUtil.getMandatoryNonEmptyAttribute(reader, WSDLConstants.ATTR_NAME);
+                            if (portTypeName != null) {
+                                if(portTypeName.getLocalPart().equals(pn)&&portTypeName.getNamespaceURI().equals(tns)) {
+                                    hasPortType = true;
+                                }
+                            }
+                        } else if (WSDLConstants.QNAME_SERVICE.equals(name)) {
+                            String sn = ParserUtil.getMandatoryNonEmptyAttribute(reader, WSDLConstants.ATTR_NAME);
+                            QName sqn = new QName(tns,sn);
+                            allServices.add(sqn);
+                            if(serviceName.equals(sqn)) {
+                                hasService = true;
+                            }
+                        } else if (WSDLConstants.QNAME_IMPORT.equals(name)) {
+                            String importedDoc = reader.getAttributeValue(null, "location");
+                            if (importedDoc != null) {
+                                importedDocs.add(new URL(src.getSystemId(), importedDoc).toString());
+                            }
+                        } else if (SCHEMA_INCLUDE_QNAME.equals(name) || SCHEMA_IMPORT_QNAME.equals(name) ||
+                                SCHEMA_REDEFINE_QNAME.equals(name)) {
+                            String importedDoc = reader.getAttributeValue(null, "schemaLocation");
+                            if (importedDoc != null) {
+                                importedDocs.add(new URL(src.getSystemId(), importedDoc).toString());
+                            }
+                        }
+                    }
+                    return new WSDLImpl(
+                        rootName,systemId,src,tns,hasPortType,hasService,importedDocs,allServices);
+                } else {
+                    return new MetadataDocument(rootName,systemId,src);
+                }
+            } finally {
+                reader.close();
+            }
+        } catch (WebServiceException e) {
+            throw new ServerRtException("runtime.parser.wsdl", systemId,e);
+        } catch (IOException e) {
+            throw new ServerRtException("runtime.parser.wsdl", systemId,e);
+        } catch (XMLStreamException e) {
+            throw new ServerRtException("runtime.parser.wsdl", systemId,e);
+        }
+    }
+
+
+    private final QName rootName;
+    private final SDDocumentSource source;
+
+    /**
+     * The original system ID of this document.
+     *
+     * When this document contains relative references to other resources,
+     * this field is used to find which {@link com.sun.xml.internal.ws.server.SDDocumentImpl} it refers to.
+     *
+     * Must not be null.
+     */
+    private final URL url;
+    private final Set<String> imports;
+
+    protected MetadataDocument(QName rootName, URL url, SDDocumentSource source) {
+        this(rootName, url, source, new HashSet<String>());
+    }
+
+    protected MetadataDocument(QName rootName, URL url, SDDocumentSource source, Set<String> imports) {
+        assert url!=null;
+        this.rootName = rootName;
+        this.source = source;
+        this.url = url;
+        this.imports = imports;
+    }
+
+    public QName getRootName() {
+        return rootName;
+    }
+
+    public boolean isWSDL() {
+        return false;
+    }
+
+    public boolean isSchema() {
+        return false;
+    }
+
+    public URL getURL() {
+        return url;
+    }
+
+    public XMLStreamReader read(XMLInputFactory xif) throws IOException, XMLStreamException {
+        return source.read(xif);
+    }
+
+    public XMLStreamReader read() throws IOException, XMLStreamException {
+        return source.read();
+    }
+
+    public URL getSystemId() {
+        return url;
+    }
+
+    public Set<String> getImports() {
+        return imports;
+    }
+
+    public void writeTo(PortAddressResolver portAddressResolver, DocumentAddressResolver resolver, OutputStream os) throws IOException {
+        XMLStreamWriter w = null;
+        try {
+            //generate the WSDL with utf-8 encoding and XML version 1.0
+            w = XMLStreamWriterFactory.create(os, "UTF-8");
+            w.writeStartDocument("UTF-8", "1.0");
+            writeTo(portAddressResolver,resolver,w);
+            w.writeEndDocument();
+        } catch (XMLStreamException e) {
+            IOException ioe = new IOException(e.getMessage());
+            ioe.initCause(e);
+            throw ioe;
+        } finally {
+            try {
+                if (w != null)
+                    w.close();
+            } catch (XMLStreamException e) {
+                IOException ioe = new IOException(e.getMessage());
+                ioe.initCause(e);
+                throw ioe;
+            }
+        }
+    }
+
+    public void writeTo(PortAddressResolver portAddressResolver, DocumentAddressResolver resolver, XMLStreamWriter out) throws XMLStreamException, IOException {
+
+        XMLStreamReader xsr = source.read();
+        try {
+            out.writeComment(VERSION_COMMENT);
+            new XMLStreamReaderToXMLStreamWriter().bridge(xsr, out);
+        } finally {
+            xsr.close();
+        }
+    }
+
+
+    /**
+     * {@link com.sun.xml.internal.ws.api.server.SDDocument.Schema} implementation.
+     *
+     * @author Kohsuke Kawaguchi
+     */
+    private static final class SchemaImpl extends MetadataDocument implements Schema {
+        private final String targetNamespace;
+
+        public SchemaImpl(QName rootName, URL url, SDDocumentSource source, String targetNamespace,
+                          Set<String> imports) {
+            super(rootName, url, source, imports);
+            this.targetNamespace = targetNamespace;
+        }
+
+        public String getTargetNamespace() {
+            return targetNamespace;
+        }
+
+        public boolean isSchema() {
+            return true;
+        }
+    }
+
+
+    private static final class WSDLImpl extends MetadataDocument implements WSDL {
+        private final String targetNamespace;
+        private final boolean hasPortType;
+        private final boolean hasService;
+        private final Set<QName> allServices;
+
+        public WSDLImpl(QName rootName, URL url, SDDocumentSource source, String targetNamespace, boolean hasPortType,
+                        boolean hasService, Set<String> imports, Set<QName> allServices) {
+            super(rootName, url, source, imports);
+            this.targetNamespace = targetNamespace;
+            this.hasPortType = hasPortType;
+            this.hasService = hasService;
+            this.allServices = allServices;
+        }
+
+        public String getTargetNamespace() {
+            return targetNamespace;
+        }
+
+        public boolean hasPortType() {
+            return hasPortType;
+        }
+
+        public boolean hasService() {
+            return hasService;
+        }
+
+        public Set<QName> getAllServices() {
+            return allServices;
+        }
+
+        public boolean isWSDL() {
+            return true;
+        }
+    }
+
+
+}
--- /dev/null	Tue Aug  4 10:20:37 2009
+++ new/src/share/classes/com/sun/xml/internal/ws/wsdl/parser/W3CAddressingMetadataWSDLParserExtension.java	Tue Aug  4 10:20:36 2009
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package com.sun.xml.internal.ws.wsdl.parser;
+
+import com.sun.xml.internal.ws.api.model.wsdl.*;
+import com.sun.xml.internal.ws.model.wsdl.WSDLOperationImpl;
+import com.sun.xml.internal.ws.model.wsdl.WSDLBoundPortTypeImpl;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.namespace.QName;
+
+/**
+ * W3C WS-Addressing Runtime WSDL parser extension that parses
+ * WS-Addressing Metadata wsdl extensibility elements
+ * This mainly reads wsam:Action element on input/output/fault messages in wsdl.
+ *
+ * @author Rama Pulavarthi
+ */
+public class W3CAddressingMetadataWSDLParserExtension extends W3CAddressingWSDLParserExtension {
+
+    String METADATA_WSDL_EXTN_NS = "http://www.w3.org/2007/05/addressing/metadata";
+    QName METADATA_WSDL_ACTION_TAG = new QName(METADATA_WSDL_EXTN_NS, "Action", "wsam");
+
+    @Override
+    public boolean bindingElements(WSDLBoundPortType binding, XMLStreamReader reader) {
+        return false;
+    }
+
+    @Override
+    public boolean portElements(WSDLPort port, XMLStreamReader reader) {
+        return false;
+    }
+
+    @Override
+    public boolean bindingOperationElements(WSDLBoundOperation operation, XMLStreamReader reader) {
+        return false;
+    }
+
+    @Override
+    public boolean portTypeOperationInput(WSDLOperation o, XMLStreamReader reader) {
+        WSDLOperationImpl impl = (WSDLOperationImpl) o;
+
+        String action = ParserUtil.getAttribute(reader, METADATA_WSDL_ACTION_TAG);
+        if (action != null) {
+            impl.getInput().setAction(action);
+            impl.getInput().setDefaultAction(false);
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean portTypeOperationOutput(WSDLOperation o, XMLStreamReader reader) {
+        WSDLOperationImpl impl = (WSDLOperationImpl) o;
+
+        String action = ParserUtil.getAttribute(reader, METADATA_WSDL_ACTION_TAG);
+        if (action != null) {
+            impl.getOutput().setAction(action);
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean portTypeOperationFault(WSDLOperation o, XMLStreamReader reader) {
+        WSDLOperationImpl impl = (WSDLOperationImpl) o;
+
+        String action = ParserUtil.getAttribute(reader, METADATA_WSDL_ACTION_TAG);
+        if (action != null) {
+            String name = ParserUtil.getMandatoryNonEmptyAttribute(reader, "name");
+            impl.getFaultActionMap().put(name, action);
+        }
+
+        return false;
+    }
+
+    @Override
+    protected void patchAnonymousDefault(WSDLBoundPortTypeImpl binding) {
+    }
+
+    @Override
+    protected String getNamespaceURI() {
+        return METADATA_WSDL_EXTN_NS;
+    }
+}
--- old/src/share/classes/com/sun/codemodel/internal/fmt/package.html	Tue Aug  4 10:20:39 2009
+++ /dev/null	Tue Aug  4 10:20:39 2009
@@ -1,29 +0,0 @@
-<!--
- Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
- This code is free software; you can redistribute it and/or modify it
- under the terms of the GNU General Public License version 2 only, as
- published by the Free Software Foundation.  Sun designates this
- particular file as subject to the "Classpath" exception as provided
- by Sun in the LICENSE file that accompanied this code.
-
- This code is distributed in the hope that it will be useful, but WITHOUT
- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- version 2 for more details (a copy is included in the LICENSE file that
- accompanied this code).
-
- You should have received a copy of the GNU General Public License version
- 2 along with this work; if not, write to the Free Software Foundation,
- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
- Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- CA 95054 USA or visit www.sun.com if you need additional information or
- have any questions.
--->
-<HTML>
-<BODY>
-Various resource file formats (classes that implement <code>JResourceFile</code>).
-</BODY>
-</HTML>
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/j2s/Messages.java	Tue Aug  4 10:20:40 2009
+++ /dev/null	Tue Aug  4 10:20:40 2009
@@ -1,46 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package com.sun.tools.internal.xjc.api.impl.j2s;
-
-import java.text.MessageFormat;
-import java.util.ResourceBundle;
-
-/**
- * @author Kohsuke Kawaguchi
- */
-enum Messages {
-    ;
-
-
-    private static final ResourceBundle rb = ResourceBundle.getBundle(Messages.class.getName());
-
-    public String toString() {
-        return format();
-    }
-
-    public String format( Object... args ) {
-        return MessageFormat.format( rb.getString(name()), args );
-    }
-}
--- old/src/share/classes/com/sun/tools/internal/xjc/api/impl/j2s/Messages.properties	Tue Aug  4 10:20:42 2009
+++ /dev/null	Tue Aug  4 10:20:42 2009
@@ -1,26 +0,0 @@
-#
-# Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Sun designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Sun in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
-# CA 95054 USA or visit www.sun.com if you need additional information or
-# have any questions.
-#
-
- 
--- old/src/share/classes/com/sun/xml/internal/fastinfoset/stax/events/StAXEventAllocator.java	Tue Aug  4 10:20:43 2009
+++ /dev/null	Tue Aug  4 10:20:43 2009
@@ -1,237 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
- */
-
-
-
-package com.sun.xml.internal.fastinfoset.stax.events;
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.stream.events.Namespace;
-import javax.xml.stream.events.XMLEvent;
-import javax.xml.stream.util.XMLEventAllocator;
-import javax.xml.stream.util.XMLEventConsumer;
-
-import com.sun.xml.internal.fastinfoset.CommonResourceBundle;
-
-/**
- * This class provides the same functionality as StAXEventAllocatorBase, but without
- * using EventFactory and creating a new object for each call.
- *
- * It seems to be good idea using static components. Unfortunately, EventReader's peek
- * and next methods require that multiple instances being created.
- *
- */
-public class StAXEventAllocator implements XMLEventAllocator {
-    StartElementEvent startElement = new StartElementEvent();
-    EndElementEvent endElement = new EndElementEvent();
-    CharactersEvent characters = new CharactersEvent();
-    CharactersEvent cData = new CharactersEvent("",true);
-    CharactersEvent space = new CharactersEvent();
-    CommentEvent comment = new CommentEvent();
-    EntityReferenceEvent entity = new EntityReferenceEvent();
-    ProcessingInstructionEvent pi = new ProcessingInstructionEvent();
-    StartDocumentEvent startDoc = new StartDocumentEvent();
-    EndDocumentEvent endDoc = new EndDocumentEvent();
-    DTDEvent dtd = new DTDEvent();
-
-    /** Creates a new instance of StAXEventAllocator */
-    public StAXEventAllocator() {
-    }
-    public XMLEventAllocator newInstance() {
-        return new StAXEventAllocator();
-    }
-
-  /**
-   * This method allocates an event given the current state of the XMLStreamReader.
-   * If this XMLEventAllocator does not have a one-to-one mapping between reader state
-   * and events this method will return null.
-   * @param streamReader The XMLStreamReader to allocate from
-   * @return the event corresponding to the current reader state
-   */
-    public XMLEvent allocate(XMLStreamReader streamReader) throws XMLStreamException {
-        if(streamReader == null )
-            throw new XMLStreamException(CommonResourceBundle.getInstance().getString("message.nullReader"));
-        return getXMLEvent(streamReader);
-    }
-
-  /**
-   * This method allocates an event or set of events given the current state of
-   * the XMLStreamReader and adds the event or set of events to the consumer that
-   * was passed in.
-   * @param streamReader The XMLStreamReader to allocate from
-   * @param consumer The XMLEventConsumer to add to.
-   */
-    public void allocate(XMLStreamReader streamReader, XMLEventConsumer consumer) throws XMLStreamException {
-        consumer.add(getXMLEvent(streamReader));
-
-    }
-    // ---------------------end of methods defined by XMLEventAllocator-----------------//
-
-
-    XMLEvent getXMLEvent(XMLStreamReader reader){
-        EventBase event = null;
-        int eventType = reader.getEventType();
-
-        switch(eventType){
-
-            case XMLEvent.START_ELEMENT:
-            {
-                startElement.reset();
-                startElement.setName(new QName(reader.getNamespaceURI(),
-                                   reader.getLocalName(), reader.getPrefix()));
-
-                addAttributes(startElement,reader);
-                addNamespaces(startElement, reader);
-                //need to fix it along with the Reader
-                //setNamespaceContext(startElement,reader);
-                event = startElement;
-                break;
-            }
-            case XMLEvent.END_ELEMENT:
-            {
-                endElement.reset();
-                endElement.setName(new QName(reader.getNamespaceURI(),
-                                 reader.getLocalName(),reader.getPrefix()));
-                addNamespaces(endElement,reader);
-                event = endElement ;
-                break;
-            }
-            case XMLEvent.PROCESSING_INSTRUCTION:
-            {
-                pi.setTarget(reader.getPITarget());
-                pi.setData(reader.getPIData());
-                event = pi;
-                break;
-            }
-            case XMLEvent.CHARACTERS:
-            {
-                characters.setData(reader.getText());
-                event = characters;
-                /**
-                if (reader.isWhiteSpace()) {
-                    space.setData(reader.getText());
-                    space.setSpace(true);
-                    event = space;
-                }
-                else {
-                    characters.setData(reader.getText());
-                    event = characters;
-                }
-                 */
-                break;
-            }
-            case XMLEvent.COMMENT:
-            {
-                comment.setText(reader.getText());
-                event = comment;
-                break;
-            }
-            case XMLEvent.START_DOCUMENT:
-            {
-                startDoc.reset();
-                String encoding = reader.getEncoding();
-                String version = reader.getVersion();
-                if (encoding != null)
-                    startDoc.setEncoding(encoding);
-                if (version != null)
-                    startDoc.setVersion(version);
-                startDoc.setStandalone(reader.isStandalone());
-                if(reader.getCharacterEncodingScheme() != null){
-                    startDoc.setDeclaredEncoding(true);
-                }else{
-                    startDoc.setDeclaredEncoding(false);
-                }
-                event = startDoc ;
-                break;
-            }
-            case XMLEvent.END_DOCUMENT:{
-                event = endDoc;
-                break;
-            }
-            case XMLEvent.ENTITY_REFERENCE:{
-                entity.setName(reader.getLocalName());
-                entity.setDeclaration(new EntityDeclarationImpl(reader.getLocalName(),reader.getText()));
-                event = entity;
-                break;
-
-            }
-            case XMLEvent.ATTRIBUTE:{
-                event = null ;
-                break;
-            }
-            case XMLEvent.DTD:{
-                dtd.setDTD(reader.getText());
-                event = dtd;
-                break;
-            }
-            case XMLEvent.CDATA:{
-                cData.setData(reader.getText());
-                event = cData;
-                break;
-            }
-            case XMLEvent.SPACE:{
-                space.setData(reader.getText());
-                space.setSpace(true);
-                event = space;
-                break;
-            }
-        }
-        event.setLocation(reader.getLocation());
-        return event ;
-    }
-
-    //use event.addAttribute instead of addAttributes to avoid creating another list
-    protected void addAttributes(StartElementEvent event,XMLStreamReader reader){
-        AttributeBase attr = null;
-        for(int i=0; i<reader.getAttributeCount() ;i++){
-            attr =  new AttributeBase(reader.getAttributeName(i), reader.getAttributeValue(i));
-            attr.setAttributeType(reader.getAttributeType(i));
-            attr.setSpecified(reader.isAttributeSpecified(i));
-            event.addAttribute(attr);
-        }
-    }
-
-    //add namespaces to StartElement/EndElement
-    protected void addNamespaces(StartElementEvent event,XMLStreamReader reader){
-        Namespace namespace = null;
-        for(int i=0; i<reader.getNamespaceCount(); i++){
-            namespace =  new NamespaceBase(reader.getNamespacePrefix(i), reader.getNamespaceURI(i));
-            event.addNamespace(namespace);
-        }
-    }
-
-    protected void addNamespaces(EndElementEvent event,XMLStreamReader reader){
-        Namespace namespace = null;
-        for(int i=0; i<reader.getNamespaceCount(); i++){
-            namespace =  new NamespaceBase(reader.getNamespacePrefix(i), reader.getNamespaceURI(i));
-            event.addNamespace(namespace);
-        }
-    }
-
-}
--- old/src/share/classes/com/sun/xml/internal/ws/addressing/model/InvalidMapException.java	Tue Aug  4 10:20:44 2009
+++ /dev/null	Tue Aug  4 10:20:44 2009
@@ -1,50 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package com.sun.xml.internal.ws.addressing.model;
-
-import javax.xml.ws.WebServiceException;
-import javax.xml.namespace.QName;
-
-/**
- * @author Arun Gupta
- */
-public class InvalidMapException extends WebServiceException {
-    QName name;
-    QName subsubcode;
-
-    public InvalidMapException(QName name, QName subsubcode) {
-        this.name = name;
-        this.subsubcode = subsubcode;
-    }
-
-    public QName getMapQName() {
-        return name;
-    }
-
-    public QName getSubsubcode() {
-        return subsubcode;
-    }
-}
--- old/src/share/classes/com/sun/xml/internal/ws/addressing/model/MapRequiredException.java	Tue Aug  4 10:20:45 2009
+++ /dev/null	Tue Aug  4 10:20:45 2009
@@ -1,44 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package com.sun.xml.internal.ws.addressing.model;
-
-import javax.xml.ws.WebServiceException;
-import javax.xml.namespace.QName;
-
-/**
- * @author Arun Gupta
- */
-public class MapRequiredException extends WebServiceException {
-    QName name;
-
-    public MapRequiredException(QName name) {
-        this.name = name;
-    }
-
-    public QName getMapQName() {
-        return name;
-    }
-}
--- old/src/share/classes/com/sun/xml/internal/ws/client/ResponseImpl.java	Tue Aug  4 10:20:47 2009
+++ /dev/null	Tue Aug  4 10:20:47 2009
@@ -1,118 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package com.sun.xml.internal.ws.client;
-
-import com.sun.xml.internal.ws.util.CompletedFuture;
-
-import javax.xml.ws.AsyncHandler;
-import javax.xml.ws.Response;
-import java.util.Map;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Future;
-import java.util.concurrent.FutureTask;
-
-/**
- * {@link Response} implementation.
- *
- * @author Kohsuke Kawaguchi
- * @author Kathy Walsh
- */
-public final class ResponseImpl<T> extends FutureTask<T> implements Response<T>, ResponseContextReceiver {
-
-    /**
-     * Optional {@link AsyncHandler} that gets invoked
-     * at the completion of the task.
-     */
-    private final AsyncHandler<T> handler;
-    private ResponseContext responseContext;
-
-    private final Callable<T> callable;
-
-    /**
-     *
-     * @param callable
-     *      This {@link Callable} is executed asynchronously.
-     * @param handler
-     *      Optional {@link AsyncHandler} to invoke at the end
-     *      of the processing. Can be null.
-     */
-    public ResponseImpl(Callable<T> callable, AsyncHandler<T> handler) {
-        super(callable);
-        this.callable = callable;
-        this.handler = handler;
-    }
-
-    @Override
-    public void run() {
-        // override so that we call set()
-        try {
-            set(callable.call(), null);
-        } catch (Throwable t) {
-            set(null, t);
-        }
-    }
-
-    protected void set(final T v, final Throwable t) {
-        // call the handler before we mark the future as 'done'
-        if (handler!=null) {
-            try {
-                /**
-                 * {@link Response} object passed into the callback.
-                 * We need a separate {@link Future} because we don't want {@link ResponseImpl}
-                 * to be marked as 'done' before the callback finishes execution.
-                 * (That would provide implicit synchronization between the application code
-                 * in the main thread and the callback code, and is compatible with the JAX-RI 2.0 FCS.
-                 */
-                class CallbackFuture<T> extends CompletedFuture<T> implements Response<T> {
-                    public CallbackFuture(T v, Throwable t) {
-                        super(v, t);
-                    }
-
-                    public Map<String, Object> getContext() {
-                        return ResponseImpl.this.getContext();
-                    }
-                }
-                handler.handleResponse(new CallbackFuture<T>(v, t));
-            } catch (Throwable e) {
-                super.setException(e);
-                return;
-            }
-        }
-        if (t != null) {
-            super.setException(t);
-        } else {
-            super.set(v);
-        }
-    }
-
-    public ResponseContext getContext() {
-        return responseContext;
-    }
-
-    public void setResponseContext(ResponseContext rc) {
-        responseContext = rc;
-    }
-}
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/AsyncBuilder.java	Tue Aug  4 10:20:48 2009
+++ /dev/null	Tue Aug  4 10:20:48 2009
@@ -1,244 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package com.sun.xml.internal.ws.client.sei;
-
-import com.sun.xml.internal.bind.api.AccessorException;
-import com.sun.xml.internal.bind.api.Bridge;
-import com.sun.xml.internal.bind.api.CompositeStructure;
-import com.sun.xml.internal.bind.api.RawAccessor;
-import com.sun.xml.internal.ws.api.SOAPVersion;
-import com.sun.xml.internal.ws.api.message.Message;
-import com.sun.xml.internal.ws.api.message.Messages;
-import com.sun.xml.internal.ws.api.model.SEIModel;
-import com.sun.xml.internal.ws.model.ParameterImpl;
-import com.sun.xml.internal.ws.model.WrapperParameter;
-import com.sun.xml.internal.ws.message.jaxb.JAXBMessage;
-import java.util.Collection;
-
-import javax.xml.bind.JAXBException;
-import javax.xml.namespace.QName;
-import javax.xml.ws.Holder;
-import javax.xml.ws.WebServiceException;
-import java.util.List;
-
-/**
- * Builds Async bean
- *
- * @see MessageFiller
- * @author Jitendra Kotamraju
- */
-abstract class AsyncBuilder {
-
-    abstract Object fillAsyncBean(Object[] methodArgs, Object returnValue, Object bean);
-
-    /**
-     * Used to create a payload JAXB object just by taking
-     * one of the parameters.
-     */
-    final static class Bare extends AsyncBuilder {
-        /**
-         * The index of the method invocation parameters that goes into the payload.
-         */
-        private final int methodPos;
-        private final ValueGetter getter;
-        private final RawAccessor accessor;
-
-        /**
-         * Creates a {@link BodyBuilder} from a bare parameter.
-         */
-        Bare(Class wrapper, ParameterImpl p) {
-            this.methodPos = p.getIndex();
-            this.getter = ValueGetter.get(p);
-            QName name = p.getName();
-            try {
-                accessor = p.getOwner().getJAXBContext().getElementPropertyAccessor(
-                        wrapper, name.getNamespaceURI(), name.getLocalPart() );
-            } catch (JAXBException e) {
-                throw new WebServiceException(  // TODO: i18n
-                    wrapper+" do not have a property of the name "+name,e);
-            }
-        }
-
-        /**
-         * Picks up an object from the method arguments and uses it.
-         */
-        Object fillAsyncBean(Object[] methodArgs, Object returnValue, Object bean) {
-            Object obj = (methodPos == -1) ? returnValue : getter.get(methodArgs[methodPos]);
-            try {
-                accessor.set(bean, obj);
-            } catch (Exception e) {
-                throw new WebServiceException(e);    // TODO:i18n
-            }
-            return bean;
-        }
-    }
-
-    final static class Filler extends AsyncBuilder {
-        /**
-         * The index of the method invocation parameters that goes into the payload.
-         */
-        private final int methodPos;
-        private final ValueGetter getter;
-
-        /**
-         * Creates a {@link BodyBuilder} from a bare parameter.
-         */
-        Filler(ParameterImpl p) {
-            this.methodPos = p.getIndex();
-            this.getter = ValueGetter.get(p);
-        }
-
-        /**
-         * Picks up an object from the method arguments and uses it.
-         */
-        Object fillAsyncBean(Object[] methodArgs, Object returnValue, Object bean) {
-            return (methodPos == -1) ? returnValue : getter.get(methodArgs[methodPos]);
-        }
-    }
-
-    public static AsyncBuilder NONE = new None();
-
-    static final class None extends AsyncBuilder {
-        Object fillAsyncBean(Object[] methodArgs, Object returnValue, Object bean) {
-            return bean;
-        }
-    }
-
-    static final class Composite extends AsyncBuilder {
-        private final AsyncBuilder[] builders;
-        private final Class beanClass;
-
-        public Composite(AsyncBuilder[] builders, Class beanClass) {
-            this.builders = builders;
-            this.beanClass = beanClass;
-        }
-
-
-        public Composite(Collection<? extends AsyncBuilder> builders, Class beanClass) {
-            this(builders.toArray(new AsyncBuilder[builders.size()]), beanClass);
-        }
-
-        Object fillAsyncBean(Object[] methodArgs, Object returnValue, Object bean) {
-            try {
-                bean = beanClass.newInstance();
-            } catch (Exception ex) {
-                throw new WebServiceException(ex);
-            }
-            for (AsyncBuilder builder : builders) {
-                builder.fillAsyncBean(methodArgs, returnValue, bean);
-            }
-            return bean;
-        }
-    }
-
-
-    /**
-     * Used to handle a 'wrapper' style request.
-     * Common part of rpc/lit and doc/lit.
-     */
-    abstract static class Wrapped extends AsyncBuilder {
-
-        /**
-         * Where in the method argument list do they come from?
-         */
-        protected final int[] indices;
-
-        /**
-         * Abstracts away the {@link Holder} handling when touching method arguments.
-         */
-        protected final ValueGetter[] getters;
-
-        protected Wrapped(WrapperParameter wp) {
-
-            List<ParameterImpl> children = wp.getWrapperChildren();
-
-            indices = new int[children.size()];
-            getters = new ValueGetter[children.size()];
-            for( int i=0; i<indices.length; i++ ) {
-                ParameterImpl p = children.get(i);
-                indices[i] = p.getIndex();
-                getters[i] = ValueGetter.get(p);
-            }
-        }
-    }
-
-    /**
-     * Used to create a payload JAXB object by wrapping
-     * multiple parameters into one "wrapper bean".
-     */
-    final static class DocLit extends Wrapped {
-        /**
-         * How does each wrapped parameter binds to XML?
-         */
-        private final RawAccessor[] accessors;
-
-        /**
-         * Wrapper bean.
-         */
-        private final Class wrapper;
-
-        /**
-         * Creates a {@link BodyBuilder} from a {@link WrapperParameter}.
-         */
-        DocLit(Class wrapper, WrapperParameter wp) {
-            super(wp);
-            this.wrapper = wrapper;
-
-            List<ParameterImpl> children = wp.getWrapperChildren();
-
-            accessors = new RawAccessor[children.size()];
-            for( int i=0; i<accessors.length; i++ ) {
-                ParameterImpl p = children.get(i);
-                QName name = p.getName();
-                try {
-                    accessors[i] = p.getOwner().getJAXBContext().getElementPropertyAccessor(
-                        wrapper, name.getNamespaceURI(), name.getLocalPart() );
-                } catch (JAXBException e) {
-                    throw new WebServiceException(  // TODO: i18n
-                        wrapper+" do not have a property of the name "+name,e);
-                }
-            }
-
-        }
-
-        /**
-         * Packs a bunch of arguments into a {@link CompositeStructure}.
-         */
-        Object fillAsyncBean(Object[] methodArgs, Object returnValue, Object bean) {
-            try {
-                // fill in wrapped parameters from methodArgs
-                for( int i=indices.length-1; i>=0; i-- ) {
-                    Object obj = (indices[i] == -1) ? returnValue : methodArgs[indices[i]];
-                    accessors[i].set(bean,getters[i].get(obj));
-                }
-            } catch (Exception e) {
-                throw new WebServiceException(e);    // TODO:i18n
-            }
-            return bean;
-        }
-    }
-
-}
--- old/src/share/classes/com/sun/xml/internal/ws/client/sei/package-info.java	Tue Aug  4 10:20:49 2009
+++ /dev/null	Tue Aug  4 10:20:49 2009
@@ -1,29 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/**
- * {@link SEIStub} and its supporting code.
- */
-package com.sun.xml.internal.ws.client.sei;
--- old/src/share/classes/com/sun/xml/internal/ws/encoding/AbstractXMLStreamWriterExImpl.java	Tue Aug  4 10:20:51 2009
+++ /dev/null	Tue Aug  4 10:20:51 2009
@@ -1,83 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package com.sun.xml.internal.ws.encoding;
-
-import com.sun.istack.internal.XMLStreamException2;
-import com.sun.xml.internal.ws.util.ByteArrayBuffer;
-import com.sun.xml.internal.org.jvnet.staxex.XMLStreamWriterEx;
-
-import javax.activation.DataHandler;
-import javax.xml.stream.XMLStreamException;
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * Partial default implementation of {@link XMLStreamWriterEx}.
- *
- * TODO: find a good home for this class.
- *
- * @author Kohsuke Kawaguchi
- */
-public abstract class AbstractXMLStreamWriterExImpl implements XMLStreamWriterEx {
-
-    private StreamImpl stream;
-
-    public void writeBinary(DataHandler data) throws XMLStreamException {
-        try {
-            StreamImpl stream = _writeBinary(data.getContentType());
-            stream.write(data.getInputStream());
-            stream.close();
-        } catch (IOException e) {
-            throw new XMLStreamException2(e);
-        }
-    }
-    public OutputStream writeBinary(String contentType) throws XMLStreamException {
-        return _writeBinary(contentType);
-    }
-
-    private StreamImpl _writeBinary(String contentType) {
-        if(stream==null)
-            stream = new StreamImpl();
-        else
-            stream.reset();
-        stream.contentType = contentType;
-        return stream;
-    }
-
-    private final class StreamImpl extends ByteArrayBuffer {
-        private String contentType;
-        public void close() throws IOException {
-            super.close();
-            try {
-                writeBinary(buf,0,size(),contentType);
-            } catch (XMLStreamException e) {
-                IOException x = new IOException();
-                x.initCause(e);
-                throw x;
-            }
-        }
-    }
-}
--- old/src/share/classes/com/sun/xml/internal/ws/streaming/XMLReader.java	Tue Aug  4 10:20:52 2009
+++ /dev/null	Tue Aug  4 10:20:52 2009
@@ -1,230 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package com.sun.xml.internal.ws.streaming;
-
-import org.xml.sax.helpers.XMLReaderFactory;
-
-import java.util.Iterator;
-
-import javax.xml.namespace.QName;
-
-/**
- * <p> XMLReader provides a high-level streaming parser interface
- * for reading XML documents. </p>
- *
- * <p> The {@link #next} method is used to read events from the XML document. </p>
- *
- * <p> Each time it is called, {@link #next} returns the new state of the reader. </p>
- *
- * <p> Possible states are: BOF, the initial state, START, denoting the start
- * tag of an element, END, denoting the end tag of an element, CHARS, denoting
- * the character content of an element, PI, denoting a processing instruction,
- * EOF, denoting the end of the document. </p>
- *
- * <p> Depending on the state the reader is in, one or more of the following
- * query methods will be meaningful: {@link #getName}, {@link #getURI},
- * {@link #getLocalName}, {@link #getAttributes}, {@link #getValue}. </p>
- *
- * <p> Elements visited by a XMLReader are tagged with unique IDs. The ID of the
- * current element can be found by calling {@link #getElementId}. </p>
- *
- * <p> A XMLReader is always namespace-aware, and keeps track of the namespace
- * declarations which are in scope at any time during streaming. The
- * {@link #getURI(java.lang.String)} method can be used to find the URI
- * associated to a given prefix in the current scope. </p>
- *
- * <p> XMLReaders can be created using a {@link XMLReaderFactory}. </p>
- *
- * <p> Some utility methods, {@link #nextContent} and {@link #nextElementContent}
- * make it possible to ignore whitespace and processing instructions with
- * minimum impact on the client code. </p>
- *
- * <p> Similarly, the {@link #skipElement} and {@link #skipElement(int elementId)}
- * methods allow to skip to the end tag of an element ignoring all its content. </p>
- *
- * <p> Finally, the {@link #recordElement} method can be invoked when the XMLReader
- * is positioned on the start tag of an element to record the element's contents
- * so that they can be played back later. </p>
- *
- * @see XMLReaderFactory
- *
- * @author WS Development Team
- */
-public interface XMLReader {
-    /**
-     * The initial state of a XMLReader.
-     */
-    public static final int BOF = 0;
-
-    /**
-     * The state denoting the start tag of an element.
-     */
-    public static final int START = 1;
-
-    /**
-     * The state denoting the end tag of an element.
-     */
-    public static final int END = 2;
-
-    /**
-     * The state denoting the character content of an element.
-     */
-    public static final int CHARS = 3;
-
-    /**
-     * The state denoting a processing instruction.
-     */
-    public static final int PI = 4;
-
-    /**
-     * The state denoting that the end of the document has been reached.
-     */
-    public static final int EOF = 5;
-
-    /**
-     * Return the next state of the XMLReader.
-     *
-     * The return value is one of: START, END, CHARS, PI, EOF.
-     */
-    public int next();
-
-    /*
-    * Return the next state of the XMLReader.
-    *
-    * <p> Whitespace character content and processing instructions are ignored. </p>
-    *
-    * <p> The return value is one of: START, END, CHARS, EOF. </p>
-    */
-    public int nextContent();
-
-    /**
-     * Return the next state of the XMLReader.
-     *
-     * <p> Whitespace character content, processing instructions are ignored.
-     * Non-whitespace character content triggers an exception. </p>
-     *
-     * <p> The return value is one of: START, END, EOF. </p>
-     */
-    public int nextElementContent();
-
-    /**
-     * Return the current state of the XMLReader.
-     *
-     */
-    public int getState();
-
-    /**
-     * Return the current qualified name.
-     *
-     * <p> Meaningful only when the state is one of: START, END. </p>
-     */
-    public QName getName();
-
-    /**
-     * Return the current URI.
-     *
-     * <p> Meaningful only when the state is one of: START, END. </p>
-     */
-    public String getURI();
-
-    /**
-     * Return the current local name.
-     *
-     * <p> Meaningful only when the state is one of: START, END, PI. </p>
-     */
-    public String getLocalName();
-
-    /**
-     * Return the current attribute list. In the jaxws implementation,
-     * this list also includes namespace declarations.
-     *
-     * <p> Meaningful only when the state is one of: START. </p>
-     *
-     * <p> The returned {@link Attributes} object belong to the XMLReader and is
-     * only guaranteed to be valid until the {@link #next} method is called,
-     * directly or indirectly.</p>
-     */
-    public Attributes getAttributes();
-
-    /**
-     * Return the current value.
-     *
-     * <p> Meaningful only when the state is one of: CHARS, PI. </p>
-     */
-    public String getValue();
-
-    /**
-     * Return the current element ID.
-     */
-    public int getElementId();
-
-    /**
-     * Return the current line number.
-     *
-     * <p> Due to aggressive parsing, this value may be off by a few lines. </p>
-     */
-    public int getLineNumber();
-
-    /**
-     * Return the URI for the given prefix.
-     *
-     * <p> If there is no namespace declaration in scope for the given
-     * prefix, return null. </p>
-     */
-    public String getURI(String prefix);
-
-    /**
-     * Return an iterator on all prefixes in scope, except for the default prefix.
-     *
-     */
-    public Iterator getPrefixes();
-
-    /**
-     * Records the current element and leaves the reader positioned on its end tag.
-     *
-     * <p> The XMLReader must be positioned on the start tag of the element.
-     * The returned reader will play back all events starting with the
-     * start tag of the element and ending with its end tag. </p>
-     */
-    public XMLReader recordElement();
-
-    /**
-     * Skip all nodes up to the end tag of the element with the current element ID.
-     */
-    public void skipElement();
-
-    /**
-     * Skip all nodes up to the end tag of the element with the given element ID.
-     */
-    public void skipElement(int elementId);
-
-    /**
-     * Close the XMLReader.
-     *
-     * <p> All subsequent calls to {@link #next} will return EOF. </p>
-     */
-    public void close();
-}
