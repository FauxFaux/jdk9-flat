#
# Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

jshell.msg.welcome =\
Welcome to JShell -- Version {0}\n\
For an introduction type: /help intro\n
jshell.err.opt.classpath.conflict = Conflicting -classpath option.
jshell.err.opt.classpath.arg = Argument to -classpath missing.
jshell.err.opt.feedback.arg = Argument to -feedback missing. Mode required.
jshell.err.opt.startup.conflict = Conflicting -startup or -nostartup option.
jshell.err.opt.unknown = Unknown option: {0}

jshell.msg.terminated =\
State engine terminated.\n\
Restore definitions with: /reload restore

jshell.msg.use.one.of = Use one of: {0}
jshell.err.def.or.id.not.found = No definition or id found named: {0}
jshell.msg.see.classes.etc = See /classes, /methods, /vars, or /list
jshell.err.arg = Invalid ''{0}'' argument: {1}
jshell.msg.see = See {0} for help.

jshell.err.file.not.accessible = File ''{1}'' for ''{0}'' is not accessible: {2}
jshell.err.file.not.found = File ''{1}'' for ''{0}'' is not found.
jshell.err.file.exception = File ''{1}'' for ''{0}'' threw exception: {2}
jshell.err.file.filename = ''{0}'' requires a filename argument.

jshell.err.startup.unexpected.exception = Unexpected exception reading start-up: {0}
jshell.err.unexpected.exception = Unexpected exception: {0}

jshell.err.no.such.command.or.snippet.id = No such command or snippet id: {0}
jshell.err.command.ambiguous = Command: ''{0}'' is ambiguous: {1}
jshell.err.set.editor.arg = The ''/set editor'' command requires a path argument
jshell.msg.set.editor.set = Editor set to: {0}
jshell.err.cant.launch.editor = Cannot launch editor -- unexpected exception: {0}
jshell.msg.try.set.editor = Try /set editor to use external editor.

jshell.msg.try.list.without.args = Try ''/list'' without arguments.
jshell.msg.no.active = There are no active definitions.

jshell.msg.resetting = Resetting...
jshell.msg.resetting.state = Resetting state.

jshell.err.reload.no.previous = No previous history to restore
jshell.err.reload.restarting.previous.state = Restarting and restoring from previous state.
jshell.err.reload.restarting.state = Restarting and restoring state.

jshell.msg.vars.not.active = (not-active)

jshell.err.out.of.range = Out of range

jshell.msg.error = Error:
jshell.msg.warning = Warning:

jshell.err.set.arg = The ''/set'' command requires a sub-command and arguments. See: ''/help /set''
jshell.err.set.ambiguous = Ambiguous sub-command argument to ''/set'': {0}

jshell.err.classpath.arg = The /classpath command requires a path argument.
jshell.msg.classpath = Path ''{0}'' added to classpath

jshell.err.help.arg = No commands or subjects start with the provided argument: {0}
jshell.msg.help.begin =\
Type a Java language expression, statement, or declaration.\n\
Or type one of the following commands:\n
jshell.msg.help.subject =\n\
For more information type ''/help'' followed by the name of command or a subject.\n\
For example ''/help /list'' or ''/help intro''.  Subjects:\n

jshell.err.drop.arg =\
In the /drop argument, please specify an import, variable, method, or class to drop.\n\
Specify by id or name. Use /list to see ids. Use /reset to reset all state.
jshell.err.drop.not.active = The argument did not specify an active import, variable, method, or class to drop.
jshell.err.drop.ambiguous = The argument references more than one import, variable, method, or class.
jshell.err.failed = Failed.
jshell.msg.native.method = Native Method
jshell.msg.unknown.source = Unknown Source
jshell.msg.goodbye = Goodbye

jshell.msg.help.for.help = Type /help for help.

jshell.err.feedback.expected.new.feedback.mode = Expected new feedback mode -- {0}
jshell.err.feedback.expected.mode.name = Expected a new feedback mode name. ''{0}'' is a known feedback mode -- {1}
jshell.err.feedback.command.quiet = Specify either ''command'' or ''quiet'' -- {0}
jshell.err.feedback.expected.field = Expected field name missing -- {0}
jshell.err.feedback.expected.mode = Expected a feedback mode -- {0}
jshell.err.feedback.does.not.match.mode = Does not match any current feedback mode: {0} -- {1}
jshell.err.feedback.ambiguous.mode = Matches more then one current feedback mode: {0} -- {1}
jshell.err.feedback.expected.format = Expected format missing -- {0}
jshell.err.feedback.must.be.quoted = Format ''{0}'' must be quoted -- {1}
jshell.err.feedback.not.a.valid.selector = Not a valid selector ''{0}'' in ''{1}'' -- {2}
jshell.err.feedback.multiple.sections = Selector kind in multiple sections of selector list ''{0}'' in ''{1}'' -- {2}
jshell.err.feedback.different.selector.kinds = Different selector kinds in same sections of selector list ''{0}'' in ''{1}'' -- {2}

jshell.msg.feedback.new.mode = Created new feedback mode: {0}
jshell.msg.feedback.mode = Feedback mode: {0}
jshell.msg.feedback.mode.following = The feedback mode should be one of the following:

jshell.err.truncation.expected.length = Expected truncation length -- {0}
jshell.err.truncation.length.not.integer = Truncation length must be an integer: {0} -- {1}

jshell.console.see.more = <press tab to see more>
jshell.console.do.nothing = Do nothing
jshell.console.choice = Choice: \

jshell.console.create.variable = Create variable
jshell.console.resolvable = \nThe identifier is resolvable in this context.
jshell.console.no.candidate = \nNo candidate fully qualified names found to import.
jshell.console.incomplete = \nResults may be incomplete; try again later for complete results.


help.usage = \
Usage:   jshell <options> <load files>\n\
where possible options include:\n\
\    -classpath <path>    Specify where to find user class files\n\
\    -cp <path>           Specify where to find user class files\n\
\    -startup <file>      One run replacement for the start-up definitions\n\
\    -nostartup           Do not run the start-up definitions\n\
\    -feedback <mode>     Specify the initial feedback mode. The mode may be\n\
\                         predefined (silent, concise, normal, or verbose) or\n\
\                         previously user-defined\n\
\    -q                   Quiet feedback.  Same as: -feedback concise\n\
\    -qq                  Really quiet feedback.  Same as: -feedback silent\n\
\    -v                   Verbose feedback.  Same as: -feedback verbose\n\
\    -J<flag>             Pass <flag> directly to the runtime system.\n\
\                         Use one -J for each runtime flag or flag argument\n\
\    -R<flag>             Pass <flag> to the remote runtime system.\n\
\                         Use one -R for each remote flag or flag argument\n\
\    -help                Print this synopsis of standard options\n\
\    -version             Version information\n

help.list.summary = list the source you have typed
help.list.args = [all|start|<name or id>]
help.list =\
Show the source of snippets, prefaced with the snippet id.\n\
\n\
/list\n\t\
    List the currently active snippets of code that you typed or read with /open\n\n\
/list start\n\t\
    List the automatically evaluated start-up snippets\n\n\
/list all\n\t\
    List all snippets including failed, overwritten, dropped, and start-up\n\n\
/list <name>\n\t\
    List snippets with the specified name (preference for active snippets)\n\n\
/list <id>\n\t\
    List the snippet with the specified snippet id

help.edit.summary = edit a source entry referenced by name or id
help.edit.args = <name or id>
help.edit =\
Edit a snippet or snippets of source in an external editor.\n\
The editor to use is set with /set editor.\n\
If no editor has been set, a simple editor will be launched.\n\
\n\
/edit <name>\n\t\
    Edit the snippet or snippets with the specified name (preference for active snippets)\n\n\
/edit <id>\n\t\
    Edit the snippet with the specified snippet id\n\n\
/edit\n\t\
    Edit the currently active snippets of code that you typed or read with /open

help.drop.summary = delete a source entry referenced by name or id
help.drop.args = <name or id>
help.drop =\
Drop a snippet -- making it inactive.\n\
\n\
/drop <name>\n\t\
    Drop the snippet with the specified name\n\n\
/drop <id>\n\t\
    Drop the snippet with the specified snippet id

help.save.summary = Save snippet source to a file.
help.save.args = [all|history|start] <file>
help.save =\
Save the specified snippets and/or commands to the specified file.\n\
\n\
/save <file>\n\t\
    Save the source of current active snippets to the file.\n\n\
/save all <file>\n\t\
    Save the source of all snippets to the file.\n\t\
    Includes source including overwritten, failed, and start-up code.\n\n\
/save history <file>\n\t\
    Save the sequential history of all commands and snippets entered since jshell was launched.\n\n\
/save start <file>\n\t\
    Save the default start-up definitions to the file.

help.open.summary = open a file as source input
help.open.args = <file>
help.open =\
Open a file and read its contents as snippets and commands.\n\
\n\
/open <file>\n\t\
    Read the specified file as jshell input.

help.vars.summary = list the declared variables and their values
help.vars.args =
help.vars =\
List the type, name, and value of the current active jshell variables.

help.methods.summary = list the declared methods and their signatures
help.methods.args =
help.methods =\
List the name, parameter types, and return type of the current active jshell methods.

help.classes.summary = list the declared classes
help.classes.args =
help.classes =\
List the current active jshell classes, interfaces, and enums.

help.imports.summary = list the imported items
help.imports.args =
help.imports =\
List the current active jshell imports.

help.exit.summary = exit jshell
help.exit.args =
help.exit =\
Leave the jshell tool.  No work is saved.\n\
Save any work before using this command

help.reset.summary = reset jshell
help.reset.args =
help.reset =\
Reset the jshell tool code and execution state:\n\t\
   * All entered code is lost.\n\t\
   * Start-up code is re-executed.\n\t\
   * The execution state is restarted.\n\t\
   * The classpath is cleared.\n\
Tool settings are maintained, as set with: /set ...\n\
Save any work before using this command

help.reload.summary = reset and replay relevant history -- current or previous (restore)
help.reload.args = [restore] [quiet]
help.reload =\
Reset the jshell tool code and execution state then replay each\n\
jshell valid command and valid snippet in the order they were entered.\n\
\n\
/reload\n\t\
     Reset and replay the valid history since jshell was entered, or\n\t\
     a /reset, or /reload command was executed -- whichever is most\n\t\
     recent.\n\n\
/reload restore\n\t\
     Reset and replay the valid history between the previous and most\n\t\
     recent time that jshell was entered, or a /reset, or /reload\n\t\
     command was executed. This can thus be used to restore a previous\n\t\
     jshell tool sesson.\n\n\
/reload [restore] quiet\n\t\
     With the 'quiet' argument the replay is not shown.  Errors will display.

help.classpath.summary = add a path to the classpath
help.classpath.args = <path>
help.classpath =\
Append a additional path to the classpath.

help.history.summary = history of what you have typed
help.history.args =
help.history =\
Display the history of snippet and command input since this jshell was launched.

help.debug.summary = toggle debugging of the jshell
help.debug.args = [0][r][g][f][c][d][e]
help.debug =\
Display debugging information for the jshell implementation.\n\
0: Debugging off\n\
r: Tool level debugging on\n\
g: General debugging on\n\
f: File manager debugging on\n\
c: Completion analysis debugging on\n\
d: Dependency debugging on\n\
e: Event debugging on

help.help.summary = get information about jshell
help.help.args = [<command>|<subject>]
help.help =\
Display information about jshell.\n\
/help\n\t\
     List the jshell commands and help subjects.\n\n\
/help <command>\n\t\
     Display information about the specified comand. The slash must be included.\n\t\
     Only the first few letters of the command are needed -- if more than one\n\t\
     each will be displayed.  Example:  /help /li\n\n\
/help <subject>\n\t\
     Display information about the specified help subject. Example: /help intro

help.set.summary = set jshell configuration information
help.set.args = editor|start|feedback|newmode|prompt|format ...
help.set =\
Set jshell configuration information, including:\n\
the external editor to use, the start-up definitions to use, a new feedback mode,\n\
the command prompt, the feedback mode to use, or the format of output.\n\
\n\
/set editor <command> <optional-arg>...\n\t\
     Specify the command to launch for the /edit command.\n\t\
     The <command> is an operating system dependent string.\n\n\
/set start <file>\n\t\
     The contents of the specified <file> become the default start-up snippets and commands.\n\n\
/set feedback <mode>\n\t\
     Set the feedback mode describing displayed feedback for entered snippets and commands.\n\n\
/set newmode <new-mode> [command|quiet [<old-mode>]]\n\t\
     Create a user-defined feedback mode, optionally copying from an existing mode.\n\n\
/set prompt <mode> "<prompt>" "<continuation-prompt>"\n\t\
     Set the displayed prompts for a given feedback mode.\n\n\
/set truncation <mode> <length> <selector>...\n\t\
     Set the maximum length of a displayed value\n\t\
/set format <mode> <field> "<format>" <selector>...\n\t\
     Configure a feedback mode by setting the format of a field when the selector matchs.\n\n\
To get more information about one of these forms, use /help with the form specified.\n\
For example:   /help /set format

help.quest.summary = get information about jshell
help.quest.args = [<command>|<subject>]
help.quest =\
Display information about jshell (abbreviation for /help).\n\
/?\n\t\
     Display list of commands and help subjects.\n\
/? <command>\n\t\
     Display information about the specified comand. The slash must be included.\n\t\
     Only the first few letters of the command are needed -- if more than one\n\t\
     match, each will be displayed.  Example:  /? /li\n\
/? <subject>\n\t\
     Display information about the specified help subject. Example: /? intro

help.bang.summary = re-run last snippet
help.bang.args =
help.bang =\
Reevaluate the most recently entered snippet.

help.id.summary = re-run snippet by id
help.id.args =
help.id =\
Reevaluate the snippet specified by the id.

help.previous.summary = re-run n-th previous snippet
help.previous.args =
help.previous =\
Reevaluate the n-th most recently entered snippet.

help.intro.summary = an introduction to the jshell tool
help.intro =\
The jshell tool allows you to execute Java code, getting immediate results.\n\
You can enter a Java definition (variable, method, class, etc), like:  int x = 8\n\
or a Java expression, like:  x + x\n\
or a Java statement or import.\n\
These little chunks of Java code are called 'snippets'.\n\
\n\
There are also jshell commands that allow you to understand and\n\
control what you are doing, like:  /list\n\
\n\
For a list of commands: /help

help.shortcuts.summary = a description of shortcuts
help.shortcuts =\
Supported shortcuts include:\n\
\n\
<tab>\n\t\t\
        After entering the first few letters of a Java identifier,\n\t\t\
        a jshell command, or, in some cases, a jshell command argument,\n\t\t\
        press the <tab> key to complete the input.\n\t\t\
        If there is more than one completion, show possible completions.\n\n\
Shift-<tab>\n\t\t\
        After the name and open parenthesis of a method or constructor invocation,\n\t\t\
        hold the <shift> key and press the <tab> to see a synopsis of all\n\t\t\
        matching methods/constructors.\n\n\
<fix-shortcut> v\n\t\t\
        After a complete expression, press "<fix-shortcut> v" to introduce a new variable\n\t\t\
        whose type is based on the type of the expression.\n\t\t\
        The "<fix-shortcut>" is either Alt-F1 or Alt-Enter, depending on the platform.\n\n\
<fix-shortcut> i\n\t\t\
        After an unresolvable identifier, press "<fix-shortcut> i" and jshell will propose\n\t\t\
        possible fully qualified names based on the content of the specified classpath.\n\t\t\
        The "<fix-shortcut>" is either Alt-F1 or Alt-Enter, depending on the platform.

help.set.format = \
Set the format for reporting a snippet event.\n\
\n\t\
/set format <mode> <field> "<format>" <selector>...\n\
\n\
Where <mode> is the name of a previously defined feedback mode -- see '/help /set newmode'.\n\
Where <field> is the name of context-specific format to define.\n\
Where <format> is a quoted string which will be the value of the field if one of\n\
the selectors matches (or there are no selectors). When the format is used,\n\
field names enclosed in braces are replaced with the value of the field at that\n\
time. These fields may have been previously defined with this command or may be\n\
one of these predefined fields specific to the context:\n\t\
{name}       == The name, e.g.: the variable name, ...\n\t\
{type}       == The type name. The type of a variable or expression, the\n\t\t\t\
                 parameter types of a method\n\t\
{value}      == The result value of an expression or variable initialization\n\t\
{unresolved} == The list of unresolved references\n\t\
{errors}     == The list of recoverable errors (during the processing of the\n\t\t\t\
                "display" field only)\n\t\
{err}        == An unformatted error line (during the processing of the\n\t\t\t\
                "errorline" field only)\n\
The following fields are accessed by the tool to determine the displayed feedback:\n\t\
{display}    == The displayed message for a snippet event\n\t\
{errorline}  == The format of one error line within the "errors" field\n\t\
{pre}        == The feedback prefix (begins command feedback)\n\t\
{post}       == The feedback postfix (ends command feedback)\n\t\
{errorpre}   == The error prefix (begins error feedback)\n\t\
{errorpost}  == The error postfix (ends error feedback)\n\
These fields have default settings (which may be overwritten).\n\
Where <selector> is the context in which the format is applied.\n\
The structure of selector is a hyphen separated list of selector kind lists.\n\
A selector kind list is a comma separated list of values of one selector kind.\n\
A selector matches if each selector kind list matches; A selector kind list\n\
matches if one of the values matches.\n\n\
The case selector kind describes the kind of snippet.  The values are:\n\t\
   import     -- import declaration\n\t\
   class      -- class declaration\n\t\
   interface  -- interface declaration\n\t\
   enum       -- enum declaration\n\t\
   annotation -- annotation interface declaration\n\t\
   method     -- method declaration -- note: {type}==parameter-types\n\t\
   vardecl    -- variable declaration without init\n\t\
   varinit    -- variable declaration with init\n\t\
   expression -- expression -- note: {name}==scratch-variable-name\n\t\
   varvalue   -- variable value expression\n\t\
   assignment -- assign variable\n\t\
   statement  -- statement\n\
The action selector kind describes what happened to the snippet.  The values are:\n\t\
   added     -- snippet has been added\n\t\
   modified  -- an existing snippet has been modified\n\t\
   replaced  -- an existing snippet has been replaced with a new snippet\n\t\
   overwrote -- an existing snippet has been overwritten\n\t\
   dropped   -- snippet has been dropped\n\t\
   used      -- snippet was used when it cannot be\n\
The when-did-it-occur selector kind describes if this is a direct or indirect action.  The values are:\n\t\
   primary -- the entered snippet\n\t\
   update  -- an update to a dependent snippet\n\
The resolution-state selector kind describes the state of resolution/definition of the snippet.  The values are:\n\t\
   ok         -- resolved correctly\n\t\
   defined    -- defined despite recoverably unresolved references\n\t\
   notdefined -- not defined because of recoverably unresolved references\n\
The unresolved-count selector kind describes the number of unresolved references.  The values are:\n\t\
   unresolved0 -- no names are unresolved\n\t\
   unresolved1 -- one name is unresolved\n\t\
   unresolved2 -- two or more names are unresolved\n\
The errors-count selector kind describes the number of errors.  The values are:\n\t\
   error0 -- no errors\n\t\
   error1 -- one error\n\t\
   error2 -- two or more errors\n\n\
Examples:\n\t\
/set format myformat action 'Created' added-primary\n\t\
/set format myformat action 'Update replaced' replaced-update\n\t\
/set format myformat display '{pre}{action} class {name}{post}' class-ok\n\t\
/set format myformat display '{pre}{action} variable {name}, reset to null{post}' replaced-vardecl,varinit-ok-update\n\n\
Note that subsequent selectors for a field may overwrite some or all of previous used selectors -- last one wins\n

help.set.truncation = \
Set the max length a displayed value.\n\
\n\t\
/set truncation <mode> <length> <selector>...\n\
\n\
Where <mode> is the name of a previously defined feedback mode -- see '/help /set newmode'.\n\
Where <length> is an unsigned integer representing a maximum length.\n\
Where <format> is a quoted string which will be the value of the field if one of\n\
Where <selector> is only needed if you wish to fine-tune value truncation length\n\
by context, <selector> is the context in which the truncation is applied.\n\
The structure of selector is a hyphen separated list of selector kind lists.\n\
A selector kind list is a comma separated list of values of one selector kind.\n\
A selector matches if each selector kind list matches; A selector kind list\n\
matches if one of the values matches.\n\n\
Below are the relevant selector kinds for truncation.\n\n\
The case selector kind describes the kind of snippet.  The values are:\n\t\
   vardecl    -- variable declaration without init\n\t\
   varinit    -- variable declaration with init\n\t\
   expression -- expression -- note: {name}==scratch-variable-name\n\t\
   varvalue   -- variable value expression\n\t\
   assignment -- assign variable\n\t\
The action selector kind describes what happened to the snippet.  The values are:\n\t\
   added     -- snippet has been added\n\t\
   modified  -- an existing snippet has been modified\n\t\
   replaced  -- an existing snippet has been replaced with a new snippet\n\
Examples:\n\t\
/set trunc mymode 80\n\t\
/set truncation mymode 45 expression\n\t\
/set truncation mymode 0 vardecl-modified,replaced\n\n\
Note that subsequent selectors for a field may overwrite some or all of previous used selectors -- last one wins\n

help.set.feedback = \
Set the feedback mode describing displayed feedback for entered snippets and commands.\n\
\n\t\
/set feedback <mode>\n\
\n\
Where <mode> is the name of a previously defined feedback mode.\n\
You may use just enough letters to make it unique.\n\
User-defined modes can be added, see '/help /set newmode'\n\
Currently defined feedback modes:\n

help.set.newmode = \
Create a user-defined feedback mode, optionally copying from an existing mode.\n\
\n\t\
/set newmode <new-mode> [command|quiet [<old-mode>]]\n\
\n\
Where <new-mode> is the name of a mode you wish to create.\n\
Where <old-mode> is the name of a previously defined feedback mode.\n\
If <old-mode> is present, its settings are copied to the new mode.\n\
'command' vs 'quiet' determines if informative/verifying command feedback is displayed.\n\
\n\
Once the new mode is created, use '/set format' and '/set prompt' to configure it.\n\
Use '/set feedback' to use the new mode.\n\

help.set.prompt = \
Set the prompts.  Both the normal prompt and the continuation-prompt must be set.\n\
\n\t\
/set prompt <mode> \"<prompt>\" \"<continuation-prompt>\"\n\
\n\
Where <mode> is the name of a previously defined feedback mode.\n\
Where <prompt> and <continuation-prompt> are quoted strings printed as input prompts;\n\
Both may optionally contain '%s' which will be substituted with the next snippet id --\n\
note that what is entered may not be assigned that id, for example it may be an error or command.\n\
The continuation-prompt is used on the second and subsequent lines of a multi-line snippet.\n

help.set.editor =\
Specify the command to launch for the /edit command.\n\
\n\t\
/set editor <command> <optional-arg>...\n\
\n\
The <command> is an operating system dependent string.\n\
The <command> may include space-separated arguments (such as flags) -- <optional-arg>....\n\
When /edit is used, the temporary file to edit will be appended as the last argument.

help.set.start =\
Set the start-up configuration -- a sequence of snippets and commands read at start-up.\n\
\n\t\
/set start <file>\n\
\n\
The contents of the specified <file> become the default start-up snippets and commands --\n\
which are run when the jshell tool is started or reset.

startup.feedback = \
/set newmode verbose command    \n\
\n\
/set prompt verbose '\\njshell> '   '   ...> '    \n\
\n\
/set format verbose pre '|  '    \n\
/set format verbose post '%n'    \n\
/set format verbose errorpre '|  '    \n\
/set format verbose errorpost '%n'    \n\
\n\
/set format verbose errorline '{post}{pre}    {err}'    \n\
\n\
/set format verbose action 'created' added-primary    \n\
/set format verbose action 'modified' modified-primary    \n\
/set format verbose action 'replaced' replaced-primary    \n\
/set format verbose action 'overwrote' overwrote-primary    \n\
/set format verbose action 'dropped' dropped-primary    \n\
/set format verbose action '  update created' added-update    \n\
/set format verbose action '  update modified' modified-update    \n\
/set format verbose action '  update replaced' replaced-update    \n\
/set format verbose action '  update overwrote' overwrote-update    \n\
/set format verbose action '  update dropped' dropped-update    \n\
\n\
/set format verbose until ', however, it cannot be instanciated or its methods invoked until'   defined-class-primary    \n\
/set format verbose until ', however, its methods cannot be invoked until'                      defined-interface-primary    \n\
/set format verbose until ', however, it cannot be used until'                                  defined-enum,annotation-primary    \n\
/set format verbose until ', however, it cannot be invoked until'                               defined-method-primary    \n\
/set format verbose until ', however, it cannot be referenced until'                            notdefined-primary    \n\
/set format verbose until ' which cannot be instanciated or its methods invoked until'          defined-class-update    \n\
/set format verbose until ' whose methods cannot be invoked until'                              defined-interface-update    \n\
/set format verbose until ' which cannot be invoked until'                                      defined-method-update    \n\
/set format verbose until ' which cannot be referenced until'                                   notdefined-update    \n\
\n\
/set format verbose unrerr '{unresolved} is declared'                                           unresolved1-error0    \n\
/set format verbose unrerr '{unresolved} are declared'                                          unresolved2-error0    \n\
/set format verbose unrerr ' this error is corrected: {errors}'                                 unresolved0-error1    \n\
/set format verbose unrerr '{unresolved} is declared and this error is corrected: {errors}'     unresolved1-error1    \n\
/set format verbose unrerr '{unresolved} are declared and this error is corrected: {errors}'    unresolved2-error1    \n\
/set format verbose unrerr ' these errors are corrected: {errors}'                              unresolved0-error2    \n\
/set format verbose unrerr '{unresolved} is declared and these errors are corrected: {errors}'  unresolved1-error2    \n\
/set format verbose unrerr '{unresolved} are declared and these errors are corrected: {errors}' unresolved2-error2    \n\
\n\
/set format verbose resolve '{until}{unrerr}'                                                   added,modified,replaced,used    \n\
\n\
/set format verbose typeKind 'class'                  class    \n\
/set format verbose typeKind 'interface'              interface    \n\
/set format verbose typeKind 'enum'                   enum    \n\
/set format verbose typeKind 'annotation interface'   annotation    \n\
\n\
/set format verbose result '{name} ==> {value}{post}'                                        added,modified,replaced-ok-primary    \n\
\n\
/set format verbose display '{result}{pre}created scratch variable {name} : {type}{post}'    expression-primary    \n\
/set format verbose display '{result}{pre}value of {name} : {type}{post}'                    varvalue-primary    \n\
/set format verbose display '{result}{pre}assigned to {name} : {type}{post}'                 assignment-primary    \n\
/set format verbose display '{result}{pre}{action} variable {name} : {type}{resolve}{post}'  varinit,vardecl    \n\
/set format verbose display '{pre}{action} variable {name}{resolve}{post}'                   vardecl,varinit-notdefined    \n\
/set format verbose display '{pre}{action} variable {name}{post}'                            dropped-vardecl,varinit    \n\
/set format verbose display '{pre}{action} variable {name}, reset to null{post}'             replaced-vardecl,varinit-ok-update    \n\
\n\
/set format verbose display '{pre}{action} {typeKind} {name}{resolve}{post}'                 class,interface,enum,annotation    \n\
/set format verbose display '{pre}{action} method {name}({type}){resolve}{post}'             method    \n\
\n\
/set format verbose display '{pre}attempted to use {typeKind} {name}{resolve}{post}'         used-class,interface,enum,annotation    \n\
/set format verbose display '{pre}attempted to call method {name}({type}){resolve}{post}'    used-method    \n\
\n\
/set truncation verbose 80\n\
/set truncation verbose 500                                                                  varvalue\n\
\n\
/set newmode normal command verbose    \n\
/set format normal display ''                                                               added,modified,replaced,overwrote,dropped-update    \n\
/set format normal display '{pre}{action} variable {name}, reset to null{post}'             replaced-vardecl,varinit-ok-update    \n\
/set format normal display '{result}'                                                       added,modified,replaced-expression,varvalue,assignment,varinit,vardecl-ok-primary    \n\
/set newmode concise quiet normal    \n\
\n\
/set prompt concise 'jshell> '   '   ...> '    \n\
\n\
/set format concise display ''                                                              class,interface,enum,annotation,method,assignment,varinit,vardecl-ok    \n\
\n\
/set feedback normal    \n\
\n\
/set newmode silent quiet    \n\
/set prompt silent '-> ' '>> '    \n\
/set format silent pre '|  '    \n\
/set format silent post '%n'    \n\
/set format silent errorpre '|  '    \n\
/set format silent errorpost '%n'    \n\
/set format silent display ''    \n
